<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\vm_insnhelper.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"constant.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_counter.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/class.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compar.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/numeric.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/proc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/random.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/variable.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"variable.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"insns.inc"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"insns_info.inc"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>extern</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>rb_method_definition_create</name><parameter_list>(<parameter><decl><type><name>rb_method_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>rb_method_definition_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>rb_method_definition_eq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>d1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>d2</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>VALUE</name></type> <name>rb_make_no_method_exception</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>priv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>vm_get_ruby_level_caller_cfp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>MJIT_STATIC</name> <name>VALUE</name></type>

<name>ruby_vm_special_exception_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>rb_obj_alloc</name><argument_list>(<argument><expr><call><name>rb_class_real</name><argument_list>(<argument><expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_obj_copy_ivar</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>e</name></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void ec_stack_overflow(rb_execution_context_t *ec, int)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ec_stack_overflow</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>setup</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name> <init>= <expr><call><name>rb_ec_vm_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>special_exceptions</name><index>[<expr><name>ruby_error_sysstack</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>raised_flag</name></name> <operator>=</operator> <name>RAISED_STACKOVERFLOW</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>setup</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>at</name> <init>= <expr><call><name>rb_ec_backtrace_object</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>ruby_vm_special_exception_copy</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>idBt</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>idBt_locations</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>mesg</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TAG_RAISE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void vm_stackoverflow(void)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_stackoverflow</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ec_stack_overflow</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>MJIT_STATIC void rb_ec_stack_overflow(rb_execution_context_t *ec, int crit)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><name>MJIT_STATIC</name> <name>void</name></type>

<name>rb_ec_stack_overflow</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>crit</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>crit</name> <operator>||</operator> <call><name>rb_during_gc</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>raised_flag</name></name> <operator>=</operator> <name>RAISED_STACKOVERFLOW</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <call><name>rb_ec_vm_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>special_exceptions</name><index>[<expr><name>ruby_error_stackfatal</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TAG_RAISE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ec_stack_overflow</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>ec_stack_overflow</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>callable_class_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>klass</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>RB_BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_ICLASS</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<case>case <expr><name>T_MODULE</name></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></switch>

<while>while <condition>(<expr><name>klass</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cBasicObject</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>FALSE</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>klass</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>callable_method_entry_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cme</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cme</name></expr></argument>, <argument><expr><name>imemo_ment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>callable_class_p</name><argument_list>(<argument><expr><name><name>cme</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_check_frame_detail</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>req_block</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>req_me</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>req_cref</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>specval</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cref_or_me</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_cframe</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>magic</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>VM_FRAME_MAGIC_MASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>imemo_type</name></name></type> <name>cref_or_me_type</name> <init>= <expr><name>imemo_env</name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>cref_or_me</name></expr></argument>, <argument><expr><name>T_IMEMO</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cref_or_me_type</name> <operator>=</operator> <call><name>imemo_type</name><argument_list>(<argument><expr><name>cref_or_me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>VM_FRAME_FLAG_BMETHOD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>req_me</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>req_block</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>&amp;</operator> <name>VM_ENV_FLAG_LOCAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_push_frame: specval (%p) should be a block_ptr on %x frame"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>specval</name></expr></argument>, <argument><expr><name>magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>req_block</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>&amp;</operator> <name>VM_ENV_FLAG_LOCAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_push_frame: specval (%p) should not be a block_ptr on %x frame"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>specval</name></expr></argument>, <argument><expr><name>magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>req_me</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cref_or_me_type</name> <operator>!=</operator> <name>imemo_ment</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_push_frame: (%s) should be method entry on %x frame"</literal></expr></argument>, <argument><expr><call><name>rb_obj_info</name><argument_list>(<argument><expr><name>cref_or_me</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>req_cref</name> <operator>&amp;&amp;</operator> <name>cref_or_me_type</name> <operator>!=</operator> <name>imemo_cref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_push_frame: (%s) should be CREF on %x frame"</literal></expr></argument>, <argument><expr><call><name>rb_obj_info</name><argument_list>(<argument><expr><name>cref_or_me</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name>cref_or_me</name> <operator>!=</operator> <name>Qfalse</name> <operator>&amp;&amp;</operator> <name>cref_or_me_type</name> <operator>!=</operator> <name>imemo_cref</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>VM_FRAME_FLAG_LAMBDA</name><operator>)</operator> <operator>||</operator> <name>magic</name> <operator>==</operator> <name>VM_FRAME_MAGIC_IFUNC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>cref_or_me_type</name> <operator>==</operator> <name>imemo_ment</name><operator>)</operator></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_push_frame: (%s) should be false or cref on %x frame"</literal></expr></argument>, <argument><expr><call><name>rb_obj_info</name><argument_list>(<argument><expr><name>cref_or_me</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cref_or_me_type</name> <operator>==</operator> <name>imemo_ment</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>cref_or_me</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>callable_method_entry_p</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_push_frame: ment (%s) should be callable on %x frame."</literal></expr></argument>, <argument><expr><call><name>rb_obj_info</name><argument_list>(<argument><expr><name>cref_or_me</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>VM_FRAME_MAGIC_MASK</name><operator>)</operator> <operator>==</operator> <name>VM_FRAME_MAGIC_DUMMY</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>iseq</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>

<call><name>RUBY_VM_NORMAL_ISEQ_P</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>is_cframe</name> <operator>==</operator> <operator>!</operator><call><name>RUBY_VM_NORMAL_ISEQ_P</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_check_frame</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>type</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>specval</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>cref_or_me</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>given_magic</name> <init>= <expr><name>type</name> <operator>&amp;</operator> <name>VM_FRAME_MAGIC_MASK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK</name><parameter_list>(<parameter><type><name>magic</name></type></parameter>, <parameter><type><name>req_block</name></type></parameter>, <parameter><type><name>req_me</name></type></parameter>, <parameter><type><name>req_cref</name></type></parameter>, <parameter><type><name>is_cframe</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case magic: vm_check_frame_detail(type, req_block, req_me, req_cref, specval, cref_or_me, is_cframe, iseq); break</cpp:value></cpp:define>

<switch>switch <condition>(<expr><name>given_magic</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>VM_FRAME_MAGIC_METHOD</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>VM_FRAME_MAGIC_CLASS</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>VM_FRAME_MAGIC_TOP</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>VM_FRAME_MAGIC_CFUNC</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>VM_FRAME_MAGIC_BLOCK</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>VM_FRAME_MAGIC_IFUNC</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>VM_FRAME_MAGIC_EVAL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>VM_FRAME_MAGIC_RESCUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>VM_FRAME_MAGIC_DUMMY</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_push_frame: unknown type (%x)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>given_magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK</name></cpp:undef>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>vm_stack_canary</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>vm_stack_canary_was_born</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>

<name>vm_check_canary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier></type><name>reg_cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_struct</name></name> <modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>LIKELY</name><argument_list>(<argument><expr><name>vm_stack_canary_was_born</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return;</return> 

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>reg_cfp</name> <operator>==</operator> <name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>+</operator> <name><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator> <operator>(</operator><name>iseq</name> <operator>=</operator> <call><name>GET_ISEQ</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>vm_stack_canary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>orig</name> <init>= <expr><call><name>rb_iseq_original_iseq</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>encoded</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>pos</name> <init>= <expr><call><name>GET_PC</name><argument_list>()</argument_list></call> <operator>-</operator> <name>encoded</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>ruby_vminsn_type</name></name></type> <name>insn</name> <init>= <expr><operator>(</operator>enum <name>ruby_vminsn_type</name><operator>)</operator><name><name>orig</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>insn_name</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>iseqw</name> <init>= <expr><call><name>rb_iseqw_new</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>inspection</name> <init>= <expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>iseqw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stri</name> <init>= <expr><call><name>rb_str_to_cstr</name><argument_list>(<argument><expr><name>inspection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>disasm</name> <init>= <expr><call><name>rb_iseq_disasm</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strd</name> <init>= <expr><call><name>rb_str_to_cstr</name><argument_list>(<argument><expr><name>disasm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,

<argument><expr><literal type="string">"We are killing the stack canary set by %s, "</literal>

<literal type="string">"at %s@pc=%"</literal><name>PRIdPTR</name><literal type="string">"\n"</literal>

<literal type="string">"watch out the C stack trace.\n"</literal>

<literal type="string">"%s"</literal></expr></argument>,

<argument><expr><name>name</name></expr></argument>, <argument><expr><name>stri</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>strd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"see above."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vm_check_canary</name><parameter_list>(<parameter><type><name>ec</name></type></parameter>, <parameter><type><name>sp</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vm_check_frame</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>vm_push_frame</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>type</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>specval</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>cref_or_me</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>local_size</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>stack_max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cfp</name> <init>= <expr><call><name>RUBY_VM_NEXT_CONTROL_FRAME</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_check_frame</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>specval</name></expr></argument>, <argument><expr><name>cref_or_me</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>local_size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_VM_STACK_OVERFLOW0</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>local_size</name> <operator>+</operator> <name>stack_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_check_canary</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name> <operator>=</operator> <name>cfp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>pc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseq</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <name>self</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>block_code</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>local_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sp</name><operator>++</operator> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>VM_ENV_DATA_INDEX_ME_CREF</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>VM_ENV_DATA_INDEX_SPECVAL</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>VM_ENV_DATA_INDEX_FLAGS</name> <operator>==</operator> <operator>-</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>sp</name><operator>++</operator> <operator>=</operator> <name>cref_or_me</name></expr>;</expr_stmt> 

<expr_stmt><expr><operator>*</operator><name>sp</name><operator>++</operator> <operator>=</operator> <name>specval</name></expr> ;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>sp</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>__bp__</name></name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>sp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_DEBUG_BP_CHECK</name></expr></cpp:if>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>bp_check</name></name> <operator>=</operator> <name>sp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>VMDEBUG</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SDR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_DEBUG_COUNTER</name></expr></cpp:if>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>VM_FRAME_MAGIC_MASK</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_FRAME_MAGIC_METHOD</name></expr>:</case> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_BLOCK</name></expr>:</case> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_CLASS</name></expr>:</case> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_TOP</name></expr>:</case> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_CFUNC</name></expr>:</case> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push_cfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_IFUNC</name></expr>:</case> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push_ifunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_EVAL</name></expr>:</case> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push_eval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_RESCUE</name></expr>:</case> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push_rescue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_DUMMY</name></expr>:</case> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_push_dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<default>default:</default> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>prev_cfp</name> <init>= <expr><call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RUBY_VM_END_CONTROL_FRAME</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>prev_cfp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cur_ruby_frame</name> <init>= <expr><call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pre_ruby_frame</name> <init>= <expr><call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>prev_cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><ternary><condition><expr><name>pre_ruby_frame</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>cur_ruby_frame</name></expr> ?</condition><then> <expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_R2R</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_R2C</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></then><else>:

<expr><operator>(</operator><ternary><condition><expr><name>cur_ruby_frame</name></expr> ?</condition><then> <expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_C2R</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>frame_C2C</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>cfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>vm_pop_frame</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name> <init>= <expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_FLAGS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>VM_CHECK_MODE</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_gc_verify_internal_consistency</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>VMDEBUG</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>SDR</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_VM_CHECK_INTS</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>flags</name> <operator>&amp;</operator> <name>VM_FRAME_FLAG_FINISH</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_STATIC</name> <name>void</name></type>

<name>rb_vm_pop_frame</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>rb_arity_error_new</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>err_mess</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <name>max</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>err_mess</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"wrong number of arguments (given %d, expected %d)"</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>max</name> <operator>==</operator> <name>UNLIMITED_ARGUMENTS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>err_mess</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"wrong number of arguments (given %d, expected %d+)"</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>err_mess</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"wrong number of arguments (given %d, expected %d..%d)"</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><name>err_mess</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_STATIC</name> <name>void</name></type>

<name>rb_error_arity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_arity_error_new</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>NOINLINE</name><argument_list>(<argument>static void vm_env_write_slowpath(const VALUE *ep, int index, VALUE v)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_env_write_slowpath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><call><name>VM_ENV_ENVVAL</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_FORCE_WRITE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ep</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ENV_FLAGS_UNSET</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_WB_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>lvar_set_slowpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_env_write</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name> <init>= <expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_FLAGS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>VM_ENV_FLAG_WB_REQUIRED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_STACK_ENV_WRITE</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>vm_env_write_slowpath</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_STATIC</name> <name>VALUE</name></type>

<name>rb_vm_bh_to_procval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>block_handler</name> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_handler_type_iseq</name></expr>:</case>

<case>case <expr><name>block_handler_type_ifunc</name></expr>:</case>

<return>return <expr><call><name>rb_vm_make_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>VM_BH_TO_CAPT_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb_cProc</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_handler_type_symbol</name></expr>:</case>

<return>return <expr><call><name>rb_sym_to_proc</name><argument_list>(<argument><expr><call><name>VM_BH_TO_SYMBOL</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_handler_type_proc</name></expr>:</case>

<return>return <expr><call><name>VM_BH_TO_PROC</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>rb_vm_bh_to_procval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_svar_valid_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>svar</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>svar</name></expr></argument>, <argument><expr><name>T_IMEMO</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>svar</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_svar</name></expr>:</case>

<case>case <expr><name>imemo_cref</name></expr>:</case>

<case>case <expr><name>imemo_ment</name></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_svar_valid_p: unknown type: %s"</literal></expr></argument>, <argument><expr><call><name>rb_obj_info</name><argument_list>(<argument><expr><name>svar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>vm_svar</name></name> <modifier>*</modifier></type>

<name>lep_svar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>lep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>svar</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lep</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ec</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ec</name><operator>-&gt;</operator><name>root_lep</name></name> <operator>!=</operator> <name>lep</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>svar</name> <operator>=</operator> <name><name>lep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>svar</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>root_svar</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>svar</name> <operator>==</operator> <name>Qfalse</name> <operator>||</operator> <call><name>vm_svar_valid_p</name><argument_list>(<argument><expr><name>svar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator>struct <name>vm_svar</name> <operator>*</operator><operator>)</operator><name>svar</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>lep_svar_write</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>lep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_svar</name></name> <modifier>*</modifier></type><name>svar</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_svar_valid_p</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>svar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lep</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ec</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ec</name><operator>-&gt;</operator><name>root_lep</name></name> <operator>!=</operator> <name>lep</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_env_write</name><argument_list>(<argument><expr><name>lep</name></expr></argument>, <argument><expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>svar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>self</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>root_svar</name></name></expr></argument>, <argument><expr><name>svar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lep_svar_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>lep</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_svar</name></name> <modifier>*</modifier></type><name>svar</name> <init>= <expr><call><name>lep_svar</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>lep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>svar</name> <operator>==</operator> <name>Qfalse</name> <operator>||</operator> <call><name>imemo_type</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>svar</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>imemo_svar</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>key</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_SVAR_LASTLINE</name></expr>:</case>

<return>return <expr><name><name>svar</name><operator>-&gt;</operator><name>lastline</name></name></expr>;</return>

<case>case <expr><name>VM_SVAR_BACKREF</name></expr>:</case>

<return>return <expr><name><name>svar</name><operator>-&gt;</operator><name>backref</name></name></expr>;</return>

<default>default:</default> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>ary</name> <init>= <expr><name><name>svar</name><operator>-&gt;</operator><name>others</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>key</name> <operator>-</operator> <name>VM_SVAR_EXTRA_START</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>vm_svar</name></name> <modifier>*</modifier></type>

<name>svar_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator>struct <name>vm_svar</name> <operator>*</operator><operator>)</operator><call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>imemo_svar</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>lep_svar_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>lep</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>vm_svar</name></name> <modifier>*</modifier></type><name>svar</name> <init>= <expr><call><name>lep_svar</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>lep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>svar</name> <operator>==</operator> <name>Qfalse</name> <operator>||</operator> <call><name>imemo_type</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>svar</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>imemo_svar</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>lep_svar_write</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>lep</name></expr></argument>, <argument><expr><name>svar</name> <operator>=</operator> <call><name>svar_new</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>svar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>key</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_SVAR_LASTLINE</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>svar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>svar</name><operator>-&gt;</operator><name>lastline</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>VM_SVAR_BACKREF</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>svar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>svar</name><operator>-&gt;</operator><name>backref</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<default>default:</default> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><name><name>svar</name><operator>-&gt;</operator><name>others</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>svar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>svar</name><operator>-&gt;</operator><name>others</name></name></expr></argument>, <argument><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>key</name> <operator>-</operator> <name>VM_SVAR_EXTRA_START</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_getspecial</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>lep</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>lep_svar_get</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>lep</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>backref</name> <init>= <expr><call><name>lep_svar_get</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>lep</name></expr></argument>, <argument><expr><name>VM_SVAR_BACKREF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <literal type="number">0x01</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>type</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_reg_last_match</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'`'</literal></expr>:</case>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_reg_match_pre</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\''</literal></expr>:</case>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_reg_match_post</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_reg_match_last</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unexpected back-ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>type</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<expr_stmt><expr><call><name>PUREFUNC</name><argument_list>(<argument><expr><specifier>static</specifier> <name>rb_callable_method_entry_t</name> <operator>*</operator><macro><name>check_method_entry</name><argument_list>(<argument>VALUE obj</argument>, <argument>int can_be_svar</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>check_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>can_be_svar</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>Qfalse</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_IMEMO</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"check_method_entry: unknown type: %s"</literal></expr></argument>, <argument><expr><call><name>rb_obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_ment</name></expr>:</case>

<return>return <expr><operator>(</operator><name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr>;</return>

<case>case <expr><name>imemo_cref</name></expr>:</case>

<return>return <expr><name>NULL</name></expr>;</return>

<case>case <expr><name>imemo_svar</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>can_be_svar</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>check_method_entry</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>vm_svar</name> <operator>*</operator><operator>)</operator><name>obj</name><operator>)</operator><operator>-&gt;</operator><name>cref_or_me</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<default>default:</default>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"check_method_entry: svar should not be there:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>MJIT_STATIC</name> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_vm_frame_method_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>me</name> <operator>=</operator> <call><name>check_method_entry</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>me</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><call><name>check_method_entry</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>method_entry_cref</name><parameter_list>(<parameter><decl><type><name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<return>return <expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>cref</name></name></expr>;</return>

<default>default:</default>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>==</operator> <literal type="number">0</literal></expr></cpp:if>

<expr_stmt><expr><call><name>PUREFUNC</name><argument_list>(<argument><expr><specifier>static</specifier> <name>rb_cref_t</name> <operator>*</operator><call><name>check_cref</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>check_cref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>can_be_svar</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>Qfalse</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_IMEMO</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"check_cref: unknown type: %s"</literal></expr></argument>, <argument><expr><call><name>rb_obj_info</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_ment</name></expr>:</case>

<return>return <expr><call><name>method_entry_cref</name><argument_list>(<argument><expr><operator>(</operator><name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>imemo_cref</name></expr>:</case>

<return>return <expr><operator>(</operator><name>rb_cref_t</name> <operator>*</operator><operator>)</operator><name>obj</name></expr>;</return>

<case>case <expr><name>imemo_svar</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>can_be_svar</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>check_cref</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>vm_svar</name> <operator>*</operator><operator>)</operator><name>obj</name><operator>)</operator><operator>-&gt;</operator><name>cref_or_me</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<default>default:</default>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"check_method_entry: svar should not be there:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_env_cref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cref</name> <operator>=</operator> <call><name>check_cref</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>cref</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><call><name>check_cref</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>is_cref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>can_be_svar</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>T_IMEMO</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_cref</name></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

<case>case <expr><name>imemo_svar</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>can_be_svar</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>is_cref</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>vm_svar</name> <operator>*</operator><operator>)</operator><name>v</name><operator>)</operator><operator>-&gt;</operator><name>cref_or_me</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_env_cref_by_cref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>!</operator><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_cref</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><call><name>is_cref</name><argument_list>(<argument><expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>cref_replace_with_duplicated_cref_each_frame</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>vptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>can_be_svar</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>parent</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>v</name> <init>= <expr><operator>*</operator><name>vptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_cref</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>T_IMEMO</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>imemo_type</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>imemo_cref</name></expr>:</case>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <operator>(</operator><name>rb_cref_t</name> <operator>*</operator><operator>)</operator><name>v</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_cref</name> <operator>=</operator> <call><name>vm_cref_dup</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>vptr</name></expr></argument>, <argument><expr><name>new_cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_FORCE_WRITE</name><argument_list>(<argument><expr><name>vptr</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>new_cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>rb_cref_t</name> <operator>*</operator><operator>)</operator><name>new_cref</name></expr>;</return>

<case>case <expr><name>imemo_svar</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>can_be_svar</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>cref_replace_with_duplicated_cref_each_frame</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><operator>(</operator>struct <name>vm_svar</name> <operator>*</operator><operator>)</operator><name>v</name><operator>)</operator><operator>-&gt;</operator><name>cref_or_me</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<case>case <expr><name>imemo_ment</name></expr>:</case>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"cref_replace_with_duplicated_cref_each_frame: unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_cref_replace_with_duplicated_cref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_env_cref_by_cref</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>envval</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>envval</name> <operator>=</operator> <ternary><condition><expr><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>VM_ENV_ENVVAL</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cref</name> <operator>=</operator> <call><name>cref_replace_with_duplicated_cref_each_frame</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>envval</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>cref</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>envval</name> <operator>=</operator> <ternary><condition><expr><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>VM_ENV_ENVVAL</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</expr_stmt>

<return>return <expr><call><name>cref_replace_with_duplicated_cref_each_frame</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr>]</index></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>envval</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_cref_dup: unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_get_cref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>vm_env_cref</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cref</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>cref</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_get_cref: unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_ec_cref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>vm_get_cref</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_get_const_key_cref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>vm_get_cref</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>key_cref</name> <init>= <expr><name>cref</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>cref</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>FL_TEST</name><argument_list>(<argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RCLASS_CLONED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>key_cref</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_rewrite_cref</name><parameter_list>(<parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>old_klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>new_klass</name></decl></parameter>, <parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_cref_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>new_cref</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>cref</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>old_klass</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>new_cref</name> <operator>=</operator> <call><name>vm_cref_new_use_prev</name><argument_list>(<argument><expr><name>new_klass</name></expr></argument>, <argument><expr><name>METHOD_VISI_UNDEF</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>new_cref_ptr</name> <operator>=</operator> <name>new_cref</name></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>new_cref</name> <operator>=</operator> <call><name>vm_cref_new_use_prev</name><argument_list>(<argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>METHOD_VISI_UNDEF</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>new_cref_ptr</name> <operator>=</operator> <name>new_cref</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_cref_ptr</name> <operator>=</operator> <operator>(</operator><name>rb_cref_t</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>new_cref</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>new_cref_ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_cref_push</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pushed_by_eval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>prev_cref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prev_cref</name> <operator>=</operator> <call><name>vm_env_cref</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>vm_get_ruby_level_caller_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prev_cref</name> <operator>=</operator> <call><name>vm_env_cref</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>vm_cref_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>prev_cref</name></expr></argument>, <argument><expr><name>pushed_by_eval</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_get_cbase</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>vm_get_cref</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><name>Qundef</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>cref</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>klass</name> <operator>=</operator> <call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>klass</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_get_const_base</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>vm_get_cref</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><name>Qundef</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>cref</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CREF_PUSHED_BY_EVAL</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name>klass</name> <operator>=</operator> <call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>klass</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_check_if_namespace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"%+"</literal><name>PRIsVALUE</name><literal type="string">" is not a class/module"</literal></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_ensure_not_refinement_module</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FL_TEST</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>RMODULE_IS_REFINEMENT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"not defined at the refinement, but at the outer class/module"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_get_iclass</name><parameter_list>(<parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>klass</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_get_ev_const</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig_klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_nil</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_defined</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name></type> <name>rb_const_warn_if_deprecated</name><argument_list>(<argument><expr><specifier>const</specifier> <name>rb_const_entry_t</name> <operator>*</operator><name>ce</name></expr></argument>, <argument><expr><name>VALUE</name> <name>klass</name></expr></argument>, <argument><expr><name>ID</name> <name>id</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>orig_klass</name> <operator>==</operator> <name>Qnil</name> <operator>&amp;&amp;</operator> <name>allow_nil</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>root_cref</name> <init>= <expr><call><name>vm_get_cref</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>root_cref</name> <operator>&amp;&amp;</operator> <call><name>CREF_PUSHED_BY_EVAL</name><argument_list>(<argument><expr><name>root_cref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>root_cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>root_cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <name>root_cref</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>cref</name> <operator>&amp;&amp;</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>CREF_PUSHED_BY_EVAL</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>av</name></decl>, <decl><type ref="prev"/><name>am</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<label><name>search_continue</name>:</label>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_const_warn_if_deprecated</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>am</name> <operator>==</operator> <name>klass</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>am</name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_defined</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_autoloading_value</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>av</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>av</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_autoload_load</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>search_continue</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_defined</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>root_cref</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>root_cref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>vm_get_iclass</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>root_cref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>CLASS_OF</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_defined</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_const_defined</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_const_get</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>vm_check_if_namespace</name><argument_list>(<argument><expr><name>orig_klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_defined</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_public_const_defined_from</name><argument_list>(<argument><expr><name>orig_klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_public_const_get_from</name><argument_list>(<argument><expr><name>orig_klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_get_cvar_base</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_get_cvar_base: no cref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FL_TEST</name><argument_list>(<argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>CREF_PUSHED_BY_EVAL</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"class variable access from toplevel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>vm_get_iclass</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"no class variables available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>klass</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_search_const_defined_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>cbase</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_const_defined_at</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>cbase</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cbase</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_const_defined_at</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tmp</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<macro><name>ALWAYS_INLINE</name><argument_list>(<argument>static VALUE vm_getivar(VALUE, ID, IVC, const struct rb_callcache *, int)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_getivar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>IVC</name></type> <name>ic</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_attr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_IC_FOR_IVAR</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><name>Qundef</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><ternary><condition><expr><name>is_attr</name></expr> ?</condition><then>

<expr><call><name>RB_DEBUG_COUNTER_INC_UNLESS</name><argument_list>(<argument><expr><name>ivar_get_ic_miss_unset</name></expr></argument>, <argument><expr><call><name>vm_cc_attr_index</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>RB_DEBUG_COUNTER_INC_UNLESS</name><argument_list>(<argument><expr><name>ivar_get_ic_miss_serial</name></expr></argument>,

<argument><expr><name><name>ic</name><operator>-&gt;</operator><name>ic_serial</name></name> <operator>==</operator> <call><name>RCLASS_SERIAL</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>index</name> <init>= <expr><ternary><condition><expr><operator>!</operator><name>is_attr</name></expr> ?</condition><then> <expr><name><name>ic</name><operator>-&gt;</operator><name>index</name></name></expr> </then><else>: <expr><operator>(</operator><call><name>vm_cc_attr_index</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ivar_get_ic_hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_OBJECT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>LIKELY</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;</operator> <call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>st_lookup</name><argument_list>(<argument><expr><call><name>rb_ivar_generic_ivtbl</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>LIKELY</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>ret</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>iv_index_tbl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>numiv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ivptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_OBJECT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iv_index_tbl</name> <operator>=</operator> <call><name>ROBJECT_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>numiv</name> <operator>=</operator> <call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ivptr</name> <operator>=</operator> <call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>fill</name>:</label>

<if_stmt><if>if <condition>(<expr><name>iv_index_tbl</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_attr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ic</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ic</name><operator>-&gt;</operator><name>ic_serial</name></name> <operator>=</operator> <call><name>RCLASS_SERIAL</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><call><name>vm_cc_attr_index_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name>numiv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>st_lookup</name><argument_list>(<argument><expr><call><name>rb_ivar_generic_ivtbl</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>numiv</name> <operator>=</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ivptr</name> <operator>=</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>iv_index_tbl</name> <operator>=</operator> <call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>fill</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<goto>goto <name>general_path</name>;</goto>

</block_content>}</block></else></if_stmt>

<label><name>ret</name>:</label>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_attr</name> <operator>&amp;&amp;</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"instance variable %"</literal><name>PRIsVALUE</name><literal type="string">" not initialized"</literal></expr></argument>, <argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<label><name>general_path</name>:</label>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ivar_get_ic_miss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_attr</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_setivar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>IVC</name></type> <name>ic</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_attr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_IC_FOR_IVAR</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_check_frozen_internal</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_OBJECT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(

<argument><expr><operator>(</operator><operator>!</operator><name>is_attr</name> <operator>&amp;&amp;</operator> <call><name>RB_DEBUG_COUNTER_INC_UNLESS</name><argument_list>(<argument><expr><name>ivar_set_ic_miss_serial</name></expr></argument>, <argument><expr><name><name>ic</name><operator>-&gt;</operator><name>ic_serial</name></name> <operator>==</operator> <call><name>RCLASS_SERIAL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>

<operator>(</operator> <name>is_attr</name> <operator>&amp;&amp;</operator> <call><name>RB_DEBUG_COUNTER_INC_UNLESS</name><argument_list>(<argument><expr><name>ivar_set_ic_miss_unset</name></expr></argument>, <argument><expr><call><name>vm_cc_attr_index</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>index</name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><name>is_attr</name></expr> ?</condition><then> <expr><name><name>ic</name><operator>-&gt;</operator><name>index</name></name></expr> </then><else>: <expr><call><name>vm_cc_attr_index</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_DEBUG_COUNTER_INC_UNLESS</name><argument_list>(<argument><expr><name>ivar_set_ic_miss_oorange</name></expr></argument>, <argument><expr><name>index</name> <operator>&lt;</operator> <call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ptr</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ivar_set_ic_hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>iv_index_tbl</name> <init>= <expr><call><name>ROBJECT_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>iv_index_tbl</name> <operator>&amp;&amp;</operator> <call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_attr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ic</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ic</name><operator>-&gt;</operator><name>ic_serial</name></name> <operator>=</operator> <call><name>RCLASS_SERIAL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too many instance variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>vm_cc_attr_index_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>index</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ivar_set_ic_miss_noobject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ivar_set_ic_miss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_getinstancevariable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>IVC</name></type> <name>ic</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_getivar</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>ic</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_setinstancevariable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>IVC</name></type> <name>ic</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_setivar</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>ic</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_throw_continue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TAG_THROW</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <call><name>THROW_DATA_STATE</name><argument_list>(<argument><expr><operator>(</operator>struct <name>vm_throw_data</name> <operator>*</operator><operator>)</operator><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TAG_RAISE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>err</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_throw_start</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>throwobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>escape_cfp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>eocfp</name> <init>= <expr><call><name>RUBY_VM_END_CONTROL_FRAME</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_BREAK</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>is_orphan</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><call><name>GET_EP</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>base_iseq</name> <init>= <expr><call><name>GET_ISEQ</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <name>reg_cfp</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>base_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>ISEQ_TYPE_BLOCK</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>escape_cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_CLASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>escape_cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <name><name>escape_cfp</name><operator>-&gt;</operator><name>ep</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>base_iseq</name> <operator>=</operator> <name><name>escape_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>base_iseq</name> <operator>=</operator> <name><name>base_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <call><name>rb_vm_search_cf_from_ep</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>escape_cfp</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>escape_cfp</name><operator>-&gt;</operator><name>iseq</name></name> <operator>==</operator> <name>base_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>VM_FRAME_LAMBDA_P</name><argument_list>(<argument><expr><name>escape_cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_orphan</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>state</name> <operator>=</operator> <name>TAG_RETURN</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>escape_cfp</name> <operator>&lt;</operator> <name>eocfp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>escape_cfp</name><operator>-&gt;</operator><name>ep</name></name> <operator>==</operator> <name>ep</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>iseq</name> <init>= <expr><name><name>escape_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>epc</name> <init>= <expr><name><name>escape_cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>ct</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ct</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table_entry</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>entry</name> <init>=

<expr><call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_BREAK</name> <operator>&amp;&amp;</operator>

<name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name> <operator>==</operator> <name>base_iseq</name> <operator>&amp;&amp;</operator>

<name><name>entry</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name>epc</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;=</operator> <name>epc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>cont</name></name> <operator>==</operator> <name>epc</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>is_orphan</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>escape_cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_orphan</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_localjump_error</name><argument_list>(<argument><expr><literal type="string">"break from proc-closure"</literal></expr></argument>, <argument><expr><name>throwobj</name></expr></argument>, <argument><expr><name>TAG_BREAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_RETRY</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><call><name>GET_EP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <call><name>rb_vm_search_cf_from_ep</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_RETURN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>current_ep</name> <init>= <expr><call><name>GET_EP</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>target_lep</name> <init>= <expr><call><name>VM_EP_LEP</name><argument_list>(<argument><expr><name>current_ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>in_class_frame</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>toplevel</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <name>reg_cfp</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>escape_cfp</name> <operator>&lt;</operator> <name>eocfp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>lep</name> <init>= <expr><call><name>VM_CF_LEP</name><argument_list>(<argument><expr><name>escape_cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>target_lep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>target_lep</name> <operator>=</operator> <name>lep</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>lep</name> <operator>==</operator> <name>target_lep</name> <operator>&amp;&amp;</operator>

<call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>escape_cfp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>escape_cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_CLASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>in_class_frame</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>target_lep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>lep</name> <operator>==</operator> <name>target_lep</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VM_FRAME_LAMBDA_P</name><argument_list>(<argument><expr><name>escape_cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>toplevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>in_class_frame</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>valid_return</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>tep</name> <init>= <expr><name>current_ep</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>target_lep</name> <operator>!=</operator> <name>tep</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>escape_cfp</name><operator>-&gt;</operator><name>ep</name></name> <operator>==</operator> <name>tep</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>valid_return</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tep</name> <operator>=</operator> <call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>tep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>escape_cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>escape_cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_TYPE_TOP</name></expr>:</case>

<case>case <expr><name>ISEQ_TYPE_MAIN</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>toplevel</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>in_class_frame</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>unexpected_return</name>;</goto></block_content></block></if></if_stmt>

<goto>goto <name>valid_return</name>;</goto>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>ISEQ_TYPE_EVAL</name></expr>:</case>

<case>case <expr><name>ISEQ_TYPE_CLASS</name></expr>:</case>

<expr_stmt><expr><name>toplevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>escape_cfp</name><operator>-&gt;</operator><name>ep</name></name> <operator>==</operator> <name>target_lep</name> <operator>&amp;&amp;</operator> <name><name>escape_cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_METHOD</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>valid_return</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>escape_cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<label><name>unexpected_return</name>:</label><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>rb_vm_localjump_error</name><argument_list>(<argument><expr><literal type="string">"unexpected return"</literal></expr></argument>, <argument><expr><name>throwobj</name></expr></argument>, <argument><expr><name>TAG_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>valid_return</name>:</label><empty_stmt>;</empty_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"isns(throw): unsupported throw type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>THROW_DATA_NEW</name><argument_list>(<argument><expr><name>throwobj</name></expr></argument>, <argument><expr><name>escape_cfp</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_throw</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name>rb_num_t</name></type> <name>throw_state</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>throwobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>state</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>throw_state</name> <operator>&amp;</operator> <name>VM_THROW_STATE_MASK</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flag</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>throw_state</name> <operator>&amp;</operator> <name>VM_THROW_NO_ESCAPE_FLAG</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>vm_throw_start</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>throwobj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>vm_throw_continue</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>throwobj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_expandarray</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>is_splat</name> <init>= <expr><name>flag</name> <operator>&amp;</operator> <literal type="number">0x01</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_num_t</name></type> <name>space_size</name> <init>= <expr><name>num</name> <operator>+</operator> <name>is_splat</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name>sp</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_num_t</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>obj</name> <init>= <expr><name>ary</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name>ary</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>&amp;</operator><name>ary</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>rb_num_t</name><operator>)</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>space_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <literal type="number">0x02</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_num_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>num</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>num</name><operator>-</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>base</name><operator>++</operator> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><name><name>ptr</name><index>[<expr><name>len</name> <operator>-</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>base</name><operator>++</operator> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>is_splat</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>base</name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>len</name> <operator>-</operator> <name>j</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_num_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>bptr</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><index>[<expr><name>space_size</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>i</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>bptr</name><operator>--</operator> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>bptr</name><operator>--</operator> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>is_splat</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>bptr</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>bptr</name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>len</name> <operator>-</operator> <name>num</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>vm_call_general</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>vm_mtbl_dump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>target_mid</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type>

<name>vm_ccs_create</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>rb_class_cc_entries</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<expr_stmt><expr><name><name>ccs</name><operator>-&gt;</operator><name>debug_sig</name></name> <operator>=</operator> <operator>~</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>ccs</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>ccs</name><operator>-&gt;</operator><name>capa</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>, <argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_CACHED_SET</name><argument_list>(<argument><expr><operator>(</operator><name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr>struct <name>rb_class_cc_entries_entry</name></expr></argument>, <argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ccs</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_ccs_push</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <name><name>ccs</name><operator>-&gt;</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nsize</name> <init>= <expr><name><name>ccs</name><operator>-&gt;</operator><name>capa</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_class_cc_entries_entry</name></name> <modifier>*</modifier></type><name>nents</name> <init>= <expr><call><name>ALLOC_N</name><argument_list>(<argument><expr>struct <name>rb_class_cc_entries_entry</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ccs</name><operator>-&gt;</operator><name>capa</name></name> <operator>=</operator> <name>nsize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>nents</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr>struct <name>rb_class_cc_entries_entry</name></expr></argument>, <argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <name>nents</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name><name>ccs</name><operator>-&gt;</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pos</name> <init>= <expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>pos</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_DEBUG_COUNTER_SETMAX</name><argument_list>(<argument><expr><name>ccs_maxlen</name></expr></argument>, <argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><name>void</name></type>

<name>rb_vm_ccs_dump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ccs:%p (%d,%d)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ccs</name></expr></argument>, <argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>vm_ci_dump</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rp</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_ccs_verify</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ccs_p</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;=</operator> <name><name>ccs</name><operator>-&gt;</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ci_p</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_class_check</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type>

<name>vm_search_cc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>cc_tbl</name> <init>= <expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc_tbl</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ccs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ccs_len</name> <init>= <expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ccs_verify</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_ccs_free</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_delete</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ccs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>ccs_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ccs_ci</name> <init>= <expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>ccs_cc</name> <init>= <expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ci_p</name><argument_list>(<argument><expr><name>ccs_ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>ccs_cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ccs_ci</name> <operator>==</operator> <name>ci</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_found_ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>ccs_cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name> <operator>==</operator> <name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ccs_cc</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>ccs_cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ccs_cc</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>cc_tbl</name> <operator>=</operator> <call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>rb_id_table_create</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><call><name>rb_callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cme</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>vm_cc_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>, <argument><expr><name>vm_call_general</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_CACHED_SET</name><argument_list>(<argument><expr><operator>(</operator>struct <name>rb_callable_method_entry_struct</name> <operator>*</operator><operator>)</operator><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ccs</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc_tbl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ccs</name> <operator>=</operator> <call><name>vm_ccs_create</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vm_ccs_push</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>ccs</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>cme</name><operator>-&gt;</operator><name>called_id</name></name> <operator>==</operator> <name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name> <operator>==</operator> <name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>cc</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>

<name>rb_vm_search_method_slowpath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>cd_owner</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>vm_search_cc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cd_owner</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>cd_owner</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>==</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>cc</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>==</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>callable_method_entry_p</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>==</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>==</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name> <operator>==</operator> <call><name>vm_ci_mid</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_search_method_fastpath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>cd_owner</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INLINE_METHOD_CACHE</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>vm_cc_class_check</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>callable_method_entry_p</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>mc_inline_hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator> 

<operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_SUPER</name><operator>)</operator> <operator>||</operator> 

<call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name> <operator>==</operator> <call><name>vm_ci_mid</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name> <operator>=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>mc_inline_miss_invalidated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>mc_inline_miss_klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_vm_search_method_slowpath</name><argument_list>(<argument><expr><name>cd_owner</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>vm_cc_cme</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name> <operator>==</operator> <call><name>vm_ci_mid</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_search_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>cd_owner</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>klass</name> <operator>!=</operator> <name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>rb_cClass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_search_method_fastpath</name><argument_list>(<argument><expr><name>cd_owner</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>check_cfunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>()</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>me</name> <operator>&amp;&amp;</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_CFUNC</name> <operator>&amp;&amp;</operator>

<name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>cfunc</name><operator>.</operator><name>func</name></name> <operator>==</operator> <name>func</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>vm_method_cfunc_is</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>CALL_DATA</name></type> <name>cd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>()</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_search_method</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>check_cfunc</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>opt_equal_fallback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>CALL_DATA</name></type> <name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_method_cfunc_is</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>rb_obj_equal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><name>recv</name> <operator>==</operator> <name>obj</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUILTIN_CLASS_P</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!SPECIAL_CONST_P(x) &amp;&amp; RBASIC_CLASS(x) == k)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EQ_UNREDEFINED_P</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>BASIC_OP_UNREDEFINED_P(BOP_EQ, t##_REDEFINED_OP_FLAG)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>

<name>FIXNUM_2_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>SIGNED_VALUE</name></type> <name>x</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SIGNED_VALUE</name></type> <name>y</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SIGNED_VALUE</name></type> <name>z</name> <init>= <expr><name>x</name> <operator>&amp;</operator> <name>y</name> <operator>&amp;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<return>return <expr><name>z</name> <operator>==</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>

<name>FLONUM_2_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_FLONUM</name></expr></cpp:if>

<decl_stmt><decl><type><name>SIGNED_VALUE</name></type> <name>x</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SIGNED_VALUE</name></type> <name>y</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SIGNED_VALUE</name></type> <name>z</name> <init>= <expr><operator>(</operator><operator>(</operator><name>x</name> <operator>^</operator> <literal type="number">2</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>y</name> <operator>^</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>!</operator><name>z</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>false</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>comparable_by_identity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><call><name>EQ_UNREDEFINED_P</name><argument_list>(<argument><expr><name>INTEGER</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><call><name>EQ_UNREDEFINED_P</name><argument_list>(<argument><expr><name>FLOAT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><call><name>EQ_UNREDEFINED_P</name><argument_list>(<argument><expr><name>SYMBOL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_BIG_INLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<specifier>inline</specifier>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>VALUE</name></type>

<name>opt_eq_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>CALL_DATA</name></type> <name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>comparable_by_identity</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>recv</name> <operator>==</operator> <name>obj</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>

<goto>goto <name>fallback</name>;</goto>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>BUILTIN_CLASS_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>rb_cFloat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>EQ_UNREDEFINED_P</name><argument_list>(<argument><expr><name>FLOAT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_float_equal</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>BUILTIN_CLASS_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>rb_cString</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>EQ_UNREDEFINED_P</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>recv</name> <operator>==</operator> <name>obj</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_eql_internal</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>fallback</name>:</label>

<return>return <expr><call><name>opt_equal_fallback</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_BIG_INLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<specifier>inline</specifier>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>VALUE</name></type>

<name>opt_eql_func</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>CALL_DATA</name></type> <name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>comparable_by_identity</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>recv</name> <operator>==</operator> <name>obj</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>

<goto>goto <name>fallback</name>;</goto>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>BUILTIN_CLASS_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>rb_cFloat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>EQ_UNREDEFINED_P</name><argument_list>(<argument><expr><name>FLOAT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_float_eql</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>BUILTIN_CLASS_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>rb_cString</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>EQ_UNREDEFINED_P</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_eql</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>fallback</name>:</label>

<return>return <expr><call><name>opt_equal_fallback</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUILTIN_CLASS_P</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EQ_UNREDEFINED_P</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vm_ci_new_id</name><parameter_list>(<parameter><type><name>mid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vm_ci_new_runtime(mid, 0, 0, NULL)</cpp:value></cpp:define>

<function><type><name>VALUE</name></type>

<name>rb_equal_opt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ci</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>vm_ci_new_id</name><argument_list>(<argument><expr><name>idEq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name></type> <name>cd</name> <init>= <expr><block>{ <expr><operator>.</operator><name>ci</name> <operator>=</operator> <name>ci</name></expr>, <expr><operator>.</operator><name>cc</name> <operator>=</operator> <macro><name>vm_cc_empty</name><argument_list>()</argument_list></macro></expr> }</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>opt_eq_func</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>obj1</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_eql_opt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name></type> <name>cd</name> <init>= <expr><block>{ <expr><operator>.</operator><name>ci</name> <operator>=</operator> <call><name>vm_ci_new_id</name><argument_list>(<argument><expr><name>idEqlP</name></expr></argument>)</argument_list></call></expr>, <expr><operator>.</operator><name>cc</name> <operator>=</operator> <macro><name>vm_cc_empty</name><argument_list>()</argument_list></macro></expr> }</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>opt_eql_func</name><argument_list>(<argument><expr><name>obj1</name></expr></argument>, <argument><expr><name>obj2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>extern</specifier> <name>VALUE</name></type> <name>rb_vm_call0</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>ID</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>check_match</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>vm_check_match_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_CHECKMATCH_TYPE_WHEN</name></expr>:</case>

<return>return <expr><name>pattern</name></expr>;</return>

<case>case <expr><name>VM_CHECKMATCH_TYPE_RESCUE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>rb_cModule</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"class or module required for rescue clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<case>case <expr><name>VM_CHECKMATCH_TYPE_CASE</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>=

<expr><call><name>rb_callable_method_entry_with_refinements</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idEqq</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_vm_call0</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>idEqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>idEqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"check_match: unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MSC_VERSION_BEFORE</name><argument_list>(<argument><expr><literal type="number">1300</literal></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_CMP_NAN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (isnan(a) || isnan(b)) return Qfalse;</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_CMP_NAN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>double_cmp_lt</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CMP_NAN</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>double_cmp_le</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CMP_NAN</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>a</name> <operator>&lt;=</operator> <name>b</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>double_cmp_gt</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CMP_NAN</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>double_cmp_ge</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CMP_NAN</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>a</name> <operator>&gt;=</operator> <name>b</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>vm_base_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

const rb_control_frame_t *prev_cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp);

if (cfp-&gt;iseq &amp;&amp; VM_FRAME_RUBYFRAME_P(cfp)) {

VALUE *bp = prev_cfp-&gt;sp + cfp-&gt;iseq-&gt;body-&gt;local_table_size + VM_ENV_DATA_SIZE;

if (cfp-&gt;iseq-&gt;body-&gt;type == ISEQ_TYPE_METHOD) {

bp += 1;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_DEBUG_BP_CHECK</name></expr></cpp:if>

if (bp != cfp-&gt;bp_check) {

fprintf(stderr, "bp_check: %ld, bp: %ld\n",

(long)(cfp-&gt;bp_check - GET_EC()-&gt;vm_stack),

(long)(bp - GET_EC()-&gt;vm_stack));

rb_bug("vm_base_ptr: unreachable");

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return bp;

}

else {

return NULL;

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name><name>cfp</name><operator>-&gt;</operator><name>__bp__</name></name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_args.c"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>vm_call_iseq_setup_2</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt_pc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>param_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local_size</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>ALWAYS_INLINE</name><argument_list>(<argument>static VALUE vm_call_iseq_setup_normal(rb_execution_context_t *ec, rb_control_frame_t *cfp, struct rb_calling_info *calling, const rb_callable_method_entry_t *me, int opt_pc, int param_size, int local_size)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>vm_call_iseq_setup_tailcall</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt_pc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>vm_call_super_method</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>vm_call_method_nome</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>vm_call_method_each_type</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>vm_call_method</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>vm_call_handler</name></type> <name>vm_call_iseq_setup_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>param_size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>local_size</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup_tailcall_0start</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_iseq_setup_tailcall_0start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_iseq_setup_tailcall</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup_normal_0start</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_iseq_setup_0start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>def_iseq_ptr</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>param</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>local</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_call_iseq_setup_normal</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_STATIC</name> <name>bool</name></type>

<name>rb_simple_iseq_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>accepts_no_kwarg</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>==</operator> <name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>

<name>rb_iseq_only_optparam_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>accepts_no_kwarg</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>==</operator> <name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>

<name>rb_iseq_only_kwparam_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>==</operator> <name>TRUE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>==</operator> <name>FALSE</name> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>==</operator> <name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>CALLER_SETUP_ARG</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>calling</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>IS_ARGS_SPLAT</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>final_hash</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_caller_setup_arg_splat</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_ARGS_KW_OR_KW_SPLAT</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>RB_TYPE_P</name><argument_list>(<argument><expr><operator>(</operator><name>final_hash</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><operator>(</operator><operator>(</operator>struct <name>RHash</name> <operator>*</operator><operator>)</operator><name>final_hash</name><operator>)</operator><operator>-&gt;</operator><name><name>basic</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>RHASH_PASS_AS_KEYWORDS</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <call><name>rb_hash_dup</name><argument_list>(<argument><expr><name>final_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>IS_ARGS_KW_OR_KW_SPLAT</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_ARGS_KEYWORD</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_caller_setup_arg_kw</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>keyword_hash</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>keyword_hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_hash_dup</name><argument_list>(<argument><expr><call><name>rb_to_hash_type</name><argument_list>(<argument><expr><name>keyword_hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IS_ARGS_KW_SPLAT_MUT</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_hash_dup</name><argument_list>(<argument><expr><name>keyword_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>CALLER_REMOVE_EMPTY_KW_SPLAT</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>calling</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_OPT_HIST</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OPT_HIST</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_HIST_MAX</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>opt_hist</name><index>[<expr><name>OPT_HIST_MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<macro><name>__attribute__</name><argument_list>(<argument>(destructor)</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>opt_hist_show_results_at_exit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>OPT_HIST_MAX</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"opt_hist\t%d\t%d\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>opt_hist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup_normal_opt_start</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>def_iseq_ptr</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lead_num</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <name>lead_num</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt_num</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt_pc</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name><index>[<expr><name>opt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>param</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>local</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>delta</name> <init>= <expr><name>opt_num</name> <operator>-</operator> <name>opt</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_iseq_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OPT_HIST</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>opt_pc</name> <operator>&lt;</operator> <name>OPT_HIST_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>opt_hist</name><index>[<expr><name>opt</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>opt_hist</name><index>[<expr><name>OPT_HIST_MAX</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>vm_call_iseq_setup_normal</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>opt_pc</name></expr></argument>, <argument><expr><name>param</name> <operator>-</operator> <name>delta</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup_tailcall_opt_start</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>def_iseq_ptr</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lead_num</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <name>lead_num</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt_pc</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name><index>[<expr><name>opt</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_iseq_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OPT_HIST</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>opt_pc</name> <operator>&lt;</operator> <name>OPT_HIST_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>opt_hist</name><index>[<expr><name>opt</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>opt_hist</name><index>[<expr><name>OPT_HIST_MAX</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>vm_call_iseq_setup_tailcall</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>opt_pc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type>

<name>args_setup_kw_parameters</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>iseq</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>passed_values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>passed_keyword_len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>passed_keywords</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>locals</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup_kwparm_kwarg</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_KWARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_iseq_kw1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>def_iseq_ptr</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>kw_param</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kw_arg</name> <init>= <expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ci_kw_len</name> <init>= <expr><name><name>kw_arg</name><operator>-&gt;</operator><name>keyword_len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>ci_keywords</name> <init>= <expr><name><name>kw_arg</name><operator>-&gt;</operator><name>keywords</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>klocals</name> <init>= <expr><name>argv</name> <operator>+</operator> <name><name>kw_param</name><operator>-&gt;</operator><name>bits_start</name></name> <operator>-</operator> <name><name>kw_param</name><operator>-&gt;</operator><name>num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lead_num</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>ci_kws</name> <init>= <expr><call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>ci_kw_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>ci_kws</name></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <name>lead_num</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>ci_kw_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>args_setup_kw_parameters</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ci_kws</name></expr></argument>, <argument><expr><name>ci_kw_len</name></expr></argument>, <argument><expr><name>ci_keywords</name></expr></argument>, <argument><expr><name>klocals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>param</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>local</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_call_iseq_setup_normal</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup_kwparm_nokwarg</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>MAYBE_UNUSED</name><parameter_list>(<parameter><decl><type><name>ci</name></type></decl></parameter>)</parameter_list> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_KWARG</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_iseq_kw2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>def_iseq_ptr</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>kw_param</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>argv</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>klocals</name> <init>= <expr><name>argv</name> <operator>+</operator> <name><name>kw_param</name><operator>-&gt;</operator><name>bits_start</name></name> <operator>-</operator> <name><name>kw_param</name><operator>-&gt;</operator><name>num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>kw_param</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>klocals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>kw_param</name><operator>-&gt;</operator><name>default_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>klocals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>param</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>local</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_call_iseq_setup_normal</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>vm_callee_setup_arg</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>param_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_KW_SPLAT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>rb_simple_iseq_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALLER_REMOVE_EMPTY_KW_SPLAT</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>argument_arity_error</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><call><name>vm_call_iseq_setup_func</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>param_size</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>vm_call_iseq_optimizable_p</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_iseq_only_optparam_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALLER_REMOVE_EMPTY_KW_SPLAT</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lead_num</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt_num</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>argc</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt</name> <init>= <expr><name>argc</name> <operator>-</operator> <name>lead_num</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>opt</name></expr></argument> &gt;</argument_list></name> <name>opt_num</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>argument_arity_error</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>lead_num</name></expr></argument>, <argument><expr><name>lead_num</name> <operator>+</operator> <name>opt_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_TAILCALL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_iseq_setup_normal_opt_start</name></expr></argument>,

<argument><expr><operator>!</operator><call><name>IS_ARGS_SPLAT</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_ARGS_KEYWORD</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>METHOD_VISI_PROTECTED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_iseq_setup_tailcall_opt_start</name></expr></argument>,

<argument><expr><operator>!</operator><call><name>IS_ARGS_SPLAT</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_ARGS_KEYWORD</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>METHOD_VISI_PROTECTED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name> <operator>==</operator> <name>lead_num</name> <operator>+</operator> <name>opt_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><name>argc</name></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>lead_num</name> <operator>+</operator> <name>opt_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name><index>[<expr><name>opt</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_iseq_only_kwparam_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_ARGS_SPLAT</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>lead_num</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>argc</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>kw_param</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_KWARG</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kw_arg</name> <init>= <expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>-</operator> <name><name>kw_arg</name><operator>-&gt;</operator><name>keyword_len</name></name> <operator>==</operator> <name>lead_num</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ci_kw_len</name> <init>= <expr><name><name>kw_arg</name><operator>-&gt;</operator><name>keyword_len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>ci_keywords</name> <init>= <expr><name><name>kw_arg</name><operator>-&gt;</operator><name>keywords</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>ci_kws</name> <init>= <expr><call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>ci_kw_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>ci_kws</name></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <name>lead_num</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>ci_kw_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>klocals</name> <init>= <expr><name>argv</name> <operator>+</operator> <name><name>kw_param</name><operator>-&gt;</operator><name>bits_start</name></name> <operator>-</operator> <name><name>kw_param</name><operator>-&gt;</operator><name>num</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>args_setup_kw_parameters</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ci_kws</name></expr></argument>, <argument><expr><name>ci_kw_len</name></expr></argument>, <argument><expr><name>ci_keywords</name></expr></argument>, <argument><expr><name>klocals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_iseq_setup_kwparm_kwarg</name></expr></argument>,

<argument><expr><operator>!</operator><operator>(</operator><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>METHOD_VISI_PROTECTED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <name>lead_num</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>klocals</name> <init>= <expr><name>argv</name> <operator>+</operator> <name><name>kw_param</name><operator>-&gt;</operator><name>bits_start</name></name> <operator>-</operator> <name><name>kw_param</name><operator>-&gt;</operator><name>num</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>args_setup_kw_parameters</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>klocals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>klocals</name><index>[<expr><name><name>kw_param</name><operator>-&gt;</operator><name>num</name></name></expr>]</index></name> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_iseq_setup_kwparm_nokwarg</name></expr></argument>,

<argument><expr><operator>!</operator><operator>(</operator><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>METHOD_VISI_PROTECTED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>setup_parameters_complex</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>arg_setup_method</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_iseq_setup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>def_iseq_ptr</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>param_size</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>local_size</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt_pc</name> <init>= <expr><call><name>vm_callee_setup_arg</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><call><name>def_iseq_ptr</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>def</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name>param_size</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_call_iseq_setup_2</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>opt_pc</name></expr></argument>, <argument><expr><name>param_size</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup_2</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>opt_pc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>param_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_TAILCALL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>vm_call_iseq_setup_normal</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>opt_pc</name></expr></argument>, <argument><expr><name>param_size</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>vm_call_iseq_setup_tailcall</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>opt_pc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup_normal</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>opt_pc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>param_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>local_size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>def_iseq_ptr</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name>argv</name> <operator>+</operator> <name>param_size</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>argv</name> <operator>-</operator> <literal type="number">1</literal></expr> ;</expr_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>VM_FRAME_MAGIC_METHOD</name> <operator>|</operator> <name>VM_ENV_FLAG_LOCAL</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>,

<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>me</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>+</operator> <name>opt_pc</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>,

<argument><expr><name>local_size</name> <operator>-</operator> <name>param_size</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_call_iseq_setup_tailcall</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>opt_pc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>def_iseq_ptr</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>src_argv</name> <init>= <expr><name>argv</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>sp_orig</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>finish_flag</name> <init>= <expr><ternary><condition><expr><call><name>VM_FRAME_FINISHED_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>VM_FRAME_FLAG_FINISH</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_BH_FROM_CFP_P</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>dst_captured</name> <init>= <expr><call><name>VM_CFP_TO_CAPTURED_BLOCK</name><argument_list>(<argument><expr><call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>src_captured</name> <init>= <expr><call><name>VM_BH_TO_CAPT_BLOCK</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dst_captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name><name>src_captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_BH_ISEQ_BLOCK_P</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name> <operator>=</operator> <call><name>VM_BH_FROM_ISEQ_BLOCK</name><argument_list>(<argument><expr><name>dst_captured</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name> <operator>=</operator> <call><name>VM_BH_FROM_IFUNC_BLOCK</name><argument_list>(<argument><expr><name>dst_captured</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>sp_orig</name> <operator>=</operator> <name>sp</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sp</name><operator>++</operator> <operator>=</operator> <name><name>src_argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>VM_FRAME_MAGIC_METHOD</name> <operator>|</operator> <name>VM_ENV_FLAG_LOCAL</name> <operator>|</operator> <name>finish_flag</name></expr></argument>,

<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>me</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>+</operator> <name>opt_pc</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>sp_orig</name></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_m2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_m1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_3</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_4</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_5</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_6</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_7</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_8</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_9</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_10</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_11</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_12</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_13</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_14</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_cfunc_15</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>VALUE</name></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>VALUE</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name>, <name>VALUE</name><operator>)</operator></call><operator>)</operator><name>func</name></expr></init>;</function_decl>

<return>return <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>vm_cfp_consistent_p</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ov_flags</name> <init>= <expr><name>RAISED_STACKOVERFLOW</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name>reg_cfp</name> <operator>==</operator> <name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_ec_raised_p</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>ov_flags</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ec_raised_reset</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>ov_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_CFP_CONSISTENCY</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(LIKELY(vm_cfp_consistent_p(ec, reg_cfp)) ? (void)0 : rb_bug(func ": cfp consistency error (%p, %p)", (void *)reg_cfp, (void *)(ec-&gt;cfp+1)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier>

<specifier>const</specifier> <name>rb_method_cfunc_t</name> <modifier>*</modifier></type>

<name>vm_method_cfunc_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_DEBUG_VERIFY_METHOD_CACHE</name></expr></cpp:if>

<switch>switch <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<break>break;</break>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_BUG</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case VM_METHOD_TYPE_##t: rb_bug("wrong method type: " #t)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>ISEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>ATTRSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>IVAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>BMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>ZSUPER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>UNDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>OPTIMIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>MISSING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>REFINED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_BUG</name><argument_list>(<argument><expr><name>ALIAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>METHOD_BUG</name></cpp:undef>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"wrong method type: %d"</literal></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name><name>body</name><operator>.</operator><name>cfunc</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_cfunc_with_frame</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_cfunc_t</name> <modifier>*</modifier></type><name>cfunc</name> <init>= <expr><call><name>vm_method_cfunc_entry</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>cfunc</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>frame_type</name> <init>= <expr><name>VM_FRAME_MAGIC_CFUNC</name> <operator>|</operator> <name>VM_FRAME_FLAG_CFRAME</name> <operator>|</operator> <name>VM_ENV_FLAG_LOCAL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>orig_argc</name> <init>= <expr><name>argc</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>frame_type</name> <operator>|=</operator> <name>VM_FRAME_FLAG_CFRAME_KW</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_CMETHOD_ENTRY_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_C_CALL</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>frame_type</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>,

<argument><expr><name>block_handler</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>me</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-=</operator> <name>orig_argc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>cfunc</name><operator>-&gt;</operator><name>invoker</name></name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>cfunc</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CFP_CONSISTENCY</name><argument_list>(<argument><expr><literal type="string">"vm_call_cfunc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_C_RETURN</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_CMETHOD_RETURN_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_cfunc</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_cfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALLER_REMOVE_EMPTY_KW_SPLAT</name><argument_list>(<argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_cfunc_with_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_ivar</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_ivar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><call><name>vm_getivar</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_attrset</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_attrset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><operator>*</operator><operator>(</operator><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<return>return <expr><call><name>vm_setivar</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_call_bmethod_body</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_vm_invoke_bmethod</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_bmethod</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_bmethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>-</operator> <name>argc</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>+=</operator> <operator>-</operator> <name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_bmethod_body</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>find_defined_class_by_owner</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>current_class</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>target_owner</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><name>current_class</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FL_TEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>RICLASS_IS_ORIGIN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>owner</name> <init>= <expr><ternary><condition><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>klass</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>==</operator> <name>target_owner</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>klass</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>current_class</name></expr>;</return> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>aliased_callable_method_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>orig_me</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>orig_me</name><operator>-&gt;</operator><name>defined_class</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name> <init>= <expr><call><name>find_defined_class_by_owner</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>, <argument><expr><name><name>orig_me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>orig_me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <call><name>rb_method_entry_complement_defined_class</name><argument_list>(<argument><expr><name>orig_me</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>alias_count</name></name> <operator>+</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>complemented_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name></name></expr></argument>, <argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name> <init>=

<expr><call><name>rb_method_definition_create</name><argument_list>(<argument><expr><name>VM_METHOD_TYPE_ALIAS</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_method_definition_set</name><argument_list>(<argument><expr><operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name>me</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>orig_me</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>callable_method_entry_p</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>cme</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_alias</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><call><name>aliased_callable_method_entry</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callcache</name></name></type> <name>cc_body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name></type> <name>cd_body</name> <init>= <expr><block>{

<expr><operator>.</operator><name>ci</name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr>,

<expr><operator>.</operator><name>cc</name> <operator>=</operator> <call><name>vm_cc_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cc_body</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_call_method_each_type</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd_body</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>method_missing_reason</name></name></type>

<name>ci_missing_reason</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>method_missing_reason</name></name></type> <name>stat</name> <init>= <expr><name>MISSING_NOENTRY</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_VCALL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>stat</name> <operator>|=</operator> <name>MISSING_VCALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_FCALL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>stat</name> <operator>|=</operator> <name>MISSING_FCALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_SUPER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>stat</name> <operator>|=</operator> <name>MISSING_SUPER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>stat</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_opt_send</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>orig_cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_opt_send</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>sym</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name></type> <name>cd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>method_missing_reason</name></name></type> <name>missing_reason</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name><name>orig_cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no method name given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <call><name>TOPN</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mid</name> <operator>=</operator> <call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_method_basic_definition_p</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idMethodMissing</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>=

<expr><call><name>rb_make_no_method_exception</name><argument_list>(<argument><expr><name>rb_eNoMethodError</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>,

<argument><expr><call><name>rb_long2int</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>TOPN</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name><name>orig_cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>VM_CALL_FCALL</name><operator>|</operator><name>VM_CALL_VCALL</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>TOPN</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>rb_str_intern</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mid</name> <operator>=</operator> <name>idMethodMissing</name></expr>;</expr_stmt>

<expr_stmt><expr><name>missing_reason</name> <operator>=</operator> <call><name>ci_missing_reason</name><argument_list>(<argument><expr><name><name>orig_cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>method_missing_reason</name></name> <operator>=</operator> <name>missing_reason</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>TOPN</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>TOPN</name><argument_list>(<argument><expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEC_SP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>new_flag</name> <init>= <expr><name>VM_CALL_FCALL</name> <operator>|</operator> <name>VM_CALL_OPT_SEND</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr> ?</condition><then> <expr><name>VM_CALL_KW_SPLAT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>ci</name></name> <operator>=</operator> <call><name>vm_ci_new_runtime</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>new_flag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> , <argument><expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name><name>orig_cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callcache</name></name></type> <name>cc_body</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <call><name>vm_cc_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cc_body</name></expr></argument>,

<argument><expr><name>Qundef</name></expr></argument>,

<argument><expr><call><name>rb_callable_method_entry_with_refinements</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>missing_reason</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>vm_cc_method_missing_reason_set</name><argument_list>(<argument><expr><name><name>cd</name><operator>.</operator><name>cc</name></name></expr></argument>, <argument><expr><name>missing_reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>vm_call_method</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><operator>(</operator><name>CALL_DATA</name><operator>)</operator><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>vm_invoke_block</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>NOINLINE</name><argument_list>(<argument>static VALUE

vm_invoke_block_opt_call(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp,

struct rb_calling_info *calling, const struct rb_callinfo *ci, VALUE block_handler)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_invoke_block_opt_call</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>TOPN</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>TOPN</name><argument_list>(<argument><expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>DEC_SP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_invoke_block</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_opt_call</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_opt_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_invoke_block_opt_call</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><call><name>VM_BH_FROM_PROC</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_opt_block_call</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_opt_block_call</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>VM_ENV_BLOCK_HANDLER</name><argument_list>(<argument><expr><call><name>VM_CF_LEP</name><argument_list>(<argument><expr><name>reg_cfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_CALL</name></expr></argument>, <argument><expr><name>PROC_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>vm_invoke_block_opt_call</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name> <operator>=</operator> <call><name>rb_vm_bh_to_procval</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_search_method</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>reg_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_general</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_method_missing_body</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>orig_ci</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>method_missing_reason</name></name></type> <name>reason</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_method_missing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>STACK_ADDR_FROM_TOP</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name></type> <name>cd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>argc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>orig_ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name> <init>= <expr><name>VM_CALL_FCALL</name> <operator>|</operator> <name>VM_CALL_OPT_SEND</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr> ?</condition><then> <expr><name>VM_CALL_KW_SPLAT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>ci</name></name> <operator>=</operator> <call><name>vm_ci_new_runtime</name><argument_list>(<argument><expr><name>idMethodMissing</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name>orig_ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callcache</name></name></type> <name>cc_body</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cd</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <call><name>vm_cc_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cc_body</name></expr></argument>,

<argument><expr><name>Qundef</name></expr></argument>,

<argument><expr><call><name>rb_callable_method_entry_without_refinements</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idMethodMissing</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>vm_call_general</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_VM_STACK_OVERFLOW</name><argument_list>(<argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_check_canary</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name>argv</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>orig_ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INC_SP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>method_missing_reason</name></name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_method</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_method_missing</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_call_method_missing_body</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>, <argument><expr><call><name>vm_cc_cmethod_missing_reason</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>refined_method_callable_without_refinement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_zsuper</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><ternary><condition><expr><name>klass</name></expr> ?</condition><then> <expr><call><name>rb_callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cme</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>vm_call_method_nome</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cme</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name> <operator>&amp;&amp;</operator>

<name><name>cme</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <call><name>refined_method_callable_without_refinement</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callcache</name></name></type> <name>cc_body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name></type> <name>cd_body</name> <init>= <expr><block>{

<expr><operator>.</operator><name>ci</name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr>,

<expr><operator>.</operator><name>cc</name> <operator>=</operator> <call><name>vm_cc_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cc_body</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_call_method_each_type</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd_body</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>find_refinement</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>refinements</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<expr_stmt><expr><call><name>PUREFUNC</name><argument_list>(<argument><expr><specifier>static</specifier> <name>rb_control_frame_t</name> <operator>*</operator> <call><name>current_method_entry</name><argument_list>(<argument><expr><specifier>const</specifier> <name>rb_execution_context_t</name> <operator>*</operator><name>ec</name></expr></argument>, <argument><expr><name>rb_control_frame_t</name> <operator>*</operator><name>cfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>current_method_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>top_cfp</name> <init>= <expr><name>cfp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name> <operator>&amp;&amp;</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_BLOCK</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>local_iseq</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>top_cfp</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while <condition>(<expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name> <operator>!=</operator> <name>local_iseq</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>cfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>refined_method_callable_without_refinement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>orig_me</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>orig_me</name><operator>-&gt;</operator><name>defined_class</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_notimplement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>orig_me</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>callable_method_entry_p</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>cme</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>search_refined_method</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>vm_get_cref</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>cref</name></expr>;</condition> <incr><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>refinement</name> <init>= <expr><call><name>find_refinement</name><argument_list>(<argument><expr><call><name>CREF_REFINEMENTS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>owner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ref_me</name> <init>=

<expr><call><name>rb_callable_method_entry</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ref_me</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_cc_call</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>vm_call_super_method</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>top_cfp</name> <init>= <expr><call><name>current_method_entry</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>top_me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name>top_cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>top_me</name> <operator>&amp;&amp;</operator> <call><name>rb_method_definition_eq</name><argument_list>(<argument><expr><name><name>ref_me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name><name>top_me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cme</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_REFINED</name> <operator>||</operator>

<name><name>cme</name><operator>-&gt;</operator><name>def</name></name> <operator>!=</operator> <name><name>ref_me</name><operator>-&gt;</operator><name>def</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <name>ref_me</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ref_me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>cme</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>refined_method_callable_without_refinement</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><ternary><condition><expr><name>klass</name></expr> ?</condition><then> <expr><call><name>rb_callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><name>cme</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_refined</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><call><name>search_refined_method</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cme</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callcache</name></name></type> <name>cc_body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name></type> <name>cd_body</name> <init>= <expr><block>{

<expr><operator>.</operator><name>ci</name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr>,

<expr><operator>.</operator><name>cc</name> <operator>=</operator> <call><name>vm_cc_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cc_body</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_call_method</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd_body</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>vm_call_method_nome</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_method_each_type</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_iseq_setup</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_iseq_setup</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_cfunc</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_cfunc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALLER_REMOVE_EMPTY_KW_SPLAT</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_cc_attr_index_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_attrset</name></expr></argument>, <argument><expr><operator>!</operator><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>VM_CALL_ARGS_SPLAT</name> <operator>|</operator> <name>VM_CALL_KW_SPLAT</name> <operator>|</operator> <name>VM_CALL_KWARG</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_attrset</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALLER_REMOVE_EMPTY_KW_SPLAT</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_cc_attr_index_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_ivar</name></expr></argument>, <argument><expr><operator>!</operator><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>VM_CALL_ARGS_SPLAT</name> <operator>|</operator> <name>VM_CALL_KW_SPLAT</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_ivar</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<expr_stmt><expr><call><name>vm_cc_method_missing_reason_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_method_missing</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_method_missing</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_bmethod</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_bmethod</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_alias</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_alias</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<switch>switch <condition>(<expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>optimize_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>OPTIMIZED_METHOD_TYPE_SEND</name></expr>:</case>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_opt_send</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_opt_send</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>OPTIMIZED_METHOD_TYPE_CALL</name></expr>:</case>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_opt_call</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_opt_call</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>OPTIMIZED_METHOD_TYPE_BLOCK_CALL</name></expr>:</case>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_opt_block_call</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_opt_block_call</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_call_method: unsupported optimized method type (%d)"</literal></expr></argument>,

<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>optimize_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<return>return <expr><call><name>vm_call_zsuper</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<return>return <expr><call><name>vm_call_refined</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_call_method: unsupported method type (%d)"</literal></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void vm_raise_method_missing(rb_execution_context_t *ec, int argc, const VALUE *argv, VALUE obj, int call_status)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_method_nome</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>stat</name> <init>= <expr><call><name>ci_missing_reason</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>idMethodMissing</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name> <init>= <expr><name>cfp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>STACK_ADDR_FROM_TOP</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_raise_method_missing</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>vm_call_method_missing_body</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>, <argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_call_method</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>callable_method_entry_p</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>METHOD_VISI_PUBLIC</name></expr>:</case> 

<return>return <expr><call><name>vm_call_method_each_type</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>METHOD_VISI_PRIVATE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_FCALL</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>method_missing_reason</name></name></type> <name>stat</name> <init>= <expr><name>MISSING_PRIVATE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_VCALL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>stat</name> <operator>|=</operator> <name>MISSING_VCALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vm_cc_method_missing_reason_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CC_SET_FASTPATH</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>vm_call_method_missing</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_method_missing</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>vm_call_method_each_type</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>METHOD_VISI_PROTECTED</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_OPT_SEND</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_cc_method_missing_reason_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>MISSING_PROTECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_method_missing</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callcache</name></name></type> <name>cc_body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name></type> <name>cd_body</name> <init>= <expr><block>{

<expr><operator>.</operator><name>ci</name> <operator>=</operator> <name>ci</name></expr>,

<expr><operator>.</operator><name>cc</name> <operator>=</operator> <call><name>vm_cc_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cc_body</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>vm_cc_call</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_call_method_each_type</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd_body</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>vm_call_method_each_type</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>vm_call_method_nome</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_general</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_general</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_method</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call_super_method</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccf_super_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_cc_call</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>vm_call_super_method</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"bug"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>vm_call_method</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_search_normal_superclass</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ICLASS</name> <operator>&amp;&amp;</operator>

<call><name>FL_TEST</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr></argument>, <argument><expr><name>RMODULE_IS_REFINEMENT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void vm_super_outside(void)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_super_outside</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eNoMethodError</name></expr></argument>, <argument><expr><literal type="string">"super called outside of method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_search_super_method</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>current_defined_class</name></decl>, <decl><type ref="prev"/><name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name>reg_cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>me</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_super_outside</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>current_defined_class</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>RCLASS_REFINED_CLASS</name><argument_list>(<argument><expr><name>current_defined_class</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>current_defined_class</name> <operator>=</operator> <call><name>RCLASS_REFINED_CLASS</name><argument_list>(<argument><expr><name>current_defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>current_defined_class</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_MODULE</name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>current_defined_class</name></expr></argument>, <argument><expr><name>RMODULE_INCLUDED_INTO_REFINEMENT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>current_defined_class</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>m</name> <init>= <expr><ternary><condition><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>current_defined_class</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><call><name>RCLASS_INCLUDER</name><argument_list>(<argument><expr><name>current_defined_class</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>current_defined_class</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,

<argument><expr><literal type="string">"self has wrong type to call super in this context: "</literal>

<literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">" (expected %"</literal><name>PRIsVALUE</name><literal type="string">")"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_BMETHOD</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_ZSUPER</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>,

<argument><expr><literal type="string">"implicit argument passing of super from method defined"</literal>

<literal type="string">" by define_method() is not supported."</literal>

<literal type="string">" Specify all arguments explicitly."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <call><name>vm_ci_new_runtime</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>,

<argument><expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>vm_search_normal_superclass</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>klass</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>vm_cc_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vm_call_method_missing</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>vm_search_method_fastpath</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>reg_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cached_cme</name> <init>= <expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cached_cme</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>empty_cc_for_super</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>empty_cc_for_super</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>empty_cc_for_super</name> <operator>=</operator> <call><name>vm_cc_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vm_call_super_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_SET_RAW</name><argument_list>(<argument><expr><name>empty_cc_for_super</name></expr></argument>, <argument><expr><name>VM_CALLCACHE_UNMARKABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>empty_cc_for_super</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name>empty_cc_for_super</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>cached_cme</name><operator>-&gt;</operator><name>called_id</name></name> <operator>!=</operator> <name>mid</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><call><name>rb_callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>vm_cc_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>, <argument><expr><name>vm_call_super_method</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>vm_cc_call_set</name><argument_list>(<argument><expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name>vm_call_super_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>block_proc_is_lambda</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>procval</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_yield_with_cfunc</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>is_lambda</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>, <decl><type ref="prev"/><name>arg</name></decl>, <decl><type ref="prev"/><name>blockarg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>frame_flag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_ifunc</name></name> <modifier>*</modifier></type><name>ifunc</name> <init>= <expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>ifunc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_lambda</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>blockarg</name> <operator>=</operator> <call><name>rb_vm_bh_to_procval</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>frame_flag</name> <operator>=</operator> <name>VM_FRAME_MAGIC_IFUNC</name> <operator>|</operator> <name>VM_FRAME_FLAG_CFRAME</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>me</name></expr> ?</condition><then> <expr><name>VM_FRAME_FLAG_BMETHOD</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kw_splat</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>frame_flag</name> <operator>|=</operator> <name>VM_FRAME_FLAG_CFRAME_KW</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>ifunc</name></name></expr></argument>,

<argument><expr><name>frame_flag</name></expr></argument>,

<argument><expr><name>self</name></expr></argument>,

<argument><expr><call><name>VM_GUARDED_PREV_EP</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>me</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>ifunc</name><operator>-&gt;</operator><name>func</name></name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>ifunc</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>blockarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_yield_with_symbol</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>symbol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_sym_proc_call</name><argument_list>(<argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><call><name>rb_vm_bh_to_procval</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>vm_callee_setup_block_arg_arg0_splat</name><parameter_list>(<parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_VM_STACK_OVERFLOW</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name> <operator>&amp;&amp;</operator> <name>i</name><operator>&lt;</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>i</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_callee_setup_block_arg_arg0_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>, <decl><type ref="prev"/><name>arg0</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

argv[0] = arg0;

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>arg0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_callee_setup_block_arg</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>arg_setup_type</name></name></type> <name>arg_setup_type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_simple_iseq_p</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg0</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALLER_REMOVE_EMPTY_KW_SPLAT</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg_setup_type</name> <operator>==</operator> <name>arg_setup_block</name> <operator>&amp;&amp;</operator>

<name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>

<name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_lead</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ambiguous_param0</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg0</name> <operator>=</operator> <call><name>vm_callee_setup_block_arg_arg0_check</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <call><name>vm_callee_setup_block_arg_arg0_splat</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>arg_setup_type</name> <operator>==</operator> <name>arg_setup_block</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_VM_STACK_OVERFLOW</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>;</expr_stmt> 

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>argument_arity_error</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>setup_parameters_complex</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>arg_setup_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_yield_setup_args</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>arg_setup_type</name></name></type> <name>arg_setup_type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_calling_info</name></name></type> <name>calling_entry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>calling</name></decl>;</decl_stmt>

<expr_stmt><expr><name>calling</name> <operator>=</operator> <operator>&amp;</operator><name>calling_entry</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name> <operator>=</operator> <name>block_handler</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name> <operator>=</operator> <name>kw_splat</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callinfo</name></name></type> <name>dummy_ci</name> <init>= <expr><block>{

<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>T_IMEMO</name> <operator>|</operator> <operator>(</operator><name>imemo_callinfo</name> <operator>&lt;&lt;</operator> <name>FL_USHIFT</name><operator>)</operator></expr>,

<expr><operator>.</operator><name>flag</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><operator>(</operator><name>kw_splat</name> <operator>?</operator> <name>VM_CALL_KW_SPLAT</name> <operator>:</operator> <literal type="number">0</literal><operator>)</operator></expr>,

}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_callee_setup_block_arg</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy_ci</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>arg_setup_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_invoke_iseq_block</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>is_lambda</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>arg_size</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>rsp</name> <init>= <expr><call><name>GET_SP</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opt_pc</name> <init>= <expr><call><name>vm_callee_setup_block_arg</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>rsp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>is_lambda</name></expr> ?</condition><then> <expr><name>arg_setup_method</name></expr> </then><else>: <expr><name>arg_setup_block</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SET_SP</name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>,

<argument><expr><name>VM_FRAME_MAGIC_BLOCK</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>is_lambda</name></expr> ?</condition><then> <expr><name>VM_FRAME_FLAG_LAMBDA</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,

<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>self</name></name></expr></argument>,

<argument><expr><call><name>VM_GUARDED_PREV_EP</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>+</operator> <name>opt_pc</name></expr></argument>,

<argument><expr><name>rsp</name> <operator>+</operator> <name>arg_size</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name>arg_size</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_invoke_symbol_block</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>symbol</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>vm_yield_with_symbol</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>symbol</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><call><name>STACK_ADDR_FROM_TOP</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POPN</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_invoke_ifunc_block</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CALLER_SETUP_ARG</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALLER_REMOVE_EMPTY_KW_SPLAT</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>vm_yield_with_cfunc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>, <argument><expr><name><name>captured</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><call><name>STACK_ADDR_FROM_TOP</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>POPN</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_proc_to_block_handler</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>procval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>vm_proc_block</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<return>return <expr><call><name>VM_BH_FROM_ISEQ_BLOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<return>return <expr><call><name>VM_BH_FROM_IFUNC_BLOCK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<return>return <expr><call><name>VM_BH_FROM_SYMBOL</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<return>return <expr><call><name>VM_BH_FROM_PROC</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>vm_yield_with_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_invoke_block</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>is_lambda</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>

<switch>switch <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_handler_type_iseq</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_BH_TO_ISEQ_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_invoke_iseq_block</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>is_lambda</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block>

<case>case <expr><name>block_handler_type_ifunc</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_BH_TO_IFUNC_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_invoke_ifunc_block</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block>

<case>case <expr><name>block_handler_type_proc</name></expr>:</case>

<expr_stmt><expr><name>is_lambda</name> <operator>=</operator> <call><name>block_proc_is_lambda</name><argument_list>(<argument><expr><call><name>VM_BH_TO_PROC</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>block_handler</name> <operator>=</operator> <call><name>vm_proc_to_block_handler</name><argument_list>(<argument><expr><call><name>VM_BH_TO_PROC</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

<case>case <expr><name>block_handler_type_symbol</name></expr>:</case>

<return>return <expr><call><name>vm_invoke_symbol_block</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><call><name>VM_BH_TO_SYMBOL</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>vm_invoke_block</name><operator>:</operator> <name>unreachable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_make_proc_with_iseq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>blockiseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_make_proc_with_iseq: unreachable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>captured</name> <operator>=</operator> <call><name>VM_CFP_TO_CAPTURED_BLOCK</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>iseq</name></name> <operator>=</operator> <name>blockiseq</name></expr>;</expr_stmt>

<return>return <expr><call><name>rb_vm_make_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>, <argument><expr><name>rb_cProc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_once_exec</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name> <init>= <expr><call><name>vm_make_proc_with_iseq</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_proc_call_with_block</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_once_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>union</name> <name>iseq_inline_storage_entry</name></name> <modifier>*</modifier></type><name>is</name> <init>= <expr><operator>(</operator>union <name>iseq_inline_storage_entry</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>running_thread</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_control_frame_t</name> <modifier>*</modifier>

<name>FUNC_FASTCALL</name></type>(<name>rb_vm_opt_struct_aref</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>TOPN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>rb_struct_aref</name><argument_list>(<argument><expr><call><name>GET_SELF</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>TOPN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>reg_cfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_control_frame_t</name> <modifier>*</modifier>

<name>FUNC_FASTCALL</name></type>(<name>rb_vm_opt_struct_aset</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_struct_aset</name><argument_list>(<argument><expr><call><name>GET_SELF</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>TOPN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TOPN</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>reg_cfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>defined_type</name></name></type>

<name>check_respond_to_missing</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_check_funcall</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idRespond_to_missing</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>DEFINED_METHOD</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>DEFINED_NOT_DEFINED</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_defined</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>op_type</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>needstr</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>defined_type</name></name></type> <name>expr_type</name> <init>= <expr><name>DEFINED_NOT_DEFINED</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>defined_type</name></name></type> <name>type</name> <init>= <expr><operator>(</operator>enum <name>defined_type</name><operator>)</operator><name>op_type</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DEFINED_IVAR</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>rb_ivar_defined</name><argument_list>(<argument><expr><call><name>GET_SELF</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_IVAR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>DEFINED_IVAR2</name></expr>:</case>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>vm_get_cbase</name><argument_list>(<argument><expr><call><name>GET_EP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DEFINED_GVAR</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>rb_gvar_defined</name><argument_list>(<argument><expr><call><name>rb_global_entry</name><argument_list>(<argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_GVAR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>DEFINED_CVAR</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>vm_get_cref</name><argument_list>(<argument><expr><call><name>GET_EP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>vm_get_cvar_base</name><argument_list>(<argument><expr><name>cref</name></expr></argument>, <argument><expr><call><name>GET_CFP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_cvar_defined</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_CVAR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>DEFINED_CONST</name></expr>:</case>

<case>case <expr><name>DEFINED_CONST_FROM</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>allow_nil</name> <init>= <expr><name>type</name> <operator>==</operator> <name>DEFINED_CONST</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_get_ev_const</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>allow_nil</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_CONST</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>DEFINED_FUNC</name></expr>:</case>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>CLASS_OF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_method_boundp</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_METHOD</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <call><name>check_respond_to_missing</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>DEFINED_METHOD</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>METHOD_VISI_PRIVATE</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>METHOD_VISI_PROTECTED</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><call><name>GET_SELF</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>rb_class_real</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<case>case <expr><name>METHOD_VISI_PUBLIC</name></expr>:</case>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_METHOD</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_defined: unreachable: %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <call><name>check_respond_to_missing</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>DEFINED_YIELD</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>GET_BLOCK_HANDLER</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_YIELD</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>DEFINED_ZSUPER</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><call><name>GET_CFP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>vm_search_normal_superclass</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_method_boundp</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_ZSUPER</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>DEFINED_REF</name></expr>:</case><block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_getspecial</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>GET_LEP</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>, <argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>expr_type</name> <operator>=</operator> <name>DEFINED_GVAR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unimplemented defined? type (VM)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>expr_type</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>needstr</name> <operator>!=</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_iseq_defined_string</name><argument_list>(<argument><expr><name>expr_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>vm_get_ep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>reg_ep</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>lv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_num_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><name>reg_ep</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lv</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>GET_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>ep</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_get_special_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>reg_ep</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>vm_special_object_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_SPECIAL_OBJECT_VMCORE</name></expr>:</case>

<return>return <expr><name>rb_mRubyVMFrozenCore</name></expr>;</return>

<case>case <expr><name>VM_SPECIAL_OBJECT_CBASE</name></expr>:</case>

<return>return <expr><call><name>vm_get_cbase</name><argument_list>(<argument><expr><name>reg_ep</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_SPECIAL_OBJECT_CONST_BASE</name></expr>:</case>

<return>return <expr><call><name>vm_get_const_base</name><argument_list>(<argument><expr><name>reg_ep</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"putspecialobject insn: unknown value_type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_freezestring</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>debug</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>id_debug_created_info</name></expr></argument>, <argument><expr><name>debug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_freeze</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_concat_array</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>ary2</name> <init>= <expr><name>ary2st</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp1</name> <init>= <expr><call><name>rb_check_to_array</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp2</name> <init>= <expr><call><name>rb_check_to_array</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp1</name> <operator>==</operator> <name>ary1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_ary_concat</name><argument_list>(<argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_splat_array</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>rb_check_to_array</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>tmp</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_check_match</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>flag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>vm_check_match_type</name></name></type> <name>type</name> <init>= <expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>flag</name><operator>)</operator> <operator>&amp;</operator> <name>VM_CHECKMATCH_TYPE_MASK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>VM_CHECKMATCH_ARRAY</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>n</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name> <init>= <expr><call><name>check_match</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>c</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>check_match</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_check_keyword</name><parameter_list>(<parameter><decl><type><name>lindex_t</name></type> <name>bits</name></decl></parameter>, <parameter><decl><type><name>lindex_t</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>kw_bits</name> <init>= <expr><operator>*</operator><operator>(</operator><name>ep</name> <operator>-</operator> <name>bits</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>kw_bits</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>b</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><call><name>FIX2ULONG</name><argument_list>(<argument><expr><name>kw_bits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idx</name> <operator>&lt;</operator> <name>KW_SPECIFIED_BITS_MAX</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>b</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0x01</literal> <operator>&lt;&lt;</operator> <name>idx</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>kw_bits</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_hash_has_key</name><argument_list>(<argument><expr><name>kw_bits</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_dtrace</name><parameter_list>(<parameter><decl><type><name>rb_event_flag_t</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RUBY_DTRACE_METHOD_ENTRY_ENABLED</name><argument_list>()</argument_list></call> <operator>||</operator>

<call><name>RUBY_DTRACE_METHOD_RETURN_ENABLED</name><argument_list>()</argument_list></call> <operator>||</operator>

<call><name>RUBY_DTRACE_CMETHOD_ENTRY_ENABLED</name><argument_list>()</argument_list></call> <operator>||</operator>

<call><name>RUBY_DTRACE_CMETHOD_RETURN_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>RUBY_EVENT_CALL</name></expr>:</case>

<expr_stmt><expr><call><name>RUBY_DTRACE_METHOD_ENTRY_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>RUBY_EVENT_C_CALL</name></expr>:</case>

<expr_stmt><expr><call><name>RUBY_DTRACE_CMETHOD_ENTRY_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>RUBY_EVENT_RETURN</name></expr>:</case>

<expr_stmt><expr><call><name>RUBY_DTRACE_METHOD_RETURN_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>RUBY_EVENT_C_RETURN</name></expr>:</case>

<expr_stmt><expr><call><name>RUBY_DTRACE_CMETHOD_RETURN_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_const_get_under</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ns</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ns</name> <operator>=</operator> <call><name>vm_search_const_defined_class</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ns</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>VM_DEFINECLASS_SCOPED_P</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_public_const_get_at</name><argument_list>(<argument><expr><name>ns</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_const_get_at</name><argument_list>(<argument><expr><name>ns</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_check_if_class</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>super</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>VM_DEFINECLASS_HAS_SUPERCLASS_P</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>rb_class_real</name><argument_list>(<argument><expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>super</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,

<argument><expr><literal type="string">"superclass mismatch for class %"</literal><name>PRIsVALUE</name><literal type="string">""</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>klass</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>klass</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_check_if_module</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>mod</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>declare_under</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_set_class_path_string</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cbase</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_const_set</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>c</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_declare_class</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>super</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><ternary><condition><expr><call><name>VM_DEFINECLASS_HAS_SUPERCLASS_P</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>super</name></expr> </then><else>: <expr><name>rb_cObject</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name> <init>= <expr><call><name>declare_under</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>cbase</name></expr></argument>, <argument><expr><call><name>rb_define_class_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_class_inherited</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>c</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_declare_module</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>declare_under</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>cbase</name></expr></argument>, <argument><expr><call><name>rb_define_module_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void unmatched_redefinition(const char *type, VALUE cbase, ID id, VALUE old)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>unmatched_redefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>old</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>message</name> <init>= <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">" is not a %s"</literal></expr></argument>,

<argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>location</name> <init>= <expr><call><name>rb_const_source_location_at</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="string">"\n%"</literal><name>PRIsVALUE</name><literal type="string">":%"</literal><name>PRIsVALUE</name><literal type="string">":"</literal>

<literal type="string">" previous definition of %"</literal><name>PRIsVALUE</name><literal type="string">" was here"</literal></expr></argument>,

<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_exc_new_str</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_define_class</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>super</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_DEFINECLASS_HAS_SUPERCLASS_P</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>super</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,

<argument><expr><literal type="string">"superclass must be a Class (%"</literal><name>PRIsVALUE</name><literal type="string">" given)"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>super</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vm_check_if_namespace</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_autoload_load</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>klass</name> <operator>=</operator> <call><name>vm_const_get_under</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>cbase</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vm_check_if_class</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>super</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>unmatched_redefinition</name><argument_list>(<argument><expr><literal type="string">"class"</literal></expr></argument>, <argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>klass</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>vm_declare_class</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>super</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_define_module</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>rb_num_t</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mod</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_check_if_namespace</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mod</name> <operator>=</operator> <call><name>vm_const_get_under</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>cbase</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vm_check_if_module</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>unmatched_redefinition</name><argument_list>(<argument><expr><literal type="string">"module"</literal></expr></argument>, <argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>mod</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>vm_declare_module</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>cbase</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_find_or_create_class_by_id</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>,

<parameter><decl><type><name>rb_num_t</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>super</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_defineclass_type_t</name></type> <name>type</name> <init>= <expr><call><name>VM_DEFINECLASS_TYPE</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_DEFINECLASS_TYPE_CLASS</name></expr>:</case>

<return>return <expr><call><name>vm_define_class</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>cbase</name></expr></argument>, <argument><expr><name>super</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_DEFINECLASS_TYPE_SINGLETON_CLASS</name></expr>:</case>

<return>return <expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_DEFINECLASS_TYPE_MODULE</name></expr>:</case>

<return>return <expr><call><name>vm_define_module</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>cbase</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unknown defineclass type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_method_visibility_t</name></type>

<name>vm_scope_visibility_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vm_env_cref_by_cref</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>METHOD_VISI_PUBLIC</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>CREF_SCOPE_VISI</name><argument_list>(<argument><expr><call><name>vm_ec_cref</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>method_visi</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_scope_module_func_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vm_env_cref_by_cref</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>CREF_SCOPE_VISI</name><argument_list>(<argument><expr><call><name>vm_ec_cref</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>module_func</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_define_method</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>iseqval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_singleton</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>vm_ec_cref</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_singleton</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>visi</name> <operator>=</operator> <call><name>vm_scope_visibility_get</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>visi</name> <operator>=</operator> <name>METHOD_VISI_PUBLIC</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"no class/module to add method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_add_method_iseq</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseqval</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_singleton</name> <operator>&amp;&amp;</operator> <call><name>vm_scope_module_func_check</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_add_method_iseq</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseqval</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_search_method_wrap</name><parameter_list>(

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_search_method</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>reg_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_search_invokeblock</name><parameter_list>(

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_invokeblock_i</name><parameter_list>(

<parameter><decl><type><name><name>struct</name> <name>rb_execution_context_struct</name></name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>VM_CF_BLOCK_HANDLER</name><argument_list>(<argument><expr><call><name>GET_CFP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>block_handler</name> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_localjump_error</name><argument_list>(<argument><expr><literal type="string">"no block given (yield)"</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>vm_invoke_block</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>GET_CFP</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_sendish</name><parameter_list>(

<parameter><decl><type><name><name>struct</name> <name>rb_execution_context_struct</name></name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>,

<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>method_explorer</name>)<parameter_list>(

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name> <init>= <expr><call><name>TOPN</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_calling_info</name></name></type> <name>calling</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>calling</name><operator>.</operator><name>block_handler</name></name> <operator>=</operator> <name>block_handler</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>.</operator><name>kw_splat</name></name> <operator>=</operator> <call><name>IS_ARGS_KW_SPLAT</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>.</operator><name>recv</name></name> <operator>=</operator> <name>recv</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>calling</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>method_explorer</name><argument_list>(<argument><expr><call><name>GET_CFP</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><call><name>vm_cc_call</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>GET_CFP</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>val</name></expr>;</return> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RESTORE_REGS</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>GET_ISEQ</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>body</name><operator>-&gt;</operator><name>catch_except_p</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ENV_FLAGS_SET</name><argument_list>(<argument><expr><call><name>GET_EP</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>val</name> <operator>=</operator> <call><name>mjit_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ENV_FLAGS_SET</name><argument_list>(<argument><expr><call><name>GET_EP</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>mjit_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_str_freeze</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bop</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>bop</name></expr></argument>, <argument><expr><name>STRING_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_cmp</name></cpp:macro> <cpp:value>idCmp</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_newarray_max</name><parameter_list>(<parameter><decl><type><name>rb_num_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MAX</name></expr></argument>, <argument><expr><name>ARRAY_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cmp_opt_data</name></name></type> <name>cmp_opt</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_snum_t</name></type> <name>i</name> <init>= <expr><name>num</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>++</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>OPTIMIZED_CMP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>cmp_opt</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>idMax</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_newarray_min</name><parameter_list>(<parameter><decl><type><name>rb_num_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MIN</name></expr></argument>, <argument><expr><name>ARRAY_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cmp_opt_data</name></name></type> <name>cmp_opt</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_snum_t</name></type> <name>i</name> <init>= <expr><name>num</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>i</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>v</name> <init>= <expr><operator>*</operator><operator>++</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>OPTIMIZED_CMP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>cmp_opt</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>idMin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>id_cmp</name></cpp:undef>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_ic_hit_p</name><parameter_list>(<parameter><decl><type><name>IC</name></type> <name>ic</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>reg_ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ic</name><operator>-&gt;</operator><name>ic_serial</name></name> <operator>==</operator> <call><name>GET_GLOBAL_CONSTANT_STATE</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name><name>ic</name><operator>-&gt;</operator><name>ic_cref</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> 

<name><name>ic</name><operator>-&gt;</operator><name>ic_cref</name></name> <operator>==</operator> <call><name>vm_get_cref</name><argument_list>(<argument><expr><name>reg_ep</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_ic_update</name><parameter_list>(<parameter><decl><type><name>IC</name></type> <name>ic</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>reg_ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ic</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ic</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ic</name><operator>-&gt;</operator><name>ic_serial</name></name> <operator>=</operator> <call><name>GET_GLOBAL_CONSTANT_STATE</name><argument_list>()</argument_list></call> <operator>-</operator> <name>ruby_vm_const_missing_count</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ic</name><operator>-&gt;</operator><name>ic_cref</name></name> <operator>=</operator> <call><name>vm_get_const_key_cref</name><argument_list>(<argument><expr><name>reg_ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ruby_vm_const_missing_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_once_dispatch</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>ISEQ</name></type> <name>iseq</name></decl></parameter>, <parameter><decl><type><name>ISE</name></type> <name>is</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>RUNNING_THREAD_ONCE_DONE</name> <init>= <expr><operator>(</operator><name>rb_thread_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><literal type="number">0x1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>

<if_stmt><if>if <condition>(<expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>running_thread</name></name> <operator>==</operator> <name>RUNNING_THREAD_ONCE_DONE</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>value</name></name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>running_thread</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>running_thread</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_ensure</name><argument_list>(<argument><expr><name>vm_once_exec</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>, <argument><expr><name>vm_once_clear</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>running_thread</name></name> <operator>=</operator> <name>RUNNING_THREAD_ONCE_DONE</name></expr>;</expr_stmt> 

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>running_thread</name></name> <operator>==</operator> <name>th</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>vm_once_exec</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RUBY_VM_CHECK_INTS</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_thread_schedule</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OFFSET</name></type>

<name>vm_case_dispatch</name><parameter_list>(<parameter><decl><type><name>CDHASH</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>OFFSET</name></type> <name>else_offset</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>OBJ_BUILTIN_TYPE</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>

<case>case <expr><name>T_FLOAT</name></expr>:</case>

<case>case <expr><name>T_SYMBOL</name></expr>:</case>

<case>case <expr><name>T_BIGNUM</name></expr>:</case>

<case>case <expr><name>T_STRING</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_EQQ</name></expr></argument>,

<argument><expr><name>SYMBOL_REDEFINED_OP_FLAG</name> <operator>|</operator>

<name>INTEGER_REDEFINED_OP_FLAG</name> <operator>|</operator>

<name>FLOAT_REDEFINED_OP_FLAG</name> <operator>|</operator>

<name>NIL_REDEFINED_OP_FLAG</name> <operator>|</operator>

<name>TRUE_REDEFINED_OP_FLAG</name> <operator>|</operator>

<name>FALSE_REDEFINED_OP_FLAG</name> <operator>|</operator>

<name>STRING_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>kval</name> <init>= <expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isinf</name><argument_list>(<argument><expr><name>kval</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>modf</name><argument_list>(<argument><expr><name>kval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>kval</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <ternary><condition><expr><call><name>FIXABLE</name><argument_list>(<argument><expr><name>kval</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>kval</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>rb_dbl2big</name><argument_list>(<argument><expr><name>kval</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_hash_stlike_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>else_offset</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void

vm_stack_consistency_error(const rb_execution_context_t *ec,

const rb_control_frame_t *,

const VALUE *)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_stack_consistency_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>bp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>nsp</name> <init>= <expr><call><name>VM_SP_CNT</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ptrdiff_t</name></type> <name>nbp</name> <init>= <expr><call><name>VM_SP_CNT</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>stack_consistency_error</name><index>[]</index></name> <init>=

<expr><literal type="string">"Stack consistency error (sp: %"</literal><name>PRIdPTRDIFF</name><literal type="string">", bp: %"</literal><name>PRIdPTRDIFF</name><literal type="string">")"</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>RUBY_DEVEL</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name> <init>= <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><name>stack_consistency_error</name></expr></argument>, <argument><expr><name>nsp</name></expr></argument>, <argument><expr><name>nbp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><call><name>rb_iseq_disasm</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_fatal</name><argument_list>(<argument><expr><call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eFatal</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><name>stack_consistency_error</name></expr></argument>, <argument><expr><name>nsp</name></expr></argument>, <argument><expr><name>nbp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_plus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_PLUS</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_fix_plus_fix</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_PLUS</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_PLUS</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_PLUS</name></expr></argument>, <argument><expr><name>STRING_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_opt_plus</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cArray</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cArray</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_PLUS</name></expr></argument>, <argument><expr><name>ARRAY_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_ary_plus</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_minus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MINUS</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_fix_minus_fix</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MINUS</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MINUS</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_mult</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MULT</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_fix_mul_fix</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MULT</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MULT</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_div</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_DIV</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>Qundef</name></expr> </then><else>: <expr><call><name>rb_fix_div_fix</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_DIV</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_flo_div_flo</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_DIV</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_flo_div_flo</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_mod</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MOD</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>Qundef</name></expr> </then><else>: <expr><call><name>rb_fix_mod_fix</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MOD</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>ruby_float_mod</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MOD</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>ruby_float_mod</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_neq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>CALL_DATA</name></type> <name>cd</name></decl></parameter>, <parameter><decl><type><name>CALL_DATA</name></type> <name>cd_eq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_method_cfunc_is</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>rb_obj_not_equal</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>opt_eq_func</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>cd_eq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>RTEST</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>Qtrue</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_lt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_LT</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>recv</name> <operator>&lt;</operator> <operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>obj</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_LT</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_LT</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CMP_NAN</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_le</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_LE</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>recv</name> <operator>&lt;=</operator> <operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>obj</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_LE</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_LE</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CMP_NAN</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_gt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_GT</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>recv</name> <operator>&gt;</operator> <operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>obj</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_GT</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_GT</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CMP_NAN</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_ge</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_GE</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>recv</name> <operator>&gt;=</operator> <operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>obj</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FLONUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_GE</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cFloat</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_GE</name></expr></argument>, <argument><expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK_CMP_NAN</name><argument_list>(<argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_ltlt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_LTLT</name></expr></argument>, <argument><expr><name>STRING_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cArray</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_LTLT</name></expr></argument>, <argument><expr><name>ARRAY_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_and</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_AND</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>recv</name> <operator>&amp;</operator> <name>obj</name><operator>)</operator> <operator>|</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_or</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_OR</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>recv</name> <operator>|</operator> <name>obj</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_aref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_2_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_AREF</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_fix_aref</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cArray</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_AREF</name></expr></argument>, <argument><expr><name>ARRAY_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_ary_entry_internal</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_ary_aref1</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cHash</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_AREF</name></expr></argument>, <argument><expr><name>HASH_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_aset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>set</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cArray</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_ASET</name></expr></argument>, <argument><expr><name>ARRAY_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>set</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cHash</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_ASET</name></expr></argument>, <argument><expr><name>HASH_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>set</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_aref_with</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cHash</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_AREF</name></expr></argument>, <argument><expr><name>HASH_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>rb_hash_compare_by_id_p</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_aset_with</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cHash</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_ASET</name></expr></argument>, <argument><expr><name>HASH_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>rb_hash_compare_by_id_p</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bop</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>bop</name></expr></argument>, <argument><expr><name>STRING_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bop</name> <operator>==</operator> <name>BOP_EMPTY_P</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_str_length</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cArray</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>bop</name></expr></argument>, <argument><expr><name>ARRAY_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cHash</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>bop</name></expr></argument>, <argument><expr><name>HASH_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_empty_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_opt_length</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>BOP_EMPTY_P</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Qundef</name></expr>:</case> <return>return <expr><name>Qundef</name></expr>;</return>

<case>case <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>:</case> <return>return <expr><name>Qtrue</name></expr>;</return>

<default>default:</default> <return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function_decl><type><name>VALUE</name></type> <name>rb_false</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_nil_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>CALL_DATA</name></type> <name>cd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>recv</name> <operator>==</operator> <name>Qnil</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_NIL_P</name></expr></argument>, <argument><expr><name>NIL_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>vm_method_cfunc_is</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>rb_false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>fix_succ</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>x</name></expr>)</condition> <block>{<block_content>

<case>case <expr><operator>~</operator><literal type="number">0UL</literal></expr>:</case>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><call><name>RSHIFT</name><argument_list>(<argument><expr><operator>~</operator><literal type="number">0UL</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>:</case>

<return>return <expr><call><name>rb_uint2big</name><argument_list>(<argument><expr><literal type="number">1UL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>SIZEOF_LONG</name> <operator>*</operator> <name>CHAR_BIT</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<return>return <expr><name>x</name> <operator>+</operator> <literal type="number">2</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_succ</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_SUCC</name></expr></argument>, <argument><expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>fix_succ</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_SUCC</name></expr></argument>, <argument><expr><name>STRING_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_succ</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_not</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>CALL_DATA</name></type> <name>cd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_method_cfunc_is</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>rb_obj_not</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>RTEST</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>Qtrue</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_opt_regexpmatch2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name> <operator>&amp;&amp;</operator>

<call><name>CLASS_OF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cRegexp</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MATCH</name></expr></argument>, <argument><expr><name>STRING_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_reg_match</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cRegexp</name> <operator>&amp;&amp;</operator>

<call><name>BASIC_OP_UNREDEFINED_P</name><argument_list>(<argument><expr><name>BOP_MATCH</name></expr></argument>, <argument><expr><name>REGEXP_REDEFINED_OP_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_reg_match</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function_decl><type><name>rb_event_flag_t</name></type> <name>rb_iseq_event_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>NOINLINE</name><argument_list>(<argument>static void vm_trace(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp, const VALUE *pc)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_trace_hook</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>,

<parameter><decl><type><name>rb_event_flag_t</name></type> <name>pc_events</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>target_event</name></decl></parameter>,

<parameter><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>global_hooks</name></decl></parameter>, <parameter><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>local_hooks</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>event</name> <init>= <expr><name>pc_events</name> <operator>&amp;</operator> <name>target_event</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name> <init>= <expr><call><name>GET_SELF</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>rb_popcount64</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>event</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>event</name> <operator>&amp;</operator> <name><name>global_hooks</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>pc</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_dtrace</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exec_event_hook_orig</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>global_hooks</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> , <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>pc</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>local_hooks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>event</name> <operator>&amp;</operator> <name><name>local_hooks</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>pc</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exec_event_hook_orig</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>local_hooks</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument> , <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>pc</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_TRACE_HOOK</name><parameter_list>(<parameter><type><name>target_event</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((pc_events &amp; (target_event)) &amp; enabled_flags) { vm_trace_hook(ec, reg_cfp, pc, pc_events, (target_event), global_hooks, local_hooks, (val)); } } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_trace</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>enabled_flags</name> <init>= <expr><name>ruby_vm_event_flags</name> <operator>&amp;</operator> <name>ISEQ_TRACE_EVENTS</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enabled_flags</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ruby_vm_event_local_num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>pos</name> <init>= <expr><name>pc</name> <operator>-</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>pc_events</name> <init>= <expr><call><name>rb_iseq_event_flags</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>local_hooks</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>local_hook_events</name> <init>= <expr><ternary><condition><expr><name>local_hooks</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>local_hooks</name><operator>-&gt;</operator><name>events</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>enabled_flags</name> <operator>|=</operator> <name>local_hook_events</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>local_hook_events</name> <operator>&amp;</operator> <operator>~</operator><name>ISEQ_TRACE_EVENTS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pc_events</name> <operator>&amp;</operator> <name>enabled_flags</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

rb_iseq_trace_set(iseq, vm_event_flags &amp; ISEQ_TRACE_EVENTS);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>trace_arg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>global_hooks</name> <init>= <expr><call><name>rb_vm_global_hooks</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"vm_trace&gt;&gt;%4d (%4x) - %s:%d %s\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>pos</name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>pc_events</name></expr></argument>,

<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rb_iseq_line_no</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>rb_iseq_label</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>==</operator> <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>pc_events</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>enabled_flags</name> <operator>&amp;</operator> <name>pc_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_TRACE_HOOK</name><argument_list>(<argument><expr><name>RUBY_EVENT_CLASS</name> <operator>|</operator> <name>RUBY_EVENT_CALL</name> <operator>|</operator> <name>RUBY_EVENT_B_CALL</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_TRACE_HOOK</name><argument_list>(<argument><expr><name>RUBY_EVENT_LINE</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_TRACE_HOOK</name><argument_list>(<argument><expr><name>RUBY_EVENT_COVERAGE_LINE</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_TRACE_HOOK</name><argument_list>(<argument><expr><name>RUBY_EVENT_COVERAGE_BRANCH</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_TRACE_HOOK</name><argument_list>(<argument><expr><name>RUBY_EVENT_END</name> <operator>|</operator> <name>RUBY_EVENT_RETURN</name> <operator>|</operator> <name>RUBY_EVENT_B_RETURN</name></expr></argument>, <argument><expr><call><name>TOPN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<expr_stmt><expr><specifier>static</specifier> <call><name>NORETURN</name><argument_list>( <argument><expr><macro><name>NOINLINE</name><argument_list>( <argument>COLDFUNC

void vm_canary_is_found_dead(enum ruby_vminsn_type i, VALUE c)</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>void</name></type>

<name>Init_vm_stack_canary</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>ruby_fill_random_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vm_stack_canary</name></expr></argument>, <argument><expr><sizeof>sizeof <name>vm_stack_canary</name></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>vm_stack_canary_was_born</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>

<name>vm_canary_is_found_dead</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>ruby_vminsn_type</name></name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>insn</name> <init>= <expr><call><name>rb_insns_name</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>inspection</name> <init>= <expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>inspection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"dead canary found at %s: %s"</literal></expr></argument>, <argument><expr><name>insn</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><name>void</name></type> <name>Init_vm_stack_canary</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker0</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr0_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr0_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker1</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr1_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr1_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker2</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr2_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr2_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker3</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr3_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr3_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker4</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr4_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr4_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker5</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr5_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr5_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker6</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr6_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr6_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker7</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr7_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v7</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr7_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker8</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr8_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v7</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v8</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr8_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker9</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr9_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v7</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v8</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v9</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr9_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker10</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr10_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v7</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v8</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v9</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v10</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr10_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker11</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr11_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v7</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v8</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v9</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v10</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v11</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr11_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker12</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr12_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v7</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v8</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v9</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v10</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v11</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v12</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr12_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker13</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr13_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v7</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v8</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v9</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v10</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v11</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v12</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v13</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr13_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker14</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr14_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v7</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v8</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v9</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v10</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v11</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v12</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v13</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v14</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr14_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">13</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>builtin_invoker15</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>rb_invoke_funcptr15_t</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v3</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v4</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v5</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v6</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v7</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v8</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v9</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v10</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v11</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v12</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v13</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v14</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v15</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>rb_invoke_funcptr15_t</name><operator>)</operator><name>funcptr</name><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">12</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">13</literal></expr>]</index></name><operator>,</operator> <name><name>argv</name><index>[<expr><literal type="number">14</literal></expr>]</index></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>builtin_invoker</name>)<parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_insn_func_t</name></type> <name>funcptr</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>builtin_invoker</name></type>

<name>lookup_builtin_invoker</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>builtin_invoker</name></type> <name><name>invokers</name><index>[]</index></name> <init>= <expr><block>{

<expr><name>builtin_invoker0</name></expr>,

<expr><name>builtin_invoker1</name></expr>,

<expr><name>builtin_invoker2</name></expr>,

<expr><name>builtin_invoker3</name></expr>,

<expr><name>builtin_invoker4</name></expr>,

<expr><name>builtin_invoker5</name></expr>,

<expr><name>builtin_invoker6</name></expr>,

<expr><name>builtin_invoker7</name></expr>,

<expr><name>builtin_invoker8</name></expr>,

<expr><name>builtin_invoker9</name></expr>,

<expr><name>builtin_invoker10</name></expr>,

<expr><name>builtin_invoker11</name></expr>,

<expr><name>builtin_invoker12</name></expr>,

<expr><name>builtin_invoker13</name></expr>,

<expr><name>builtin_invoker14</name></expr>,

<expr><name>builtin_invoker15</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>invokers</name><index>[<expr><name>argc</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>invoke_bf</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name><modifier>*</modifier></type> <name>bf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><operator>*</operator><call><name>lookup_builtin_invoker</name><argument_list>(<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>(</operator><name>ec</name><operator>,</operator> <name>self</name><operator>,</operator> <name>argv</name><operator>,</operator> <operator>(</operator><name>rb_insn_func_t</name><operator>)</operator><name><name>bf</name><operator>-&gt;</operator><name>func_ptr</name></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_invoke_builtin</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name><modifier>*</modifier></type> <name>bf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>invoke_bf</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>bf</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_invoke_builtin_delegate</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type><name>bf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>start_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"vm_invoke_builtin_delegate: passing -&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>bf</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">":%s "</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name><operator>+</operator><name>start_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s %s(%d):%p\n"</literal></expr></argument>, <argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>, <argument><expr><name><name>bf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>bf</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>bf</name><operator>-&gt;</operator><name>func_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bf</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>invoke_bf</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>bf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name> <operator>-</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name>VM_ENV_DATA_SIZE</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>start_index</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>invoke_bf</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>bf</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_vm_lvar_exposed</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

</unit>
