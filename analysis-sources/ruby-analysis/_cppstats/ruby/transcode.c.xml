<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\transcode.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/inits.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/string.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/transcode.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transcode_data.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_ECONV_NEWLINE_OPTION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eUndefinedConversionError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eInvalidByteSequenceError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eConverterNotFoundError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cEncodingConverter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_invalid</name></decl>, <decl><type ref="prev"/><name>sym_undef</name></decl>, <decl><type ref="prev"/><name>sym_replace</name></decl>, <decl><type ref="prev"/><name>sym_fallback</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_xml</name></decl>, <decl><type ref="prev"/><name>sym_text</name></decl>, <decl><type ref="prev"/><name>sym_attr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_universal_newline</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_crlf_newline</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_cr_newline</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_ECONV_NEWLINE_OPTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_newline</name></decl>, <decl><type ref="prev"/><name>sym_universal</name></decl>, <decl><type ref="prev"/><name>sym_crlf</name></decl>, <decl><type ref="prev"/><name>sym_cr</name></decl>, <decl><type ref="prev"/><name>sym_lf</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_partial_input</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_invalid_byte_sequence</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_undefined_conversion</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_destination_buffer_full</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_source_buffer_empty</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_finished</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_after_output</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_incomplete_input</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>

<name>allocate_converted_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>caller_dst_buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>caller_dst_bufsize</name></decl></parameter>,

<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>dst_len_ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct <name>rb_transcoding</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>transcoder</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>resume_position</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>next_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>next_info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>next_byte</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>output_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>recognized_len</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ssize_t</name></type> <name>readagain_len</name></decl>;</decl_stmt> 

<union>union <block>{

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ary</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt> 

}</block> <decl><name>readbuf</name></decl>;</union> 

<decl_stmt><decl><type><name>ssize_t</name></type> <name>writebuf_off</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>writebuf_len</name></decl>;</decl_stmt>

<union>union <block>{

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ary</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt> 

}</block> <decl><name>writebuf</name></decl>;</union>

<union>union <name>rb_transcoding_state_t</name> <block>{ 

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>ary</name><index>[<expr><ternary><condition><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>dummy_for_alignment</name></decl>;</decl_stmt>

}</block> <decl><name>state</name></decl>;</union>

}</block></struct></type> <name>rb_transcoding</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRANSCODING_READBUF</name><parameter_list>(<parameter><type><name>tc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((tc)-&gt;transcoder-&gt;max_input &lt;= (int)sizeof((tc)-&gt;readbuf.ary) ? (tc)-&gt;readbuf.ary : (tc)-&gt;readbuf.ptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRANSCODING_WRITEBUF</name><parameter_list>(<parameter><type><name>tc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((tc)-&gt;transcoder-&gt;max_output &lt;= (int)sizeof((tc)-&gt;writebuf.ary) ? (tc)-&gt;writebuf.ary : (tc)-&gt;writebuf.ptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRANSCODING_WRITEBUF_SIZE</name><parameter_list>(<parameter><type><name>tc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((tc)-&gt;transcoder-&gt;max_output &lt;= (int)sizeof((tc)-&gt;writebuf.ary) ? sizeof((tc)-&gt;writebuf.ary) : (size_t)(tc)-&gt;transcoder-&gt;max_output)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRANSCODING_STATE_EMBED_MAX</name></cpp:macro> <cpp:value>((int)sizeof(union rb_transcoding_state_t))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRANSCODING_STATE</name><parameter_list>(<parameter><type><name>tc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((tc)-&gt;transcoder-&gt;state_size &lt;= (int)sizeof((tc)-&gt;state) ? (tc)-&gt;state.ary : (tc)-&gt;state.ptr)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_transcoding</name></name> <modifier>*</modifier></type><name>tc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_buf_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_data_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_data_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_buf_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>last_result</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_econv_elem_t</name>;</typedef>

<struct>struct <name>rb_econv_t</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>started</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_encoding_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>destination_encoding_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>replacement_str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>replacement_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>replacement_enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_buf_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_data_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_data_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_buf_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_elem_t</name> <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>replacement_allocated</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>num_allocated</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_trans</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_finished</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_transcoding</name></name> <modifier>*</modifier></type><name>last_tc</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_transcoding</name></name> <modifier>*</modifier></type><name>error_tc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_encoding</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>destination_encoding</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>error_bytes_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>error_bytes_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>readagain_len</name></decl>;</decl_stmt>

}</block> <decl><name>last_error</name></decl>;</struct>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>source_encoding</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>destination_encoding</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECORATOR_P</name><parameter_list>(<parameter><type><name>sname</name></type></parameter>, <parameter><type><name>dname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(sname) == '\0')</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lib</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>transcoder</name></decl>;</decl_stmt>

}</block></struct></type> <name>transcoder_entry_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>transcoder_table</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>transcoder_entry_t</name> <modifier>*</modifier></type>

<name>make_transcoder_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>table2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>transcoder_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><call><name>st_init_strcasetable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name>transcoder_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>sname</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>table2</name> <operator>=</operator> <operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>table2</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>ALLOC</name><argument_list>(<argument><expr><name>transcoder_entry_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sname</name></name> <operator>=</operator> <name>sname</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>dname</name></name> <operator>=</operator> <name>dname</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>lib</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>transcoder</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>entry</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name>table2</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dname</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>transcoder_entry_t</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>transcoder_entry_t</name> <modifier>*</modifier></type>

<name>get_transcoder_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>table2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>transcoder_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>table2</name> <operator>=</operator> <operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>table2</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>transcoder_entry_t</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_register_transcoder</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>sname</name> <init>= <expr><name><name>tr</name><operator>-&gt;</operator><name>src_encoding</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>dname</name> <init>= <expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>make_transcoder_entry</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>transcoder</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"transcoder from %s to %s has been already registered"</literal></expr></argument>,

<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>transcoder</name></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>declare_transcoder</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>make_transcoder_entry</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>lib</name></name> <operator>=</operator> <name>lib</name></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>transcoder_lib_prefix</name><index>[]</index></name> <init>= <expr><literal type="string">"enc/trans/"</literal></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>

<name>rb_declare_transcoder</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enc1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enc2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lib</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid library name - (null)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>declare_transcoder</name><argument_list>(<argument><expr><name>enc1</name></expr></argument>, <argument><expr><name>enc2</name></expr></argument>, <argument><expr><name>lib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>encoding_equal</name><parameter_list>(<parameter><type><name>enc1</name></type></parameter>, <parameter><type><name>enc2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(STRCASECMP((enc1), (enc2)) == 0)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>search_path_queue_tag</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>search_path_queue_tag</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

}</block></struct></type> <name>search_path_queue_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>visited</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>search_path_queue_t</name> <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>search_path_queue_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>queue_last_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base_enc</name></decl>;</decl_stmt>

}</block></struct></type> <name>search_path_bfs_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>transcode_search_path_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>search_path_bfs_t</name> <modifier>*</modifier></type><name>bfs</name> <init>= <expr><operator>(</operator><name>search_path_bfs_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>search_path_queue_t</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>bfs</name><operator>-&gt;</operator><name>visited</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr><name>search_path_queue_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>dname</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name><name>bfs</name><operator>-&gt;</operator><name>queue_last_ptr</name></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bfs</name><operator>-&gt;</operator><name>queue_last_ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name><name>bfs</name><operator>-&gt;</operator><name>visited</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dname</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>bfs</name><operator>-&gt;</operator><name>base_enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>transcode_search_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>,

<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>callback</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list></function_decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>search_path_bfs_t</name></type> <name>bfs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>search_path_queue_t</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>table2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pathlen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>encoding_equal</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr><name>search_path_queue_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>sname</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bfs</name><operator>.</operator><name>queue_last_ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bfs</name><operator>.</operator><name>queue</name></name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bfs</name><operator>.</operator><name>visited</name></name> <operator>=</operator> <call><name>st_init_strcasetable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name><name>bfs</name><operator>.</operator><name>visited</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>sname</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>bfs</name><operator>.</operator><name>queue</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>q</name> <operator>=</operator> <name><name>bfs</name><operator>.</operator><name>queue</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bfs</name><operator>.</operator><name>queue</name></name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bfs</name><operator>.</operator><name>queue</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>bfs</name><operator>.</operator><name>queue_last_ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>bfs</name><operator>.</operator><name>queue</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>transcoder_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>q</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>table2</name> <operator>=</operator> <operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>table2</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name><name>bfs</name><operator>.</operator><name>visited</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dname</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>q</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bfs</name><operator>.</operator><name>base_enc</name></name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>table2</name></expr></argument>, <argument><expr><name>transcode_search_path_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>bfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bfs</name><operator>.</operator><name>base_enc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>

<while>while <condition>(<expr><name><name>bfs</name><operator>.</operator><name>queue</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>q</name> <operator>=</operator> <name><name>bfs</name><operator>.</operator><name>queue</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bfs</name><operator>.</operator><name>queue</name></name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><name>dname</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>

<expr_stmt><expr><name>pathlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>bfs</name><operator>.</operator><name>visited</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pathlen</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>depth</name> <operator>=</operator> <name>pathlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <name>dname</name></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>bfs</name><operator>.</operator><name>visited</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>val</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>--</operator><name>depth</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>bfs</name><operator>.</operator><name>visited</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>pathlen</name></expr>;</return> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type>

<name>load_transcoder_entry</name><parameter_list>(<parameter><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>transcoder</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>transcoder</name></name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>lib</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>lib</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>lib</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>lib</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>total_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>transcoder_lib_prefix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>fn</name> <init>= <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>path</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>transcoder_lib_prefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>transcoder_lib_prefix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>transcoder_lib_prefix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>lib</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_require_string</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>transcoder</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>transcoder</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type>

<name>get_replacement_character</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encname</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len_ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>repl_encname_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>encoding_equal</name><argument_list>(<argument><expr><name>encname</name></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>len_ret</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>repl_encname_ptr</name> <operator>=</operator> <literal type="string">"UTF-8"</literal></expr>;</expr_stmt>

<return>return <expr><literal type="string">"\xEF\xBF\xBD"</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>len_ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>repl_encname_ptr</name> <operator>=</operator> <literal type="string">"US-ASCII"</literal></expr>;</expr_stmt>

<return>return <expr><literal type="string">"?"</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>

<name>transcode_char_start</name><parameter_list>(<parameter><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_start</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>inchar_start</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_p</name></decl></parameter>,

<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>char_len_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>inchar_start</name> <operator>-</operator> <name>in_start</name> <operator>&lt;</operator> <name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name></expr>)</condition> <block>{<block_content>

<macro><name>MEMCPY</name><argument_list>(<argument>TRANSCODING_READBUF(tc) + tc-&gt;recognized_len</argument>,

<argument>inchar_start</argument>, <argument>unsigned char</argument>, <argument>in_p - inchar_start</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>TRANSCODING_READBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>inchar_start</name> <operator>-</operator> <name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>char_len_ptr</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name> <operator>+</operator> <operator>(</operator><name>in_p</name> <operator>-</operator> <name>inchar_start</name><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_result_t</name></type>

<name>transcode_restartable0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>in_pos</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_pos</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_stop</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_stop</name></decl></parameter>,

<parameter><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name> <init>= <expr><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>unitlen</name> <init>= <expr><name><name>tr</name><operator>-&gt;</operator><name>input_unit_length</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>readagain_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>inchar_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>in_p</name> <operator>=</operator> <name>inchar_start</name> <operator>=</operator> <operator>*</operator><name>in_pos</name></expr>;</expr_stmt>

<expr_stmt><expr><name>out_p</name> <operator>=</operator> <operator>*</operator><name>out_pos</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUSPEND</name><parameter_list>(<parameter><type><name>ret</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { tc-&gt;resume_position = (num); if (0 &lt; in_p - inchar_start) MEMMOVE(TRANSCODING_READBUF(tc)+tc-&gt;recognized_len, inchar_start, unsigned char, in_p - inchar_start); *in_pos = in_p; *out_pos = out_p; tc-&gt;recognized_len += in_p - inchar_start; if (readagain_len) { tc-&gt;recognized_len -= readagain_len; tc-&gt;readagain_len = readagain_len; } return (ret); resume_label ##num:; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUSPEND_OBUF</name><parameter_list>(<parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { while (out_stop - out_p &lt; 1) { SUSPEND(econv_destination_buffer_full, num); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUSPEND_AFTER_OUTPUT</name><parameter_list>(<parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if ((opt &amp; ECONV_AFTER_OUTPUT) &amp;&amp; *out_pos != out_p) { SUSPEND(econv_after_output, num); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next_table</name></cpp:macro> <cpp:value>(tc-&gt;next_table)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next_info</name></cpp:macro> <cpp:value>(tc-&gt;next_info)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next_byte</name></cpp:macro> <cpp:value>(tc-&gt;next_byte)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>writebuf_len</name></cpp:macro> <cpp:value>(tc-&gt;writebuf_len)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>writebuf_off</name></cpp:macro> <cpp:value>(tc-&gt;writebuf_off)</cpp:value></cpp:define>

<switch>switch <condition>(<expr><name><name>tc</name><operator>-&gt;</operator><name>resume_position</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <goto>goto <name>resume_label1</name>;</goto>

<case>case <expr><literal type="number">2</literal></expr>:</case> <goto>goto <name>resume_label2</name>;</goto>

<case>case <expr><literal type="number">3</literal></expr>:</case> <goto>goto <name>resume_label3</name>;</goto>

<case>case <expr><literal type="number">4</literal></expr>:</case> <goto>goto <name>resume_label4</name>;</goto>

<case>case <expr><literal type="number">5</literal></expr>:</case> <goto>goto <name>resume_label5</name>;</goto>

<case>case <expr><literal type="number">6</literal></expr>:</case> <goto>goto <name>resume_label6</name>;</goto>

<case>case <expr><literal type="number">7</literal></expr>:</case> <goto>goto <name>resume_label7</name>;</goto>

<case>case <expr><literal type="number">8</literal></expr>:</case> <goto>goto <name>resume_label8</name>;</goto>

<case>case <expr><literal type="number">9</literal></expr>:</case> <goto>goto <name>resume_label9</name>;</goto>

<case>case <expr><literal type="number">10</literal></expr>:</case> <goto>goto <name>resume_label10</name>;</goto>

<case>case <expr><literal type="number">11</literal></expr>:</case> <goto>goto <name>resume_label11</name>;</goto>

<case>case <expr><literal type="number">12</literal></expr>:</case> <goto>goto <name>resume_label12</name>;</goto>

<case>case <expr><literal type="number">13</literal></expr>:</case> <goto>goto <name>resume_label13</name>;</goto>

<case>case <expr><literal type="number">14</literal></expr>:</case> <goto>goto <name>resume_label14</name>;</goto>

<case>case <expr><literal type="number">15</literal></expr>:</case> <goto>goto <name>resume_label15</name>;</goto>

<case>case <expr><literal type="number">16</literal></expr>:</case> <goto>goto <name>resume_label16</name>;</goto>

<case>case <expr><literal type="number">17</literal></expr>:</case> <goto>goto <name>resume_label17</name>;</goto>

<case>case <expr><literal type="number">18</literal></expr>:</case> <goto>goto <name>resume_label18</name>;</goto>

<case>case <expr><literal type="number">19</literal></expr>:</case> <goto>goto <name>resume_label19</name>;</goto>

<case>case <expr><literal type="number">20</literal></expr>:</case> <goto>goto <name>resume_label20</name>;</goto>

<case>case <expr><literal type="number">21</literal></expr>:</case> <goto>goto <name>resume_label21</name>;</goto>

<case>case <expr><literal type="number">22</literal></expr>:</case> <goto>goto <name>resume_label22</name>;</goto>

<case>case <expr><literal type="number">23</literal></expr>:</case> <goto>goto <name>resume_label23</name>;</goto>

<case>case <expr><literal type="number">24</literal></expr>:</case> <goto>goto <name>resume_label24</name>;</goto>

<case>case <expr><literal type="number">25</literal></expr>:</case> <goto>goto <name>resume_label25</name>;</goto>

<case>case <expr><literal type="number">26</literal></expr>:</case> <goto>goto <name>resume_label26</name>;</goto>

<case>case <expr><literal type="number">27</literal></expr>:</case> <goto>goto <name>resume_label27</name>;</goto>

<case>case <expr><literal type="number">28</literal></expr>:</case> <goto>goto <name>resume_label28</name>;</goto>

<case>case <expr><literal type="number">29</literal></expr>:</case> <goto>goto <name>resume_label29</name>;</goto>

<case>case <expr><literal type="number">30</literal></expr>:</case> <goto>goto <name>resume_label30</name>;</goto>

<case>case <expr><literal type="number">31</literal></expr>:</case> <goto>goto <name>resume_label31</name>;</goto>

<case>case <expr><literal type="number">32</literal></expr>:</case> <goto>goto <name>resume_label32</name>;</goto>

<case>case <expr><literal type="number">33</literal></expr>:</case> <goto>goto <name>resume_label33</name>;</goto>

<case>case <expr><literal type="number">34</literal></expr>:</case> <goto>goto <name>resume_label34</name>;</goto>

</block_content>}</block></switch>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inchar_start</name> <operator>=</operator> <name>in_p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>next_table</name> <operator>=</operator> <name><name>tr</name><operator>-&gt;</operator><name>conv_tree_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_AFTER_OUTPUT</name><argument_list>(<argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>in_stop</name> <operator>&lt;=</operator> <name>in_p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>ECONV_PARTIAL_INPUT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>SUSPEND</name><argument_list>(<argument><expr><name>econv_source_buffer_empty</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_ADDR</name><parameter_list>(<parameter><type><name>index</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(tr-&gt;byte_array + (index))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORD_ADDR</name><parameter_list>(<parameter><type><name>index</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(tr-&gt;word_array + INFO2WORDINDEX(index))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BL_BASE</name></cpp:macro> <cpp:value>BYTE_ADDR(BYTE_LOOKUP_BASE(WORD_ADDR(next_table)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BL_INFO</name></cpp:macro> <cpp:value>WORD_ADDR(BYTE_LOOKUP_INFO(WORD_ADDR(next_table)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BL_MIN_BYTE</name></cpp:macro> <cpp:value>(BL_BASE[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BL_MAX_BYTE</name></cpp:macro> <cpp:value>(BL_BASE[1])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BL_OFFSET</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BL_BASE[2+(byte)-BL_MIN_BYTE])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BL_ACTION</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BL_INFO[BL_OFFSET((byte))])</cpp:value></cpp:define>

<expr_stmt><expr><name>next_byte</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>in_p</name><operator>++</operator></expr>;</expr_stmt>

<label><name>follow_byte</name>:</label>

<if_stmt><if>if <condition>(<expr><name>next_byte</name> <operator>&lt;</operator> <name>BL_MIN_BYTE</name> <operator>||</operator> <name>BL_MAX_BYTE</name> <operator>&lt;</operator> <name>next_byte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>next_info</name> <operator>=</operator> <name>INVALID</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>next_info</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>BL_ACTION</name><argument_list>(<argument><expr><name>next_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<label><name>follow_info</name>:</label>

<switch>switch <condition>(<expr><name>next_info</name> <operator>&amp;</operator> <literal type="number">0x1F</literal></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NOMAP</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>inchar_start</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>writebuf_off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>in_p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call><index>[<expr><name>writebuf_off</name><operator>++</operator></expr>]</index> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>writebuf_len</name> <operator>=</operator> <name>writebuf_off</name></expr>;</expr_stmt>

<expr_stmt><expr><name>writebuf_off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>writebuf_off</name> <operator>&lt;</operator> <name>writebuf_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call><index>[<expr><name>writebuf_off</name><operator>++</operator></expr>]</index></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block>

<continue>continue;</continue>

<case>case <expr><literal type="number">0x00</literal></expr>:</case> <case>case <expr><literal type="number">0x04</literal></expr>:</case> <case>case <expr><literal type="number">0x08</literal></expr>:</case> <case>case <expr><literal type="number">0x0C</literal></expr>:</case>

<case>case <expr><literal type="number">0x10</literal></expr>:</case> <case>case <expr><literal type="number">0x14</literal></expr>:</case> <case>case <expr><literal type="number">0x18</literal></expr>:</case> <case>case <expr><literal type="number">0x1C</literal></expr>:</case>

<expr_stmt><expr><call><name>SUSPEND_AFTER_OUTPUT</name><argument_list>(<argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>in_p</name> <operator>&gt;=</operator> <name>in_stop</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>ECONV_PARTIAL_INPUT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>incomplete</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>SUSPEND</name><argument_list>(<argument><expr><name>econv_source_buffer_empty</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>next_byte</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>in_p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>next_table</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>next_info</name></expr>;</expr_stmt>

<goto>goto <name>follow_byte</name>;</goto>

<case>case <expr><name>ZERObt</name></expr>:</case> 

<continue>continue;</continue>

<case>case <expr><name>ONEbt</name></expr>:</case>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT1</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><name>TWObt</name></expr>:</case>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT1</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT2</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><name>THREEbt</name></expr>:</case>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT1</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT2</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT3</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><name>FOURbt</name></expr>:</case>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT0</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT1</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT2</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getBT3</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><name>GB4bt</name></expr>:</case>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getGB4bt0</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getGB4bt1</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getGB4bt2</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>getGB4bt3</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><name>STR1</name></expr>:</case>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>output_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>tc</name><operator>-&gt;</operator><name>output_index</name></name> <operator>&lt;</operator> <call><name>STR1_LENGTH</name><argument_list>(<argument><expr><call><name>BYTE_ADDR</name><argument_list>(<argument><expr><call><name>STR1_BYTEINDEX</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>BYTE_ADDR</name><argument_list>(<argument><expr><call><name>STR1_BYTEINDEX</name><argument_list>(<argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">1</literal><operator>+</operator><name><name>tc</name><operator>-&gt;</operator><name>output_index</name></name></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>output_index</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<continue>continue;</continue>

<case>case <expr><name>FUNii</name></expr>:</case>

<expr_stmt><expr><name>next_info</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call>(<modifier>*</modifier><name><name>tr</name><operator>-&gt;</operator><name>func_ii</name></name>)<argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>next_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>follow_info</name>;</goto>

<case>case <expr><name>FUNsi</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>char_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>char_len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>char_start</name> <operator>=</operator> <call><name>transcode_char_start</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><operator>*</operator><name>in_pos</name></expr></argument>, <argument><expr><name>inchar_start</name></expr></argument>, <argument><expr><name>in_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>char_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>next_info</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call>(<modifier>*</modifier><name><name>tr</name><operator>-&gt;</operator><name>func_si</name></name>)<argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>char_start</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>char_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>follow_info</name>;</goto>

</block_content>}</block>

<case>case <expr><name>FUNio</name></expr>:</case>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>max_output</name></name> <operator>&lt;=</operator> <name>out_stop</name> <operator>-</operator> <name>out_p</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>out_p</name> <operator>+=</operator> <call><name><name>tr</name><operator>-&gt;</operator><name>func_io</name></name><argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>next_info</name></expr></argument>, <argument><expr><name>out_p</name></expr></argument>, <argument><expr><name>out_stop</name> <operator>-</operator> <name>out_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>writebuf_len</name> <operator>=</operator> <call><name><name>tr</name><operator>-&gt;</operator><name>func_io</name></name><argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>next_info</name></expr></argument>,

<argument><expr><call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TRANSCODING_WRITEBUF_SIZE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>writebuf_off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>writebuf_off</name> <operator>&lt;</operator> <name>writebuf_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call><index>[<expr><name>writebuf_off</name><operator>++</operator></expr>]</index></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>FUNso</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>char_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>char_len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>max_output</name></name> <operator>&lt;=</operator> <name>out_stop</name> <operator>-</operator> <name>out_p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>char_start</name> <operator>=</operator> <call><name>transcode_char_start</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><operator>*</operator><name>in_pos</name></expr></argument>, <argument><expr><name>inchar_start</name></expr></argument>, <argument><expr><name>in_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>char_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>out_p</name> <operator>+=</operator> <call><name><name>tr</name><operator>-&gt;</operator><name>func_so</name></name><argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>char_start</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>char_len</name></expr></argument>,

<argument><expr><name>out_p</name></expr></argument>, <argument><expr><name>out_stop</name> <operator>-</operator> <name>out_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>char_start</name> <operator>=</operator> <call><name>transcode_char_start</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><operator>*</operator><name>in_pos</name></expr></argument>, <argument><expr><name>inchar_start</name></expr></argument>, <argument><expr><name>in_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>char_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>writebuf_len</name> <operator>=</operator> <call><name><name>tr</name><operator>-&gt;</operator><name>func_so</name></name><argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>char_start</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>char_len</name></expr></argument>,

<argument><expr><call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TRANSCODING_WRITEBUF_SIZE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>writebuf_off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>writebuf_off</name> <operator>&lt;</operator> <name>writebuf_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call><index>[<expr><name>writebuf_off</name><operator>++</operator></expr>]</index></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>FUNsio</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>char_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>char_len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>max_output</name></name> <operator>&lt;=</operator> <name>out_stop</name> <operator>-</operator> <name>out_p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>char_start</name> <operator>=</operator> <call><name>transcode_char_start</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><operator>*</operator><name>in_pos</name></expr></argument>, <argument><expr><name>inchar_start</name></expr></argument>, <argument><expr><name>in_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>char_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>out_p</name> <operator>+=</operator> <call><name><name>tr</name><operator>-&gt;</operator><name>func_sio</name></name><argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>char_start</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>char_len</name></expr></argument>, <argument><expr><name>next_info</name></expr></argument>,

<argument><expr><name>out_p</name></expr></argument>, <argument><expr><name>out_stop</name> <operator>-</operator> <name>out_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>char_start</name> <operator>=</operator> <call><name>transcode_char_start</name><argument_list>(<argument><expr><name>tc</name></expr></argument>, <argument><expr><operator>*</operator><name>in_pos</name></expr></argument>, <argument><expr><name>inchar_start</name></expr></argument>, <argument><expr><name>in_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>char_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>writebuf_len</name> <operator>=</operator> <call><name><name>tr</name><operator>-&gt;</operator><name>func_sio</name></name><argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>char_start</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>char_len</name></expr></argument>, <argument><expr><name>next_info</name></expr></argument>,

<argument><expr><call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TRANSCODING_WRITEBUF_SIZE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>writebuf_off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>writebuf_off</name> <operator>&lt;</operator> <name>writebuf_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">34</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call><index>[<expr><name>writebuf_off</name><operator>++</operator></expr>]</index></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>INVALID</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name> <operator>+</operator> <operator>(</operator><name>in_p</name> <operator>-</operator> <name>inchar_start</name><operator>)</operator> <operator>&lt;=</operator> <name>unitlen</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name> <operator>+</operator> <operator>(</operator><name>in_p</name> <operator>-</operator> <name>inchar_start</name><operator>)</operator> <operator>&lt;</operator> <name>unitlen</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>SUSPEND_AFTER_OUTPUT</name><argument_list>(<argument><expr><literal type="number">26</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>ECONV_PARTIAL_INPUT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name> <operator>+</operator> <operator>(</operator><name>in_stop</name> <operator>-</operator> <name>inchar_start</name><operator>)</operator> <operator>&lt;</operator> <name>unitlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>in_p</name> <operator>=</operator> <name>in_stop</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SUSPEND</name><argument_list>(<argument><expr><name>econv_source_buffer_empty</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name> <operator>+</operator> <operator>(</operator><name>in_stop</name> <operator>-</operator> <name>inchar_start</name><operator>)</operator> <operator>&lt;=</operator> <name>unitlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>in_p</name> <operator>=</operator> <name>in_stop</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>in_p</name> <operator>=</operator> <name>inchar_start</name> <operator>+</operator> <operator>(</operator><name>unitlen</name> <operator>-</operator> <name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>invalid_len</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ssize_t</name></type> <name>discard_len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>invalid_len</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name> <operator>+</operator> <operator>(</operator><name>in_p</name> <operator>-</operator> <name>inchar_start</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>discard_len</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>invalid_len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>unitlen</name><operator>)</operator> <operator>*</operator> <name>unitlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>readagain_len</name> <operator>=</operator> <name>invalid_len</name> <operator>-</operator> <name>discard_len</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<goto>goto <name>invalid</name>;</goto>

<case>case <expr><name>UNDEF</name></expr>:</case>

<goto>goto <name>undef</name>;</goto>

<default>default:</default>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"unknown transcoding instruction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<continue>continue;</continue>

<label><name>invalid</name>:</label>

<expr_stmt><expr><call><name>SUSPEND</name><argument_list>(<argument><expr><name>econv_invalid_byte_sequence</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<label><name>incomplete</name>:</label>

<expr_stmt><expr><call><name>SUSPEND</name><argument_list>(<argument><expr><name>econv_incomplete_input</name></expr></argument>, <argument><expr><literal type="number">27</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<label><name>undef</name>:</label>

<expr_stmt><expr><call><name>SUSPEND</name><argument_list>(<argument><expr><name>econv_undefined_conversion</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>finish_func</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>max_output</name></name> <operator>&lt;=</operator> <name>out_stop</name> <operator>-</operator> <name>out_p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>out_p</name> <operator>+=</operator> <call><name><name>tr</name><operator>-&gt;</operator><name>finish_func</name></name><argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>out_p</name></expr></argument>, <argument><expr><name>out_stop</name> <operator>-</operator> <name>out_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>writebuf_len</name> <operator>=</operator> <call><name><name>tr</name><operator>-&gt;</operator><name>finish_func</name></name><argument_list>(<argument><expr><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TRANSCODING_WRITEBUF_SIZE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>writebuf_off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>writebuf_off</name> <operator>&lt;</operator> <name>writebuf_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SUSPEND_OBUF</name><argument_list>(<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_p</name><operator>++</operator> <operator>=</operator> <call><name>TRANSCODING_WRITEBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call><index>[<expr><name>writebuf_off</name><operator>++</operator></expr>]</index></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>SUSPEND</name><argument_list>(<argument><expr><name>econv_finished</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SUSPEND</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>next_table</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>next_info</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>next_byte</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>writebuf_len</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>writebuf_off</name></cpp:undef>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_result_t</name></type>

<name>transcode_restartable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>in_pos</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_pos</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>in_stop</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_stop</name></decl></parameter>,

<parameter><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>readagain_buf</name> <init>= <macro><name>ALLOCA_N</name><argument_list>(<argument>unsigned char</argument>, <argument>tc-&gt;readagain_len</argument>)</argument_list></macro></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>readagain_pos</name> <init>= <expr><name>readagain_buf</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>readagain_stop</name> <init>= <expr><name>readagain_buf</name> <operator>+</operator> <name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>res</name></decl>;</decl_stmt>

<macro><name>MEMCPY</name><argument_list>(<argument>readagain_buf</argument>, <argument>TRANSCODING_READBUF(tc) + tc-&gt;recognized_len</argument>,

<argument>unsigned char</argument>, <argument>tc-&gt;readagain_len</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>transcode_restartable0</name><argument_list>(<argument><expr><operator>&amp;</operator><name>readagain_pos</name></expr></argument>, <argument><expr><name>out_pos</name></expr></argument>, <argument><expr><name>readagain_stop</name></expr></argument>, <argument><expr><name>out_stop</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>opt</name><operator>|</operator><name>ECONV_PARTIAL_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>econv_source_buffer_empty</name></expr>)</condition> <block>{<block_content>

<macro><name>MEMCPY</name><argument_list>(<argument>TRANSCODING_READBUF(tc) + tc-&gt;recognized_len + tc-&gt;readagain_len</argument>,

<argument>readagain_pos</argument>, <argument>unsigned char</argument>, <argument>readagain_stop - readagain_pos</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name> <operator>+=</operator> <name>readagain_stop</name> <operator>-</operator> <name>readagain_pos</name></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>transcode_restartable0</name><argument_list>(<argument><expr><name>in_pos</name></expr></argument>, <argument><expr><name>out_pos</name></expr></argument>, <argument><expr><name>in_stop</name></expr></argument>, <argument><expr><name>out_stop</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_transcoding</name> <modifier>*</modifier></type>

<name>rb_transcoding_open_by_transcoder</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tc</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr><name>rb_transcoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name> <operator>=</operator> <name>tr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>TRANSCODING_STATE_EMBED_MAX</name> <operator>&lt;</operator> <name><name>tr</name><operator>-&gt;</operator><name>state_size</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>state_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>state_init_func</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name><name>tr</name><operator>-&gt;</operator><name>state_init_func</name></name><operator>)</operator><operator>(</operator><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>resume_position</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>writebuf_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>writebuf_off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>readbuf</name><operator>.</operator><name>ary</name></name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>tr</name><operator>-&gt;</operator><name>max_input</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>readbuf</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>max_input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>writebuf</name><operator>.</operator><name>ary</name></name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>tr</name><operator>-&gt;</operator><name>max_output</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>writebuf</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>max_output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>tc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_result_t</name></type>

<name>rb_transcoding_convert</name><parameter_list>(<parameter><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>input_ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input_stop</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>output_ptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output_stop</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>transcode_restartable</name><argument_list>(

<argument><expr><name>input_ptr</name></expr></argument>, <argument><expr><name>output_ptr</name></expr></argument>,

<argument><expr><name>input_stop</name></expr></argument>, <argument><expr><name>output_stop</name></expr></argument>,

<argument><expr><name>tc</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_transcoding_close</name><parameter_list>(<parameter><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name> <init>= <expr><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>state_fini_func</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name><name>tr</name><operator>-&gt;</operator><name>state_fini_func</name></name><operator>)</operator><operator>(</operator><call><name>TRANSCODING_STATE</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>TRANSCODING_STATE_EMBED_MAX</name> <operator>&lt;</operator> <name><name>tr</name><operator>-&gt;</operator><name>state_size</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>readbuf</name><operator>.</operator><name>ary</name></name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>tr</name><operator>-&gt;</operator><name>max_input</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>readbuf</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>writebuf</name><operator>.</operator><name>ary</name></name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>tr</name><operator>-&gt;</operator><name>max_output</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>writebuf</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>rb_transcoding_memsize</name><parameter_list>(<parameter><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_transcoding</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name> <init>= <expr><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>TRANSCODING_STATE_EMBED_MAX</name> <operator>&lt;</operator> <name><name>tr</name><operator>-&gt;</operator><name>state_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>tr</name><operator>-&gt;</operator><name>state_size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>readbuf</name><operator>.</operator><name>ary</name></name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>tr</name><operator>-&gt;</operator><name>max_input</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>tr</name><operator>-&gt;</operator><name>max_input</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>tc</name><operator>-&gt;</operator><name>writebuf</name><operator>.</operator><name>ary</name></name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>tr</name><operator>-&gt;</operator><name>max_output</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>tr</name><operator>-&gt;</operator><name>max_output</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_t</name> <modifier>*</modifier></type>

<name>rb_econv_alloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n_hint</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n_hint</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n_hint</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr><name>rb_econv_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>started</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_str</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_enc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_allocated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>in_buf_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>in_data_end</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>in_buf_end</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>num_allocated</name></name> <operator>=</operator> <name>n_hint</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>rb_econv_elem_t</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>num_allocated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>num_finished</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_tc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>econv_source_buffer_empty</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_tc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>destination_encoding</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>readagain_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>ec</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_econv_add_transcoder_at</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>==</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_allocated</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_allocated</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REALLOC_N</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>, <argument><expr><name>rb_econv_elem_t</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>num_allocated</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name></name><operator>+</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name></name><operator>+</operator><name>i</name></expr></argument>, <argument><expr><name>rb_econv_elem_t</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tc</name> <operator>=</operator> <call><name>rb_transcoding_open_by_transcoder</name><argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_buf_start</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_buf_end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>bufsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_data_start</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_data_end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_result</name> <operator>=</operator> <name>econv_source_buffer_empty</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>src_encoding</name></name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>j</name></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>tc</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr2</name> <init>= <expr><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name><name>tr2</name><operator>-&gt;</operator><name>src_encoding</name></name></expr></argument>, <argument><expr><name><name>tr2</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_tc</name></name> <operator>=</operator> <name>tc</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_t</name> <modifier>*</modifier></type>

<name>rb_econv_open_by_transcoder_entries</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>entries</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>load_transcoder_entry</name><argument_list>(<argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tr</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_alloc</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name> <init>= <expr><call><name>load_transcoder_entry</name><argument_list>(<argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_add_transcoder_at</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>ec</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>trans_open_t</name> <block>{

<decl_stmt><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_additional</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>trans_open_i</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>trans_open_t</name></name> <modifier>*</modifier></type><name>toarg</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>toarg</name><operator>-&gt;</operator><name>entries</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>toarg</name><operator>-&gt;</operator><name>entries</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>transcoder_entry_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>depth</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name><name>toarg</name><operator>-&gt;</operator><name>num_additional</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>toarg</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <call><name>get_transcoder_entry</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_t</name> <modifier>*</modifier></type>

<name>rb_econv_open0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_trans</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sname</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_enc_find_index</name><argument_list>(<argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dname</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_enc_find_index</name><argument_list>(<argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sname</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>dname</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>num_trans</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>entries</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sname</name> <operator>=</operator> <name>dname</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>trans_open_t</name></name></type> <name>toarg</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>toarg</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>toarg</name><operator>.</operator><name>num_additional</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>num_trans</name> <operator>=</operator> <call><name>transcode_search_path</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>trans_open_i</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>toarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>toarg</name><operator>.</operator><name>entries</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num_trans</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_open_by_transcoder_entries</name><argument_list>(<argument><expr><name>num_trans</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>ecflags</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding_name</name></name> <operator>=</operator> <name>sname</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding_name</name></name> <operator>=</operator> <name>dname</name></expr>;</expr_stmt>

<return>return <expr><name>ec</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ECFLAGS_DECORATORS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>decorator_names</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>decorators_ret</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>num_decorators</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_NEWLINE_DECORATOR_MASK</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ECONV_UNIVERSAL_NEWLINE_DECORATOR</name></expr>:</case>

<case>case <expr><name>ECONV_CRLF_NEWLINE_DECORATOR</name></expr>:</case>

<case>case <expr><name>ECONV_CR_NEWLINE_DECORATOR</name></expr>:</case>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<break>break;</break>

<default>default:</default>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_XML_TEXT_DECORATOR</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_XML_ATTR_CONTENT_DECORATOR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num_decorators</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_XML_TEXT_DECORATOR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>decorators_ret</name><index>[<expr><name>num_decorators</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"xml_text_escape"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_XML_ATTR_CONTENT_DECORATOR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>decorators_ret</name><index>[<expr><name>num_decorators</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"xml_attr_content_escape"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_XML_ATTR_QUOTE_DECORATOR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>decorators_ret</name><index>[<expr><name>num_decorators</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"xml_attr_quote"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_CRLF_NEWLINE_DECORATOR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>decorators_ret</name><index>[<expr><name>num_decorators</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"crlf_newline"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_CR_NEWLINE_DECORATOR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>decorators_ret</name><index>[<expr><name>num_decorators</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"cr_newline"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_UNIVERSAL_NEWLINE_DECORATOR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>decorators_ret</name><index>[<expr><name>num_decorators</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"universal_newline"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>num_decorators</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_econv_t</name> <modifier>*</modifier></type>

<name>rb_econv_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_decorators</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>decorators</name><index>[<expr><name>MAX_ECFLAGS_DECORATORS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>num_decorators</name> <operator>=</operator> <call><name>decorator_names</name><argument_list>(<argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>decorators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num_decorators</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_open0</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_ERROR_HANDLER_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_decorators</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_econv_decorate_at_last</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>decorators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ecflags</name> <operator>&amp;</operator> <operator>~</operator><name>ECONV_ERROR_HANDLER_MASK</name></expr>;</expr_stmt>

<return>return <expr><name>ec</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>trans_sweep</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>input_ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input_stop</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>output_ptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output_stop</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>try</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>f</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ipp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>is</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iold</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>opp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>os</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>oold</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name>try</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>try</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>try</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_elem_t</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ipp</name> <operator>=</operator> <name>input_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>is</name> <operator>=</operator> <name>input_stop</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_elem_t</name> <modifier>*</modifier></type><name>prev_te</name> <init>= <expr><operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ipp</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>prev_te</name><operator>-&gt;</operator><name>out_data_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>is</name> <operator>=</operator> <name><name>prev_te</name><operator>-&gt;</operator><name>out_data_end</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>opp</name> <operator>=</operator> <name>output_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>os</name> <operator>=</operator> <name>output_stop</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>out_buf_start</name></name> <operator>!=</operator> <name><name>te</name><operator>-&gt;</operator><name>out_data_start</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name> <init>= <expr><name><name>te</name><operator>-&gt;</operator><name>out_data_end</name></name> <operator>-</operator> <name><name>te</name><operator>-&gt;</operator><name>out_data_start</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>off</name> <init>= <expr><name><name>te</name><operator>-&gt;</operator><name>out_data_start</name></name> <operator>-</operator> <name><name>te</name><operator>-&gt;</operator><name>out_buf_start</name></name></expr></init></decl>;</decl_stmt>

<macro><name>MEMMOVE</name><argument_list>(<argument>te-&gt;out_buf_start</argument>, <argument>te-&gt;out_data_start</argument>, <argument>unsigned char</argument>, <argument>len</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>out_data_start</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>out_buf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>out_data_end</name></name> <operator>-=</operator> <name>off</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>opp</name> <operator>=</operator> <operator>&amp;</operator><name><name>te</name><operator>-&gt;</operator><name>out_data_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>os</name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>out_buf_end</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>num_finished</name></name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>f</name> <operator>|=</operator> <name>ECONV_PARTIAL_INPUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ECONV_AFTER_OUTPUT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>ECONV_AFTER_OUTPUT</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>f</name> <operator>&amp;=</operator> <operator>~</operator><name>ECONV_AFTER_OUTPUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>iold</name> <operator>=</operator> <operator>*</operator><name>ipp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>oold</name> <operator>=</operator> <operator>*</operator><name>opp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>last_result</name></name> <operator>=</operator> <name>res</name> <operator>=</operator> <call><name>rb_transcoding_convert</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>tc</name></name></expr></argument>, <argument><expr><name>ipp</name></expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr><name>opp</name></expr></argument>, <argument><expr><name>os</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>iold</name> <operator>!=</operator> <operator>*</operator><name>ipp</name> <operator>||</operator> <name>oold</name> <operator>!=</operator> <operator>*</operator><name>opp</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>try</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>econv_invalid_byte_sequence</name></expr>:</case>

<case>case <expr><name>econv_incomplete_input</name></expr>:</case>

<case>case <expr><name>econv_undefined_conversion</name></expr>:</case>

<case>case <expr><name>econv_after_output</name></expr>:</case>

<return>return <expr><name>i</name></expr>;</return>

<case>case <expr><name>econv_destination_buffer_full</name></expr>:</case>

<case>case <expr><name>econv_source_buffer_empty</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>econv_finished</name></expr>:</case>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>num_finished</name></name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

</block_content>}</block></while>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_result_t</name></type>

<name>rb_trans_conv</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>input_ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input_stop</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>output_ptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output_stop</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result_position_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>needreport_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sweep_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>empty_buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>empty_ptr</name> <init>= <expr><operator>&amp;</operator><name>empty_buf</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>input_ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input_ptr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>empty_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>input_stop</name> <operator>=</operator> <name>empty_ptr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>output_ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>output_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>empty_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>output_stop</name> <operator>=</operator> <name>empty_ptr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>last_result</name> <operator>==</operator> <name>econv_after_output</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>last_result</name> <operator>=</operator> <name>econv_source_buffer_empty</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_result</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>econv_invalid_byte_sequence</name></expr>:</case>

<case>case <expr><name>econv_incomplete_input</name></expr>:</case>

<case>case <expr><name>econv_undefined_conversion</name></expr>:</case>

<case>case <expr><name>econv_after_output</name></expr>:</case>

<case>case <expr><name>econv_finished</name></expr>:</case>

<expr_stmt><expr><name>sweep_start</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

<goto>goto <name>found_needreport</name>;</goto>

<case>case <expr><name>econv_destination_buffer_full</name></expr>:</case>

<case>case <expr><name>econv_source_buffer_empty</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unexpected transcode last result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>last_result</name> <operator>==</operator> <name>econv_destination_buffer_full</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ECONV_AFTER_OUTPUT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rb_trans_conv</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>output_ptr</name></expr></argument>, <argument><expr><name>output_stop</name></expr></argument>,

<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>ECONV_AFTER_OUTPUT</name><operator>)</operator><operator>|</operator><name>ECONV_PARTIAL_INPUT</name></expr></argument>,

<argument><expr><name>result_position_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>econv_source_buffer_empty</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>econv_after_output</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sweep_start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>found_needreport</name>:</label>

<do>do <block>{<block_content>

<expr_stmt><expr><name>needreport_index</name> <operator>=</operator> <call><name>trans_sweep</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>input_ptr</name></expr></argument>, <argument><expr><name>input_stop</name></expr></argument>, <argument><expr><name>output_ptr</name></expr></argument>, <argument><expr><name>output_stop</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>sweep_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sweep_start</name> <operator>=</operator> <name>needreport_index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>needreport_index</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>needreport_index</name> <operator>!=</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_result</name> <operator>!=</operator> <name>econv_source_buffer_empty</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>res</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_result</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>econv_invalid_byte_sequence</name> <operator>||</operator>

<name>res</name> <operator>==</operator> <name>econv_incomplete_input</name> <operator>||</operator>

<name>res</name> <operator>==</operator> <name>econv_undefined_conversion</name> <operator>||</operator>

<name>res</name> <operator>==</operator> <name>econv_after_output</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last_result</name> <operator>=</operator> <name>econv_source_buffer_empty</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result_position_ptr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>result_position_ptr</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>result_position_ptr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>result_position_ptr</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>econv_source_buffer_empty</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_result_t</name></type>

<name>rb_econv_convert0</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>input_ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input_stop</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>output_ptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output_stop</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result_position</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_output</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>last_error</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>in_buf_start</name></name> <operator>&amp;&amp;</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name> <operator>!=</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_data_end</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>output_stop</name> <operator>-</operator> <operator>*</operator><name>output_ptr</name> <operator>&lt;</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_data_end</name></name> <operator>-</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>output_stop</name> <operator>-</operator> <operator>*</operator><name>output_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>output_ptr</name> <operator>=</operator> <name>output_stop</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>econv_destination_buffer_full</name></expr>;</expr_stmt>

<goto>goto <name>gotresult</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_data_end</name></name> <operator>-</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>output_ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_data_end</name></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_buf_start</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ECONV_AFTER_OUTPUT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>econv_after_output</name></expr>;</expr_stmt>

<goto>goto <name>gotresult</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>output_stop</name> <operator>-</operator> <operator>*</operator><name>output_ptr</name> <operator>&lt;</operator> <name>input_stop</name> <operator>-</operator> <operator>*</operator><name>input_ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>output_stop</name> <operator>-</operator> <operator>*</operator><name>output_ptr</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>input_stop</name> <operator>-</operator> <operator>*</operator><name>input_ptr</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ECONV_AFTER_OUTPUT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>*</operator><name>output_ptr</name><operator>)</operator><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>*</operator><name>input_ptr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>econv_after_output</name></expr>;</expr_stmt>

<goto>goto <name>gotresult</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name></expr></argument>, <argument><expr><operator>*</operator><name>input_ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>output_ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>input_ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input_ptr</name> <operator>!=</operator> <name>input_stop</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>econv_destination_buffer_full</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ECONV_PARTIAL_INPUT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>econv_source_buffer_empty</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>econv_finished</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<goto>goto <name>gotresult</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>out_data_start</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data_start</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>out_data_start</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data_end</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>out_data_end</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>data_start</name> <operator>!=</operator> <name>data_end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>output_stop</name> <operator>-</operator> <operator>*</operator><name>output_ptr</name> <operator>&lt;</operator> <name>data_end</name> <operator>-</operator> <name>data_start</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>output_stop</name> <operator>-</operator> <operator>*</operator><name>output_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name></expr></argument>, <argument><expr><name>data_start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>output_ptr</name> <operator>=</operator> <name>output_stop</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>out_data_start</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>econv_destination_buffer_full</name></expr>;</expr_stmt>

<goto>goto <name>gotresult</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>data_end</name> <operator>-</operator> <name>data_start</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name></expr></argument>, <argument><expr><name>data_start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>output_ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>out_data_start</name> <operator>=</operator>

<name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>out_data_end</name> <operator>=</operator>

<name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>out_buf_start</name></expr>;</expr_stmt>

<expr_stmt><expr><name>has_output</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>in_buf_start</name></name> <operator>&amp;&amp;</operator>

<name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name> <operator>!=</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_data_end</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rb_trans_conv</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>in_data_end</name></name></expr></argument>, <argument><expr><name>output_ptr</name></expr></argument>, <argument><expr><name>output_stop</name></expr></argument>,

<argument><expr><operator>(</operator><name>flags</name><operator>&amp;</operator><operator>~</operator><name>ECONV_AFTER_OUTPUT</name><operator>)</operator><operator>|</operator><name>ECONV_PARTIAL_INPUT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>econv_source_buffer_empty</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>gotresult</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_output</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ECONV_AFTER_OUTPUT</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>*</operator><name>input_ptr</name> <operator>!=</operator> <name>input_stop</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input_stop</name> <operator>=</operator> <operator>*</operator><name>input_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rb_trans_conv</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>input_ptr</name></expr></argument>, <argument><expr><name>input_stop</name></expr></argument>, <argument><expr><name>output_ptr</name></expr></argument>, <argument><expr><name>output_stop</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>econv_source_buffer_empty</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>econv_after_output</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ECONV_AFTER_OUTPUT</name><operator>)</operator> <operator>||</operator>

<name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rb_trans_conv</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>input_ptr</name></expr></argument>, <argument><expr><name>input_stop</name></expr></argument>, <argument><expr><name>output_ptr</name></expr></argument>, <argument><expr><name>output_stop</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ECONV_AFTER_OUTPUT</name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rb_trans_conv</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>input_ptr</name></expr></argument>, <argument><expr><name>input_stop</name></expr></argument>, <argument><expr><name>output_ptr</name></expr></argument>, <argument><expr><name>output_stop</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>res</name> <operator>==</operator> <name>econv_after_output</name></expr>)</condition>;</do>

</block_content>}</block></else></if_stmt>

<label><name>gotresult</name>:</label>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>econv_invalid_byte_sequence</name> <operator>||</operator>

<name>res</name> <operator>==</operator> <name>econv_incomplete_input</name> <operator>||</operator>

<name>res</name> <operator>==</operator> <name>econv_undefined_conversion</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>error_tc</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>result_position</name></expr>]</index></name><operator>.</operator><name>tc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_tc</name></name> <operator>=</operator> <name>error_tc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name> <operator>=</operator> <name><name>error_tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>src_encoding</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>destination_encoding</name></name> <operator>=</operator> <name><name>error_tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name> <operator>=</operator> <call><name>TRANSCODING_READBUF</name><argument_list>(<argument><expr><name>error_tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name> <operator>=</operator> <name><name>error_tc</name><operator>-&gt;</operator><name>recognized_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>readagain_len</name></name> <operator>=</operator> <name><name>error_tc</name><operator>-&gt;</operator><name>readagain_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>output_replacement_character</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>output_hex_charref</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>utfbuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>utf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>utf_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>utf_allocated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>charef_buf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>encoding_equal</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>, <argument><expr><literal type="string">"UTF-32BE"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>utf</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>utf_len</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>utf</name> <operator>=</operator> <call><name>allocate_converted_string</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>, <argument><expr><literal type="string">"UTF-32BE"</literal></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name></expr></argument>,

<argument><expr><name>utfbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>utfbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><operator>&amp;</operator><name>utf_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>utf</name> <operator>!=</operator> <name>utfbuf</name> <operator>&amp;&amp;</operator> <name>utf</name> <operator>!=</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>utf_allocated</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>utf_len</name> <operator>%</operator> <literal type="number">4</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>utf</name></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">4</literal> <operator>&lt;=</operator> <name>utf_len</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>u</name> <operator>+=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>u</name> <operator>+=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>u</name> <operator>+=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>u</name> <operator>+=</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>charef_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>charef_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&amp;#x%X;"</literal></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_insert_output</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>charef_buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>charef_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"US-ASCII"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>utf_len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>utf_allocated</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>

<if_stmt><if>if <condition>(<expr><name>utf_allocated</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_econv_result_t</name></type>

<name>rb_econv_convert</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>input_ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>input_stop</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>output_ptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>output_stop</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>empty_buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>empty_ptr</name> <init>= <expr><operator>&amp;</operator><name>empty_buf</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>started</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>input_ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input_ptr</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>empty_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>input_stop</name> <operator>=</operator> <name>empty_ptr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>output_ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>output_ptr</name> <operator>=</operator> <operator>&amp;</operator><name>empty_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>output_stop</name> <operator>=</operator> <name>empty_ptr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>resume</name>:</label>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_convert0</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>input_ptr</name></expr></argument>, <argument><expr><name>input_stop</name></expr></argument>, <argument><expr><name>output_ptr</name></expr></argument>, <argument><expr><name>output_stop</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>econv_invalid_byte_sequence</name> <operator>||</operator>

<name>ret</name> <operator>==</operator> <name>econv_incomplete_input</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ECONV_INVALID_MASK</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ECONV_INVALID_REPLACE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>output_replacement_character</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>resume</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>econv_undefined_conversion</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ECONV_UNDEF_MASK</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ECONV_UNDEF_REPLACE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>output_replacement_character</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>resume</name>;</goto></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>ECONV_UNDEF_HEX_CHARREF</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>output_hex_charref</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>resume</name>;</goto></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_econv_encoding_to_insert_output</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>last_tc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="string">""</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tr</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tr</name><operator>-&gt;</operator><name>asciicompat_type</name></name> <operator>==</operator> <name>asciicompat_encoder</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>tr</name><operator>-&gt;</operator><name>src_encoding</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>

<name>allocate_converted_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>caller_dst_buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>caller_dst_bufsize</name></decl></parameter>,

<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>dst_len_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dst_str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>dst_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>dst_bufsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>caller_dst_buf</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dst_bufsize</name> <operator>=</operator> <name>caller_dst_bufsize</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dst_bufsize</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>dst_bufsize</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_open</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ec</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>caller_dst_buf</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dst_str</name> <operator>=</operator> <name>caller_dst_buf</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>dst_str</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>dst_bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>dst_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>dst_str</name><operator>+</operator><name>dst_len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rb_econv_convert</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dp</name></expr></argument>, <argument><expr><name>dst_str</name><operator>+</operator><name>dst_bufsize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dst_len</name> <operator>=</operator> <name>dp</name> <operator>-</operator> <name>dst_str</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>res</name> <operator>==</operator> <name>econv_destination_buffer_full</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>SIZE_MAX</name><operator>/</operator><literal type="number">2</literal> <operator>&lt;</operator> <name>dst_bufsize</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dst_bufsize</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dst_str</name> <operator>==</operator> <name>caller_dst_buf</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>dst_bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>dst_str</name></expr></argument>, <argument><expr><name>dst_bufsize</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dst_str</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>dst_str</name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(<argument><expr><name>dst_str</name></expr></argument>, <argument><expr><name>dst_bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>dst_str</name><operator>+</operator><name>dst_len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rb_econv_convert</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dp</name></expr></argument>, <argument><expr><name>dst_str</name><operator>+</operator><name>dst_bufsize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dst_len</name> <operator>=</operator> <name>dp</name> <operator>-</operator> <name>dst_str</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>econv_finished</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>dst_len_ptr</name> <operator>=</operator> <name>dst_len</name></expr>;</expr_stmt>

<return>return <expr><name>dst_str</name></expr>;</return>

<label><name>fail</name>:</label>

<if_stmt><if>if <condition>(<expr><name>dst_str</name> <operator>!=</operator> <name>caller_dst_buf</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>dst_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_econv_insert_output</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_encoding</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>insert_encoding</name> <init>= <expr><call><name>rb_econv_encoding_to_insert_output</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>insert_buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>insert_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>insert_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_trans_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf_start_p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data_start_p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data_end_p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf_end_p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>need</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>started</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>encoding_equal</name><argument_list>(<argument><expr><name>insert_encoding</name></expr></argument>, <argument><expr><name>str_encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>insert_str</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>insert_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>insert_str</name> <operator>=</operator> <call><name>allocate_converted_string</name><argument_list>(<argument><expr><name>str_encoding</name></expr></argument>, <argument><expr><name>insert_encoding</name></expr></argument>,

<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>insert_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>insert_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>insert_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>insert_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>need</name> <operator>=</operator> <name>insert_len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>last_trans_index</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf_start_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>in_buf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>data_start_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>data_end_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>in_data_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf_end_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>in_buf_end</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>last_trans_index</name></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>asciicompat_type</name></name> <operator>==</operator> <name>asciicompat_encoder</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tc</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>last_trans_index</name></expr>]</index></name><operator>.</operator><name>tc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>need</name> <operator>+=</operator> <name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need</name> <operator>&lt;</operator> <name>insert_len</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>last_trans_index</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>buf_start_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>in_buf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>data_start_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>in_data_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>data_end_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>in_data_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf_end_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>in_buf_end</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_elem_t</name> <modifier>*</modifier></type><name>ee</name> <init>= <expr><operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>last_trans_index</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>buf_start_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ee</name><operator>-&gt;</operator><name>out_buf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>data_start_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ee</name><operator>-&gt;</operator><name>out_data_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>data_end_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ee</name><operator>-&gt;</operator><name>out_data_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf_end_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ee</name><operator>-&gt;</operator><name>out_buf_end</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_elem_t</name> <modifier>*</modifier></type><name>ee</name> <init>= <expr><operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>last_trans_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>buf_start_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ee</name><operator>-&gt;</operator><name>out_buf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>data_start_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ee</name><operator>-&gt;</operator><name>out_data_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>data_end_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ee</name><operator>-&gt;</operator><name>out_data_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf_end_p</name> <operator>=</operator> <operator>&amp;</operator><name><name>ee</name><operator>-&gt;</operator><name>out_buf_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>tc</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>last_trans_index</name></expr>]</index></name><operator>.</operator><name>tc</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf_start_p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>need</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>buf_start_p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>data_start_p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>data_end_p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>buf_end_p</name> <operator>=</operator> <name>buf</name><operator>+</operator><name>need</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>buf_end_p</name> <operator>-</operator> <operator>*</operator><name>data_end_p</name><operator>)</operator> <operator>&lt;</operator> <name>need</name></expr>)</condition> <block>{<block_content>

<macro><name>MEMMOVE</name><argument_list>(<argument>*buf_start_p</argument>, <argument>*data_start_p</argument>, <argument>unsigned char</argument>, <argument>*data_end_p - *data_start_p</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><operator>*</operator><name>data_end_p</name> <operator>=</operator> <operator>*</operator><name>buf_start_p</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>data_end_p</name> <operator>-</operator> <operator>*</operator><name>data_start_p</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>data_start_p</name> <operator>=</operator> <operator>*</operator><name>buf_start_p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>buf_end_p</name> <operator>-</operator> <operator>*</operator><name>data_end_p</name><operator>)</operator> <operator>&lt;</operator> <name>need</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>s</name> <init>= <expr><operator>(</operator><operator>*</operator><name>data_end_p</name> <operator>-</operator> <operator>*</operator><name>buf_start_p</name><operator>)</operator> <operator>+</operator> <name>need</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>need</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(<argument><expr><operator>*</operator><name>buf_start_p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>data_start_p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>data_end_p</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>data_end_p</name> <operator>-</operator> <operator>*</operator><name>buf_start_p</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>buf_start_p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>buf_end_p</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>data_end_p</name></expr></argument>, <argument><expr><name>insert_str</name></expr></argument>, <argument><expr><name>insert_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>data_end_p</name> <operator>+=</operator> <name>insert_len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tc</name> <operator>&amp;&amp;</operator> <name><name>tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>asciicompat_type</name></name> <operator>==</operator> <name>asciicompat_encoder</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>data_end_p</name></expr></argument>, <argument><expr><call><name>TRANSCODING_READBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call><operator>+</operator><name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name></expr></argument>, <argument><expr><name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>data_end_p</name> <operator>+=</operator> <name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>insert_str</name> <operator>!=</operator> <name>str</name> <operator>&amp;&amp;</operator> <name>insert_str</name> <operator>!=</operator> <name>insert_buf</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>insert_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>

<if_stmt><if>if <condition>(<expr><name>insert_str</name> <operator>!=</operator> <name>str</name> <operator>&amp;&amp;</operator> <name>insert_str</name> <operator>!=</operator> <name>insert_buf</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>insert_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_econv_close</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_allocated</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>replacement_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_transcoding_close</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_buf_start</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_buf_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>in_buf_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>size_t</name></type>

<name>rb_econv_memsize</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_econv_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_allocated</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>ec</name><operator>-&gt;</operator><name>replacement_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_transcoding_memsize</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_buf_start</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_buf_end</name> <operator>-</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_buf_start</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_buf_end</name></name> <operator>-</operator> <name><name>ec</name><operator>-&gt;</operator><name>in_buf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rb_econv_elem_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_allocated</name></name></expr>;</expr_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_econv_putbackable</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_SIZE_T</name> <operator>&gt;</operator> <name>SIZEOF_INT</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>INT_MAX</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_econv_putback</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tc</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>TRANSCODING_READBUF</name><argument_list>(<argument><expr><name>tc</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>tc</name><operator>-&gt;</operator><name>recognized_len</name></name> <operator>+</operator> <name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tc</name><operator>-&gt;</operator><name>readagain_len</name></name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>asciicompat_encoding_t</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ascii_compat_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ascii_incompat_name</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>asciicompat_encoding_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>asciicompat_encoding_t</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>asciicompat_encoding_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>transcoder_entry_t</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>load_transcoder_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tr</name> <operator>&amp;&amp;</operator> <name><name>tr</name><operator>-&gt;</operator><name>asciicompat_type</name></name> <operator>==</operator> <name>asciicompat_decoder</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>ascii_compat_name</name></name> <operator>=</operator> <name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr>;</expr_stmt>

<return>return <expr><name>ST_STOP</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_econv_asciicompat_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ascii_incompat_name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>table2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>asciicompat_encoding_t</name></name></type> <name>data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>transcoder_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>ascii_incompat_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>table2</name> <operator>=</operator> <operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator><name>v</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>table2</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>ascii_incompat_name</name></name> <operator>=</operator> <name>ascii_incompat_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>ascii_compat_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>table2</name></expr></argument>, <argument><expr><name>asciicompat_encoding_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>data</name><operator>.</operator><name>ascii_compat_name</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_econv_append</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>se</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ds</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_output</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>last_tc</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>max_output</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>max_output</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>max_output</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<do>do <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>dlen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_str_capacity</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>dlen</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>len</name> <operator>+</operator> <name>max_output</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>new_capa</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>dlen</name> <operator>+</operator> <name>len</name> <operator>+</operator> <name>max_output</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>LONG_MAX</name> <operator>&lt;</operator> <name>new_capa</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too long string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>new_capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>ss</name></expr>;</expr_stmt>

<expr_stmt><expr><name>se</name> <operator>=</operator> <name>sp</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ds</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>de</name> <operator>=</operator> <name>ds</name> <operator>+</operator> <call><name>rb_str_capacity</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dp</name> <operator>=</operator> <name>ds</name> <operator>+=</operator> <name>dlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rb_econv_convert</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>, <argument><expr><name>se</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dp</name></expr></argument>, <argument><expr><name>de</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>-=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>sp</name> <operator>-</operator> <name>ss</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ss</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>sp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dlen</name> <operator>+</operator> <operator>(</operator><name>dp</name> <operator>-</operator> <name>ds</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_econv_check_error</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>res</name> <operator>==</operator> <name>econv_destination_buffer_full</name></expr>)</condition>;</do>

<return>return <expr><name>dst</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_econv_substr_append</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>rb_econv_append</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dst</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_econv_str_append</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_econv_substr_append</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_econv_substr_convert</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>byteoff</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>bytesize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_econv_substr_append</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>byteoff</name></expr></argument>, <argument><expr><name>bytesize</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_econv_str_convert</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_econv_substr_append</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_econv_add_converter</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>started</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>get_transcoder_entry</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tr</name> <operator>=</operator> <call><name>load_transcoder_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_econv_add_transcoder_at</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_econv_decorate_at</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>decorator_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_econv_add_converter</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>decorator_name</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_econv_decorate_at_first</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>decorator_name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_econv_decorate_at</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>decorator_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tr</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>src_encoding</name></name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>tr</name><operator>-&gt;</operator><name>asciicompat_type</name></name> <operator>==</operator> <name>asciicompat_decoder</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_econv_decorate_at</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>decorator_name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_econv_decorate_at</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>decorator_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_econv_decorate_at_last</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>decorator_name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_econv_decorate_at</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>decorator_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tr</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>src_encoding</name></name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>tr</name><operator>-&gt;</operator><name>asciicompat_type</name></name> <operator>==</operator> <name>asciicompat_encoder</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_econv_decorate_at</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>decorator_name</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_econv_decorate_at</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>decorator_name</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_econv_binmode</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ECONV_NEWLINE_DECORATOR_MASK</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ECONV_UNIVERSAL_NEWLINE_DECORATOR</name></expr>:</case>

<expr_stmt><expr><name>dname</name> <operator>=</operator> <literal type="string">"universal_newline"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ECONV_CRLF_NEWLINE_DECORATOR</name></expr>:</case>

<expr_stmt><expr><name>dname</name> <operator>=</operator> <literal type="string">"crlf_newline"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ECONV_CR_NEWLINE_DECORATOR</name></expr>:</case>

<expr_stmt><expr><name>dname</name> <operator>=</operator> <literal type="string">"cr_newline"</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>dname</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>transcoder</name> <init>= <expr><call><name>get_transcoder_entry</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>transcoder</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_trans</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_trans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>transcoder</name> <operator>==</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_transcoding_close</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>out_buf_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ECONV_NEWLINE_DECORATOR_MASK</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_description</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>has_description</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sname</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>dname</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sname</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>dname</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"%s to %s"</literal></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>has_description</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <operator>(</operator><name>ECONV_NEWLINE_DECORATOR_MASK</name><operator>|</operator>

<name>ECONV_XML_TEXT_DECORATOR</name><operator>|</operator>

<name>ECONV_XML_ATTR_CONTENT_DECORATOR</name><operator>|</operator>

<name>ECONV_XML_ATTR_QUOTE_DECORATOR</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pre</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_description</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">" with "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_UNIVERSAL_NEWLINE_DECORATOR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pre</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"universal_newline"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_CRLF_NEWLINE_DECORATOR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pre</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"crlf_newline"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_CR_NEWLINE_DECORATOR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pre</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"cr_newline"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_XML_TEXT_DECORATOR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pre</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"xml_text"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_XML_ATTR_CONTENT_DECORATOR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pre</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"xml_attr_content"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_XML_ATTR_QUOTE_DECORATOR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pre</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"xml_attr_quote"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>has_description</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_description</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"no-conversion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>mesg</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_econv_open_exc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>, <decl><type ref="prev"/><name>exc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><literal type="string">"code converter not found ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>econv_description</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eConverterNotFoundError</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>make_econv_exception</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>, <decl><type ref="prev"/><name>exc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>result</name></name> <operator>==</operator> <name>econv_invalid_byte_sequence</name> <operator>||</operator>

<name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>result</name></name> <operator>==</operator> <name>econv_incomplete_input</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>error_len</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bytes</name> <init>= <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>error_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dumped</name> <init>= <expr><call><name>rb_str_dump</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>readagain_len</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>readagain_len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bytes2</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dumped2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>result</name></name> <operator>==</operator> <name>econv_incomplete_input</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"incomplete %s on %s"</literal></expr></argument>,

<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>dumped</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>readagain_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bytes2</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name>err</name><operator>+</operator><name>error_len</name></expr></argument>, <argument><expr><name>readagain_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dumped2</name> <operator>=</operator> <call><name>rb_str_dump</name><argument_list>(<argument><expr><name>bytes2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%s followed by %s on %s"</literal></expr></argument>,

<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>dumped</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>dumped2</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%s on %s"</literal></expr></argument>,

<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>dumped</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eInvalidByteSequenceError</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"error_bytes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"readagain_bytes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bytes2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"incomplete_input"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>result</name></name> <operator>==</operator> <name>econv_incomplete_input</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>set_encs</name>:</label>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"source_encoding_name"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"destination_encoding_name"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>destination_encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>rb_enc_find_index</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>idx</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"source_encoding"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>rb_enc_find_index</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>destination_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>idx</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"destination_encoding"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>result</name></name> <operator>==</operator> <name>econv_undefined_conversion</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bytes</name> <init>= <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dumped</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>utf8</name> <init>= <expr><call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name> <operator>+</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name>size_t</name><operator>)</operator><call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cc</name> <init>= <expr><call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dumped</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"U+%04X"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dumped</name> <operator>==</operator> <name>Qnil</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dumped</name> <operator>=</operator> <call><name>rb_str_dump</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>destination_encoding</name></name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%s from %s to %s"</literal></expr></argument>,

<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>dumped</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>destination_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%s to %s in conversion from %s"</literal></expr></argument>,

<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>dumped</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>destination_encoding</name></name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>src_encoding</name></name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">" to %s"</literal></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eUndefinedConversionError</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>rb_enc_find_index</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>idx</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"error_char"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>set_encs</name>;</goto>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>

<name>more_output_buffer</name><argument_list>(

<argument><expr><name>VALUE</name> <name>destination</name></expr></argument>,

<argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><call>(<modifier>*</modifier><name>resize_destination</name>)<argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>int</name> <name>max_output</name></expr></argument>,

<argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><name>out_start_ptr</name></expr></argument>,

<argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><name>out_pos</name></expr></argument>,

<argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><name>out_stop_ptr</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><operator>(</operator><operator>*</operator><name>out_pos</name> <operator>-</operator> <operator>*</operator><name>out_start_ptr</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>new_len</name> <init>= <expr><operator>(</operator><name>len</name> <operator>+</operator> <name>max_output</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>out_start_ptr</name> <operator>=</operator> <call><name>resize_destination</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_pos</name> <operator>=</operator> <operator>*</operator><name>out_start_ptr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>out_stop_ptr</name> <operator>=</operator> <operator>*</operator><name>out_start_ptr</name> <operator>+</operator> <name>new_len</name></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>make_replacement</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>tc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>replacement</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>repl_enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ins_enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_str</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ins_enc</name> <operator>=</operator> <call><name>rb_econv_encoding_to_insert_output</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tc</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_tc</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ins_enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tr</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_find</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>replacement</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>get_replacement_character</name><argument_list>(<argument><expr><name>ins_enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>repl_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>replacement</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"?"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>repl_enc</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_str</name></name> <operator>=</operator> <name>replacement</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_enc</name></name> <operator>=</operator> <name>repl_enc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_allocated</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_econv_set_replacement</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encname2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>encname2</name> <operator>=</operator> <call><name>rb_econv_encoding_to_insert_output</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>encname2</name> <operator>||</operator> <call><name>encoding_equal</name><argument_list>(<argument><expr><name>encname</name></expr></argument>, <argument><expr><name>encname2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>MEMCPY</name><argument_list>(<argument>str2</argument>, <argument>str</argument>, <argument>unsigned char</argument>, <argument>len</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> 

<expr_stmt><expr><name>len2</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>encname2</name> <operator>=</operator> <name>encname</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>allocate_converted_string</name><argument_list>(<argument><expr><name>encname</name></expr></argument>, <argument><expr><name>encname2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str2</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_allocated</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>replacement_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_allocated</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_str</name></name> <operator>=</operator> <name>str2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_len</name></name> <operator>=</operator> <name>len2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_enc</name></name> <operator>=</operator> <name>encname2</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>output_replacement_character</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>make_replacement</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_insert_output</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_str</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_len</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hash_fallback</name></cpp:macro> <cpp:value>rb_hash_aref</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_fallback</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fallback</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_proc_call</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>, <argument><expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>method_fallback</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fallback</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_method_call</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>aref_fallback</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fallback</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_funcallv_public</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>

<name>transcode_loop</name><argument_list>(<argument><expr><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><name>in_pos</name></expr></argument>, <argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><name>out_pos</name></expr></argument>,

<argument><expr><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><name>in_stop</name></expr></argument>, <argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><name>out_stop</name></expr></argument>,

<argument><expr><name>VALUE</name> <name>destination</name></expr></argument>,

<argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><call>(<modifier>*</modifier><name>resize_destination</name>)<argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>src_encoding</name></expr></argument>,

<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>dst_encoding</name></expr></argument>,

<argument><expr><name>int</name> <name>ecflags</name></expr></argument>,

<argument><expr><name>VALUE</name> <name>ecopts</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>last_tc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_start</name> <init>= <expr><operator>*</operator><name>out_pos</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_output</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>fallback</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>fallback_func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_open_opts</name><argument_list>(<argument><expr><name>src_encoding</name></expr></argument>, <argument><expr><name>dst_encoding</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_econv_open_exc</name><argument_list>(<argument><expr><name>src_encoding</name></expr></argument>, <argument><expr><name>dst_encoding</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>ecopts</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>ecopts</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fallback</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>ecopts</name></expr></argument>, <argument><expr><name>sym_fallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fallback_func</name> <operator>=</operator> <name>hash_fallback</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fallback_func</name> <operator>=</operator> <name>proc_fallback</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_obj_is_method</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fallback_func</name> <operator>=</operator> <name>method_fallback</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>fallback_func</name> <operator>=</operator> <name>aref_fallback</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>last_tc</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_tc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>max_output</name> <operator>=</operator> <ternary><condition><expr><name>last_tc</name></expr> ?</condition><then> <expr><name><name>last_tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>max_output</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<label><name>resume</name>:</label>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_convert</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>in_pos</name></expr></argument>, <argument><expr><name>in_stop</name></expr></argument>, <argument><expr><name>out_pos</name></expr></argument>, <argument><expr><name>out_stop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ret</name> <operator>==</operator> <name>econv_undefined_conversion</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rep</name> <init>= <expr><call><name>rb_enc_str_new</name><argument_list>(

<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name></expr></argument>,

<argument><expr><call><name>rb_enc_find</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>rep</name> <operator>=</operator> <call>(<modifier>*</modifier><name>fallback_func</name>)<argument_list>(<argument><expr><name>fallback</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rep</name> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_insert_output</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big fallback string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>resume</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>econv_invalid_byte_sequence</name> <operator>||</operator>

<name>ret</name> <operator>==</operator> <name>econv_incomplete_input</name> <operator>||</operator>

<name>ret</name> <operator>==</operator> <name>econv_undefined_conversion</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>make_econv_exception</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>econv_destination_buffer_full</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>more_output_buffer</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>resize_destination</name></expr></argument>, <argument><expr><name>max_output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_start</name></expr></argument>, <argument><expr><name>out_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>resume</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></decl></decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>

<name>transcode_loop</name><argument_list>(<argument><expr><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><name>in_pos</name></expr></argument>, <argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><operator>*</operator><name>out_pos</name></expr></argument>,

<argument><expr><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><name>in_stop</name></expr></argument>, <argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><name>out_stop</name></expr></argument>,

<argument><expr><name>VALUE</name> <name>destination</name></expr></argument>,

<argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><call>(<modifier>*</modifier><name>resize_destination</name>)<argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>src_encoding</name></expr></argument>,

<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>dst_encoding</name></expr></argument>,

<argument><expr><name>int</name> <name>ecflags</name></expr></argument>,

<argument><expr><name>VALUE</name> <name>ecopts</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_transcoding</name> <modifier>*</modifier></type><name>last_tc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out_start</name> <init>= <expr><operator>*</operator><name>out_pos</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_output</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_open_opts</name><argument_list>(<argument><expr><name>src_encoding</name></expr></argument>, <argument><expr><name>dst_encoding</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_econv_open_exc</name><argument_list>(<argument><expr><name>src_encoding</name></expr></argument>, <argument><expr><name>dst_encoding</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>last_tc</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_tc</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>max_output</name> <operator>=</operator> <ternary><condition><expr><name>last_tc</name></expr> ?</condition><then> <expr><name><name>last_tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>max_output</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>econv_source_buffer_empty</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>*</operator><name>in_pos</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>ret</name> <operator>!=</operator> <name>econv_finished</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>input_byte</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name>input_byte</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>econv_source_buffer_empty</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>in_stop</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input_byte</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_convert</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>out_pos</name></expr></argument>, <argument><expr><name>out_stop</name></expr></argument>, <argument><expr><name>ECONV_PARTIAL_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_convert</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>out_pos</name></expr></argument>, <argument><expr><name>out_stop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_convert</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>out_pos</name></expr></argument>, <argument><expr><name>out_stop</name></expr></argument>, <argument><expr><name>ECONV_PARTIAL_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>&amp;</operator><name>input_byte</name> <operator>!=</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>p</name> <operator>-</operator> <operator>&amp;</operator><name>input_byte</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>econv_invalid_byte_sequence</name></expr>:</case>

<case>case <expr><name>econv_incomplete_input</name></expr>:</case>

<case>case <expr><name>econv_undefined_conversion</name></expr>:</case>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>make_econv_exception</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>econv_destination_buffer_full</name></expr>:</case>

<expr_stmt><expr><call><name>more_output_buffer</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>resize_destination</name></expr></argument>, <argument><expr><name>max_output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_start</name></expr></argument>, <argument><expr><name>out_pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>out_stop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>econv_source_buffer_empty</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>econv_finished</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></while>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>in_pos</name> <operator>=</operator> <name>in_stop</name></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>

<name>str_transcoding_resize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>destination</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>econv_opts</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newlineflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_invalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>v</name><operator>==</operator><name>sym_replace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>ECONV_INVALID_REPLACE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unknown value for invalid character option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_undef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>v</name><operator>==</operator><name>sym_replace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>ECONV_UNDEF_REPLACE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unknown value for undefined character option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_INVALID_REPLACE</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>ECONV_UNDEF_REPLACE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_xml</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>v</name><operator>==</operator><name>sym_text</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>ECONV_XML_TEXT_DECORATOR</name><operator>|</operator><name>ECONV_UNDEF_HEX_CHARREF</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>v</name><operator>==</operator><name>sym_attr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>ECONV_XML_ATTR_CONTENT_DECORATOR</name><operator>|</operator><name>ECONV_XML_ATTR_QUOTE_DECORATOR</name><operator>|</operator><name>ECONV_UNDEF_HEX_CHARREF</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>T_SYMBOL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected value for xml option: %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected value for xml option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_ECONV_NEWLINE_OPTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>newlineflag</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ecflags</name> <operator>&amp;=</operator> <operator>~</operator><name>ECONV_NEWLINE_DECORATOR_MASK</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>sym_universal</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>ECONV_UNIVERSAL_NEWLINE_DECORATOR</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>v</name> <operator>==</operator> <name>sym_crlf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>ECONV_CRLF_NEWLINE_DECORATOR</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>v</name> <operator>==</operator> <name>sym_cr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>ECONV_CR_NEWLINE_DECORATOR</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>v</name> <operator>==</operator> <name>sym_lf</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected value for newline option: %"</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unexpected value for newline option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>setflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_universal_newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>setflags</name> <operator>|=</operator> <name>ECONV_UNIVERSAL_NEWLINE_DECORATOR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>newlineflag</name> <operator>|=</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_crlf_newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>setflags</name> <operator>|=</operator> <name>ECONV_CRLF_NEWLINE_DECORATOR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>newlineflag</name> <operator>|=</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_cr_newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>setflags</name> <operator>|=</operator> <name>ECONV_CR_NEWLINE_DECORATOR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>newlineflag</name> <operator>|=</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>newlineflag</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>ecflags</name> <operator>&amp;=</operator> <operator>~</operator><name>ECONV_NEWLINE_DECORATOR_MASK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>setflags</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">":newline option preceds other newline options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<return>return <expr><name>ecflags</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_econv_prepare_options</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>opthash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>newhash</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>opthash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>opts</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<return>return <expr><name>ecflags</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ecflags</name> <operator>=</operator> <call><name>econv_opts</name><argument_list>(<argument><expr><name>opthash</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opthash</name></expr></argument>, <argument><expr><name>sym_replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dumped</name> <init>= <expr><call><name>rb_str_dump</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"replacement string is broken: %s as %s"</literal></expr></argument>,

<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>dumped</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>newhash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>newhash</name></expr></argument>, <argument><expr><name>sym_replace</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opthash</name></expr></argument>, <argument><expr><name>sym_fallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>h</name> <init>= <expr><call><name>rb_check_hash_type</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>

?</condition><then> <expr><operator>(</operator><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>rb_obj_is_method</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>rb_respond_to</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idAREF</name></expr></argument>)</argument_list></call><operator>)</operator></expr>

</then><else>: <expr><operator>(</operator><name>v</name> <operator>=</operator> <name>h</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>newhash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>newhash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>newhash</name></expr></argument>, <argument><expr><name>sym_fallback</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>newhash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_hash_freeze</name><argument_list>(<argument><expr><name>newhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>opts</name> <operator>=</operator> <name>newhash</name></expr>;</expr_stmt>

<return>return <expr><name>ecflags</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_econv_prepare_opts</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>opthash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_econv_prepare_options</name><argument_list>(<argument><expr><name>opthash</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_econv_t</name> <modifier>*</modifier></type>

<name>rb_econv_open_opts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_encoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>destination_encoding</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>opthash</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>replacement</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>opthash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>replacement</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>opthash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>opthash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_econv_open_opts called with invalid opthash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>replacement</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opthash</name></expr></argument>, <argument><expr><name>sym_replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_open</name><argument_list>(<argument><expr><name>source_encoding</name></expr></argument>, <argument><expr><name>destination_encoding</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ec</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_set_replacement</name><argument_list>(<argument><expr><name>ec</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ec</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>enc_arg</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name_p</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>enc_p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>encval</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>encidx</name> <operator>=</operator> <call><name>rb_to_encoding_index</name><argument_list>(<argument><expr><name>encval</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<operator>!</operator><operator>(</operator><name>enc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>encidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>name_p</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>enc_p</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>

<return>return <expr><name>encidx</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>str_transcode_enc_args</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sname_p</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>senc_p</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dname_p</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>denc_p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>senc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>denc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sencidx</name></decl>, <decl><type ref="prev"/><name>dencidx</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dencidx</name> <operator>=</operator> <call><name>enc_arg</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>denc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><operator>*</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sencidx</name> <operator>=</operator> <call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>senc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>sencidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sname</name> <operator>=</operator> <call><name>rb_enc_name</name><argument_list>(<argument><expr><name>senc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>sencidx</name> <operator>=</operator> <call><name>enc_arg</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>senc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>sname_p</name> <operator>=</operator> <name>sname</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>senc_p</name> <operator>=</operator> <name>senc</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>dname_p</name> <operator>=</operator> <name>dname</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>denc_p</name> <operator>=</operator> <name>denc</name></expr>;</expr_stmt>

<return>return <expr><name>dencidx</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>str_transcode0</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ecopts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dest</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><operator>*</operator><name>self</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg1</name></decl>, <decl><type ref="prev"/><name>arg2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>blen</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>fromp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>senc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>denc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dencidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>explicitly_invalid_replace</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>rb_enc_default_internal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ecflags</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>rb_obj_encoding</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_INVALID_MASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>explicitly_invalid_replace</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ecflags</name> <operator>|=</operator> <name>ECONV_INVALID_REPLACE</name> <operator>|</operator> <name>ECONV_UNDEF_REPLACE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>arg1</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>arg2</name> <operator>=</operator> <ternary><condition><expr><name>argc</name><operator>&lt;=</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>dencidx</name> <operator>=</operator> <call><name>str_transcode_enc_args</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>senc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>denc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ecflags</name> <operator>&amp;</operator> <operator>(</operator><name>ECONV_NEWLINE_DECORATOR_MASK</name><operator>|</operator>

<name>ECONV_XML_TEXT_DECORATOR</name><operator>|</operator>

<name>ECONV_XML_ATTR_CONTENT_DECORATOR</name><operator>|</operator>

<name>ECONV_XML_ATTR_QUOTE_DECORATOR</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>senc</name> <operator>&amp;&amp;</operator> <name>senc</name> <operator>==</operator> <name>denc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ecflags</name> <operator>&amp;</operator> <name>ECONV_INVALID_MASK</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>explicitly_invalid_replace</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rep</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rep</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>ecopts</name></expr></argument>, <argument><expr><name>sym_replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>rb_enc_str_scrub</name><argument_list>(<argument><expr><name>senc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dest</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>self</name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>

<return>return <expr><name>dencidx</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>dencidx</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>senc</name> <operator>&amp;&amp;</operator> <name>denc</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>senc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>denc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>dencidx</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>encoding_equal</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>dencidx</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>encoding_equal</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dname</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>fromp</name> <operator>=</operator> <name>sp</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>blen</name> <operator>=</operator> <name>slen</name> <operator>+</operator> <literal type="number">30</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>rb_str_tmp_new</name><argument_list>(<argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bp</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>transcode_loop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fromp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bp</name></expr></argument>, <argument><expr><operator>(</operator><name>sp</name><operator>+</operator><name>slen</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>bp</name><operator>+</operator><name>blen</name><operator>)</operator></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>str_transcoding_resize</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fromp</name> <operator>!=</operator> <name>sp</name><operator>+</operator><name>slen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"not fully converted, %"</literal><name>PRIdPTRDIFF</name><literal type="string">" bytes left"</literal></expr></argument>, <argument><expr><name>sp</name><operator>+</operator><name>slen</name><operator>-</operator><name>fromp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>bp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>bp</name> <operator>-</operator> <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>denc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dencidx</name> <operator>=</operator> <call><name>rb_define_dummy_encoding</name><argument_list>(<argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>self</name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>

<return>return <expr><name>dencidx</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>str_transcode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ecflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ecopts</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"02:"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>=</operator> <call><name>rb_econv_prepare_opts</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>str_transcode0</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>str_encode_associate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_coderange_scan_restartable</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_encode_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>newstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>newstr</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>encidx</name> <operator>=</operator> <call><name>str_transcode</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>newstr</name> <operator>==</operator> <name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_shared_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>str_encode_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>encoded_dup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>newstr</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encidx</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_encode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>newstr</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><call><name>str_transcode</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>encoded_dup</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_encode</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ecopts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><operator>&amp;</operator><name>to</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>newstr</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><call><name>str_transcode0</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newstr</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>encoded_dup</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>encoded_dup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>newstr</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>newstr</name> <operator>==</operator> <name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>newstr</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>newstr</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>str_encode_associate</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>econv_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>econv_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_econv_t</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>econv_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"econv"</literal></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>econv_free</name></expr>, <expr><name>econv_memsize</name></expr>,}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_s_allocate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>econv_data_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>

<name>make_dummy_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>rb_define_dummy_encoding</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>enc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>

<name>make_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_find</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>make_dummy_encoding</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>enc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>make_encobj</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><call><name>make_encoding</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_s_asciicompat_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>result_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>arg_enc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>result_enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>enc_arg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result_name</name> <operator>=</operator> <call><name>rb_econv_asciicompat_encoding</name><argument_list>(<argument><expr><name>arg_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>result_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>result_enc</name> <operator>=</operator> <call><name>make_encoding</name><argument_list>(<argument><expr><name>result_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name>result_enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>econv_args</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>snamev_p</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>dnamev_p</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sname_p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dname_p</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>senc_p</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>denc_p</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ecflags_p</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ecopts_p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opt</name></decl>, <decl><type ref="prev"/><name>flags_v</name></decl>, <decl><type ref="prev"/><name>ecopts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sidx</name></decl>, <decl><type ref="prev"/><name>didx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>senc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>denc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ecflags</name></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"21:"</literal></expr></argument>, <argument><expr><name>snamev_p</name></expr></argument>, <argument><expr><name>dnamev_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags_v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>flags_v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_error_arity</name><argument_list>(<argument><expr><name>argc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ecflags</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><call><name>rb_to_int</name><argument_list>(<argument><expr><name>flags_v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ecopts</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>=</operator> <call><name>rb_econv_prepare_opts</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ecflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ecopts</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>senc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sidx</name> <operator>=</operator> <call><name>rb_to_encoding_index</name><argument_list>(<argument><expr><operator>*</operator><name>snamev_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>sidx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>senc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>sidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><operator>*</operator><name>snamev_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>denc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>didx</name> <operator>=</operator> <call><name>rb_to_encoding_index</name><argument_list>(<argument><expr><operator>*</operator><name>dnamev_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>didx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>denc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>didx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><operator>*</operator><name>dnamev_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>sname</name> <operator>=</operator> <ternary><condition><expr><name>senc</name></expr> ?</condition><then> <expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>senc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><operator>*</operator><name>snamev_p</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>dname</name> <operator>=</operator> <ternary><condition><expr><name>denc</name></expr> ?</condition><then> <expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>denc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><operator>*</operator><name>dnamev_p</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>sname_p</name> <operator>=</operator> <name>sname</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>dname_p</name> <operator>=</operator> <name>dname</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>senc_p</name> <operator>=</operator> <name>senc</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>denc_p</name> <operator>=</operator> <name>denc</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ecflags_p</name> <operator>=</operator> <name>ecflags</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ecopts_p</name> <operator>=</operator> <name>ecopts</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>decorate_convpath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>convpath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>num_decorators</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>decorators</name><index>[<expr><name>MAX_ECFLAGS_DECORATORS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>num_decorators</name> <operator>=</operator> <call><name>decorator_names</name><argument_list>(<argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>decorators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num_decorators</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>n</name> <operator>=</operator> <call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pair</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name> <init>= <expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_to_encoding</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name> <init>= <expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_to_encoding</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>transcoder_entry_t</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>get_transcoder_entry</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name> <init>= <expr><call><name>load_transcoder_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tr</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>src_encoding</name></name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>tr</name><operator>-&gt;</operator><name>asciicompat_type</name></name> <operator>==</operator> <name>asciicompat_encoder</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>num_decorators</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>num_decorators</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_decorators</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name><name>decorators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>search_convpath_i</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ary_p</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ary_p</name> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>ary_p</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>make_encobj</name><argument_list>(<argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>make_encobj</name><argument_list>(<argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><operator>*</operator><name>ary_p</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_s_search_convpath</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>snamev</name></decl>, <decl><type ref="prev"/><name>dnamev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>senc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>denc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ecflags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ecopts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>convpath</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>econv_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>snamev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnamev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>senc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>denc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ecflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>convpath</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>transcode_search_path</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>search_convpath_i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>convpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_econv_open_exc</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>snamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>dnamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>decorate_convpath</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_econv_open_exc</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>snamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>dnamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>convpath</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_econv_has_convpath_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>from_encoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>to_encoding</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>convpath</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>transcode_search_path</name><argument_list>(<argument><expr><name>from_encoding</name></expr></argument>, <argument><expr><name>to_encoding</name></expr></argument>, <argument><expr><name>search_convpath_i</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>convpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RTEST</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>rb_econv_init_by_convpath_t</name> <block>{

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_econv_init_by_convpath_i</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_econv_init_by_convpath_t</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>rb_econv_init_by_convpath_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ret</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_add_converter</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>ret</name></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_t</name> <modifier>*</modifier></type>

<name>rb_econv_init_by_convpath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>convpath</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sname_p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dname_p</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>senc_p</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name><modifier>*</modifier><modifier>*</modifier></type><name>denc_p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>first</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>elt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>senc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>denc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_alloc</name><argument_list>(<argument><expr><call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>snamev</name></decl>, <decl><type ref="prev"/><name>dnamev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pair</name></decl>;</decl_stmt>

<expr_stmt><expr><name>elt</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>convpath</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>pair</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"not a 2-element array in convpath"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>snamev</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>enc_arg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>snamev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>senc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dnamev</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>enc_arg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dnamev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>denc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>sname</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dname</name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_add_converter</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>msg</name> <init>= <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"decoration failed: %s"</literal></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>snamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>dnamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_exc_new_str</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_econv_init_by_convpath_t</name></name></type> <name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>ec</name></name> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>ret</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>transcode_search_path</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>rb_econv_init_by_convpath_i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>arg</name><operator>.</operator><name>ret</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>msg</name> <init>= <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"adding conversion failed: %s to %s"</literal></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>snamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>dnamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_exc_new_str</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>senc_p</name> <operator>=</operator> <name>senc</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>sname_p</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>src_encoding</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>denc_p</name> <operator>=</operator> <name>denc</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>dname_p</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>senc_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>denc_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>sname_p</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>dname_p</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding_name</name></name> <operator>=</operator> <operator>*</operator><name>sname_p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding_name</name></name> <operator>=</operator> <operator>*</operator><name>dname_p</name></expr>;</expr_stmt>

<return>return <expr><name>ec</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ecopts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>snamev</name></decl>, <decl><type ref="prev"/><name>dnamev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>senc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>denc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ecflags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>convpath</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>econv_data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"already initialized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>convpath</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_init_by_convpath</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>convpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>senc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>denc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ecflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ecopts</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>econv_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>snamev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnamev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>senc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>denc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ecflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_open_opts</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_econv_open_exc</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>snamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>dnamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>senc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>senc</name> <operator>=</operator> <call><name>make_dummy_encoding</name><argument_list>(<argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>denc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>denc</name> <operator>=</operator> <call><name>make_dummy_encoding</name><argument_list>(<argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>snamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>dnamev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding</name></name> <operator>=</operator> <name>senc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding</name></name> <operator>=</operator> <name>denc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cname</name> <init>= <expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>rb_econv_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>econv_data_type</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%s: uninitialized&gt;"</literal></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding_name</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dname</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding_name</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%s: "</literal></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>econv_description</name><argument_list>(<argument><expr><name>sname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_econv_t</name> <modifier>*</modifier></type>

<name>check_econv</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>rb_econv_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>econv_data_type</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized encoding converter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ec</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_source_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ec</name><operator>-&gt;</operator><name>source_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_destination_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_convpath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ec</name><operator>-&gt;</operator><name>num_trans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_transcoder</name> <modifier>*</modifier></type><name>tr</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DECORATOR_P</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>src_encoding</name></name></expr></argument>, <argument><expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>make_encobj</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>src_encoding</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>make_encobj</name><argument_list>(<argument><expr><name><name>tr</name><operator>-&gt;</operator><name>dst_encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec1</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_typeddata_is_kind_of</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>econv_data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ec2</name> <operator>=</operator> <call><name>DATA_PTR</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec1</name><operator>-&gt;</operator><name>source_encoding_name</name></name> <operator>!=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>source_encoding_name</name></name> <operator>&amp;&amp;</operator>

<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>source_encoding_name</name></name></expr></argument>, <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>source_encoding_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec1</name><operator>-&gt;</operator><name>destination_encoding_name</name></name> <operator>!=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>destination_encoding_name</name></name> <operator>&amp;&amp;</operator>

<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>destination_encoding_name</name></name></expr></argument>, <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>destination_encoding_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec1</name><operator>-&gt;</operator><name>flags</name></name> <operator>!=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>flags</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec1</name><operator>-&gt;</operator><name>replacement_enc</name></name> <operator>!=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>replacement_enc</name></name> <operator>&amp;&amp;</operator>

<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>replacement_enc</name></name></expr></argument>, <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>replacement_enc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec1</name><operator>-&gt;</operator><name>replacement_len</name></name> <operator>!=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>replacement_len</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec1</name><operator>-&gt;</operator><name>replacement_str</name></name> <operator>!=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>replacement_str</name></name> <operator>&amp;&amp;</operator>

<call><name>memcmp</name><argument_list>(<argument><expr><name><name>ec1</name><operator>-&gt;</operator><name>replacement_str</name></name></expr></argument>, <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>replacement_str</name></name></expr></argument>, <argument><expr><name><name>ec2</name><operator>-&gt;</operator><name>replacement_len</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec1</name><operator>-&gt;</operator><name>num_trans</name></name> <operator>!=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>num_trans</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ec1</name><operator>-&gt;</operator><name>num_trans</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ec1</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name> <operator>!=</operator> <name><name>ec2</name><operator>-&gt;</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>tc</name><operator>-&gt;</operator><name>transcoder</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_result_to_symbol</name><parameter_list>(<parameter><decl><type><name>rb_econv_result_t</name></type> <name>res</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>econv_invalid_byte_sequence</name></expr>:</case> <return>return <expr><name>sym_invalid_byte_sequence</name></expr>;</return>

<case>case <expr><name>econv_incomplete_input</name></expr>:</case> <return>return <expr><name>sym_incomplete_input</name></expr>;</return>

<case>case <expr><name>econv_undefined_conversion</name></expr>:</case> <return>return <expr><name>sym_undefined_conversion</name></expr>;</return>

<case>case <expr><name>econv_destination_buffer_full</name></expr>:</case> <return>return <expr><name>sym_destination_buffer_full</name></expr>;</return>

<case>case <expr><name>econv_source_buffer_empty</name></expr>:</case> <return>return <expr><name>sym_source_buffer_empty</name></expr>;</return>

<case>case <expr><name>econv_finished</name></expr>:</case> <return>return <expr><name>sym_finished</name></expr>;</return>

<case>case <expr><name>econv_after_output</name></expr>:</case> <return>return <expr><name>sym_after_output</name></expr>;</return>

<default>default:</default> <return>return <expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return> 

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_primitive_convert</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>input</name></decl>, <decl><type ref="prev"/><name>output</name></decl>, <decl><type ref="prev"/><name>output_byteoffset_v</name></decl>, <decl><type ref="prev"/><name>output_bytesize_v</name></decl>, <decl><type ref="prev"/><name>opt</name></decl>, <decl><type ref="prev"/><name>flags_v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ip</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>is</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>op</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>os</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>output_byteoffset</name></decl>, <decl><type ref="prev"/><name>output_bytesize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>output_byteend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"23:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output_byteoffset_v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output_bytesize_v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags_v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>output_byteoffset_v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>output_byteoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if> 

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>output_byteoffset</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>output_byteoffset_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>output_bytesize_v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>output_bytesize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if> 

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>output_bytesize</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>output_bytesize_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>flags_v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_error_arity</name><argument_list>(<argument><expr><name>argc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><call><name>rb_to_int</name><argument_list>(<argument><expr><name>flags_v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_partial_input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ECONV_PARTIAL_INPUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>sym_after_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ECONV_AFTER_OUTPUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_modify</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>output_bytesize_v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>output_bytesize</name> <operator>=</operator> <name>RSTRING_EMBED_LEN_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>output_bytesize</name> <operator>&lt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>output_bytesize</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>retry</name>:</label>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>output_byteoffset_v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>output_byteoffset</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>output_byteoffset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative output_byteoffset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>output_byteoffset</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"output_byteoffset too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>output_bytesize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative output_bytesize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>output_byteend</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>output_byteoffset</name> <operator>+</operator>

<operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>output_bytesize</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>output_byteend</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>output_byteoffset</name> <operator>||</operator>

<name>LONG_MAX</name> <operator>&lt;</operator> <name>output_byteend</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"output_byteoffset+output_bytesize too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_str_capacity</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>output_byteend</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>output_byteend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <name>is</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>is</name> <operator>=</operator> <name>ip</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>output_byteoffset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>os</name> <operator>=</operator> <name>op</name> <operator>+</operator> <name>output_bytesize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>rb_econv_convert</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><name>is</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>op</name></expr></argument>, <argument><expr><name>os</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>op</name><operator>-</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_drop_bytes</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>ip</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>output_bytesize_v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>res</name> <operator>==</operator> <name>econv_destination_buffer_full</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>LONG_MAX</name> <operator>/</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>output_bytesize</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too long conversion result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>output_bytesize</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>output_byteoffset_v</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<goto>goto <name>retry</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>destination_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>econv_result_to_symbol</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_convert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>source_string</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>av</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ac</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>source_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>source_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2NUM</name><argument_list>(<argument><expr><name>ECONV_PARTIAL_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ac</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>econv_primitive_convert</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>sym_invalid_byte_sequence</name> <operator>||</operator>

<name>ret</name> <operator>==</operator> <name>sym_undefined_conversion</name> <operator>||</operator>

<name>ret</name> <operator>==</operator> <name>sym_incomplete_input</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>make_econv_exception</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>sym_finished</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"converter already finished"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>sym_source_buffer_empty</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unexpected result of econv_primitive_convert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>dst</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_finish</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>av</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ac</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ac</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>econv_primitive_convert</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>sym_invalid_byte_sequence</name> <operator>||</operator>

<name>ret</name> <operator>==</operator> <name>sym_undefined_conversion</name> <operator>||</operator>

<name>ret</name> <operator>==</operator> <name>sym_incomplete_input</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>make_econv_exception</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>sym_finished</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unexpected result of econv_primitive_convert"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>dst</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_primitive_errinfo</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>econv_result_to_symbol</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>result</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>destination_encoding</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>destination_encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>rb_str_new</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>rb_str_new</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_start</name></name> <operator>+</operator> <name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>error_bytes_len</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>last_error</name><operator>.</operator><name>readagain_len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_insert_output</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>string</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>insert_enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>insert_enc</name> <operator>=</operator> <call><name>rb_econv_encoding_to_insert_output</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>rb_str_encode</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><call><name>rb_enc_find</name><argument_list>(<argument><expr><name>insert_enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_insert_output</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>insert_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too big string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_putback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>putbackable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name>max</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_econv_putbackable</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>putbackable</name> <operator>=</operator> <call><name>rb_econv_putbackable</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>putbackable</name> <operator>&lt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>putbackable</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_econv_putback</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>source_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_last_error</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>make_econv_exception</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_get_replacement</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>make_replacement</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eUndefinedConversionError</name></expr></argument>, <argument><expr><literal type="string">"replacement character setup failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_find</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>replacement_enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>replacement_str</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>replacement_len</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>econv_set_replacement</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>check_econv</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>string</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_econv_set_replacement</name><argument_list>(<argument><expr><name>ec</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eUndefinedConversionError</name></expr></argument>, <argument><expr><literal type="string">"replacement character setup failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_econv_make_exception</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>make_econv_exception</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_econv_check_error</name><parameter_list>(<parameter><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>make_econv_exception</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ecerr_source_encoding_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"source_encoding_name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ecerr_source_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"source_encoding"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ecerr_destination_encoding_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"destination_encoding_name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ecerr_destination_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"destination_encoding"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ecerr_error_char</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"error_char"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ecerr_error_bytes</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"error_bytes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ecerr_readagain_bytes</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"readagain_bytes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ecerr_incomplete_input</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"incomplete_input"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>

<function><type><name>void</name></type>

<name>Init_transcode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>transcoder_table</name> <operator>=</operator> <call><name>st_init_strcasetable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_invalid</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"invalid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_undef</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"undef"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_replace</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"replace"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_fallback</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"fallback"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_xml</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"xml"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_text</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"text"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_attr</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"attr"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_invalid_byte_sequence</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"invalid_byte_sequence"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_undefined_conversion</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"undefined_conversion"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_destination_buffer_full</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"destination_buffer_full"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_source_buffer_empty</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"source_buffer_empty"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_finished</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"finished"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_after_output</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"after_output"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_incomplete_input</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"incomplete_input"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_universal_newline</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"universal_newline"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_crlf_newline</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"crlf_newline"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_cr_newline</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"cr_newline"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_partial_input</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"partial_input"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_ECONV_NEWLINE_OPTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>sym_newline</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"newline"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_universal</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"universal"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_crlf</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"crlf"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_cr</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"cr"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_lf</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"lf"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>InitVM</name><argument_list>(<argument><expr><name>transcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>InitVM_transcode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>rb_eUndefinedConversionError</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"UndefinedConversionError"</literal></expr></argument>, <argument><expr><name>rb_eEncodingError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eInvalidByteSequenceError</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"InvalidByteSequenceError"</literal></expr></argument>, <argument><expr><name>rb_eEncodingError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eConverterNotFoundError</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"ConverterNotFoundError"</literal></expr></argument>, <argument><expr><name>rb_eEncodingError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"encode"</literal></expr></argument>, <argument><expr><name>str_encode</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"encode!"</literal></expr></argument>, <argument><expr><name>str_encode_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cEncodingConverter</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"Converter"</literal></expr></argument>, <argument><expr><name>rb_cData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><name>econv_s_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"asciicompat_encoding"</literal></expr></argument>, <argument><expr><name>econv_s_asciicompat_encoding</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"search_convpath"</literal></expr></argument>, <argument><expr><name>econv_s_search_convpath</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>econv_init</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>econv_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"convpath"</literal></expr></argument>, <argument><expr><name>econv_convpath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"source_encoding"</literal></expr></argument>, <argument><expr><name>econv_source_encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"destination_encoding"</literal></expr></argument>, <argument><expr><name>econv_destination_encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"primitive_convert"</literal></expr></argument>, <argument><expr><name>econv_primitive_convert</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"convert"</literal></expr></argument>, <argument><expr><name>econv_convert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"finish"</literal></expr></argument>, <argument><expr><name>econv_finish</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"primitive_errinfo"</literal></expr></argument>, <argument><expr><name>econv_primitive_errinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"insert_output"</literal></expr></argument>, <argument><expr><name>econv_insert_output</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"putback"</literal></expr></argument>, <argument><expr><name>econv_putback</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"last_error"</literal></expr></argument>, <argument><expr><name>econv_last_error</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"replacement"</literal></expr></argument>, <argument><expr><name>econv_get_replacement</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"replacement="</literal></expr></argument>, <argument><expr><name>econv_set_replacement</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>econv_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"INVALID_MASK"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_INVALID_MASK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"INVALID_REPLACE"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_INVALID_REPLACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"UNDEF_MASK"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_UNDEF_MASK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"UNDEF_REPLACE"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_UNDEF_REPLACE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"UNDEF_HEX_CHARREF"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_UNDEF_HEX_CHARREF</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"PARTIAL_INPUT"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_PARTIAL_INPUT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"AFTER_OUTPUT"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_AFTER_OUTPUT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"UNIVERSAL_NEWLINE_DECORATOR"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_UNIVERSAL_NEWLINE_DECORATOR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"CRLF_NEWLINE_DECORATOR"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_CRLF_NEWLINE_DECORATOR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"CR_NEWLINE_DECORATOR"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_CR_NEWLINE_DECORATOR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"XML_TEXT_DECORATOR"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_XML_TEXT_DECORATOR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"XML_ATTR_CONTENT_DECORATOR"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_XML_ATTR_CONTENT_DECORATOR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>, <argument><expr><literal type="string">"XML_ATTR_QUOTE_DECORATOR"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ECONV_XML_ATTR_QUOTE_DECORATOR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eUndefinedConversionError</name></expr></argument>, <argument><expr><literal type="string">"source_encoding_name"</literal></expr></argument>, <argument><expr><name>ecerr_source_encoding_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eUndefinedConversionError</name></expr></argument>, <argument><expr><literal type="string">"destination_encoding_name"</literal></expr></argument>, <argument><expr><name>ecerr_destination_encoding_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eUndefinedConversionError</name></expr></argument>, <argument><expr><literal type="string">"source_encoding"</literal></expr></argument>, <argument><expr><name>ecerr_source_encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eUndefinedConversionError</name></expr></argument>, <argument><expr><literal type="string">"destination_encoding"</literal></expr></argument>, <argument><expr><name>ecerr_destination_encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eUndefinedConversionError</name></expr></argument>, <argument><expr><literal type="string">"error_char"</literal></expr></argument>, <argument><expr><name>ecerr_error_char</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eInvalidByteSequenceError</name></expr></argument>, <argument><expr><literal type="string">"source_encoding_name"</literal></expr></argument>, <argument><expr><name>ecerr_source_encoding_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eInvalidByteSequenceError</name></expr></argument>, <argument><expr><literal type="string">"destination_encoding_name"</literal></expr></argument>, <argument><expr><name>ecerr_destination_encoding_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eInvalidByteSequenceError</name></expr></argument>, <argument><expr><literal type="string">"source_encoding"</literal></expr></argument>, <argument><expr><name>ecerr_source_encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eInvalidByteSequenceError</name></expr></argument>, <argument><expr><literal type="string">"destination_encoding"</literal></expr></argument>, <argument><expr><name>ecerr_destination_encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eInvalidByteSequenceError</name></expr></argument>, <argument><expr><literal type="string">"error_bytes"</literal></expr></argument>, <argument><expr><name>ecerr_error_bytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eInvalidByteSequenceError</name></expr></argument>, <argument><expr><literal type="string">"readagain_bytes"</literal></expr></argument>, <argument><expr><name>ecerr_readagain_bytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eInvalidByteSequenceError</name></expr></argument>, <argument><expr><literal type="string">"incomplete_input?"</literal></expr></argument>, <argument><expr><name>ecerr_incomplete_input</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Init_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
