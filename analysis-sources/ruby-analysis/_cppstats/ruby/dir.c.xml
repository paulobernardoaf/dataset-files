<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\dir.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_CLOEXEC</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_OPENDIR_AT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FDOPENDIR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRFD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENAT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTATAT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_OPENDIR_AT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_OPENDIR_AT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OPENDIR_AT</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_DIRENT_NAMLEN</name></cpp:undef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_DIRENT_H</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>_WIN32</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMLEN</name><parameter_list>(<parameter><type><name>dirent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strlen((dirent)-&gt;d_name)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_DIRECT_H</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>_WIN32</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMLEN</name><parameter_list>(<parameter><type><name>dirent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strlen((dirent)-&gt;d_name)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dirent</name></cpp:macro> <cpp:value>direct</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMLEN</name><parameter_list>(<parameter><type><name>dirent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(dirent)-&gt;d_namlen</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_DIRENT_NAMLEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYS_NDIR_H</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ndir.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_SYS_DIR_H</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/dir.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_NDIR_H</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ndir.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32/dir.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>getenv</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRING_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>strchr</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>char</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_ATTR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/attr.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NAME_ON_FS_REAL_BASENAME</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NAME_ON_FS_BY_FNMATCH</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETATTRLIST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NAME_ON_FS</name></cpp:macro> <cpp:value>USE_NAME_ON_FS_REAL_BASENAME</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUP32</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size)+3/4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEUP32</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RUP32(sizeof(type))</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NAME_ON_FS</name></cpp:macro> <cpp:value>USE_NAME_ON_FS_REAL_BASENAME</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>DOSISH</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NAME_ON_FS</name></cpp:macro> <cpp:value>USE_NAME_ON_FS_BY_FNMATCH</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NAME_ON_FS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORMALIZE_UTF8PATH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mount.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/vnode.h&gt;</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORMALIZE_UTF8PATH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"encindex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/dir.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/file.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/vm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/ruby.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>AT_FDCWD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_FDCWD</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vm_initialized</name></cpp:macro> <cpp:value>rb_cThread</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>chdir</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chdir</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_uchdir(p)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>mkdir</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mkdir</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_umkdir((p), (m))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rmdir</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rmdir</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_urmdir(p)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>opendir</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>opendir</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_uopendir(p)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ruby_getcwd</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>rb_w32_ugetcwd(NULL, 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_WIN32</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_WIN32</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NORMALIZE_UTF8PATH</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_FGETATTRLIST</name> <operator>||</operator> <operator>!</operator><name>defined</name> <name>HAVE_GETATTRLIST</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>need_normalization</name><parameter_list>(<parameter><type><name>dirp</name></type></parameter>, <parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>need_normalization(dirp)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>need_normalization</name><parameter_list>(<parameter><type><name>dirp</name></type></parameter>, <parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>need_normalization(path)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>need_normalization</name><parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dirp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_FGETATTRLIST</name> <operator>||</operator> <name>defined</name> <name>HAVE_GETATTRLIST</name></expr></cpp:if>

<decl_stmt><decl><type><name>u_int32_t</name></type> <name><name>attrbuf</name><index>[<expr><call><name>SIZEUP32</name><argument_list>(<argument><expr><name>fsobj_tag_t</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>attrlist</name></name></type> <name>al</name> <init>= <expr><block>{<expr><name>ATTR_BIT_MAP_COUNT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>ATTR_CMN_OBJTAG</name></expr>,}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_FGETATTRLIST</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>fgetattrlist</name><argument_list>(<argument><expr><call><name>dirfd</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>al</name></expr></argument>, <argument><expr><name>attrbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>getattrlist</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>al</name></expr></argument>, <argument><expr><name>attrbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>fsobj_tag_t</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>attrbuf</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>tag</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VT_HFS</name></expr>:</case>

<case>case <expr><name>VT_CIFS</name></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>has_nonascii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISASCII</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_NORMALIZE_UTF8PATH</name><parameter_list>(<parameter><type><name>something</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>something</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_NORMALIZE_UTF8PATH</name><parameter_list>(<parameter><type><name>something</name></type></parameter>)</parameter_list></cpp:macro></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IFTODT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IFTODT</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) / ((~S_IFMT &amp; (S_IFMT-1)) + 1))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DT_UNKNOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl><name>path_exist</name> <init>= <expr><name>DT_UNKNOWN</name></expr></init></decl>,

<decl><name>path_directory</name> <init>= <expr><name>DT_DIR</name></expr></init></decl>,

<decl><name>path_regular</name> <init>= <expr><name>DT_REG</name></expr></init></decl>,

<decl><name>path_symlink</name> <init>= <expr><name>DT_LNK</name></expr></init></decl>,

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl><name>path_exist</name></decl>,

<decl><name>path_directory</name> <init>= <expr><call><name>IFTODT</name><argument_list>(<argument><expr><name>S_IFDIR</name></expr></argument>)</argument_list></call></expr></init></decl>,

<decl><name>path_regular</name> <init>= <expr><call><name>IFTODT</name><argument_list>(<argument><expr><name>S_IFREG</name></expr></argument>)</argument_list></call></expr></init></decl>,

<decl><name>path_symlink</name> <init>= <expr><call><name>IFTODT</name><argument_list>(<argument><expr><name>S_IFLNK</name></expr></argument>)</argument_list></call></expr></init></decl>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl><name>path_noent</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,

<decl><name>path_unknown</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>

}</block></enum></type> <name>rb_pathtype_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_NOESCAPE</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_PATHNAME</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_DOTMATCH</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_CASEFOLD</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_EXTGLOB</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CASEFOLD_FILESYSTEM</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_SYSCASE</name></cpp:macro> <cpp:value>FNM_CASEFOLD</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_SYSCASE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_WIN32</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_SHORTNAME</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_SHORTNAME</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_GLOB_NOSORT</name></cpp:macro> <cpp:value>0x40</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_NOMATCH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNM_ERROR</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Next</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>e</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)+ rb_enc_mbclen((p), (e), (enc)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Inc</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>e</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p) = Next((p), (e), (enc)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>bracket</name><parameter_list>(

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, 

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pend</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, 

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>send</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nocase</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>FNM_CASEFOLD</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>escape</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_NOESCAPE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ok</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>not</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>pend</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>not</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t1</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>escape</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>t1</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>t1</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>t1</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>t1</name> <operator>+</operator> <operator>(</operator><name>r</name> <operator>=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>pend</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t2</name> <init>= <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>escape</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>t2</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>t2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>t2</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>t2</name> <operator>+</operator> <operator>(</operator><name>r2</name> <operator>=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>&lt;=</operator> <operator>(</operator><name>send</name><operator>-</operator><name>s</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>r2</name> <operator>&lt;=</operator> <operator>(</operator><name>send</name><operator>-</operator><name>s</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nocase</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>rb_enc_toupper</name><argument_list>(<argument><expr><name>c1</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nocase</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>rb_enc_toupper</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>&lt;</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nocase</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>rb_enc_toupper</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>&gt;</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <operator>(</operator><name>send</name><operator>-</operator><name>s</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nocase</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>rb_enc_toupper</name><argument_list>(<argument><expr><call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>rb_enc_toupper</name><argument_list>(<argument><expr><call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><ternary><condition><expr><name>ok</name> <operator>==</operator> <name>not</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNESCAPE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(escape &amp;&amp; *(p) == '\\' ? (p) + 1 : (p))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISEND</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!*(p) || (pathname &amp;&amp; *(p) == '/'))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN</name><parameter_list>(<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>return *pcur = p, *scur = s, (val);</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fnmatch_helper</name><parameter_list>(

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pcur</name></decl></parameter>, 

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>scur</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>period</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_DOTMATCH</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pathname</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>FNM_PATHNAME</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>escape</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_NOESCAPE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>nocase</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>FNM_CASEFOLD</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pcur</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pend</name> <init>= <expr><name>p</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>*</operator><name>scur</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>send</name> <init>= <expr><name>s</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>period</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><call><name>UNESCAPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>FNM_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<do>do <block>{<block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><call><name>ISEND</name><argument_list>(<argument><expr><call><name>UNESCAPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>UNESCAPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEND</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>FNM_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptmp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>stmp</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>ISEND</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>FNM_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEND</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>FNM_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <call><name>bracket</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<goto>goto <name>failed</name>;</goto>

</block_content>}</block>

</block_content>}</block></switch>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>UNESCAPE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEND</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>ISEND</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>FNM_NOMATCH</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEND</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <operator>(</operator><name>send</name><operator>-</operator><name>s</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nocase</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_toupper</name><argument_list>(<argument><expr><call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator>

<call><name>rb_enc_toupper</name><argument_list>(<argument><expr><call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<label><name>failed</name>:</label> 

<if_stmt><if>if <condition>(<expr><name>ptmp</name> <operator>&amp;&amp;</operator> <name>stmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>ptmp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>stmp</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>stmp</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>FNM_NOMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fnmatch</name><parameter_list>(

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pattern</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>send</name> <init>= <expr><name>s</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>period</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_DOTMATCH</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pathname</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>FNM_PATHNAME</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pathname</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>;</do>

<expr_stmt><expr><name>ptmp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>stmp</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fnmatch_helper</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptmp</name> <operator>&amp;&amp;</operator> <name>stmp</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>period</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>stmp</name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>stmp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>stmp</name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>stmp</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>stmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>ptmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>stmp</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>stmp</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FNM_NOMATCH</name></expr>;</return>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>fnmatch_helper</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cDir</name></decl>;</decl_stmt>

<struct>struct <name>dir_data</name> <block>{

<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dir_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dir_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>dir</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>dir_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>dir_data</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>dir_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"dir"</literal></expr>,

<expr><block>{<expr><name>dir_mark</name></expr>, <expr><name>dir_free</name></expr>, <expr><name>dir_memsize</name></expr>,}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_WB_PROTECTED</name> <operator>|</operator> <name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>dir_close</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>struct <name>dir_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir_data_type</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dirp</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_opendir</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>opendir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DIR</name> <modifier>*</modifier></type>

<name>opendir_without_gvl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>vm_initialized</name></expr>)</condition> <block>{<block_content>

<union>union <block>{ <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt> }</block> <decl><name>u</name></decl>;</union>

<expr_stmt><expr><name><name>u</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<return>return <expr><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_opendir</name></expr></argument>, <argument><expr><name><name>u</name><operator>.</operator><name>out</name></name></expr></argument>, <argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>opendir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fsenc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dirname</name></decl>, <decl><type ref="prev"/><name>opt</name></decl>, <decl><type ref="prev"/><name>orig</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name><name>keyword_ids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>keyword_ids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>keyword_ids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_id_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fsenc</name> <operator>=</operator> <call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"1:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>keyword_ids</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fsenc</name> <operator>=</operator> <call><name>rb_to_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>orig</name> <operator>=</operator> <call><name>rb_str_dup_frozen</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>rb_str_dup_frozen</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr>struct <name>dir_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir_data_type</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>dir</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name><name>dp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>fsenc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <call><name>opendir_without_gvl</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>dir</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_gc_for_fd</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <call><name>opendir_without_gvl</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETATTRLIST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>e</name> <operator>==</operator> <name>EIO</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>u_int32_t</name></type> <name><name>attrbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>attrlist</name></name></type> <name>al</name> <init>= <expr><block>{<expr><name>ATTR_BIT_MAP_COUNT</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getattrlist</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>al</name></expr></argument>, <argument><expr><name>attrbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FSOPT_NOFOLLOW</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>dp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <call><name>opendir_without_gvl</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>dir</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dp</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dir</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_open</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dir</name> <init>= <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>struct <name>dir_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir_data_type</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dir_initialize</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>rb_yield</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir_close</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>dir</name></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void dir_closed(void)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dir_closed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><literal type="string">"closed directory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type>

<name>dir_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir_data_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type>

<name>dir_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name> <init>= <expr><call><name>dir_get</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dir_closed</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>dirp</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetDIR</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>dirp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((dirp) = dir_check(obj))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr>struct <name>dir_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir_data_type</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><literal type="string">"#&lt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_class_name</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>idTo_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRFD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIR_D_FD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dirfd</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)-&gt;d_fd)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_DIRFD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIR_DD_FD</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dirfd</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)-&gt;dd_fd)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_DIRFD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRFD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_fileno</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetDIR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>dirfd</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="string">"dirfd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dir_fileno</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr>struct <name>dir_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir_data_type</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fundamental_encoding_p</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ENCINDEX_ASCII</name></expr>:</case>

<case>case <expr><name>ENCINDEX_US_ASCII</name></expr>:</case>

<case>case <expr><name>ENCINDEX_UTF_8</name></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READDIR</name><parameter_list>(<parameter><type><name>dir</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_readdir((dir), (enc))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READDIR</name><parameter_list>(<parameter><type><name>dir</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>readdir((dir))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>to_be_skipped</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRENT_NAMLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<switch>switch <condition>(<expr><call><name>NAMLEN</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_read</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetDIR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dp</name> <operator>=</operator> <call><name>READDIR</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><call><name>NAMLEN</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_syserr_fail</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return> 

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>dir_each_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_yield</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>dir_each_entry</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir_yield</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_each_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>each</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>children_only</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<macro><name>IF_NORMALIZE_UTF8PATH</name><argument_list>(<argument>int norm_p</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>GetDIR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rewinddir</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>IF_NORMALIZE_UTF8PATH</name><argument_list>(<argument><expr><name>norm_p</name> <operator>=</operator> <call><name>need_normalization</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>dp</name> <operator>=</operator> <call><name>READDIR</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>namlen</name> <init>= <expr><call><name>NAMLEN</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>children_only</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>namlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>namlen</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NORMALIZE_UTF8PATH</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>norm_p</name> <operator>&amp;&amp;</operator> <call><name>has_nonascii</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namlen</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>path</name> <operator>=</operator> <call><name>rb_str_normalize_ospath</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_external_str_with_enc</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namlen</name></expr></argument>, <argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>each</name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>dir</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TELLDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_tell</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetDIR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>telldir</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_int2inum</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dir_tell</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SEEKDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_seek</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>p</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetDIR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>seekdir</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dir</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dir_seek</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SEEKDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_set_pos</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>dir_seek</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>pos</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dir_set_pos</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_rewind</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetDIR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rewinddir</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dir</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_close</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dirp</name> <operator>=</operator> <call><name>dir_get</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_chdir</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>chdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dir_chdir</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>chdir_blocking</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>chdir_thread</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<struct>struct <name>chdir_data</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>old_path</name></decl>, <decl><type ref="prev"/><name>new_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>chdir_yield</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>chdir_data</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dir_chdir</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>new_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>done</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>chdir_blocking</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>chdir_thread</name> <operator>==</operator> <name>Qnil</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>chdir_thread</name> <operator>=</operator> <call><name>rb_thread_current</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>new_path</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>chdir_restore</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>chdir_data</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>chdir_blocking</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>chdir_blocking</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>chdir_thread</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>dir_chdir</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>old_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_chdir</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><call><name>rb_get_path</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dist</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOME"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dist</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"LOGDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dist</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"HOME/LOGDIR not set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><name>dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>chdir_blocking</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>rb_thread_current</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>chdir_thread</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"conflicting chdir during another chdir block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>chdir_data</name></name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>old_path</name></name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><call><name>rb_dir_getwd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>new_path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>done</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<return>return <expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>chdir_yield</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>chdir_restore</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_chdir</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>VALUE</name></type>

<name>rb_dir_getwd_ospath</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>cwd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path_guard</name></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RUBY_UNTYPED_DATA_WARNING</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_UNTYPED_DATA_WARNING</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<expr_stmt><expr><name>path_guard</name> <operator>=</operator> <call><name>Data_Wrap_Struct</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RUBY_DEFAULT_FREE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>ruby_getcwd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>path_guard</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>cwd</name> <operator>=</operator> <call><name>rb_str_normalize_ospath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>cwd</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>path_guard</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>cwd</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>VALUE</name></type>

<name>rb_dir_getwd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fsenc</name> <init>= <expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>cwd</name> <init>= <expr><call><name>rb_dir_getwd_ospath</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>fsenc</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ENCINDEX_US_ASCII</name></expr>:</case>

<expr_stmt><expr><name>fsenc</name> <operator>=</operator> <name>ENCINDEX_ASCII</name></expr>;</expr_stmt>

<case>case <expr><name>ENCINDEX_ASCII</name></expr>:</case>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>||</operator> <name>defined</name> <name>__APPLE__</name></expr></cpp:if>

<default>default:</default>

<return>return <expr><call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></switch>

<return>return <expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>fsenc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_getwd</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_dir_getwd</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>check_dirname</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>d</name> <init>= <expr><name>dir</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>path</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pend</name> <operator>=</operator> <call><name>rb_enc_path_end</name><argument_list>(<argument><expr><call><name>rb_enc_path_skip_prefix</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pend</name> <operator>-</operator> <name>path</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pend</name> <operator>-</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CHROOT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_chroot</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>check_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>chroot</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dir_s_chroot</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>mkdir_arg</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_mkdir</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>mkdir_arg</name></name> <modifier>*</modifier></type><name>m</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>mkdir</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_mkdir</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>mkdir_arg</name></name></type> <name>m</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>, <decl><type ref="prev"/><name>vmode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vmode</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>m</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <call><name>NUM2MODET</name><argument_list>(<argument><expr><name>vmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>m</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <literal type="number">0777</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>check_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>m</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_mkdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_rmdir</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rmdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_rmdir</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>check_dirname</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_rmdir</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>warning_args</name> <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sys_enc_warning_in</name><parameter_list>(<parameter><type><name>func</name></type></parameter>, <parameter><type><name>mesg</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sys_enc_warning(mesg, enc)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sys_warning_1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>warning_args</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>warning_args</name> <operator>*</operator><operator>)</operator><name>mesg</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_sys_enc_warning</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>mesg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>rb_sys_enc_warning</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>mesg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>sys_enc_warning_in</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>warning_args</name></name></type> <name>arg</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>mesg</name></name> <operator>=</operator> <name>mesg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_protect</name><argument_list>(<argument><expr><name>sys_warning_1</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOB_VERBOSE</name></cpp:macro> <cpp:value>(1U &lt;&lt; (sizeof(int) * CHAR_BIT - 1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sys_warning</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((flags &amp; GLOB_VERBOSE) ? sys_enc_warning_in(RUBY_FUNCTION_NAME_STRING, (val), (enc)) :(void)0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>

<name>glob_alloc_size</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>z</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_mul_size_overflow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>SSIZE_MAX</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>z</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type>

<name>glob_alloc_n</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>malloc</name><argument_list>(<argument><expr><call><name>glob_alloc_size</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type>

<name>glob_realloc_n</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>glob_alloc_size</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOB_ALLOC</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)malloc(sizeof(type)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOB_ALLOC_N</name><parameter_list>(<parameter><type><name>type</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((type *)glob_alloc_n(sizeof(type), n))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOB_REALLOC</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>realloc((ptr), (size))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOB_REALLOC_N</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>glob_realloc_n(ptr, sizeof(*(ptr)), n)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOB_FREE</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>free(ptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOB_JUMP_TAG</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((status) == -1) ? rb_memerror() : rb_jump_tag(status))</cpp:value></cpp:define>

<macro><name>ALWAYS_INLINE</name><argument_list>(<argument>static int to_be_ignored(int e)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>to_be_ignored</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>e</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>ENOTDIR</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_ustati128((p), (s))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>lstat</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lstat</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_ulstati128((p), (s))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>stat((p), (s))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <function_decl><type><name>int</name></type> <name>ruby_glob_errfunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>ruby_glob_func</name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ruby_glob_errfunc</name> <modifier>*</modifier></type><name>error</name></decl>;</decl_stmt>

}</block></struct></type> <name>ruby_glob_funcs_t</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>at_subpath</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>baselen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OPENDIR_AT</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>AT_FDCWD</name> <operator>&amp;&amp;</operator> <name>baselen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>+=</operator> <name>baselen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>path</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><ternary><condition><expr><operator>*</operator><name>path</name></expr> ?</condition><then> <expr><name>path</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>do_stat</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>baselen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>pst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OPENDIR_AT</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>fstatat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>at_subpath</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>STAT</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>to_be_ignored</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sys_warning</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_LSTAT</name> <operator>||</operator> <name>defined</name> <name>lstat</name> <operator>||</operator> <name>USE_OPENDIR_AT</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>do_lstat</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>baselen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>pst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OPENDIR_AT</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>fstatat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>at_subpath</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pst</name></expr></argument>, <argument><expr><name>AT_SYMLINK_NOFOLLOW</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>lstat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>to_be_ignored</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sys_warning</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>do_lstat</name></cpp:macro> <cpp:value>do_stat</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>opendir_at_arg</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>basefd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>with_gvl_gc_for_fd</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><ternary><condition><expr><call><name>rb_gc_for_fd</name><argument_list>(<argument><expr><operator>*</operator><name>e</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>gc_for_fd_with_gvl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>vm_initialized</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_with_gvl</name><argument_list>(<argument><expr><name>with_gvl_gc_for_fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><call><name>rb_gc_for_fd</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_opendir_at</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>opendir_at_arg</name></name> <modifier>*</modifier></type><name>oaa</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OPENDIR_AT</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opendir_flags</name> <init>= <expr><operator>(</operator><name>O_RDONLY</name><operator>|</operator><name>O_CLOEXEC</name><operator>|</operator>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_DIRECTORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>O_DIRECTORY</name><operator>|</operator>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>openat</name><argument_list>(<argument><expr><name><name>oaa</name><operator>-&gt;</operator><name>basefd</name></name></expr></argument>, <argument><expr><name><name>oaa</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>opendir_flags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dirp</name> <operator>=</operator> <ternary><condition><expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>fdopendir</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dirp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>gc_for_fd_with_gvl</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>openat</name><argument_list>(<argument><expr><name><name>oaa</name><operator>-&gt;</operator><name>basefd</name></name></expr></argument>, <argument><expr><name><name>oaa</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>opendir_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dirp</name> <operator>=</operator> <call><name>fdopendir</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dirp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>dirp</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<expr_stmt><expr><name>dirp</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name><name>oaa</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dirp</name> <operator>&amp;&amp;</operator> <call><name>gc_for_fd_with_gvl</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dirp</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name><name>oaa</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<return>return <expr><name>dirp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DIR</name> <modifier>*</modifier></type>

<name>opendir_at</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>basefd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>opendir_at_arg</name></name></type> <name>oaa</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>oaa</name><operator>.</operator><name>basefd</name></name> <operator>=</operator> <name>basefd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>oaa</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vm_initialized</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_opendir_at</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oaa</name></expr></argument>, <argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>nogvl_opendir_at</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oaa</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DIR</name> <modifier>*</modifier></type>

<name>do_opendir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>basefd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>baselen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,

<parameter><decl><type><name>ruby_glob_errfunc</name> <modifier>*</modifier></type><name>errfunc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fundamental_encoding_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>dirp</name> <operator>=</operator> <call><name>opendir_at</name><argument_list>(<argument><expr><name>basefd</name></expr></argument>, <argument><expr><call><name>at_subpath</name><argument_list>(<argument><expr><name>basefd</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dirp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>to_be_ignored</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errfunc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name>errfunc</name>)<argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>sys_warning</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>dirp</name></expr>;</return>

</block_content>}</block></function>

<enum>enum <name>glob_pattern_type</name> <block>{ <decl><name>PLAIN</name></decl>, <decl><name>ALPHA</name></decl>, <decl><name>BRACE</name></decl>, <decl><name>MAGICAL</name></decl>, <decl><name>RECURSIVE</name></decl>, <decl><name>MATCH_ALL</name></decl>, <decl><name>MATCH_DIR</name></decl> }</block>;</enum>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>glob_pattern_type</name></name></type>

<name>has_magic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pend</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>escape</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_NOESCAPE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hasalpha</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hasmagical</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'{'</literal></expr>:</case>

<return>return <expr><name>BRACE</name></expr>;</return>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<case>case <expr><literal type="char">'['</literal></expr>:</case>

<expr_stmt><expr><name>hasmagical</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>escape</name> <operator>&amp;&amp;</operator> <name>p</name><operator>++</operator> <operator>&gt;=</operator> <name>pend</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="char">'.'</literal></expr>:</case>

<break>break;</break>

<case>case <expr><literal type="char">'~'</literal></expr>:</case>

<expr_stmt><expr><name>hasalpha</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><name>IS_WIN32</name> <operator>||</operator> <call><name>ISALPHA</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hasalpha</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>Next</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><ternary><condition><expr><name>hasmagical</name></expr> ?</condition><then> <expr><name>MAGICAL</name></expr> </then><else>: <expr><ternary><condition><expr><name>hasalpha</name></expr> ?</condition><then> <expr><name>ALPHA</name></expr> </then><else>: <expr><name>PLAIN</name></expr></else></ternary></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>find_dirsep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pend</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>escape</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_NOESCAPE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>open</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'['</literal></expr>:</case>

<expr_stmt><expr><name>open</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">']'</literal></expr>:</case>

<expr_stmt><expr><name>open</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'{'</literal></expr>:</case>

<expr_stmt><expr><name>open</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'}'</literal></expr>:</case>

<expr_stmt><expr><name>open</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'/'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>open</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>escape</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></switch>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>Next</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>remove_backslashes</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pend</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <name>p</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>++</operator><name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>glob_pattern</name> <block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>glob_pattern_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>glob_free_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type>

<name>glob_make_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>list</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name>list</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dirsep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>recursive</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>GLOB_ALLOC</name><argument_list>(<argument><expr>struct <name>glob_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while> </block_content>}</block> while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>;</do>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>RECURSIVE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>dirsep</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>recursive</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>find_dirsep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>glob_pattern_type</name></name></type> <name>magic</name> <init>= <expr><call><name>has_magic</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>glob_pattern_type</name></name></type> <name>non_magic</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>USE_NAME_ON_FS</name> <operator>||</operator> <name>FNM_SYSCASE</name><operator>)</operator></expr> ?</condition><then> <expr><name>PLAIN</name></expr> </then><else>: <expr><name>ALPHA</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>FNM_SYSCASE</name> <operator>||</operator> <name>magic</name> <operator>&gt;</operator> <name>non_magic</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursive</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>m</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>m2</name></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>has_magic</name><argument_list>(<argument><expr><name>m</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>m2</name> <operator>=</operator> <call><name>find_dirsep</name><argument_list>(<argument><expr><name>m</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>non_magic</name> <operator>&amp;&amp;</operator>

<operator>*</operator><name>m2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>m</name> <operator>=</operator> <name>m2</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>m</name><operator>-</operator><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>m</name><operator>-</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>m</name><operator>-</operator><name>p</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><name>magic</name> <operator>&gt;</operator> <name>MAGICAL</name></expr> ?</condition><then> <expr><name>MAGICAL</name></expr> </then><else>: <expr><ternary><condition><expr><name>magic</name> <operator>&gt;</operator> <name>non_magic</name></expr> ?</condition><then> <expr><name>magic</name></expr> </then><else>: <expr><name>PLAIN</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>m</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dirsep</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>dirsep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><name>tmp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>GLOB_ALLOC</name><argument_list>(<argument><expr>struct <name>glob_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>

<label><name>error</name>:</label>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>glob_free_pattern</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><name>dirsep</name></expr> ?</condition><then> <expr><name>MATCH_DIR</name></expr> </then><else>: <expr><name>MATCH_ALL</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>glob_free_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>list</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>str</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>join_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dirsep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>namlen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><name>namlen</name><operator>+</operator><operator>(</operator><ternary><condition><expr><name>dirsep</name></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dirsep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>+</operator><name>namlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETATTRLIST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_FGETATTRLIST</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_case_sensitive</name><parameter_list>(<parameter><type><name>dirp</name></type></parameter>, <parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>is_case_sensitive(dirp)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_case_sensitive</name><parameter_list>(<parameter><type><name>dirp</name></type></parameter>, <parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>is_case_sensitive(path)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>is_case_sensitive</name><parameter_list>(<parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dirp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<struct>struct <block>{

<decl_stmt><decl><type><name>u_int32_t</name></type> <name>length</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vol_capabilities_attr_t</name></type> <name><name>cap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

}</block> <decl><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><call><name>aligned</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>,</operator> <name>packed</name><operator>)</operator></expr></argument>)</argument_list> <name><name>attrbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>attrlist</name></name></type> <name>al</name> <init>= <expr><block>{<expr><name>ATTR_BIT_MAP_COUNT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>ATTR_VOL_INFO</name><operator>|</operator><name>ATTR_VOL_CAPABILITIES</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>vol_capabilities_attr_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cap</name> <init>= <expr><name><name>attrbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cap</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>idx</name> <init>= <expr><name>VOL_CAPABILITIES_FORMAT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name>mask</name> <init>= <expr><name>VOL_CAP_FMT_CASE_SENSITIVE</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_FGETATTRLIST</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>fgetattrlist</name><argument_list>(<argument><expr><call><name>dirfd</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>al</name></expr></argument>, <argument><expr><name>attrbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FSOPT_NOFOLLOW</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><call><name>getattrlist</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>al</name></expr></argument>, <argument><expr><name>attrbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FSOPT_NOFOLLOW</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cap</name><operator>-&gt;</operator><name>valid</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>cap</name><operator>-&gt;</operator><name>capabilities</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>replace_real_basename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norm_p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_pathtype_t</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<struct>struct <block>{

<decl_stmt><decl><type><name>u_int32_t</name></type> <name>length</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>attrreference_t</name></type> <name><name>ref</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>fsobj_type_t</name></type> <name>objtype</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAXPATHLEN</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

}</block> <decl><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><call><name>aligned</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>,</operator> <name>packed</name><operator>)</operator></expr></argument>)</argument_list> <name><name>attrbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>attrlist</name></name></type> <name>al</name> <init>= <expr><block>{<expr><name>ATTR_BIT_MAP_COUNT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>ATTR_CMN_NAME</name><operator>|</operator><name>ATTR_CMN_OBJTYPE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>attrreference_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ar</name> <init>= <expr><name><name>attrbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ref</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<macro><name>IF_NORMALIZE_UTF8PATH</name><argument_list>(<argument>VALUE utf8str = Qnil</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>path_noent</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getattrlist</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>al</name></expr></argument>, <argument><expr><name>attrbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>FSOPT_NOFOLLOW</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>to_be_ignored</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sys_warning</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>path</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>attrbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>objtype</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VREG</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>path_regular</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VDIR</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>path_directory</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VLNK</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>path_symlink</name></expr>;</expr_stmt> <break>break;</break>

<default>default:</default> <expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>path_exist</name></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ar</name> <operator>+</operator> <name><name>ar</name><operator>-&gt;</operator><name>attr_dataoffset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>ar</name><operator>-&gt;</operator><name>attr_length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>attrbuf</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>attrbuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NORMALIZE_UTF8PATH</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>norm_p</name> <operator>&amp;&amp;</operator> <call><name>has_nonascii</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>utf8str</name> <operator>=</operator> <call><name>rb_str_normalize_ospath</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>utf8str</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>GLOB_REALLOC</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <name>base</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>path</name><index>[<expr><name>base</name> <operator>+</operator> <name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>IF_NORMALIZE_UTF8PATH</name><argument_list>(<argument>if (!NIL_P(utf8str)) rb_str_resize(utf8str, <literal type="number">0</literal>)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<return>return <expr><name>path</name></expr>;</return>

</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:elif>

<function_decl><type><name>VALUE</name></type> <name>rb_w32_conv_from_wchar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WCHAR</name> <modifier>*</modifier></type><name>wstr</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_w32_reparse_symlink_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WCHAR</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>replace_real_basename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>norm_p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_pathtype_t</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>plainname</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>tmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WIN32_FIND_DATAW</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WIN32_FILE_ATTRIBUTE_DATA</name></type> <name>fa</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>wplain</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>wlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>fundamental_encoding_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_enc_str_new_cstr</name><argument_list>(<argument><expr><name>plainname</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>plainname</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>wplain</name> <operator>=</operator> <call><name>rb_w32_mbstr_to_wstr</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><name>plainname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>wlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wplain</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>GetFileAttributesExW</name><argument_list>(<argument><expr><name>wplain</name></expr></argument>, <argument><expr><name>GetFileExInfoStandard</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fa</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>FindFirstFileW</name><argument_list>(<argument><expr><name>wplain</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_w32_map_errno</name><argument_list>(<argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fa</name><operator>.</operator><name>dwFileAttributes</name></name> <operator>&amp;</operator> <name>FILE_ATTRIBUTE_REPARSE_POINT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_w32_reparse_symlink_p</name><argument_list>(<argument><expr><name>wplain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fa</name><operator>.</operator><name>dwFileAttributes</name></name> <operator>&amp;=</operator> <operator>~</operator><name>FILE_ATTRIBUTE_REPARSE_POINT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wplain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>path_noent</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>to_be_ignored</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sys_warning</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>path</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator>

<ternary><condition><expr><operator>(</operator><name><name>fa</name><operator>.</operator><name>dwFileAttributes</name></name> <operator>&amp;</operator> <name>FILE_ATTRIBUTE_REPARSE_POINT</name><operator>)</operator></expr> ?</condition><then> <expr><name>path_symlink</name></expr> </then><else>:

<expr><ternary><condition><expr><operator>(</operator><name><name>fa</name><operator>.</operator><name>dwFileAttributes</name></name> <operator>&amp;</operator> <name>FILE_ATTRIBUTE_DIRECTORY</name><operator>)</operator></expr> ?</condition><then> <expr><name>path_directory</name></expr> </then><else>:

<expr><name>path_regular</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_w32_conv_from_wchar</name><argument_list>(<argument><expr><name><name>fd</name><operator>.</operator><name>cFileName</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wlen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GLOB_REALLOC</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <name>base</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>path</name><index>[<expr><name>base</name> <operator>+</operator> <name>wlen</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>utf8filename</name></decl>;</decl_stmt>

<expr_stmt><expr><name>wlen</name> <operator>=</operator> <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>fd</name><operator>.</operator><name>cFileName</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>utf8filename</name> <operator>=</operator> <call><name>GLOB_REALLOC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>utf8filename</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>fd</name><operator>.</operator><name>cFileName</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>utf8filename</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GLOB_REALLOC</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <name>base</name></expr></argument>, <argument><expr><name>utf8filename</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>path</name><index>[<expr><name>base</name> <operator>+</operator> <name>wlen</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>utf8filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>path</name></expr>;</return>

</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>USE_NAME_ON_FS</name> <operator>==</operator> <name>USE_NAME_ON_FS_REAL_BASENAME</name></expr></cpp:elif>

<cpp:error>#<cpp:directive>error</cpp:directive> not implemented</cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISDIR</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFDIR)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISLNK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_IFLNK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISLNK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISLNK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFLNK)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>glob_args</name> <block>{

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>baselen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>glob_call_func</name><parameter_list>(<parameter><type><name>func</name></type></parameter>, <parameter><type><name>path</name></type></parameter>, <parameter><type><name>arg</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(func))((path), (arg), (void *)(enc))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>glob_func_caller</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_args</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator>struct <name>glob_args</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>glob_call_func</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>glob_error_args</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>glob_func_warning</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_error_args</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>glob_error_args</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_syserr_enc_warning</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static int

rb_glob_warning(const char *path, VALUE a, const void *enc, int error)

{

int status;

struct glob_error_args args;

args.path = path;

args.enc = enc;

args.error = error;

rb_protect(glob_func_warning, (VALUE)&amp;args, &amp;status);

return status;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>glob_func_error</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_error_args</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>glob_error_args</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_enc_str_new_cstr</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_str</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_glob_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_error_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>errfunc</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>glob_func_error</name></expr></init>;</function_decl>

<if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <name>EACCES</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>errfunc</name> <operator>=</operator> <name>glob_func_warning</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>error</name></name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_protect</name><argument_list>(<argument><expr><name>errfunc</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>rb_dirent</name> <block>{

<decl_stmt><decl><type><name>long</name></type> <name>d_namlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>d_name</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>d_altname</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>uint8_t</name></type> <name>d_type</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_dirent_t</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>dirent_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_dirent_t</name> <modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>fnmatch</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>d_altname</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_SHORTNAME</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>fnmatch</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_altname</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>push_glob_args</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>baselen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>namelen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dirsep</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>rb_pathtype_t</name></type> <name>pathtype</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ruby_glob_funcs_t</name> <modifier>*</modifier></type><name>funcs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>dirent_brace_args</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_dirent_t</name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>dirent_match_brace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dirent_brace_args</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>dirent_brace_args</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>dirent_match</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>dp</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>

<name>join_path_from_pattern</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>beg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>path_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>beg</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>RECURSIVE</name></expr>:</case>

<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">"**"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MATCH_DIR</name></expr>:</case>

<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>str</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>path</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>path_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>path_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>path</name><index>[<expr><name>path_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>GLOB_REALLOC</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_len</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>path</name><index>[<expr><name>path_len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <name>path_len</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>path</name><index>[<expr><name>path_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>path</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>push_caller</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ruby_brace_expand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ruby_glob_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>var</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>rb_dirent_name_offset</name> <init>=

<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>rb_dirent_t</name></expr></argument>, <argument><expr><name>d_type</name></expr></argument>)</argument_list></call> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>rb_dirent_t</name> <modifier>*</modifier></type>

<name>dirent_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dp</name></decl></parameter>, <parameter><decl><type><name>rb_dirent_t</name> <modifier>*</modifier></type><name>rdp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>namlen</name> <init>= <expr><call><name>NAMLEN</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>altlen</name> <init>=

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<expr><ternary><condition><expr><name><name>dp</name><operator>-&gt;</operator><name>d_altlen</name></name></expr> ?</condition><then> <expr><name><name>dp</name><operator>-&gt;</operator><name>d_altlen</name></name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_dirent_t</name> <modifier>*</modifier></type><name>newrdp</name> <init>= <expr><name>rdp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rdp</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>newrdp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>rb_dirent_name_offset</name> <operator>+</operator> <name>namlen</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>altlen</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>newrdp</name><operator>-&gt;</operator><name>d_namlen</name></name> <operator>=</operator> <name>namlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rdp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>newrdp</name> <operator>+</operator> <name>rb_dirent_name_offset</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>namlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>name</name><index>[<expr><name>namlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>newrdp</name><operator>-&gt;</operator><name>d_altname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>altlen</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>altname</name> <init>= <expr><name>name</name> <operator>+</operator> <name>namlen</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>altname</name></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_altname</name></name></expr></argument>, <argument><expr><name>altlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>altname</name><index>[<expr><name>altlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>newrdp</name><operator>-&gt;</operator><name>d_altname</name></name> <operator>=</operator> <name>altname</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>newrdp</name><operator>-&gt;</operator><name>d_name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>newrdp</name><operator>-&gt;</operator><name>d_name</name></name> <operator>=</operator> <name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>newrdp</name><operator>-&gt;</operator><name>d_altname</name></name> <operator>=</operator> <name><name>dp</name><operator>-&gt;</operator><name>d_altname</name></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DT_UNKNOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>newrdp</name><operator>-&gt;</operator><name>d_type</name></name> <operator>=</operator> <name><name>dp</name><operator>-&gt;</operator><name>d_type</name></name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>newrdp</name><operator>-&gt;</operator><name>d_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>newrdp</name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><union>union <block>{

<struct>struct <block>{

<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_dirent_t</name></type> <name>ent</name></decl>;</decl_stmt>

}</block> <decl><name>nosort</name></decl>;</struct>

<struct>struct <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>count</name></decl>, <name>idx</name>;</decl_stmt>

<decl_stmt><decl><type><name>rb_dirent_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>

}</block> <decl><name>sort</name></decl>;</struct>

}</block></union></type> <name>ruby_glob_entries_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>glob_sort_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_dirent_t</name> <modifier>*</modifier></type><name>ent1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_dirent_t</name> <modifier>*</modifier></type><name>ent2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ent1</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name><name>ent2</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>glob_dir_finish</name><parameter_list>(<parameter><decl><type><name>ruby_glob_entries_t</name> <modifier>*</modifier></type><name>ent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FNM_GLOB_NOSORT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>nosort</name><operator>.</operator><name>dirp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>nosort</name><operator>.</operator><name>dirp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>count</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>count</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ruby_glob_entries_t</name> <modifier>*</modifier></type>

<name>glob_opendir</name><parameter_list>(<parameter><decl><type><name>ruby_glob_entries_t</name> <modifier>*</modifier></type><name>ent</name></decl></parameter>, <parameter><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dirp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><name>ruby_glob_entries_t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FNM_GLOB_NOSORT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>nosort</name><operator>.</operator><name>dirp</name></name> <operator>=</operator> <name>dirp</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>newp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>capacity</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>capacity</name> <operator>=</operator> <name><name>dirp</name><operator>-&gt;</operator><name>nfiles</name></name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>newp</name> <operator>=</operator> <call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr><name>rb_dirent_t</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <name>newp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><operator>(</operator><name>dp</name> <operator>=</operator> <call><name>READDIR</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_dirent_t</name> <modifier>*</modifier></type><name>rdp</name> <init>= <expr><call><name>dirent_copy</name><argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rdp</name></expr>)</condition> <block>{<block_content>

<label><name>nomem</name>:</label>

<expr_stmt><expr><call><name>glob_dir_finish</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name>capacity</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>capacity</name> <operator>+=</operator> <literal type="number">256</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>newp</name> <operator>=</operator> <call><name>GLOB_REALLOC_N</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>nomem</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <name>newp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>rdp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>capacity</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>newp</name> <operator>=</operator> <call><name>GLOB_REALLOC_N</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>glob_dir_finish</name><argument_list>(<argument><expr><name>ent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <name>newp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ruby_qsort</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name></name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>count</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><name>glob_sort_cmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ent</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_dirent_t</name> <modifier>*</modifier></type>

<name>glob_getent</name><parameter_list>(<parameter><decl><type><name>ruby_glob_entries_t</name> <modifier>*</modifier></type><name>ent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FNM_GLOB_NOSORT</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>dirent_copy</name><argument_list>(<argument><expr><call><name>READDIR</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>nosort</name><operator>.</operator><name>dirp</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>nosort</name><operator>.</operator><name>ent</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>idx</name></name> <operator>&lt;</operator> <name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>count</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>entries</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>sort</name><operator>.</operator><name>idx</name></name><operator>++</operator></expr>]</index></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>glob_helper</name><parameter_list>(

<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>baselen</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>namelen</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dirsep</name></decl></parameter>, 

<parameter><decl><type><name>rb_pathtype_t</name></type> <name>pathtype</name></decl></parameter>, 

<parameter><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>beg</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>end</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>ruby_glob_funcs_t</name> <modifier>*</modifier></type><name>funcs</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>cur</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>new_beg</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>new_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>plain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>brace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>magical</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>recursive</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>match_all</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>match_dir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>escape</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_NOESCAPE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>pathlen</name> <init>= <expr><name>baselen</name> <operator>+</operator> <name>namelen</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>beg</name></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>cur</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>cur</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>RECURSIVE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>recursive</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>PLAIN</name></expr>:</case>

<expr_stmt><expr><name>plain</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ALPHA</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NAME_ON_FS</name> <operator>==</operator> <name>USE_NAME_ON_FS_REAL_BASENAME</name></expr></cpp:if>

<expr_stmt><expr><name>plain</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>magical</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<case>case <expr><name>BRACE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recursive</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>brace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>MAGICAL</name></expr>:</case>

<expr_stmt><expr><name>magical</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MATCH_ALL</name></expr>:</case>

<expr_stmt><expr><name>match_all</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MATCH_DIR</name></expr>:</case>

<expr_stmt><expr><name>match_dir</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>RECURSIVE</name></expr>:</case>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"continuous RECURSIVEs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>brace</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>push_glob_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>brace_path</name> <init>= <expr><call><name>join_path_from_pattern</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>brace_path</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>baselen</name></name> <operator>=</operator> <name>baselen</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>namelen</name></name> <operator>=</operator> <name>namelen</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>dirsep</name></name> <operator>=</operator> <name>dirsep</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>pathtype</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>funcs</name></name> <operator>=</operator> <name>funcs</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ruby_brace_expand</name><argument_list>(<argument><expr><name>brace_path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>push_caller</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>brace_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>path</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>match_all</name> <operator>&amp;&amp;</operator> <name>pathtype</name> <operator>==</operator> <name>path_unknown</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>do_lstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pathtype</name> <operator>=</operator> <call><name>IFTODT</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>pathtype</name> <operator>=</operator> <name>path_noent</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>match_dir</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pathtype</name> <operator>==</operator> <name>path_unknown</name> <operator>||</operator> <name>pathtype</name> <operator>==</operator> <name>path_symlink</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>do_stat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pathtype</name> <operator>=</operator> <call><name>IFTODT</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>pathtype</name> <operator>=</operator> <name>path_noent</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>match_all</name> <operator>&amp;&amp;</operator> <name>pathtype</name> <operator>&gt;</operator> <name>path_noent</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name>path</name> <operator>+</operator> <name>baselen</name> <operator>+</operator> <operator>(</operator><name>baselen</name> <operator>&amp;&amp;</operator> <name><name>path</name><index>[<expr><name>baselen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>glob_call_func</name><argument_list>(<argument><expr><name><name>funcs</name><operator>-&gt;</operator><name>match</name></name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>match_dir</name> <operator>&amp;&amp;</operator> <name>pathtype</name> <operator>==</operator> <name>path_directory</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>seplen</name> <init>= <expr><operator>(</operator><name>baselen</name> <operator>&amp;&amp;</operator> <name><name>path</name><index>[<expr><name>baselen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name>path</name> <operator>+</operator> <name>baselen</name> <operator>+</operator> <name>seplen</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>join_path</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>namelen</name> <operator>-</operator> <name>seplen</name></expr></argument>, <argument><expr><name>dirsep</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>glob_call_func</name><argument_list>(<argument><expr><name><name>funcs</name><operator>-&gt;</operator><name>match</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>==</operator> <name>path_noent</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>magical</name> <operator>||</operator> <name>recursive</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_dirent_t</name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NAME_ON_FS</name> <operator>==</operator> <name>USE_NAME_ON_FS_BY_FNMATCH</name></expr></cpp:if>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>plainname</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>IF_NORMALIZE_UTF8PATH</name><argument_list>(<argument>int norm_p</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NAME_ON_FS</name> <operator>==</operator> <name>USE_NAME_ON_FS_BY_FNMATCH</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>end</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>cur</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>&lt;=</operator> <name>ALPHA</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>plainname</name> <operator>=</operator> <call><name>join_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>, <argument><expr><name>dirsep</name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>cur</name><operator>)</operator><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>cur</name><operator>)</operator><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plainname</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>dirp</name> <operator>=</operator> <call><name>do_opendir</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>basename</name></expr></argument>, <argument><expr><name>plainname</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>funcs</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>plainname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<empty_stmt>;</empty_stmt></block_content></block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>dirp</name> <operator>=</operator> <call><name>do_opendir</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>funcs</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dirp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FNM_SYSCASE</name> <operator>||</operator> <name>NORMALIZE_UTF8PATH</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>magical</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursive</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>errno</name> <operator>==</operator> <name>EACCES</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<goto>goto <name>literally</name>;</goto>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>IF_NORMALIZE_UTF8PATH</name><argument_list>(<argument><expr><name>norm_p</name> <operator>=</operator> <call><name>need_normalization</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>path</name></expr> ?</condition><then> <expr><name>path</name></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NORMALIZE_UTF8PATH</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>norm_p</name> <operator>||</operator> <name>magical</name> <operator>||</operator> <name>recursive</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>literally</name>;</goto>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETATTRLIST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>is_case_sensitive</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FNM_CASEFOLD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>ruby_glob_entries_t</name></type> <name>globent</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>glob_opendir</name><argument_list>(<argument><expr><operator>&amp;</operator><name>globent</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>funcs</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>funcs</name><operator>-&gt;</operator><name>error</name></name>)<argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>sys_warning</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>dp</name> <operator>=</operator> <call><name>glob_getent</name><argument_list>(<argument><expr><operator>&amp;</operator><name>globent</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_pathtype_t</name></type> <name>new_pathtype</name> <init>= <expr><name>path_unknown</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>namlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dotfile</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>IF_NORMALIZE_UTF8PATH</name><argument_list>(<argument>VALUE utf8str = Qnil</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>namlen</name> <operator>=</operator> <name><name>dp</name><operator>-&gt;</operator><name>d_namlen</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>recursive</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>dotfile</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>namlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_DOTMATCH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>dotfile</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_pathtype</name> <operator>=</operator> <name>path_directory</name></expr>;</expr_stmt> 

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>namlen</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NORMALIZE_UTF8PATH</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>norm_p</name> <operator>&amp;&amp;</operator> <call><name>has_nonascii</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>utf8str</name> <operator>=</operator> <call><name>rb_str_normalize_ospath</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>utf8str</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>join_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>, <argument><expr><name>dirsep</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>IF_NORMALIZE_UTF8PATH</name><argument_list>(<argument>if (!NIL_P(utf8str)) rb_str_resize(utf8str, <literal type="number">0</literal>)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>pathlen</name> <operator>+</operator> <operator>(</operator><name>dirsep</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DT_UNKNOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>d_type</name></name> <operator>!=</operator> <name>DT_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>new_pathtype</name> <operator>=</operator> <name><name>dp</name><operator>-&gt;</operator><name>d_type</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>recursive</name> <operator>&amp;&amp;</operator> <name>dotfile</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_DOTMATCH</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>

<name>new_pathtype</name> <operator>==</operator> <name>path_unknown</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>do_lstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>new_pathtype</name> <operator>=</operator> <call><name>IFTODT</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>new_pathtype</name> <operator>=</operator> <name>path_noent</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>new_beg</name> <operator>=</operator> <name>new_end</name> <operator>=</operator> <call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr>struct <name>glob_pattern</name> <operator>*</operator></expr></argument>, <argument><expr><operator>(</operator><name>end</name> <operator>-</operator> <name>beg</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_beg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>beg</name></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>cur</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>cur</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dirent_brace_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>RECURSIVE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>new_pathtype</name> <operator>==</operator> <name>path_directory</name> <operator>||</operator> 

<name>new_pathtype</name> <operator>==</operator> <name>path_exist</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dotfile</name> <operator>&lt;</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_DOTMATCH</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>new_end</name><operator>++</operator> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BRACE</name></expr>:</case>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>dp</name></name> <operator>=</operator> <name>dp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ruby_brace_expand</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>dirent_match_brace</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>new_end</name><operator>++</operator> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>ALPHA</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NAME_ON_FS</name> <operator>==</operator> <name>USE_NAME_ON_FS_BY_FNMATCH</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>plainname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>new_end</name><operator>++</operator> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>PLAIN</name></expr>:</case>

<case>case <expr><name>MAGICAL</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>dirent_match</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>new_end</name><operator>++</operator> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>glob_helper</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>name</name> <operator>-</operator> <name>buf</name> <operator>-</operator> <name>baselen</name> <operator>+</operator> <name>namlen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,

<argument><expr><name>new_pathtype</name></expr></argument>, <argument><expr><name>new_beg</name></expr></argument>, <argument><expr><name>new_end</name></expr></argument>,

<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>funcs</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>new_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>glob_dir_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>globent</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>plain</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>copy_beg</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>copy_end</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>cur2</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FNM_SYSCASE</name> <operator>||</operator> <name>NORMALIZE_UTF8PATH</name></expr></cpp:if>

<label><name>literally</name>:</label>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>copy_beg</name> <operator>=</operator> <name>copy_end</name> <operator>=</operator> <call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr>struct <name>glob_pattern</name> <operator>*</operator></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy_beg</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>beg</name></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>cur</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>copy_end</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>cur</name><operator>)</operator><operator>-&gt;</operator><name>type</name> <operator>&lt;=</operator> <name>ALPHA</name></expr> ?</condition><then> <expr><operator>*</operator><name>cur</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>cur</name> <operator>=</operator> <name>copy_beg</name></expr>;</init> <condition><expr><name>cur</name> <operator>&lt;</operator> <name>copy_end</name></expr>;</condition> <incr><expr><operator>++</operator><name>cur</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cur</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_pathtype_t</name></type> <name>new_pathtype</name> <init>= <expr><name>path_unknown</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>cur</name><operator>)</operator><operator>-&gt;</operator><name>str</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>cur</name><operator>)</operator><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>escape</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>remove_backslashes</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name><operator>+</operator><name>len</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>name</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>new_beg</name> <operator>=</operator> <name>new_end</name> <operator>=</operator> <call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr>struct <name>glob_pattern</name> <operator>*</operator></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_beg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>new_end</name><operator>++</operator> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>cur</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>cur2</name> <operator>=</operator> <name>cur</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>cur2</name> <operator>&lt;</operator> <name>copy_end</name></expr>;</condition> <incr><expr><operator>++</operator><name>cur2</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cur2</name> <operator>&amp;&amp;</operator> <call><name>fnmatch</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>cur2</name><operator>)</operator><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>new_end</name><operator>++</operator> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>cur2</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>cur2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>join_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>, <argument><expr><name>dirsep</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>new_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NAME_ON_FS</name> <operator>==</operator> <name>USE_NAME_ON_FS_REAL_BASENAME</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>cur</name><operator>)</operator><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ALPHA</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>replace_real_basename</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pathlen</name> <operator>+</operator> <operator>(</operator><name>dirsep</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>, <argument><expr><name>enc</name></expr></argument>,

<argument><expr><call><name>IF_NORMALIZE_UTF8PATH</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">0</literal></expr></argument>,

<argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_pathtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>glob_helper</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>,

<argument><expr><name>namelen</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>pathlen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,

<argument><expr><name>new_pathtype</name></expr></argument>, <argument><expr><name>new_beg</name></expr></argument>, <argument><expr><name>new_end</name></expr></argument>,

<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>funcs</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>new_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>copy_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>push_caller</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>push_glob_args</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>push_glob_args</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>glob_make_pattern</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>path</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>glob_helper</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>baselen</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>namelen</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>dirsep</name></name></expr></argument>,

<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>pathtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>funcs</name></name></expr></argument>,

<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>glob_free_pattern</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ruby_glob0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>ruby_glob_funcs_t</name> <modifier>*</modifier></type><name>funcs</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>push_glob0_args</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ruby_glob_funcs_t</name> <modifier>*</modifier></type><name>funcs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>push_glob0_caller</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>push_glob0_args</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>push_glob0_args</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ruby_glob0</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>funcs</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ruby_glob0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>ruby_glob_funcs_t</name> <modifier>*</modifier></type><name>funcs</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_pattern</name></name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>root</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>baselen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>dirsep</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name>root</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>root</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>push_glob0_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>funcs</name></name> <operator>=</operator> <name>funcs</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<return>return <expr><call><name>ruby_brace_expand</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>push_glob0_caller</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>FNM_SYSCASE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name></expr></cpp:if>

<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>rb_enc_path_skip_prefix</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>root</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>root</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>root</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>root</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name> <operator>&amp;&amp;</operator> <name>base</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>baselen</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dirsep</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>glob_make_pattern</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>root</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>glob_helper</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><name>baselen</name></expr></argument>, <argument><expr><name>dirsep</name></expr></argument>,

<argument><expr><name>path_unknown</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>list</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>funcs</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>glob_free_pattern</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>ruby_glob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ruby_glob_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ruby_glob_funcs_t</name></type> <name>funcs</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>funcs</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>funcs</name><operator>.</operator><name>error</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><call><name>ruby_glob0</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>GLOB_VERBOSE</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>funcs</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_glob_caller</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_args</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator>struct <name>glob_args</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_protect</name><argument_list>(<argument><expr><name>glob_func_caller</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ruby_glob_funcs_t</name></type> <name>rb_glob_funcs</name> <init>= <expr><block>{

<expr><name>rb_glob_caller</name></expr>, <expr><name>rb_glob_error</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>

<name>rb_glob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ruby_glob0</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>GLOB_VERBOSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rb_glob_funcs</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GLOB_JUMP_TAG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>push_pattern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>||</operator> <name>defined</name> <name>__APPLE__</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><call><name>rb_utf8_str_new_cstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>eenc</name> <init>= <expr><call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name>eenc</name></expr> ?</condition><then> <expr><name>eenc</name></expr> </then><else>: <expr><name>enc</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ruby_brace_expand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ruby_glob_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>var</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>escape</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FNM_NOESCAPE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pend</name> <init>= <expr><name>p</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lbrace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rbrace</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>status</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <name>nest</name><operator>++</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lbrace</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'}'</literal> <operator>&amp;&amp;</operator> <name>lbrace</name> <operator>&amp;&amp;</operator> <operator>--</operator><name>nest</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rbrace</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>escape</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><operator>++</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>lbrace</name> <operator>&amp;&amp;</operator> <name>rbrace</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>GLOB_ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>shift</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>lbrace</name><operator>-</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>shift</name> <operator>=</operator> <operator>(</operator><name>lbrace</name><operator>-</operator><name>s</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>lbrace</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>rbrace</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>++</operator><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>nest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>rbrace</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <name>nest</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nest</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nest</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>escape</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name>p</name> <operator>==</operator> <name>rbrace</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>shift</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><name>shift</name><operator>+</operator><operator>(</operator><name>p</name><operator>-</operator><name>t</name><operator>)</operator></expr></argument>, <argument><expr><name>rbrace</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name><operator>-</operator><operator>(</operator><name>shift</name><operator>+</operator><operator>(</operator><name>p</name><operator>-</operator><name>t</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ruby_brace_expand</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>GLOB_FREE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>lbrace</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>rbrace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>glob_call_func</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>brace_args</name> <block>{

<decl_stmt><decl><type><name>ruby_glob_funcs_t</name></type> <name>funcs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>glob_brace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>brace_args</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>brace_args</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ruby_glob0</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arg</name><operator>-&gt;</operator><name>funcs</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>ruby_brace_glob_with_enc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ruby_glob_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>brace_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>GLOB_VERBOSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>funcs</name><operator>.</operator><name>match</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>funcs</name><operator>.</operator><name>error</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

<return>return <expr><call><name>ruby_brace_expand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>glob_brace</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>ruby_brace_glob</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>ruby_glob_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>ruby_brace_glob_with_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>push_glob</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>glob_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>||</operator> <name>defined</name> <name>__APPLE__</name></expr></cpp:if>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENCINDEX_US_ASCII</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENCINDEX_US_ASCII</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>GLOB_VERBOSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>push_pattern</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>ary</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>base</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <name>AT_FDCWD</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_data</name></name> <modifier>*</modifier></type><name>dirp</name> <init>= <expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dir_closed</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRFD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>dirfd</name><argument_list>(<argument><expr><name><name>dirp</name><operator>-&gt;</operator><name>dir</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><call><name>dir_inspect</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>dirp</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>base</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>||</operator> <name>defined</name> <name>__APPLE__</name></expr></cpp:if>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>ruby_glob0</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rb_glob_funcs</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_push_glob</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_str_to_cstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"nul-separated glob pattern is deprecated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>push_glob</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GLOB_JUMP_TAG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_globs</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>push_glob</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>GLOB_JUMP_TAG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dir_glob_options</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sort</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name><name>kw</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>kw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>kw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>kw</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>kw</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"flags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>flags</name></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>Qundef</name> <operator>||</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>base</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OPENDIR_AT</name></expr></cpp:if>

<if type="elseif">else if <condition>(<expr><call><name>rb_typeddata_is_kind_of</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir_data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>base</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>base</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sort</name> <operator>&amp;&amp;</operator> <name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>Qfalse</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>sort</name> <operator>|=</operator> <name>FNM_GLOB_NOSORT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;&amp;</operator> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_aref</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opts</name></decl>, <decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"*:"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dir_glob_options</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sort</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_push_glob</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>dir_globs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_glob</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>, <decl><type ref="prev"/><name>rflags</name></decl>, <decl><type ref="prev"/><name>ary</name></decl>, <decl><type ref="prev"/><name>opts</name></decl>, <decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>, <decl><type ref="prev"/><name>sort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>rflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>dir_glob_options</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>sort</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_push_glob</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>rb_ary_replace</name><argument_list>(<argument><expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>dir_globs</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_each</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_open_dir</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dir</name> <init>= <expr><call><name>rb_funcallv_kw</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"open"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dir_data_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dir</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_foreach</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dir</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>dir_open_dir</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>dir_each</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir_close</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_collect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dir_each_entry</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>rb_ary_push</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_entries</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dir</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>dir_open_dir</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>dir_collect</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir_close</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_each_child</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>dir_each_entry</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir_yield</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_each_child</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dir</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>dir_open_dir</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>dir_each_child</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir_close</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_each_child_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>dir_each_entry</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir_yield</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_collect_children</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dir_each_entry</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>rb_ary_push</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_children</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dir</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>dir_open_dir</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>dir_collect_children</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dir_close</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fnmatch_brace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>brace_args</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>brace_args</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc_pattern</name> <init>= <expr><name>enc</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc_path</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_pattern</name> <operator>!=</operator> <name>enc_path</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc_pattern</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FNM_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc_path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FNM_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_str_asciionly_p</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><name>ENC_CODERANGE_7BIT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_str_coderange_scan_restartable</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern</name> <operator>+</operator> <name>len</name></expr></argument>,

<argument><expr><name>enc_pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FNM_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FNM_NOMATCH</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>fnmatch</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>file_s_fnmatch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pattern</name></decl>, <decl><type ref="prev"/><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rflags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"21"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rflags</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>rflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FilePathStringValue</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FNM_EXTGLOB</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>brace_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ruby_brace_expand</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fnmatch_brace</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_compatible</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fnmatch</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>dir_s_home</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>user</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>user</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SafeStringValue</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>u</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_home_dir_of</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_default_home_dir</name><argument_list>(<argument><expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

VALUE

rb_file_directory_p(void)

{

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_dir_exists_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"Dir.exists? is a deprecated name, use Dir.exist? instead"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_file_directory_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_dir_empty_p</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>opendir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qtrue</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>gc_for_fd_with_gvl</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<default>default:</default>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>ENOTDIR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt> 

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>Qundef</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>dp</name> <operator>=</operator> <call><name>READDIR</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>to_be_skipped</name><argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_dir_s_empty_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dirname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>orig</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<enum>enum <block>{<decl><name>false_on_notdir</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>}</block>;</enum>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>orig</name> <operator>=</operator> <call><name>rb_str_dup_frozen</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>rb_str_dup_frozen</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_GETATTRLIST</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>ATTR_DIR_ENTRYCOUNT</name></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><name>u_int32_t</name></type> <name><name>attrbuf</name><index>[<expr><call><name>SIZEUP32</name><argument_list>(<argument><expr><name>fsobj_tag_t</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>attrlist</name></name></type> <name>al</name> <init>= <expr><block>{<expr><name>ATTR_BIT_MAP_COUNT</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>ATTR_CMN_OBJTAG</name></expr>,}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getattrlist</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>al</name></expr></argument>, <argument><expr><name>attrbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>fsobj_tag_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>attrbuf</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>VT_HFS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>al</name><operator>.</operator><name>commonattr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>al</name><operator>.</operator><name>dirattr</name></name> <operator>=</operator> <name>ATTR_DIR_ENTRYCOUNT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getattrlist</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>al</name></expr></argument>, <argument><expr><name>attrbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>attrbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>attrbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>u_int32_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>attrbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>Qtrue</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>false_on_notdir</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_dir_empty_p</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>path</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_Dir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>rb_cDir</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Dir"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>, <argument><expr><name>rb_mEnumerable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>, <argument><expr><name>dir_s_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>, <argument><expr><literal type="string">"open"</literal></expr></argument>, <argument><expr><name>dir_s_open</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>, <argument><expr><literal type="string">"foreach"</literal></expr></argument>, <argument><expr><name>dir_foreach</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>, <argument><expr><literal type="string">"entries"</literal></expr></argument>, <argument><expr><name>dir_entries</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>, <argument><expr><literal type="string">"each_child"</literal></expr></argument>, <argument><expr><name>dir_s_each_child</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>, <argument><expr><literal type="string">"children"</literal></expr></argument>, <argument><expr><name>dir_s_children</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>dir_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"fileno"</literal></expr></argument>, <argument><expr><name>dir_fileno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>dir_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"to_path"</literal></expr></argument>, <argument><expr><name>dir_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>dir_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"read"</literal></expr></argument>, <argument><expr><name>dir_read</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>dir_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"each_child"</literal></expr></argument>, <argument><expr><name>dir_each_child_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"children"</literal></expr></argument>, <argument><expr><name>dir_collect_children</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"rewind"</literal></expr></argument>, <argument><expr><name>dir_rewind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"tell"</literal></expr></argument>, <argument><expr><name>dir_tell</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"seek"</literal></expr></argument>, <argument><expr><name>dir_seek</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"pos"</literal></expr></argument>, <argument><expr><name>dir_tell</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"pos="</literal></expr></argument>, <argument><expr><name>dir_set_pos</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"close"</literal></expr></argument>, <argument><expr><name>dir_close</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"chdir"</literal></expr></argument>, <argument><expr><name>dir_s_chdir</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"getwd"</literal></expr></argument>, <argument><expr><name>dir_s_getwd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"pwd"</literal></expr></argument>, <argument><expr><name>dir_s_getwd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"chroot"</literal></expr></argument>, <argument><expr><name>dir_s_chroot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"mkdir"</literal></expr></argument>, <argument><expr><name>dir_s_mkdir</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"rmdir"</literal></expr></argument>, <argument><expr><name>dir_s_rmdir</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"delete"</literal></expr></argument>, <argument><expr><name>dir_s_rmdir</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"unlink"</literal></expr></argument>, <argument><expr><name>dir_s_rmdir</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"home"</literal></expr></argument>, <argument><expr><name>dir_s_home</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"glob"</literal></expr></argument>, <argument><expr><name>dir_s_glob</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>dir_s_aref</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"exist?"</literal></expr></argument>, <argument><expr><name>rb_file_directory_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"exists?"</literal></expr></argument>, <argument><expr><name>rb_dir_exists_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cDir</name></expr></argument>,<argument><expr><literal type="string">"empty?"</literal></expr></argument>, <argument><expr><name>rb_dir_s_empty_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>,<argument><expr><literal type="string">"fnmatch"</literal></expr></argument>, <argument><expr><name>file_s_fnmatch</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>,<argument><expr><literal type="string">"fnmatch?"</literal></expr></argument>, <argument><expr><name>file_s_fnmatch</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_file_const</name><argument_list>(<argument><expr><literal type="string">"FNM_NOESCAPE"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>FNM_NOESCAPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_file_const</name><argument_list>(<argument><expr><literal type="string">"FNM_PATHNAME"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>FNM_PATHNAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_file_const</name><argument_list>(<argument><expr><literal type="string">"FNM_DOTMATCH"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>FNM_DOTMATCH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_file_const</name><argument_list>(<argument><expr><literal type="string">"FNM_CASEFOLD"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>FNM_CASEFOLD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_file_const</name><argument_list>(<argument><expr><literal type="string">"FNM_EXTGLOB"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>FNM_EXTGLOB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_file_const</name><argument_list>(<argument><expr><literal type="string">"FNM_SYSCASE"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>FNM_SYSCASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_file_const</name><argument_list>(<argument><expr><literal type="string">"FNM_SHORTNAME"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>FNM_SHORTNAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
