<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\vm_eval.c"><struct>struct <name>local_var_list</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>tbl</name></decl>;</decl_stmt>

}</block>;</struct>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>method_missing</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>method_missing_reason</name></name></type> <name>call_status</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>vm_yield_with_cref</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_lambda</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>vm_yield</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>vm_yield_with_block</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>vm_yield_force_blockarg</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>vm_exec</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mjit_enable_p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vm_set_eval_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type> <name>th</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>base_block</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>vm_collect_local_variables_in_heap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>dfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>local_var_list</name></name> <modifier>*</modifier></type><name>vars</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eUncaughtThrow</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_result</name></decl>, <decl><type ref="prev"/><name>id_tag</name></decl>, <decl><type ref="prev"/><name>id_value</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_mesg</name></cpp:macro> <cpp:value>idMesg</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <name>call_type</name> <block>{

<decl><name>CALL_PUBLIC</name></decl>,

<decl><name>CALL_FCALL</name></decl>,

<decl><name>CALL_VCALL</name></decl>,

<decl><name>CALL_PUBLIC_KW</name></decl>,

<decl><name>CALL_FCALL_KW</name></decl>,

<decl><name>CALL_TYPE_MAX</name></decl>

}</block></enum></type> <name>call_type</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>send_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>call_type</name></type> <name>scope</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>vm_call0_body</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name><modifier>*</modifier></type> <name>ec</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_vm_call0</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_calling_info</name></name></type> <name>calling</name> <init>= <expr><block>{ <expr><name>Qundef</name></expr>, <expr><name>recv</name></expr>, <expr><name>argc</name></expr>, <expr><name>kw_splat</name></expr>, }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><call><name>vm_ci_new_runtime</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><ternary><condition><expr><name>kw_splat</name></expr> ?</condition><then> <expr><name>VM_CALL_KW_SPLAT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callcache</name></name></type> <name>cc_body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>vm_cc_fill</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cc_body</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>vm_call_general</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name></type> <name>cd</name> <init>= <expr><block>{ <expr><name>ci</name></expr>, <expr><name>cc</name></expr>, }</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_call0_body</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>calling</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cd</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call0_cfunc_with_frame</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name><modifier>*</modifier></type> <name>ec</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_cfunc_t</name> <modifier>*</modifier></type><name>cfunc</name> <init>= <expr><call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name><name>body</name><operator>.</operator><name>cfunc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>cfunc</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>frame_flags</name> <init>= <expr><name>VM_FRAME_MAGIC_CFUNC</name> <operator>|</operator> <name>VM_FRAME_FLAG_CFRAME</name> <operator>|</operator> <name>VM_ENV_FLAG_LOCAL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>frame_flags</name> <operator>|=</operator> <name>VM_FRAME_FLAG_CFRAME_KW</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_CMETHOD_ENTRY_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_C_CALL</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>frame_flags</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>,

<argument><expr><name>block_handler</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>me</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>cfunc</name><operator>-&gt;</operator><name>invoker</name></name>)<argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name><name>cfunc</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_CFP_CONSISTENCY</name><argument_list>(<argument><expr><literal type="string">"vm_call0_cfunc_with_frame"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_C_RETURN</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_CMETHOD_RETURN_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call0_cfunc</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_call0_cfunc_with_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_call0_body</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>cc</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name> <operator>=</operator> <call><name>vm_passed_block_handler</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>again</name>:</label>

<switch>switch <condition>(<expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_VM_STACK_OVERFLOW</name><argument_list>(<argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_check_canary</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name><name>reg_cfp</name><operator>-&gt;</operator><name>sp</name></name><operator>++</operator> <operator>=</operator> <name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name><name>reg_cfp</name><operator>-&gt;</operator><name>sp</name></name><operator>++</operator> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>vm_call_iseq_setup</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>reg_cfp</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ENV_FLAGS_SET</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return> 

</block_content>}</block>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>vm_call0_cfunc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>success</name>;</goto>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name> <operator>&amp;&amp;</operator>

<name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_ivar_set</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>success</name>;</goto>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name> <operator>&amp;&amp;</operator>

<name><name>calling</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>success</name>;</goto>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>vm_call_bmethod_body</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>calling</name></expr></argument>, <argument><expr><name>cd</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>success</name>;</goto>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_type_t</name></type> <name>type</name> <init>= <expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>super_class</name> <init>= <expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>defined_class</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VM_METHOD_TYPE_ZSUPER</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>super_class</name> <operator>=</operator> <call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>super_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_cc_cme_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><call><name>refined_method_callable_without_refinement</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>super_class</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>super_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>super_class</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_cc_cme_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><call><name>rb_callable_method_entry</name><argument_list>(<argument><expr><name>super_class</name></expr></argument>, <argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RUBY_VM_CHECK_INTS</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>method_missing_reason</name></name></type> <name>ex</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>VM_METHOD_TYPE_ZSUPER</name><operator>)</operator></expr> ?</condition><then> <expr><name>MISSING_SUPER</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>method_missing</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>success</name>;</goto>

</block_content>}</block>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<expr_stmt><expr><call><name>vm_cc_cme_set</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><call><name>aliased_callable_method_entry</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_passed_block_handler_set</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>method_missing</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>,

<argument><expr><name>argv</name></expr></argument>, <argument><expr><name>MISSING_NOENTRY</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<switch>switch <condition>(<expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>optimize_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>OPTIMIZED_METHOD_TYPE_SEND</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>send_internal</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr> ?</condition><then> <expr><name>CALL_FCALL_KW</name></expr> </then><else>: <expr><name>CALL_FCALL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>success</name>;</goto>

<case>case <expr><name>OPTIMIZED_METHOD_TYPE_CALL</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name><name>calling</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_vm_invoke_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>, <argument><expr><name><name>calling</name><operator>-&gt;</operator><name>block_handler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>success</name>;</goto>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_call0: unsupported optimized method type (%d)"</literal></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>optimize_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_call0: unsupported method type (%d)"</literal></expr></argument>, <argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

<label><name>success</name>:</label>

<expr_stmt><expr><call><name>RUBY_VM_CHECK_INTS</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_vm_call_kw</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_vm_call0</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_call_super</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"vm_call_super: should not be reached"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>me</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>method_missing</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>MISSING_SUPER</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_vm_call_kw</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_call_super_kw</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PASS_PASSED_BLOCK_HANDLER_EC</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_super</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_call_super</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>PASS_PASSED_BLOCK_HANDLER_EC</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_call_super</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_current_receiver</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>cfp</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"no self, no life"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>stack_check</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_ec_raised_p</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RAISED_STACKOVERFLOW</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>rb_ec_stack_check</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ec_raised_set</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RAISED_STACKOVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ec_stack_overflow</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>rb_search_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>enum</name> <name>method_missing_reason</name></name></type> <name>rb_method_call_status</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>call_type</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>rb_call0</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>,

<parameter><decl><type><name>call_type</name></type> <name>call_scope</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>method_missing_reason</name></name></type> <name>call_status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>call_type</name></type> <name>scope</name> <init>= <expr><name>call_scope</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kw_splat</name> <init>= <expr><name>RB_NO_KEYWORDS</name></expr></init></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name>scope</name></expr>)</condition> <block>{<block_content>

<case>case<expr><operator>(</operator><name>CALL_PUBLIC_KW</name><operator>)</operator></expr>:</case>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <name>CALL_PUBLIC</name></expr>;</expr_stmt>

<expr_stmt><expr><name>kw_splat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case<expr><operator>(</operator><name>CALL_FCALL_KW</name><operator>)</operator></expr>:</case>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <name>CALL_FCALL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>kw_splat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>CALL_PUBLIC</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_callable_method_entry_with_refinements</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_search_method_entry</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>call_status</name> <operator>=</operator> <call><name>rb_method_call_status</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>call_status</name> <operator>!=</operator> <name>MISSING_NONE</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>method_missing</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>call_status</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>stack_check</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_vm_call_kw</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>rescue_funcall_args</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>respond</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>respond_to_missing</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kw_splat</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>check_funcall_exec</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rescue_funcall_args</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>call_method_entry</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>,

<argument><expr><name><name>args</name><operator>-&gt;</operator><name>recv</name></name></expr></argument>, <argument><expr><name>idMethodMissing</name></expr></argument>,

<argument><expr><name><name>args</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>argv</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>check_funcall_failed</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>e</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rescue_funcall_args</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>respond</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>rb_method_boundp</name><argument_list>(<argument><expr><name><name>args</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>mid</name></name></expr></argument>,

<argument><expr><name>BOUND_PRIVATE</name><operator>|</operator><name>BOUND_RESPONDS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>args</name><operator>-&gt;</operator><name>respond_to_missing</name></name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>check_funcall_respond_to</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_respond_to</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>check_funcall_callable</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_method_call_status</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>CALL_FCALL</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>MISSING_NONE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>check_funcall_missing</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>respond</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>def</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rescue_funcall_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><name>Qundef</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>basic_obj_respond_to_missing</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>,

<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>def</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>respond</name></name> <operator>=</operator> <name>respond</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>respond_to_missing</name></name> <operator>=</operator> <operator>(</operator><name>ret</name> <operator>!=</operator> <name>Qundef</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>def</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <call><name>callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>idMethodMissing</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><operator>.</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cme</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>METHOD_ENTRY_BASIC</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argbuf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_args</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>argbuf</name></expr></argument>, <argument><expr><name>argc</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>new_args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>argv</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>VALUE</name></type> <name>buf</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argv</name> <operator>=</operator> <operator>&amp;</operator><name>buf</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>new_args</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>method_missing_reason</name></name> <operator>=</operator> <name>MISSING_NOENTRY</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>ec</name></name> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>recv</name></name> <operator>=</operator> <name>recv</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>cme</name></name> <operator>=</operator> <name>cme</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>mid</name></name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <name>argc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>argv</name></name> <operator>=</operator> <name>new_args</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>kw_splat</name></name> <operator>=</operator> <name>kw_splat</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_rescue2</name><argument_list>(<argument><expr><name>check_funcall_exec</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>,

<argument><expr><name>check_funcall_failed</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>,

<argument><expr><name>rb_eNoMethodError</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>argbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_check_funcall_default_kw</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>def</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>VALUE</name></type>

<name>rb_check_funcall_kw</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_funcall_default_kw</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_check_funcall</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_funcall_default_kw</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_check_funcall_default_kw</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>def</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>respond</name> <init>= <expr><call><name>check_funcall_respond_to</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>respond</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>def</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_search_method_entry</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_funcall_callable</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>check_funcall_missing</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>,

<argument><expr><name>respond</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>def</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>stack_check</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_vm_call_kw</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_check_funcall_default</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_funcall_default_kw</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_check_funcall_with_hook_kw</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>,

<parameter><decl><type><name>rb_check_funcall_hook</name> <modifier>*</modifier></type><name>hook</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>respond</name> <init>= <expr><call><name>check_funcall_respond_to</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>respond</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name>hook</name>)<argument_list>(<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_search_method_entry</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_funcall_callable</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>check_funcall_missing</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>,

<argument><expr><name>respond</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>hook</name>)<argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <name>Qundef</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>stack_check</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>hook</name>)<argument_list>(<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_vm_call_kw</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_check_funcall_with_hook</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>,

<parameter><decl><type><name>rb_check_funcall_hook</name> <modifier>*</modifier></type><name>hook</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_funcall_with_hook_kw</name><argument_list>(<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>hook</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_type_str</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>ruby_value_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>type_case</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>t: return #t</cpp:value></cpp:define>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_NONE</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_OBJECT</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_FLOAT</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_STRUCT</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_BIGNUM</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_FILE</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_DATA</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_MATCH</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_COMPLEX</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_RATIONAL</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_NIL</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_TRUE</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_FALSE</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_SYMBOL</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_FIXNUM</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_IMEMO</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_UNDEF</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_NODE</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_ZOMBIE</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><call><name>type_case</name><argument_list>(<argument><expr><name>T_MOVED</name></expr></argument>)</argument_list></call></expr><empty_stmt>;</empty_stmt>

<case>case <expr><name>T_MASK</name></expr>:</case> <break>break;</break>

</case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></case></block_content>}</block></switch>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>type_case</name></cpp:undef>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void uncallable_object(VALUE recv, ID mid)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>uncallable_object</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typestr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mname</name> <init>= <expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eNotImpError</name></expr></argument>,

<argument><expr><literal type="string">"method `%"</literal><name>PRIsVALUE</name><literal type="string">"' called on unexpected immediate object (%p)"</literal></expr></argument>,

<argument><expr><name>mname</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>=</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eNotImpError</name></expr></argument>,

<argument><expr><literal type="string">"method `%"</literal><name>PRIsVALUE</name><literal type="string">"' called on terminated object (%p)"</literal></expr></argument>,

<argument><expr><name>mname</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>typestr</name> <operator>=</operator> <call><name>rb_type_str</name><argument_list>(<argument><expr><name>type</name> <operator>=</operator> <call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<macro><name>rb_raise</name><argument_list>(<argument>rb_eNotImpError</argument>,

<argument><literal type="string">"method `%"</literal>PRIsVALUE<literal type="string">"' called on broken T_?""</literal>?<literal type="string">""</literal>?(<literal type="number">0x</literal>%<literal type="number">02x</literal>) object<literal type="string">"

"</literal> (%p flags=<literal type="number">0x</literal>%<literal type="string">"PRIxVALUE"</literal>)<literal type="string">",

mname, type, (void *)recv, flags);

}

else if (T_OBJECT &lt;= type &amp;&amp; type &lt; T_NIL) {

rb_raise(rb_eNotImpError,

"</literal>method `%<literal type="string">"PRIsVALUE"</literal><literal type="char">' called on hidden %s object"

" (%p flags=0x%"PRIxVALUE")",

mname, typestr, (void *)recv, flags);

}

else {

rb_raise(rb_eNotImpError,

"method `%"PRIsVALUE"'</literal> called on unexpected %s object<literal type="string">"

"</literal> (%p flags=<literal type="number">0x</literal>%<literal type="string">"PRIxVALUE"</literal>)<literal type="string">",

mname, typestr, (void *)recv, flags);

}

}

static inline const rb_callable_method_entry_t *

rb_search_method_entry(VALUE recv, ID mid)

{

VALUE klass = CLASS_OF(recv);

if (!klass) uncallable_object(recv, mid);

return rb_callable_method_entry(klass, mid);

}

static inline enum method_missing_reason

rb_method_call_status(rb_execution_context_t *ec, const rb_callable_method_entry_t *me, call_type scope, VALUE self)

{

VALUE klass;

ID oid;

rb_method_visibility_t visi;

if (UNDEFINED_METHOD_ENTRY_P(me)) {

undefined:

return scope == CALL_VCALL ? MISSING_VCALL : MISSING_NOENTRY;

}

if (me-&gt;def-&gt;type == VM_METHOD_TYPE_REFINED) {

me = rb_resolve_refined_method_callable(Qnil, me);

if (UNDEFINED_METHOD_ENTRY_P(me)) goto undefined;

}

klass = me-&gt;owner;

oid = me-&gt;def-&gt;original_id;

visi = METHOD_ENTRY_VISI(me);

if (oid != idMethodMissing) {

/* receiver specified form for private method */

if (UNLIKELY(visi != METHOD_VISI_PUBLIC)) {

if (visi == METHOD_VISI_PRIVATE &amp;&amp; scope == CALL_PUBLIC) {

return MISSING_PRIVATE;

}

/* self must be kind of a specified form for protected method */

if (visi == METHOD_VISI_PROTECTED &amp;&amp; scope == CALL_PUBLIC) {

VALUE defined_class = klass;

if (RB_TYPE_P(defined_class, T_ICLASS)) {

defined_class = RBASIC(defined_class)-&gt;klass;

}

if (self == Qundef || !rb_obj_is_kind_of(self, defined_class)) {

return MISSING_PROTECTED;

}

}

}

}

return MISSING_NONE;

}

/*!

* \internal

* calls the specified method.

*

* This function is called by functions in rb_call* family.

* \param recv receiver

* \param mid an ID that represents the name of the method

* \param argc the number of method arguments

* \param argv a pointer to an array of method arguments

* \param scope

*/

static inline VALUE

rb_call(VALUE recv, ID mid, int argc, const VALUE *argv, call_type scope)

{

rb_execution_context_t *ec = GET_EC();

return rb_call0(ec, recv, mid, argc, argv, scope, ec-&gt;cfp-&gt;self);

}

NORETURN(static void raise_method_missing(rb_execution_context_t *ec, int argc, const VALUE *argv,

VALUE obj, enum method_missing_reason call_status));

/*

* call-seq:

* obj.method_missing(symbol [, *args] ) -&gt; result

*

* Invoked by Ruby when &lt;i&gt;obj&lt;/i&gt; is sent a message it cannot handle.

* &lt;i&gt;symbol&lt;/i&gt; is the symbol for the method called, and &lt;i&gt;args&lt;/i&gt;

* are any arguments that were passed to it. By default, the interpreter

* raises an error when this method is called. However, it is possible

* to override the method to provide more dynamic behavior.

* If it is decided that a particular method should not be handled, then

* &lt;i&gt;super&lt;/i&gt; should be called, so that ancestors can pick up the

* missing method.

* The example below creates

* a class &lt;code&gt;Roman&lt;/code&gt;, which responds to methods with names

* consisting of roman numerals, returning the corresponding integer

* values.

*

* class Roman

* def roman_to_int(str)

* #...

* end

*

* def method_missing(symbol, *args)

* str = symbol.id2name

* begin

* roman_to_int(str)

* rescue

* super(symbol, *args)

* end

* end

* end

*

* r = Roman.new

* r.iv #=&gt; 4

* r.xxiii #=&gt; 23

* r.mm #=&gt; 2000

* r.foo #=&gt; NoMethodError

*/

static VALUE

rb_method_missing(int argc, const VALUE *argv, VALUE obj)

{

rb_execution_context_t *ec = GET_EC();

raise_method_missing(ec, argc, argv, obj, ec-&gt;method_missing_reason);

UNREACHABLE_RETURN(Qnil);

}

MJIT_FUNC_EXPORTED VALUE

rb_make_no_method_exception(VALUE exc, VALUE format, VALUE obj,

int argc, const VALUE *argv, int priv)

{

VALUE name = argv[0];

if (!format) {

format = rb_fstring_lit("</literal>undefined method `%s<literal type="char">' for %s%s%s");

}

if (exc == rb_eNoMethodError) {

VALUE args = rb_ary_new4(argc - 1, argv + 1);

return rb_nomethod_err_new(format, obj, name, args, priv);

}

else {

return rb_name_err_new(format, obj, name);

}

}

#endif /* #ifndef MJIT_HEADER */

static void

raise_method_missing(rb_execution_context_t *ec, int argc, const VALUE *argv, VALUE obj,

enum method_missing_reason last_call_status)

{

VALUE exc = rb_eNoMethodError;

VALUE format = 0;

if (UNLIKELY(argc == 0)) {

rb_raise(rb_eArgError, "no method name given");

}

else if (UNLIKELY(!SYMBOL_P(argv[0]))) {

const VALUE e = rb_eArgError; /* TODO: TypeError? */

rb_raise(e, "method name must be a Symbol but %"PRIsVALUE" is given",

rb_obj_class(argv[0]));

}

stack_check(ec);

if (last_call_status &amp; MISSING_PRIVATE) {

format = rb_fstring_lit("private method `%s'</literal> called for %s%s%s<literal type="string">");

}

else if (last_call_status &amp; MISSING_PROTECTED) {

format = rb_fstring_lit("</literal>protected method `%s<literal type="char">' called for %s%s%s");

}

else if (last_call_status &amp; MISSING_VCALL) {

format = rb_fstring_lit("undefined local variable or method `%s'</literal> for %s%s%s<literal type="string">");

exc = rb_eNameError;

}

else if (last_call_status &amp; MISSING_SUPER) {

format = rb_fstring_lit("</literal>super: no superclass method `%s<literal type="char">' for %s%s%s");

}

{

exc = rb_make_no_method_exception(exc, format, obj, argc, argv,

last_call_status &amp; (MISSING_FCALL|MISSING_VCALL));

if (!(last_call_status &amp; MISSING_MISSING)) {

rb_vm_pop_cfunc_frame();

}

rb_exc_raise(exc);

}

}

static void

vm_raise_method_missing(rb_execution_context_t *ec, int argc, const VALUE *argv,

VALUE obj, int call_status)

{

vm_passed_block_handler_set(ec, VM_BLOCK_HANDLER_NONE);

raise_method_missing(ec, argc, argv, obj, call_status | MISSING_MISSING);

}

static inline VALUE

method_missing(VALUE obj, ID id, int argc, const VALUE *argv, enum method_missing_reason call_status, int kw_splat)

{

VALUE *nargv, result, work, klass;

rb_execution_context_t *ec = GET_EC();

VALUE block_handler = vm_passed_block_handler(ec);

const rb_callable_method_entry_t *me;

ec-&gt;method_missing_reason = call_status;

if (id == idMethodMissing) {

missing:

raise_method_missing(ec, argc, argv, obj, call_status | MISSING_MISSING);

}

nargv = ALLOCV_N(VALUE, work, argc + 1);

nargv[0] = ID2SYM(id);

#if defined(__GLIBC__)
if (!argv) {

static const VALUE buf = Qfalse;

VM_ASSERT(argc == 0);

argv = &amp;buf;

}

#endif

MEMCPY(nargv + 1, argv, VALUE, argc);

++argc;

argv = nargv;

klass = CLASS_OF(obj);

if (!klass) goto missing;

me = rb_callable_method_entry(klass, idMethodMissing);

if (!me || METHOD_ENTRY_BASIC(me)) goto missing;

vm_passed_block_handler_set(ec, block_handler);

result = rb_vm_call_kw(ec, obj, idMethodMissing, argc, argv, me, kw_splat);

if (work) ALLOCV_END(work);

return result;

}

#if !defined(MJIT_HEADER)
/*!

* Calls a method

* \param recv receiver of the method

* \param mid an ID that represents the name of the method

* \param args an Array object which contains method arguments

*

* \pre \a args must refer an Array object.

*/

VALUE

rb_apply(VALUE recv, ID mid, VALUE args)

{

int argc;

VALUE *argv, ret;

argc = RARRAY_LENINT(args);

if (argc &gt;= 0x100) {

args = rb_ary_subseq(args, 0, argc);

RBASIC_CLEAR_CLASS(args);

OBJ_FREEZE(args);

ret = rb_call(recv, mid, argc, RARRAY_CONST_PTR(args), CALL_FCALL);

RB_GC_GUARD(args);

return ret;

}

argv = ALLOCA_N(VALUE, argc);

MEMCPY(argv, RARRAY_CONST_PTR_TRANSIENT(args), VALUE, argc);

return rb_call(recv, mid, argc, argv, CALL_FCALL);

}

#if defined(rb_funcall)
#undef rb_funcall

#endif

/*!

* Calls a method

* \param recv receiver of the method

* \param mid an ID that represents the name of the method

* \param n the number of arguments

* \param ... arbitrary number of method arguments

*

* \pre each of arguments after \a n must be a VALUE.

*/

VALUE

rb_funcall(VALUE recv, ID mid, int n, ...)

{

VALUE *argv;

va_list ar;

if (n &gt; 0) {

long i;

va_init_list(ar, n);

argv = ALLOCA_N(VALUE, n);

for (i = 0; i &lt; n; i++) {

argv[i] = va_arg(ar, VALUE);

}

va_end(ar);

}

else {

argv = 0;

}

return rb_call(recv, mid, n, argv, CALL_FCALL);

}

#if defined(rb_funcallv)
#undef rb_funcallv

#endif

/*!

* Calls a method

* \param recv receiver of the method

* \param mid an ID that represents the name of the method

* \param argc the number of arguments

* \param argv pointer to an array of method arguments

*/

VALUE

rb_funcallv(VALUE recv, ID mid, int argc, const VALUE *argv)

{

return rb_call(recv, mid, argc, argv, CALL_FCALL);

}

VALUE

rb_funcallv_kw(VALUE recv, ID mid, int argc, const VALUE *argv, int kw_splat)

{

return rb_call(recv, mid, argc, argv, kw_splat ? CALL_FCALL_KW : CALL_FCALL);

}

/*!

* Calls a method.

*

* Same as rb_funcallv but this function can call only public methods.

* \param recv receiver of the method

* \param mid an ID that represents the name of the method

* \param argc the number of arguments

* \param argv pointer to an array of method arguments

*/

VALUE

rb_funcallv_public(VALUE recv, ID mid, int argc, const VALUE *argv)

{

return rb_call(recv, mid, argc, argv, CALL_PUBLIC);

}

VALUE

rb_funcallv_public_kw(VALUE recv, ID mid, int argc, const VALUE *argv, int kw_splat)

{

return rb_call(recv, mid, argc, argv, kw_splat ? CALL_PUBLIC_KW : CALL_PUBLIC);

}

VALUE

rb_funcall_passing_block(VALUE recv, ID mid, int argc, const VALUE *argv)

{

PASS_PASSED_BLOCK_HANDLER();

return rb_call(recv, mid, argc, argv, CALL_PUBLIC);

}

VALUE

rb_funcall_passing_block_kw(VALUE recv, ID mid, int argc, const VALUE *argv, int kw_splat)

{

PASS_PASSED_BLOCK_HANDLER();

return rb_call(recv, mid, argc, argv, kw_splat ? CALL_PUBLIC_KW : CALL_PUBLIC);

}

VALUE

rb_funcall_with_block(VALUE recv, ID mid, int argc, const VALUE *argv, VALUE passed_procval)

{

if (!NIL_P(passed_procval)) {

vm_passed_block_handler_set(GET_EC(), passed_procval);

}

return rb_call(recv, mid, argc, argv, CALL_PUBLIC);

}

VALUE

rb_funcall_with_block_kw(VALUE recv, ID mid, int argc, const VALUE *argv, VALUE passed_procval, int kw_splat)

{

if (!NIL_P(passed_procval)) {

vm_passed_block_handler_set(GET_EC(), passed_procval);

}

return rb_call(recv, mid, argc, argv, kw_splat ? CALL_PUBLIC_KW : CALL_PUBLIC);

}

static VALUE *

current_vm_stack_arg(const rb_execution_context_t *ec, const VALUE *argv)

{

rb_control_frame_t *prev_cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(ec-&gt;cfp);

if (RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P(ec, prev_cfp)) return NULL;

if (prev_cfp-&gt;sp + 1 != argv) return NULL;

return prev_cfp-&gt;sp + 1;

}

static VALUE

send_internal(int argc, const VALUE *argv, VALUE recv, call_type scope)

{

ID id;

VALUE vid;

VALUE self;

VALUE ret, vargv = 0;

rb_execution_context_t *ec = GET_EC();

int public = scope == CALL_PUBLIC || scope == CALL_PUBLIC_KW;

if (public) {

self = Qundef;

}

else {

self = RUBY_VM_PREVIOUS_CONTROL_FRAME(ec-&gt;cfp)-&gt;self;

}

if (argc == 0) {

rb_raise(rb_eArgError, "no method name given");

}

vid = *argv;

id = rb_check_id(&amp;vid);

if (!id) {

if (rb_method_basic_definition_p(CLASS_OF(recv), idMethodMissing)) {

VALUE exc = rb_make_no_method_exception(rb_eNoMethodError, 0,

recv, argc, argv,

!public);

rb_exc_raise(exc);

}

if (!SYMBOL_P(*argv)) {

VALUE *tmp_argv = current_vm_stack_arg(ec, argv);

vid = rb_str_intern(vid);

if (tmp_argv) {

tmp_argv[0] = vid;

}

else if (argc &gt; 1) {

tmp_argv = ALLOCV_N(VALUE, vargv, argc);

tmp_argv[0] = vid;

MEMCPY(tmp_argv+1, argv+1, VALUE, argc-1);

argv = tmp_argv;

}

else {

argv = &amp;vid;

}

}

id = idMethodMissing;

ec-&gt;method_missing_reason = MISSING_NOENTRY;

}

else {

argv++; argc--;

}

PASS_PASSED_BLOCK_HANDLER_EC(ec);

ret = rb_call0(ec, recv, id, argc, argv, scope, self);

ALLOCV_END(vargv);

return ret;

}

static VALUE

send_internal_kw(int argc, const VALUE *argv, VALUE recv, call_type scope)

{

if (rb_keyword_given_p()) {

switch (scope) {

case CALL_PUBLIC:

scope = CALL_PUBLIC_KW;

break;

case CALL_FCALL:

scope = CALL_FCALL_KW;

break;

default:

break;

}

}

return send_internal(argc, argv, recv, scope);

}

/*

* call-seq:

* foo.send(symbol [, args...]) -&gt; obj

* foo.__send__(symbol [, args...]) -&gt; obj

* foo.send(string [, args...]) -&gt; obj

* foo.__send__(string [, args...]) -&gt; obj

*

* Invokes the method identified by _symbol_, passing it any

* arguments specified. You can use &lt;code&gt;__send__&lt;/code&gt; if the name

* +send+ clashes with an existing method in _obj_.

* When the method is identified by a string, the string is converted

* to a symbol.

*

* BasicObject implements +__send__+, Kernel implements +send+.

*

* class Klass

* def hello(*args)

* "Hello " + args.join('</literal> <literal type="char">')

* end

* end

* k = Klass.new

* k.send :hello, "gentle", "readers" #=&gt; "Hello gentle readers"

*/

VALUE

rb_f_send(int argc, VALUE *argv, VALUE recv)

{

return send_internal_kw(argc, argv, recv, CALL_FCALL);

}

/*

* call-seq:

* obj.public_send(symbol [, args...]) -&gt; obj

* obj.public_send(string [, args...]) -&gt; obj

*

* Invokes the method identified by _symbol_, passing it any

* arguments specified. Unlike send, public_send calls public

* methods only.

* When the method is identified by a string, the string is converted

* to a symbol.

*

* 1.public_send(:puts, "hello") #causes NoMethodError

*/

static VALUE

rb_f_public_send(int argc, VALUE *argv, VALUE recv)

{

return send_internal_kw(argc, argv, recv, CALL_PUBLIC);

}

/* yield */

static inline VALUE

rb_yield_0_kw(int argc, const VALUE * argv, int kw_splat)

{

return vm_yield(GET_EC(), argc, argv, kw_splat);

}

static inline VALUE

rb_yield_0(int argc, const VALUE * argv)

{

return vm_yield(GET_EC(), argc, argv, RB_NO_KEYWORDS);

}

VALUE

rb_yield_1(VALUE val)

{

return rb_yield_0(1, &amp;val);

}

VALUE

rb_yield(VALUE val)

{

if (val == Qundef) {

return rb_yield_0(0, 0);

}

else {

return rb_yield_1(val);

}

}

#undef rb_yield_values

VALUE

rb_yield_values(int n, ...)

{

if (n == 0) {

return rb_yield_0(0, 0);

}

else {

int i;

VALUE *argv;

va_list args;

argv = ALLOCA_N(VALUE, n);

va_init_list(args, n);

for (i=0; i&lt;n; i++) {

argv[i] = va_arg(args, VALUE);

}

va_end(args);

return rb_yield_0(n, argv);

}

}

VALUE

rb_yield_values2(int argc, const VALUE *argv)

{

return rb_yield_0(argc, argv);

}

VALUE

rb_yield_values_kw(int argc, const VALUE *argv, int kw_splat)

{

return rb_yield_0_kw(argc, argv, kw_splat);

}

VALUE

rb_yield_splat(VALUE values)

{

VALUE tmp = rb_check_array_type(values);

VALUE v;

if (NIL_P(tmp)) {

rb_raise(rb_eArgError, "not an array");

}

v = rb_yield_0(RARRAY_LENINT(tmp), RARRAY_CONST_PTR(tmp));

RB_GC_GUARD(tmp);

return v;

}

VALUE

rb_yield_splat_kw(VALUE values, int kw_splat)

{

VALUE tmp = rb_check_array_type(values);

VALUE v;

if (NIL_P(tmp)) {

rb_raise(rb_eArgError, "not an array");

}

v = rb_yield_0_kw(RARRAY_LENINT(tmp), RARRAY_CONST_PTR(tmp), kw_splat);

RB_GC_GUARD(tmp);

return v;

}

VALUE

rb_yield_force_blockarg(VALUE values)

{

return vm_yield_force_blockarg(GET_EC(), values);

}

VALUE

rb_yield_block(RB_BLOCK_CALL_FUNC_ARGLIST(val, arg))

{

return vm_yield_with_block(GET_EC(), argc, argv,

NIL_P(blockarg) ? VM_BLOCK_HANDLER_NONE : blockarg,

rb_keyword_given_p());

}

static VALUE

loop_i(VALUE _)

{

for (;;) {

rb_yield_0(0, 0);

}

return Qnil;

}

static VALUE

loop_stop(VALUE dummy, VALUE exc)

{

return rb_attr_get(exc, id_result);

}

static VALUE

rb_f_loop_size(VALUE self, VALUE args, VALUE eobj)

{

return DBL2NUM(HUGE_VAL);

}

/*

* call-seq:

* loop { block }

* loop -&gt; an_enumerator

*

* Repeatedly executes the block.

*

* If no block is given, an enumerator is returned instead.

*

* loop do

* print "Input: "

* line = gets

* break if !line or line =~ /^qQ/

* #...

* end

*

* StopIteration raised in the block breaks the loop. In this case,

* loop returns the "result" value stored in the exception.

*

* enum = Enumerator.new { |y|

* y &lt;&lt; "one"

* y &lt;&lt; "two"

* :ok

* }

*

* result = loop {

* puts enum.next

* } #=&gt; :ok

*/

static VALUE

rb_f_loop(VALUE self)

{

RETURN_SIZED_ENUMERATOR(self, 0, 0, rb_f_loop_size);

return rb_rescue2(loop_i, (VALUE)0, loop_stop, (VALUE)0, rb_eStopIteration, (VALUE)0);

}

#if VMDEBUG

static const char *

vm_frametype_name(const rb_control_frame_t *cfp);

#endif

static VALUE

rb_iterate0(VALUE (* it_proc) (VALUE), VALUE data1,

const struct vm_ifunc *const ifunc,

rb_execution_context_t *ec)

{

enum ruby_tag_type state;

volatile VALUE retval = Qnil;

rb_control_frame_t *const cfp = ec-&gt;cfp;

EC_PUSH_TAG(ec);

state = EC_EXEC_TAG();

if (state == 0) {

iter_retry:

{

VALUE block_handler;

if (ifunc) {

struct rb_captured_block *captured = VM_CFP_TO_CAPTURED_BLOCK(cfp);

captured-&gt;code.ifunc = ifunc;

block_handler = VM_BH_FROM_IFUNC_BLOCK(captured);

}

else {

block_handler = VM_CF_BLOCK_HANDLER(cfp);

}

vm_passed_block_handler_set(ec, block_handler);

}

retval = (*it_proc) (data1);

}

else if (state == TAG_BREAK || state == TAG_RETRY) {

const struct vm_throw_data *const err = (struct vm_throw_data *)ec-&gt;errinfo;

const rb_control_frame_t *const escape_cfp = THROW_DATA_CATCH_FRAME(err);

if (cfp == escape_cfp) {

rb_vm_rewind_cfp(ec, cfp);

state = 0;

ec-&gt;tag-&gt;state = TAG_NONE;

ec-&gt;errinfo = Qnil;

if (state == TAG_RETRY) goto iter_retry;

retval = THROW_DATA_VAL(err);

}

else if (0) {

SDR(); fprintf(stderr, "%p, %p\n", (void *)cfp, (void *)escape_cfp);

}

}

EC_POP_TAG();

if (state) {

EC_JUMP_TAG(ec, state);

}

return retval;

}

VALUE

rb_iterate(VALUE (* it_proc)(VALUE), VALUE data1,

rb_block_call_func_t bl_proc, VALUE data2)

{

return rb_iterate0(it_proc, data1,

bl_proc ? rb_vm_ifunc_proc_new(bl_proc, (void *)data2) : 0,

GET_EC());

}

struct iter_method_arg {

VALUE obj;

ID mid;

int argc;

const VALUE *argv;

int kw_splat;

};

static VALUE

iterate_method(VALUE obj)

{

const struct iter_method_arg * arg =

(struct iter_method_arg *) obj;

return rb_call(arg-&gt;obj, arg-&gt;mid, arg-&gt;argc, arg-&gt;argv, arg-&gt;kw_splat ? CALL_FCALL_KW : CALL_FCALL);

}

VALUE

rb_block_call(VALUE obj, ID mid, int argc, const VALUE * argv,

rb_block_call_func_t bl_proc, VALUE data2)

{

struct iter_method_arg arg;

arg.obj = obj;

arg.mid = mid;

arg.argc = argc;

arg.argv = argv;

arg.kw_splat = 0;

return rb_iterate(iterate_method, (VALUE)&amp;arg, bl_proc, data2);

}

VALUE

rb_block_call_kw(VALUE obj, ID mid, int argc, const VALUE * argv,

rb_block_call_func_t bl_proc, VALUE data2, int kw_splat)

{

struct iter_method_arg arg;

arg.obj = obj;

arg.mid = mid;

arg.argc = argc;

arg.argv = argv;

arg.kw_splat = kw_splat;

return rb_iterate(iterate_method, (VALUE)&amp;arg, bl_proc, data2);

}

VALUE

rb_lambda_call(VALUE obj, ID mid, int argc, const VALUE *argv,

rb_block_call_func_t bl_proc, int min_argc, int max_argc,

VALUE data2)

{

struct iter_method_arg arg;

struct vm_ifunc *block;

if (!bl_proc) rb_raise(rb_eArgError, "NULL lambda function");

arg.obj = obj;

arg.mid = mid;

arg.argc = argc;

arg.argv = argv;

arg.kw_splat = 0;

block = rb_vm_ifunc_new(bl_proc, (void *)data2, min_argc, max_argc);

return rb_iterate0(iterate_method, (VALUE)&amp;arg, block, GET_EC());

}

static VALUE

iterate_check_method(VALUE obj)

{

const struct iter_method_arg * arg =

(struct iter_method_arg *) obj;

return rb_check_funcall(arg-&gt;obj, arg-&gt;mid, arg-&gt;argc, arg-&gt;argv);

}

VALUE

rb_check_block_call(VALUE obj, ID mid, int argc, const VALUE *argv,

rb_block_call_func_t bl_proc, VALUE data2)

{

struct iter_method_arg arg;

arg.obj = obj;

arg.mid = mid;

arg.argc = argc;

arg.argv = argv;

arg.kw_splat = 0;

return rb_iterate(iterate_check_method, (VALUE)&amp;arg, bl_proc, data2);

}

VALUE

rb_each(VALUE obj)

{

return rb_call(obj, idEach, 0, 0, CALL_FCALL);

}

void rb_parser_warn_location(VALUE, int);

static const rb_iseq_t *

eval_make_iseq(VALUE src, VALUE fname, int line, const rb_binding_t *bind,

const struct rb_block *base_block)

{

const VALUE parser = rb_parser_new();

const rb_iseq_t *const parent = vm_block_iseq(base_block);

VALUE realpath = Qnil;

rb_iseq_t *iseq = NULL;

rb_ast_t *ast;

if (!fname) {

fname = rb_source_location(&amp;line);

}

if (fname != Qundef) {

if (!NIL_P(fname)) fname = rb_fstring(fname);

realpath = fname;

}

else {

fname = rb_fstring_lit("(eval)");

}

rb_parser_set_context(parser, parent, FALSE);

ast = rb_parser_compile_string_path(parser, fname, src, line);

if (ast-&gt;body.root) {

iseq = rb_iseq_new_with_opt(&amp;ast-&gt;body,

parent-&gt;body-&gt;location.label,

fname, realpath, INT2FIX(line),

parent, ISEQ_TYPE_EVAL, NULL);

}

rb_ast_dispose(ast);

if (iseq != NULL) {

if (0 &amp;&amp; iseq) { /* for debug */

VALUE disasm = rb_iseq_disasm(iseq);

printf("%s\n", StringValuePtr(disasm));

}

rb_exec_event_hook_script_compiled(GET_EC(), iseq, src);

}

return iseq;

}

static VALUE

eval_string_with_cref(VALUE self, VALUE src, rb_cref_t *cref, VALUE file, int line)

{

rb_execution_context_t *ec = GET_EC();

struct rb_block block;

const rb_iseq_t *iseq;

rb_control_frame_t *cfp = rb_vm_get_ruby_level_next_cfp(ec, ec-&gt;cfp);

if (!cfp) {

rb_raise(rb_eRuntimeError, "Can'</literal>t eval on top of Fiber or Thread<literal type="string">");

}

block.as.captured = *VM_CFP_TO_CAPTURED_BLOCK(cfp);

block.as.captured.self = self;

block.as.captured.code.iseq = cfp-&gt;iseq;

block.type = block_type_iseq;

iseq = eval_make_iseq(src, file, line, NULL, &amp;block);

if (!iseq) {

rb_exc_raise(ec-&gt;errinfo);

}

/* TODO: what the code checking? */

if (!cref &amp;&amp; block.as.captured.code.val) {

rb_cref_t *orig_cref = vm_get_cref(vm_block_ep(&amp;block));

cref = vm_cref_dup(orig_cref);

}

vm_set_eval_stack(ec, iseq, cref, &amp;block);

/* kick */

return vm_exec(ec, TRUE);

}

static VALUE

eval_string_with_scope(VALUE scope, VALUE src, VALUE file, int line)

{

rb_execution_context_t *ec = GET_EC();

rb_binding_t *bind = Check_TypedStruct(scope, &amp;ruby_binding_data_type);

const rb_iseq_t *iseq = eval_make_iseq(src, file, line, bind, &amp;bind-&gt;block);

if (!iseq) {

rb_exc_raise(ec-&gt;errinfo);

}

vm_set_eval_stack(ec, iseq, NULL, &amp;bind-&gt;block);

/* save new env */

if (iseq-&gt;body-&gt;local_table_size &gt; 0) {

vm_bind_update_env(scope, bind, vm_make_env_object(ec, ec-&gt;cfp));

}

/* kick */

return vm_exec(ec, TRUE);

}

/*

* call-seq:

* eval(string [, binding [, filename [,lineno]]]) -&gt; obj

*

* Evaluates the Ruby expression(s) in &lt;em&gt;string&lt;/em&gt;. If

* &lt;em&gt;binding&lt;/em&gt; is given, which must be a Binding object, the

* evaluation is performed in its context. If the optional

* &lt;em&gt;filename&lt;/em&gt; and &lt;em&gt;lineno&lt;/em&gt; parameters are present, they

* will be used when reporting syntax errors.

*

* def get_binding(str)

* return binding

* end

* str = "</literal>hello<literal type="string">"

* eval "</literal>str + <literal type="char">' Fred'</literal><literal type="string">" #=&gt; "</literal>hello Fred<literal type="string">"

* eval "</literal>str + <literal type="char">' Fred'</literal><literal type="string">", get_binding("</literal>bye<literal type="string">") #=&gt; "</literal>bye Fred<literal type="string">"

*/

VALUE

rb_f_eval(int argc, const VALUE *argv, VALUE self)

{

VALUE src, scope, vfile, vline;

VALUE file = Qundef;

int line = 1;

rb_scan_args(argc, argv, "</literal><literal type="number">13</literal><literal type="string">", &amp;src, &amp;scope, &amp;vfile, &amp;vline);

SafeStringValue(src);

if (argc &gt;= 3) {

StringValue(vfile);

}

if (argc &gt;= 4) {

line = NUM2INT(vline);

}

if (!NIL_P(vfile))

file = vfile;

if (NIL_P(scope))

return eval_string_with_cref(self, src, NULL, file, line);

else

return eval_string_with_scope(scope, src, file, line);

}

/** @note This function name is not stable. */

VALUE

ruby_eval_string_from_file(const char *str, const char *filename)

{

VALUE file = filename ? rb_str_new_cstr(filename) : 0;

return eval_string_with_cref(rb_vm_top_self(), rb_str_new2(str), NULL, file, 1);

}

/**

* Evaluates the given string in an isolated binding.

*

* Here "</literal>isolated<literal type="string">" means the binding does not inherit any other binding. This

* behaves same as the binding for required libraries.

*

* __FILE__ will be "</literal>(eval)<literal type="string">", and __LINE__ starts from 1 in the evaluation.

*

* @param str Ruby code to evaluate.

* @return The evaluated result.

* @throw Exception Raises an exception on error.

*/

VALUE

rb_eval_string(const char *str)

{

return ruby_eval_string_from_file(str, "</literal>eval<literal type="string">");

}

static VALUE

eval_string_protect(VALUE str)

{

return rb_eval_string((char *)str);

}

/**

* Evaluates the given string in an isolated binding.

*

* __FILE__ will be "</literal>(eval)<literal type="string">", and __LINE__ starts from 1 in the evaluation.

*

* @sa rb_eval_string

* @param str Ruby code to evaluate.

* @param state Being set to zero if succeeded. Nonzero if an error occurred.

* @return The evaluated result if succeeded, an undefined value if otherwise.

*/

VALUE

rb_eval_string_protect(const char *str, int *pstate)

{

return rb_protect(eval_string_protect, (VALUE)str, pstate);

}

struct eval_string_wrap_arg {

VALUE top_self;

VALUE klass;

const char *str;

};

static VALUE

eval_string_wrap_protect(VALUE data)

{

const struct eval_string_wrap_arg *const arg = (struct eval_string_wrap_arg*)data;

rb_cref_t *cref = rb_vm_cref_new_toplevel();

cref-&gt;klass = arg-&gt;klass;

return eval_string_with_cref(arg-&gt;top_self, rb_str_new_cstr(arg-&gt;str), cref, rb_str_new_cstr("</literal>eval<literal type="string">"), 1);

}

/**

* Evaluates the given string under a module binding in an isolated binding.

* This is same as the binding for loaded libraries on "</literal>load(<literal type="char">'foo'</literal>, true)<literal type="string">".

*

* __FILE__ will be "</literal>(eval)<literal type="string">", and __LINE__ starts from 1 in the evaluation.

*

* @sa rb_eval_string

* @param str Ruby code to evaluate.

* @param state Being set to zero if succeeded. Nonzero if an error occurred.

* @return The evaluated result if succeeded, an undefined value if otherwise.

*/

VALUE

rb_eval_string_wrap(const char *str, int *pstate)

{

int state;

rb_thread_t *th = GET_THREAD();

VALUE self = th-&gt;top_self;

VALUE wrapper = th-&gt;top_wrapper;

VALUE val;

struct eval_string_wrap_arg data;

th-&gt;top_wrapper = rb_module_new();

th-&gt;top_self = rb_obj_clone(rb_vm_top_self());

rb_extend_object(th-&gt;top_self, th-&gt;top_wrapper);

data.top_self = th-&gt;top_self;

data.klass = th-&gt;top_wrapper;

data.str = str;

val = rb_protect(eval_string_wrap_protect, (VALUE)&amp;data, &amp;state);

th-&gt;top_self = self;

th-&gt;top_wrapper = wrapper;

if (pstate) {

*pstate = state;

}

else if (state != TAG_NONE) {

EC_JUMP_TAG(th-&gt;ec, state);

}

return val;

}

VALUE

rb_eval_cmd_kw(VALUE cmd, VALUE arg, int kw_splat)

{

enum ruby_tag_type state;

volatile VALUE val = Qnil; /* OK */

rb_execution_context_t * volatile ec = GET_EC();

EC_PUSH_TAG(ec);

if ((state = EC_EXEC_TAG()) == TAG_NONE) {

if (!RB_TYPE_P(cmd, T_STRING)) {

val = rb_funcallv_kw(cmd, idCall, RARRAY_LENINT(arg),

RARRAY_CONST_PTR(arg), kw_splat);

}

else {

val = eval_string_with_cref(rb_vm_top_self(), cmd, NULL, 0, 0);

}

}

EC_POP_TAG();

if (state) EC_JUMP_TAG(ec, state);

return val;

}

/* block eval under the class/module context */

static VALUE

yield_under(VALUE under, VALUE self, int argc, const VALUE *argv, int kw_splat)

{

rb_execution_context_t *ec = GET_EC();

rb_control_frame_t *cfp = ec-&gt;cfp;

VALUE block_handler = VM_CF_BLOCK_HANDLER(cfp);

VALUE new_block_handler = 0;

const struct rb_captured_block *captured = NULL;

struct rb_captured_block new_captured;

const VALUE *ep = NULL;

rb_cref_t *cref;

int is_lambda = FALSE;

if (block_handler != VM_BLOCK_HANDLER_NONE) {

again:

switch (vm_block_handler_type(block_handler)) {

case block_handler_type_iseq:

captured = VM_BH_TO_CAPT_BLOCK(block_handler);

new_captured = *captured;

new_block_handler = VM_BH_FROM_ISEQ_BLOCK(&amp;new_captured);

break;

case block_handler_type_ifunc:

captured = VM_BH_TO_CAPT_BLOCK(block_handler);

new_captured = *captured;

new_block_handler = VM_BH_FROM_IFUNC_BLOCK(&amp;new_captured);

break;

case block_handler_type_proc:

is_lambda = rb_proc_lambda_p(block_handler) != Qfalse;

block_handler = vm_proc_to_block_handler(VM_BH_TO_PROC(block_handler));

goto again;

case block_handler_type_symbol:

return rb_sym_proc_call(SYM2ID(VM_BH_TO_SYMBOL(block_handler)),

argc, argv, kw_splat,

VM_BLOCK_HANDLER_NONE);

}

new_captured.self = self;

ep = captured-&gt;ep;

VM_FORCE_WRITE_SPECIAL_CONST(&amp;VM_CF_LEP(ec-&gt;cfp)[VM_ENV_DATA_INDEX_SPECVAL], new_block_handler);

}

cref = vm_cref_push(ec, under, ep, TRUE);

return vm_yield_with_cref(ec, argc, argv, kw_splat, cref, is_lambda);

}

VALUE

rb_yield_refine_block(VALUE refinement, VALUE refinements)

{

rb_execution_context_t *ec = GET_EC();

VALUE block_handler = VM_CF_BLOCK_HANDLER(ec-&gt;cfp);

if (vm_block_handler_type(block_handler) != block_handler_type_iseq) {

rb_bug("</literal>rb_yield_refine_block: an iseq block is required<literal type="string">");

}

else {

const struct rb_captured_block *captured = VM_BH_TO_ISEQ_BLOCK(block_handler);

struct rb_captured_block new_captured = *captured;

VALUE new_block_handler = VM_BH_FROM_ISEQ_BLOCK(&amp;new_captured);

const VALUE *ep = captured-&gt;ep;

rb_cref_t *cref = vm_cref_push(ec, refinement, ep, TRUE);

CREF_REFINEMENTS_SET(cref, refinements);

VM_FORCE_WRITE_SPECIAL_CONST(&amp;VM_CF_LEP(ec-&gt;cfp)[VM_ENV_DATA_INDEX_SPECVAL], new_block_handler);

new_captured.self = refinement;

return vm_yield_with_cref(ec, 0, NULL, RB_NO_KEYWORDS, cref, FALSE);

}

}

/* string eval under the class/module context */

static VALUE

eval_under(VALUE under, VALUE self, VALUE src, VALUE file, int line)

{

rb_cref_t *cref = vm_cref_push(GET_EC(), under, NULL, SPECIAL_CONST_P(self) &amp;&amp; !NIL_P(under));

SafeStringValue(src);

return eval_string_with_cref(self, src, cref, file, line);

}

static VALUE

specific_eval(int argc, const VALUE *argv, VALUE klass, VALUE self, int kw_splat)

{

if (rb_block_given_p()) {

rb_check_arity(argc, 0, 0);

return yield_under(klass, self, 1, &amp;self, kw_splat);

}

else {

VALUE file = Qundef;

int line = 1;

VALUE code;

rb_check_arity(argc, 1, 3);

code = argv[0];

SafeStringValue(code);

if (argc &gt; 2)

line = NUM2INT(argv[2]);

if (argc &gt; 1) {

file = argv[1];

if (!NIL_P(file)) StringValue(file);

}

return eval_under(klass, self, code, file, line);

}

}

static VALUE

singleton_class_for_eval(VALUE self)

{

if (SPECIAL_CONST_P(self)) {

return rb_special_singleton_class(self);

}

switch (BUILTIN_TYPE(self)) {

case T_FLOAT: case T_BIGNUM: case T_SYMBOL:

return Qnil;

case T_STRING:

if (FL_TEST_RAW(self, RSTRING_FSTR)) return Qnil;

default:

return rb_singleton_class(self);

}

}

/*

* call-seq:

* obj.instance_eval(string [, filename [, lineno]] ) -&gt; obj

* obj.instance_eval {|obj| block } -&gt; obj

*

* Evaluates a string containing Ruby source code, or the given block,

* within the context of the receiver (_obj_). In order to set the

* context, the variable +self+ is set to _obj_ while

* the code is executing, giving the code access to _obj_'s

* instance variables and private methods.

*

* When &lt;code&gt;instance_eval&lt;/code&gt; is given a block, _obj_ is also

* passed in as the block's only argument.

*

* When &lt;code&gt;instance_eval&lt;/code&gt; is given a +String+, the optional

* second and third parameters supply a filename and starting line number

* that are used when reporting compilation errors.

*

* class KlassWithSecret

* def initialize

* @secret = 99

* end

* private

* def the_secret

* "</literal>Ssssh! The secret is #{@secret}.<literal type="string">"

* end

* end

* k = KlassWithSecret.new

* k.instance_eval { @secret } #=&gt; 99

* k.instance_eval { the_secret } #=&gt; "</literal>Ssssh! The secret is <literal type="number">99.</literal><literal type="string">"

* k.instance_eval {|obj| obj == self } #=&gt; true

*/

static VALUE

rb_obj_instance_eval_internal(int argc, const VALUE *argv, VALUE self)

{

VALUE klass = singleton_class_for_eval(self);

return specific_eval(argc, argv, klass, self, RB_PASS_CALLED_KEYWORDS);

}

VALUE

rb_obj_instance_eval(int argc, const VALUE *argv, VALUE self)

{

VALUE klass = singleton_class_for_eval(self);

return specific_eval(argc, argv, klass, self, RB_NO_KEYWORDS);

}

/*

* call-seq:

* obj.instance_exec(arg...) {|var...| block } -&gt; obj

*

* Executes the given block within the context of the receiver

* (_obj_). In order to set the context, the variable +self+ is set

* to _obj_ while the code is executing, giving the code access to

* _obj_'s instance variables. Arguments are passed as block parameters.

*

* class KlassWithSecret

* def initialize

* @secret = 99

* end

* end

* k = KlassWithSecret.new

* k.instance_exec(5) {|x| @secret+x } #=&gt; 104

*/

static VALUE

rb_obj_instance_exec_internal(int argc, const VALUE *argv, VALUE self)

{

VALUE klass = singleton_class_for_eval(self);

return yield_under(klass, self, argc, argv, RB_PASS_CALLED_KEYWORDS);

}

VALUE

rb_obj_instance_exec(int argc, const VALUE *argv, VALUE self)

{

VALUE klass = singleton_class_for_eval(self);

return yield_under(klass, self, argc, argv, RB_NO_KEYWORDS);

}

/*

* call-seq:

* mod.class_eval(string [, filename [, lineno]]) -&gt; obj

* mod.class_eval {|mod| block } -&gt; obj

* mod.module_eval(string [, filename [, lineno]]) -&gt; obj

* mod.module_eval {|mod| block } -&gt; obj

*

* Evaluates the string or block in the context of _mod_, except that when

* a block is given, constant/class variable lookup is not affected. This

* can be used to add methods to a class. &lt;code&gt;module_eval&lt;/code&gt; returns

* the result of evaluating its argument. The optional _filename_ and

* _lineno_ parameters set the text for error messages.

*

* class Thing

* end

* a = %q{def hello() "</literal>Hello there!<literal type="string">" end}

* Thing.module_eval(a)

* puts Thing.new.hello()

* Thing.module_eval("</literal>invalid code<literal type="string">", "</literal>dummy<literal type="string">", 123)

*

* &lt;em&gt;produces:&lt;/em&gt;

*

* Hello there!

* dummy:123:in `module_eval': undefined local variable

* or method `code' for Thing:Class

*/

static VALUE

rb_mod_module_eval_internal(int argc, const VALUE *argv, VALUE mod)

{

return specific_eval(argc, argv, mod, mod, RB_PASS_CALLED_KEYWORDS);

}

VALUE

rb_mod_module_eval(int argc, const VALUE *argv, VALUE mod)

{

return specific_eval(argc, argv, mod, mod, RB_NO_KEYWORDS);

}

/*

* call-seq:

* mod.module_exec(arg...) {|var...| block } -&gt; obj

* mod.class_exec(arg...) {|var...| block } -&gt; obj

*

* Evaluates the given block in the context of the class/module.

* The method defined in the block will belong to the receiver.

* Any arguments passed to the method will be passed to the block.

* This can be used if the block needs to access instance variables.

*

* class Thing

* end

* Thing.class_exec{

* def hello() "</literal>Hello there!<literal type="string">" end

* }

* puts Thing.new.hello()

*

* &lt;em&gt;produces:&lt;/em&gt;

*

* Hello there!

*/

static VALUE

rb_mod_module_exec_internal(int argc, const VALUE *argv, VALUE mod)

{

return yield_under(mod, mod, argc, argv, RB_PASS_CALLED_KEYWORDS);

}

VALUE

rb_mod_module_exec(int argc, const VALUE *argv, VALUE mod)

{

return yield_under(mod, mod, argc, argv, RB_NO_KEYWORDS);

}

/*

* Document-class: UncaughtThrowError

*

* Raised when +throw+ is called with a _tag_ which does not have

* corresponding +catch+ block.

*

* throw "</literal>foo<literal type="string">", "</literal>bar<literal type="string">"

*

* &lt;em&gt;raises the exception:&lt;/em&gt;

*

* UncaughtThrowError: uncaught throw "</literal>foo<literal type="string">"

*/

static VALUE

uncaught_throw_init(int argc, const VALUE *argv, VALUE exc)

{

rb_check_arity(argc, 2, UNLIMITED_ARGUMENTS);

rb_call_super(argc - 2, argv + 2);

rb_ivar_set(exc, id_tag, argv[0]);

rb_ivar_set(exc, id_value, argv[1]);

return exc;

}

/*

* call-seq:

* uncaught_throw.tag -&gt; obj

*

* Return the tag object which was called for.

*/

static VALUE

uncaught_throw_tag(VALUE exc)

{

return rb_ivar_get(exc, id_tag);

}

/*

* call-seq:

* uncaught_throw.value -&gt; obj

*

* Return the return value which was called for.

*/

static VALUE

uncaught_throw_value(VALUE exc)

{

return rb_ivar_get(exc, id_value);

}

/*

* call-seq:

* uncaught_throw.to_s -&gt; string

*

* Returns formatted message with the inspected tag.

*/

static VALUE

uncaught_throw_to_s(VALUE exc)

{

VALUE mesg = rb_attr_get(exc, id_mesg);

VALUE tag = uncaught_throw_tag(exc);

return rb_str_format(1, &amp;tag, mesg);

}

/*

* call-seq:

* throw(tag [, obj])

*

* Transfers control to the end of the active +catch+ block

* waiting for _tag_. Raises +UncaughtThrowError+ if there

* is no +catch+ block for the _tag_. The optional second

* parameter supplies a return value for the +catch+ block,

* which otherwise defaults to +nil+. For examples, see

* Kernel::catch.

*/

static VALUE

rb_f_throw(int argc, VALUE *argv, VALUE _)

{

VALUE tag, value;

rb_scan_args(argc, argv, "</literal><literal type="number">11</literal><literal type="string">", &amp;tag, &amp;value);

rb_throw_obj(tag, value);

UNREACHABLE_RETURN(Qnil);

}

void

rb_throw_obj(VALUE tag, VALUE value)

{

rb_execution_context_t *ec = GET_EC();

struct rb_vm_tag *tt = ec-&gt;tag;

while (tt) {

if (tt-&gt;tag == tag) {

tt-&gt;retval = value;

break;

}

tt = tt-&gt;prev;

}

if (!tt) {

VALUE desc[3];

desc[0] = tag;

desc[1] = value;

desc[2] = rb_str_new_cstr("</literal>uncaught throw %p<literal type="string">");

rb_exc_raise(rb_class_new_instance(numberof(desc), desc, rb_eUncaughtThrow));

}

ec-&gt;errinfo = (VALUE)THROW_DATA_NEW(tag, NULL, TAG_THROW);

EC_JUMP_TAG(ec, TAG_THROW);

}

void

rb_throw(const char *tag, VALUE val)

{

rb_throw_obj(rb_sym_intern_ascii_cstr(tag), val);

}

static VALUE

catch_i(RB_BLOCK_CALL_FUNC_ARGLIST(tag, _))

{

return rb_yield_0(1, &amp;tag);

}

/*

* call-seq:

* catch([tag]) {|tag| block } -&gt; obj

*

* +catch+ executes its block. If +throw+ is not called, the block executes

* normally, and +catch+ returns the value of the last expression evaluated.

*

* catch(1) { 123 } #=&gt; 123

*

* If &lt;code&gt;throw(tag2, val)&lt;/code&gt; is called, Ruby searches up its stack for

* a +catch+ block whose +tag+ has the same +object_id+ as _tag2_. When found,

* the block stops executing and returns _val_ (or +nil+ if no second argument

* was given to +throw+).

*

* catch(1) { throw(1, 456) } #=&gt; 456

* catch(1) { throw(1) } #=&gt; nil

*

* When +tag+ is passed as the first argument, +catch+ yields it as the

* parameter of the block.

*

* catch(1) {|x| x + 2 } #=&gt; 3

*

* When no +tag+ is given, +catch+ yields a new unique object (as from

* +Object.new+) as the block parameter. This object can then be used as the

* argument to +throw+, and will match the correct +catch+ block.

*

* catch do |obj_A|

* catch do |obj_B|

* throw(obj_B, 123)

* puts "</literal>This puts is not reached<literal type="string">"

* end

*

* puts "</literal>This puts is displayed<literal type="string">"

* 456

* end

*

* #=&gt; 456

*

* catch do |obj_A|

* catch do |obj_B|

* throw(obj_A, 123)

* puts "</literal>This puts is still not reached<literal type="string">"

* end

*

* puts "</literal>Now this puts is also not reached<literal type="string">"

* 456

* end

*

* #=&gt; 123

*/

static VALUE

rb_f_catch(int argc, VALUE *argv, VALUE self)

{

VALUE tag = rb_check_arity(argc, 0, 1) ? argv[0] : rb_obj_alloc(rb_cObject);

return rb_catch_obj(tag, catch_i, 0);

}

VALUE

rb_catch(const char *tag, rb_block_call_func_t func, VALUE data)

{

VALUE vtag = tag ? rb_sym_intern_ascii_cstr(tag) : rb_obj_alloc(rb_cObject);

return rb_catch_obj(vtag, func, data);

}

static VALUE

vm_catch_protect(VALUE tag, rb_block_call_func *func, VALUE data,

enum ruby_tag_type *stateptr, rb_execution_context_t *volatile ec)

{

enum ruby_tag_type state;

VALUE val = Qnil; /* OK */

rb_control_frame_t *volatile saved_cfp = ec-&gt;cfp;

EC_PUSH_TAG(ec);

_tag.tag = tag;

if ((state = EC_EXEC_TAG()) == TAG_NONE) {

/* call with argc=1, argv = [tag], block = Qnil to insure compatibility */

val = (*func)(tag, data, 1, (const VALUE *)&amp;tag, Qnil);

}

else if (state == TAG_THROW &amp;&amp; THROW_DATA_VAL((struct vm_throw_data *)ec-&gt;errinfo) == tag) {

rb_vm_rewind_cfp(ec, saved_cfp);

val = ec-&gt;tag-&gt;retval;

ec-&gt;errinfo = Qnil;

state = 0;

}

EC_POP_TAG();

if (stateptr)

*stateptr = state;

return val;

}

VALUE

rb_catch_protect(VALUE t, rb_block_call_func *func, VALUE data, enum ruby_tag_type *stateptr)

{

return vm_catch_protect(t, func, data, stateptr, GET_EC());

}

VALUE

rb_catch_obj(VALUE t, rb_block_call_func_t func, VALUE data)

{

enum ruby_tag_type state;

rb_execution_context_t *ec = GET_EC();

VALUE val = vm_catch_protect(t, (rb_block_call_func *)func, data, &amp;state, ec);

if (state) EC_JUMP_TAG(ec, state);

return val;

}

static void

local_var_list_init(struct local_var_list *vars)

{

vars-&gt;tbl = rb_ident_hash_new();

RBASIC_CLEAR_CLASS(vars-&gt;tbl);

}

static VALUE

local_var_list_finish(struct local_var_list *vars)

{

/* TODO: not to depend on the order of st_table */

VALUE ary = rb_hash_keys(vars-&gt;tbl);

rb_hash_clear(vars-&gt;tbl);

vars-&gt;tbl = 0;

return ary;

}

static int

local_var_list_update(st_data_t *key, st_data_t *value, st_data_t arg, int existing)

{

if (existing) return ST_STOP;

*value = (st_data_t)Qtrue; /* INT2FIX(arg) */

return ST_CONTINUE;

}

static void

local_var_list_add(const struct local_var_list *vars, ID lid)

{

if (lid &amp;&amp; rb_is_local_id(lid)) {

/* should skip temporary variable */

st_data_t idx = 0; /* tbl-&gt;num_entries */

rb_hash_stlike_update(vars-&gt;tbl, ID2SYM(lid), local_var_list_update, idx);

}

}

/*

* call-seq:

* local_variables -&gt; array

*

* Returns the names of the current local variables.

*

* fred = 1

* for i in 1..10

* #...

* end

* local_variables #=&gt; [:fred, :i]

*/

static VALUE

rb_f_local_variables(VALUE _)

{

struct local_var_list vars;

rb_execution_context_t *ec = GET_EC();

rb_control_frame_t *cfp = vm_get_ruby_level_caller_cfp(ec, RUBY_VM_PREVIOUS_CONTROL_FRAME(ec-&gt;cfp));

unsigned int i;

local_var_list_init(&amp;vars);

while (cfp) {

if (cfp-&gt;iseq) {

for (i = 0; i &lt; cfp-&gt;iseq-&gt;body-&gt;local_table_size; i++) {

local_var_list_add(&amp;vars, cfp-&gt;iseq-&gt;body-&gt;local_table[i]);

}

}

if (!VM_ENV_LOCAL_P(cfp-&gt;ep)) {

/* block */

const VALUE *ep = VM_CF_PREV_EP(cfp);

if (vm_collect_local_variables_in_heap(ep, &amp;vars)) {

break;

}

else {

while (cfp-&gt;ep != ep) {

cfp = RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp);

}

}

}

else {

break;

}

}

return local_var_list_finish(&amp;vars);

}

/*

* call-seq:

* block_given? -&gt; true or false

* iterator? -&gt; true or false

*

* Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;yield&lt;/code&gt; would execute a

* block in the current context. The &lt;code&gt;iterator?&lt;/code&gt; form

* is mildly deprecated.

*

* def try

* if block_given?

* yield

* else

* "</literal>no block<literal type="string">"

* end

* end

* try #=&gt; "</literal>no block<literal type="string">"

* try { "</literal>hello<literal type="string">" } #=&gt; "</literal>hello<literal type="string">"

* try do "</literal>hello<literal type="string">" end #=&gt; "</literal>hello<literal type="string">"

*/

static VALUE

rb_f_block_given_p(VALUE _)

{

rb_execution_context_t *ec = GET_EC();

rb_control_frame_t *cfp = ec-&gt;cfp;

cfp = vm_get_ruby_level_caller_cfp(ec, RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp));

if (cfp != NULL &amp;&amp; VM_CF_BLOCK_HANDLER(cfp) != VM_BLOCK_HANDLER_NONE) {

return Qtrue;

}

else {

return Qfalse;

}

}

VALUE

rb_current_realfilepath(void)

{

const rb_execution_context_t *ec = GET_EC();

rb_control_frame_t *cfp = ec-&gt;cfp;

cfp = vm_get_ruby_level_caller_cfp(ec, RUBY_VM_PREVIOUS_CONTROL_FRAME(cfp));

if (cfp != 0) return rb_iseq_realpath(cfp-&gt;iseq);

return Qnil;

}

void

Init_vm_eval(void)

{

rb_define_global_function("</literal>eval<literal type="string">", rb_f_eval, -1);

rb_define_global_function("</literal>local_variables<literal type="string">", rb_f_local_variables, 0);

rb_define_global_function("</literal>iterator?<literal type="string">", rb_f_block_given_p, 0);

rb_define_global_function("</literal>block_given?<literal type="string">", rb_f_block_given_p, 0);

rb_define_global_function("</literal>catch<literal type="string">", rb_f_catch, -1);

rb_define_global_function("</literal>throw<literal type="string">", rb_f_throw, -1);

rb_define_global_function("</literal>loop<literal type="string">", rb_f_loop, 0);

rb_define_method(rb_cBasicObject, "</literal>instance_eval<literal type="string">", rb_obj_instance_eval_internal, -1);

rb_define_method(rb_cBasicObject, "</literal>instance_exec<literal type="string">", rb_obj_instance_exec_internal, -1);

rb_define_private_method(rb_cBasicObject, "</literal>method_missing<literal type="string">", rb_method_missing, -1);

#if 1

rb_add_method(rb_cBasicObject, id__send__,

VM_METHOD_TYPE_OPTIMIZED, (void *)OPTIMIZED_METHOD_TYPE_SEND, METHOD_VISI_PUBLIC);

rb_add_method(rb_mKernel, idSend,

VM_METHOD_TYPE_OPTIMIZED, (void *)OPTIMIZED_METHOD_TYPE_SEND, METHOD_VISI_PUBLIC);

#else

rb_define_method(rb_cBasicObject, "</literal>__send__<literal type="string">", rb_f_send, -1);

rb_define_method(rb_mKernel, "</literal>send<literal type="string">", rb_f_send, -1);

#endif

rb_define_method(rb_mKernel, "</literal>public_send<literal type="string">", rb_f_public_send, -1);

rb_define_method(rb_cModule, "</literal>module_exec<literal type="string">", rb_mod_module_exec_internal, -1);

rb_define_method(rb_cModule, "</literal>class_exec<literal type="string">", rb_mod_module_exec_internal, -1);

rb_define_method(rb_cModule, "</literal>module_eval<literal type="string">", rb_mod_module_eval_internal, -1);

rb_define_method(rb_cModule, "</literal>class_eval<literal type="string">", rb_mod_module_eval_internal, -1);

rb_eUncaughtThrow = rb_define_class("</literal>UncaughtThrowError<literal type="string">", rb_eArgError);

rb_define_method(rb_eUncaughtThrow, "</literal>initialize<literal type="string">", uncaught_throw_init, -1);

rb_define_method(rb_eUncaughtThrow, "</literal>tag<literal type="string">", uncaught_throw_tag, 0);

rb_define_method(rb_eUncaughtThrow, "</literal>value<literal type="string">", uncaught_throw_value, 0);

rb_define_method(rb_eUncaughtThrow, "</literal>to_s<literal type="string">", uncaught_throw_to_s, 0);

id_result = rb_intern_const("</literal>result<literal type="string">");

id_tag = rb_intern_const("</literal>tag<literal type="string">");

id_value = rb_intern_const("</literal>value<literal type="string">"</literal></argument></argument_list></macro></block_content></block></if></if_stmt></block_content></block></function>);

}

#endif /* #ifndef MJIT_HEADER */

</unit>
