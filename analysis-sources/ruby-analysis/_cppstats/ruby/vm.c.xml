<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\vm.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vm_exec</name></cpp:macro> <cpp:value>rb_vm_exec</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval_intern.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compile.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/cont.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/eval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/inits.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/mjit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/parse.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/proc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/re.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/symbol.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/vm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iseq.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mjit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/st.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/vm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_callinfo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_debug.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_exec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_insnhelper.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"probes.h"</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"probes.dmyh"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"probes_helper.h"</cpp:file></cpp:include>

<function_decl><type><name>VALUE</name></type> <name>rb_str_concat_literals</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>RUBY_FUNC_EXPORTED</name>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<name>MJIT_FUNC_EXPORTED</name>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>VALUE</name></type> <name>vm_exec</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PUREFUNC</name><argument_list>(<argument><expr><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>VALUE</name> <operator>*</operator><call><name>VM_EP_LEP</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VALUE</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>VM_EP_LEP</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>!</operator><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ep</name> <operator>=</operator> <call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>ep</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>rb_vm_search_cf_from_ep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ep</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>eocfp</name> <init>= <expr><call><name>RUBY_VM_END_CONTROL_FRAME</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<while>while <condition>(<expr><name>cfp</name> <operator>&lt;</operator> <name>eocfp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name> <operator>==</operator> <name>ep</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>cfp</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>rb_vm_ep_local_ep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_EP_LEP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<expr_stmt><expr><call><name>PUREFUNC</name><argument_list>(<argument><expr><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>VALUE</name> <operator>*</operator><call><name>VM_CF_LEP</name><argument_list>(<argument><expr><specifier>const</specifier> <name>rb_control_frame_t</name> <operator>*</operator> <specifier>const</specifier> <name>cfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>VM_CF_LEP</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_EP_LEP</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>VM_CF_PREV_EP</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>PUREFUNC</name><argument_list>(<argument>static inline VALUE VM_CF_BLOCK_HANDLER(const rb_control_frame_t * const cfp)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>VM_CF_BLOCK_HANDLER</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><call><name>VM_CF_LEP</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>VM_ENV_BLOCK_HANDLER</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_vm_cframe_keyword_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_FRAME_CFRAME_KW_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_vm_frame_block_handler</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>VM_CF_BLOCK_HANDLER</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>VM_CFP_IN_HEAP_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>+</operator> <name><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>start</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>cfp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>cfp</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>VM_EP_IN_HEAP_P</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>start</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;=</operator> <name>ep</name> <operator>&amp;&amp;</operator> <name>ep</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_ep_in_heap_p_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VM_EP_IN_HEAP_P</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>envval</name> <init>= <expr><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>envval</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>rb_env_t</name> <operator>*</operator><operator>)</operator><name>envval</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_assert_env</name><argument_list>(<argument><expr><name>envval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_ESCAPED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name> <operator>==</operator> <name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_vm_ep_in_heap_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>vm_ep_in_heap_p_</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type>

<name>VM_CFP_TO_CAPTURED_BLOCK</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>VM_CFP_IN_HEAP_P</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator>struct <name>rb_captured_block</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>VM_CAPTURED_BLOCK_TO_CFP</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>rb_control_frame_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>captured</name><operator>)</operator> <operator>-</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>VM_CFP_IN_HEAP_P</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><ternary><condition><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_control_frame_t</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">7</literal> <operator>+</operator> <name>VM_DEBUG_BP_CHECK</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>cfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>VM_BH_FROM_CFP_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_CFP_TO_CAPTURED_BLOCK</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>VM_TAGGED_PTR_REF</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>, <argument><expr><literal type="number">0x03</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>captured</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_passed_block_handler</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>passed_block_handler</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>passed_block_handler</name></name> <operator>=</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_block_handler_verify</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>block_handler</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_cref_new0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>module_func</name></decl></parameter>, <parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>prev_cref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pushed_by_eval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_prev_prev</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>refinements</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>omod_shared</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

<union>union <block>{

<decl_stmt><decl><type><name>rb_scope_visibility_t</name></type> <name>visi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>

}</block> <decl><name>scope_visi</name></decl>;</union>

<expr_stmt><expr><name><name>scope_visi</name><operator>.</operator><name>visi</name><operator>.</operator><name>method_visi</name></name> <operator>=</operator> <name>visi</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scope_visi</name><operator>.</operator><name>visi</name><operator>.</operator><name>module_func</name></name> <operator>=</operator> <name>module_func</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_cref</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>prev_cref</name> <operator>!=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">1</literal></expr> )</condition> <block>{<block_content>

<expr_stmt><expr><name>refinements</name> <operator>=</operator> <call><name>CREF_REFINEMENTS</name><argument_list>(<argument><expr><name>prev_cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>omod_shared</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CREF_OMOD_SHARED_SET</name><argument_list>(<argument><expr><name>prev_cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <operator>(</operator><name>rb_cref_t</name> <operator>*</operator><operator>)</operator><call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>imemo_cref</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>use_prev_prev</name></expr> ?</condition><then> <expr><call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>prev_cref</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>prev_cref</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>scope_visi</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>refinements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pushed_by_eval</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CREF_PUSHED_BY_EVAL_SET</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>omod_shared</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CREF_OMOD_SHARED_SET</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>cref</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_cref_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>module_func</name></decl></parameter>, <parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>prev_cref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pushed_by_eval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_cref_new0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>, <argument><expr><name>module_func</name></expr></argument>, <argument><expr><name>prev_cref</name></expr></argument>, <argument><expr><name>pushed_by_eval</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_cref_new_use_prev</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>module_func</name></decl></parameter>, <parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>prev_cref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pushed_by_eval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_cref_new0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>, <argument><expr><name>module_func</name></expr></argument>, <argument><expr><name>prev_cref</name></expr></argument>, <argument><expr><name>pushed_by_eval</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ref_delete_symkey</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>unused</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>ST_DELETE</name></expr> </then><else>: <expr><name>ST_CONTINUE</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_cref_dup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_scope_visibility_t</name> <modifier>*</modifier></type><name>visi</name> <init>= <expr><call><name>CREF_SCOPE_VISI</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>next_cref</name> <init>= <expr><call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_cref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pushed_by_eval</name> <init>= <expr><call><name>CREF_PUSHED_BY_EVAL</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>new_cref</name> <operator>=</operator> <call><name>vm_cref_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name><name>visi</name><operator>-&gt;</operator><name>method_visi</name></name></expr></argument>, <argument><expr><name><name>visi</name><operator>-&gt;</operator><name>module_func</name></name></expr></argument>, <argument><expr><name>next_cref</name></expr></argument>, <argument><expr><name>pushed_by_eval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>CREF_REFINEMENTS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ref</name> <init>= <expr><call><name>rb_hash_dup</name><argument_list>(<argument><expr><call><name>CREF_REFINEMENTS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>ref_delete_symkey</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CREF_REFINEMENTS_SET</name><argument_list>(<argument><expr><name>new_cref</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CREF_OMOD_SHARED_UNSET</name><argument_list>(<argument><expr><name>new_cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>new_cref</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>vm_cref_new_toplevel</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>vm_cref_new</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>METHOD_VISI_PRIVATE</name></expr></argument> , <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>top_wrapper</name> <init>= <expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>top_wrapper</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>top_wrapper</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>vm_cref_new</name><argument_list>(<argument><expr><name>top_wrapper</name></expr></argument>, <argument><expr><name>METHOD_VISI_PRIVATE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>cref</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_cref_t</name> <modifier>*</modifier></type>

<name>rb_vm_cref_new_toplevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_cref_new_toplevel</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_cref_dump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"vm_cref_dump: %s (%p)\n"</literal></expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>cref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"= cref| klass: %s\n"</literal></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>rb_class_path</name><argument_list>(<argument><expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>CREF_NEXT</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_block_ep_update</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>VALUE</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>ep</name></name><operator>)</operator> <operator>=</operator> <name>ep</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><call><name>VM_ENV_ENVVAL</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_bind_update_env</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>, <parameter><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>envval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name> <init>= <expr><operator>(</operator><name>rb_env_t</name> <operator>*</operator><operator>)</operator><name>envval</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_block_ep_update</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_COLLECT_USAGE_DETAILS</name></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vm_collect_usage_operand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>op</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vm_collect_usage_insn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>insn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>vm_collect_usage_register</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isset</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>vm_make_env_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>VALUE</name></type> <name>rb_vm_invoke_bmethod</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>vm_invoke_proc</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_insnhelper.c"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_exec.c"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_method.c"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_eval.c"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROCDEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><name>rb_serial_t</name></type>

<name>rb_next_class_serial</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_serial_t</name></type> <name>class_serial</name> <init>= <expr><call><name>NEXT_CLASS_SERIAL</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mjit_add_class_serial</name><argument_list>(<argument><expr><name>class_serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>class_serial</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cRubyVM</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cThread</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_mRubyVMFrozenCore</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_block_param_proxy</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ruby_vm_redefined_flag</name></cpp:macro> <cpp:value>GET_VM()-&gt;redefined_flag</cpp:value></cpp:define>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ruby_vm_const_missing_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>ruby_current_vm_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ruby_current_execution_context_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>ruby_vm_event_flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>ruby_vm_event_enabled_global_flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ruby_vm_event_local_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_serial_t</name></type> <name>ruby_vm_global_method_state</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_serial_t</name></type> <name>ruby_vm_global_constant_state</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_serial_t</name></type> <name>ruby_vm_class_serial</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>vm_empty_cc</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>thread_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>

<name>rb_vm_inc_const_missing_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>ruby_vm_const_missing_count</name> <operator>+=</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>int</name></type>

<name>rb_dtrace_setup</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>ruby_dtrace_method_hook_args</name></name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>ruby_value_type</name></name></type> <name>type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>klass</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>GET_EC</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_ec_frame_method_id_and_class</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>klass</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>klass</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id__attached__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>T_CLASS</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>T_ICLASS</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>T_MODULE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><call><name>rb_class_path</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>classname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>methodname</name> <init>= <expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>methodname</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>filename</name> <operator>=</operator> <call><name>rb_source_location_cstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>line_no</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><operator>(</operator><name>classname</name> <operator>=</operator> <call><name>StringValuePtr</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>classname</name> <operator>=</operator> <literal type="string">"&lt;unknown&gt;"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>classname</name></name> <operator>=</operator> <name>classname</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>methodname</name></name> <operator>=</operator> <name>methodname</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>klass</name></name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_stat</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_global_method_state</name></decl>, <decl><type ref="prev"/><name>sym_global_constant_state</name></decl>, <decl><type ref="prev"/><name>sym_class_serial</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>key</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"non-hash or symbol given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sym_global_method_state</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sym_##s = ID2SYM(rb_intern_const(#s))</cpp:value></cpp:define>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>global_method_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>global_constant_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>class_serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>S</name></cpp:undef>

</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>attr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (key == sym_##name) return SERIALT2NUM(attr); else if (hash != Qnil) rb_hash_aset(hash, sym_##name, SERIALT2NUM(attr));</cpp:value></cpp:define>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>global_method_state</name></expr></argument>, <argument><expr><name>ruby_vm_global_method_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>global_constant_state</name></expr></argument>, <argument><expr><name>ruby_vm_global_constant_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>class_serial</name></expr></argument>, <argument><expr><name>ruby_vm_class_serial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET</name></cpp:undef>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unknown key: %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_set_top_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>ISEQ_TYPE_TOP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"Not a toplevel InstructionSequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>VM_FRAME_MAGIC_TOP</name> <operator>|</operator> <name>VM_ENV_FLAG_LOCAL</name> <operator>|</operator> <name>VM_FRAME_FLAG_FINISH</name></expr></argument>, <argument><expr><call><name>rb_ec_thread_ptr</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>top_self</name></expr></argument>,

<argument><expr><name>VM_BLOCK_HANDLER_NONE</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>vm_cref_new_toplevel</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>, 

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_set_eval_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>base_block</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>VM_FRAME_MAGIC_EVAL</name> <operator>|</operator> <name>VM_FRAME_FLAG_FINISH</name></expr></argument>,

<argument><expr><call><name>vm_block_self</name><argument_list>(<argument><expr><name>base_block</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VM_GUARDED_PREV_EP</name><argument_list>(<argument><expr><call><name>vm_block_ep</name><argument_list>(<argument><expr><name>base_block</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cref</name></expr></argument>, 

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_set_main_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>toplevel_binding</name> <init>= <expr><call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"TOPLEVEL_BINDING"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>toplevel_binding</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_ASSERT_MESG</name><argument_list>(<argument><expr><name>bind</name></expr></argument>, <argument><expr><literal type="string">"TOPLEVEL_BINDING is not built"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_set_eval_stack</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_bind_update_env</name><argument_list>(<argument><expr><name>toplevel_binding</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><call><name>vm_make_env_object</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>rb_vm_get_binding_creatable_next_cfp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>!</operator><call><name>RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_control_frame_t</name> <operator>*</operator><operator>)</operator><name>cfp</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>rb_vm_get_ruby_level_next_cfp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_control_frame_t</name> <operator>*</operator><operator>)</operator><name>cfp</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>vm_get_ruby_level_caller_cfp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_control_frame_t</name> <operator>*</operator><operator>)</operator><name>cfp</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_control_frame_t</name> <operator>*</operator><operator>)</operator><name>cfp</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_PASSED</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_STATIC</name> <name>void</name></type>

<name>rb_vm_pop_cfunc_frame</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_C_RETURN</name></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_CMETHOD_RETURN_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>

<name>rb_vm_rewind_cfp</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name> <operator>!=</operator> <name>cfp</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VMDEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"skipped frame: %s\n"</literal></expr></argument>, <argument><expr><call><name>vm_frametype_name</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>VM_FRAME_TYPE</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>VM_FRAME_MAGIC_CFUNC</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><call><name>rb_vm_pop_cfunc_frame</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ruby_vm_at_exit</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_at_exit_list</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><call><name>ALLOC</name><argument_list>(<argument><expr><name>rb_at_exit_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>nl</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nl</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>vm</name><operator>-&gt;</operator><name>at_exit</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>at_exit</name></name> <operator>=</operator> <name>nl</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ruby_vm_run_at_exit_hooks</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_at_exit_list</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name><name>vm</name><operator>-&gt;</operator><name>at_exit</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>l</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_at_exit_list</name><modifier>*</modifier></type> <name>t</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_vm_at_exit_func</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>func</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>check_env_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>check_env</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"---\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"envptr: %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>env</name><operator>-&gt;</operator><name>ep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"envval: %10p "</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>env</name><operator>-&gt;</operator><name>ep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dp</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>ep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ep: %10p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_vm_env_prev_env</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"&gt;&gt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_env_value</name><argument_list>(<argument><expr><call><name>rb_vm_env_prev_env</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>check_env_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>check_env</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>env</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"invalid env"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_block_handler_escape</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_handler_type_ifunc</name></expr>:</case>

<case>case <expr><name>block_handler_type_iseq</name></expr>:</case>

<return>return <expr><call><name>rb_vm_make_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>VM_BH_TO_CAPT_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb_cProc</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_handler_type_symbol</name></expr>:</case>

<case>case <expr><name>block_handler_type_proc</name></expr>:</case>

<return>return <expr><name>block_handler</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>vm_block_handler_escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_make_env_each</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>ep</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>env_iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>env_body</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>env_ep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>local_size</name></decl>, <decl><type ref="prev"/><name>env_size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>VM_ENV_ENVVAL</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>prev_ep</name> <init>= <expr><call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name>prev_ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>prev_cfp</name> <init>= <expr><call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>prev_cfp</name><operator>-&gt;</operator><name>ep</name></name> <operator>!=</operator> <name>prev_ep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prev_cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>prev_cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>prev_cfp</name><operator>-&gt;</operator><name>ep</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>vm_make_env_each</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>prev_cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_FORCE_WRITE_SPECIAL_CONST</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_SPECVAL</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>VM_GUARDED_PREV_EP</name><argument_list>(<argument><expr><name><name>prev_cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>VM_ENV_BLOCK_HANDLER</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>block_handler</name> <operator>!=</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>blockprocval</name> <init>= <expr><call><name>vm_block_handler_escape</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_STACK_ENV_WRITE</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_ENV_DATA_INDEX_SPECVAL</name></expr></argument>, <argument><expr><name>blockprocval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>local_size</name> <operator>=</operator> <name>VM_ENV_DATA_SIZE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>local_size</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>+</operator> <name>VM_ENV_DATA_SIZE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>env_size</name> <operator>=</operator> <name>local_size</name> <operator>+</operator>

<literal type="number">1</literal></expr> ;</expr_stmt>

<expr_stmt><expr><name>env_body</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>env_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>env_body</name></expr></argument>, <argument><expr><name>ep</name> <operator>-</operator> <operator>(</operator><name>local_size</name> <operator>-</operator> <literal type="number">1</literal> <operator>)</operator></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>local_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

for (i = 0; i &lt; local_size; i++) {

if (VM_FRAME_RUBYFRAME_P(cfp)) {

ep[-local_size + i] = 0;

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>env_iseq</name> <operator>=</operator> <ternary><condition><expr><call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>env_ep</name> <operator>=</operator> <operator>&amp;</operator><name><name>env_body</name><index>[<expr><name>local_size</name> <operator>-</operator> <literal type="number">1</literal></expr> ]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>vm_env_new</name><argument_list>(<argument><expr><name>env_ep</name></expr></argument>, <argument><expr><name>env_body</name></expr></argument>, <argument><expr><name>env_size</name></expr></argument>, <argument><expr><name>env_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name> <operator>=</operator> <name>env_ep</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ENV_FLAGS_SET</name><argument_list>(<argument><expr><name>env_ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_ESCAPED</name> <operator>|</operator> <name>VM_ENV_FLAG_WB_REQUIRED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_STACK_ENV_WRITE</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>env</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_make_env_object</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>envval</name> <init>= <expr><call><name>vm_make_env_each</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>PROCDEBUG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_env_value</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_env_t</name> <operator>*</operator><operator>)</operator><name>envval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>envval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_stack_to_heap</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>cfp</name> <operator>=</operator> <call><name>rb_vm_get_binding_creatable_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_make_env_object</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type>

<name>rb_vm_env_prev_env</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><name><name>env</name><operator>-&gt;</operator><name>ep</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>VM_ENV_ENVVAL_PTR</name><argument_list>(<argument><expr><call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>collect_local_variables_in_iseq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>local_var_list</name></name> <modifier>*</modifier></type><name>vars</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iseq</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>local_var_list_add</name><argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>collect_local_variables_in_env</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>local_var_list</name></name> <modifier>*</modifier></type><name>vars</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>collect_local_variables_in_iseq</name><argument_list>(<argument><expr><name><name>env</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>env</name> <operator>=</operator> <call><name>rb_vm_env_prev_env</name><argument_list>(<argument><expr><name>env</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_collect_local_variables_in_heap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>local_var_list</name></name> <modifier>*</modifier></type><name>vars</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>collect_local_variables_in_env</name><argument_list>(<argument><expr><call><name>VM_ENV_ENVVAL_PTR</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_vm_env_local_variables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>local_var_list</name></name></type> <name>vars</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>local_var_list_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>collect_local_variables_in_env</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>local_var_list_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vars</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_local_variables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>local_var_list</name></name></type> <name>vars</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>local_var_list_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>collect_local_variables_in_iseq</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vars</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><call><name>local_var_list_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vars</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_proc_create_from_captured</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>rb_block_type</name></name></type> <name>block_type</name></decl></parameter>,

<parameter><decl><type><name>int8_t</name></type> <name>is_from_method</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>is_lambda</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><call><name>rb_proc_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><call><name>RTYPEDDATA_DATA</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_EP_IN_HEAP_P</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>self</name></name></expr></argument>, <argument><expr><name><name>captured</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_block_ep_update</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_block_type_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name>block_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>is_from_method</name></name> <operator>=</operator> <name>is_from_method</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name> <operator>=</operator> <name>is_lambda</name></expr>;</expr_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_block_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>self</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_block_ep_update</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>proc_create</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>is_from_method</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>is_lambda</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><call><name>rb_proc_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><call><name>RTYPEDDATA_DATA</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_EP_IN_HEAP_P</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>vm_block_ep</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_block_copy</name><argument_list>(<argument><expr><name>procval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_block_type_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>is_from_method</name></name> <operator>=</operator> <name>is_from_method</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name> <operator>=</operator> <name>is_lambda</name></expr>;</expr_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_proc_dup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>procval</name> <operator>=</operator> <call><name>proc_create</name><argument_list>(<argument><expr><name>rb_cProc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>is_from_method</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>is_lambda</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_vm_make_proc_lambda</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>int8_t</name></type> <name>is_lambda</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ENV_ESCAPED_P</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>VM_CAPTURED_BLOCK_TO_CFP</name><argument_list>(<argument><expr><name>captured</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_make_env_object</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>VM_EP_IN_HEAP_P</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>imemo_type_p</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>imemo_iseq</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>imemo_type_p</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name>imemo_ifunc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>procval</name> <operator>=</operator> <call><name>vm_proc_create_from_captured</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>,

<argument><expr><ternary><condition><expr><call><name>imemo_type</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>imemo_iseq</name></expr> ?</condition><then> <expr><name>block_type_iseq</name></expr> </then><else>: <expr><name>block_type_ifunc</name></expr></else></ternary></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>is_lambda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>procval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_vm_make_binding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>src_cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_binding_creatable_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>src_cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>ruby_level_cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>src_cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bindval</name></decl>, <decl><type ref="prev"/><name>envval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>ruby_level_cfp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"Can't create Binding Object on top of Fiber."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>envval</name> <operator>=</operator> <call><name>vm_make_env_object</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>==</operator> <name>ruby_level_cfp</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>rb_vm_get_binding_creatable_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>bindval</name> <operator>=</operator> <call><name>rb_binding_alloc</name><argument_list>(<argument><expr><name>rb_cBinding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetBindingPtr</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_bind_update_env</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>envval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>self</name></name></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name><operator>.</operator><name>as</name><operator>.</operator><name>captured</name><operator>.</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>, <argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>pathobj</name></name></expr></argument>, <argument><expr><name><name>ruby_level_cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bind</name><operator>-&gt;</operator><name>first_lineno</name></name> <operator>=</operator> <call><name>rb_vm_get_sourceline</name><argument_list>(<argument><expr><name>ruby_level_cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>bindval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>rb_binding_add_dynavars</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bindval</name></decl></parameter>, <parameter><decl><type><name>rb_binding_t</name> <modifier>*</modifier></type><name>bind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dyncount</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ID</name> <modifier>*</modifier></type><name>dynvars</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>envval</name></decl>, <decl><type ref="prev"/><name>pathobj</name> <init>= <expr><name><name>bind</name><operator>-&gt;</operator><name>pathobj</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>pathobj_path</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>realpath</name> <init>= <expr><call><name>pathobj_realpath</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>base_block</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_env_t</name> <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>base_iseq</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_ast_body_t</name></type> <name>ast</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>NODE</name></type> <name>tmp_node</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name><name>minibuf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dyns</name> <init>= <expr><name>minibuf</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>idtmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dyncount</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>base_block</name> <operator>=</operator> <operator>&amp;</operator><name><name>bind</name><operator>-&gt;</operator><name>block</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>base_iseq</name> <operator>=</operator> <call><name>vm_block_iseq</name><argument_list>(<argument><expr><name>base_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dyncount</name> <operator>&gt;=</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>minibuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dyns</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>idtmp</name></expr></argument>, <argument><expr><name>dyncount</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dyns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>dyncount</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>dyns</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>dynvars</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>, <argument><expr><name>dyncount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_node_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_node</name></expr></argument>, <argument><expr><name>NODE_SCOPE</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dyns</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ast</name><operator>.</operator><name>root</name></name> <operator>=</operator> <operator>&amp;</operator><name>tmp_node</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ast</name><operator>.</operator><name>compile_option</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ast</name><operator>.</operator><name>line_count</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>base_iseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>rb_iseq_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ast</name></expr></argument>, <argument><expr><name><name>base_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>, <argument><expr><name>base_iseq</name></expr></argument>, <argument><expr><name>ISEQ_TYPE_EVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tempstr</name> <init>= <expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"&lt;temp&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>rb_iseq_new_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ast</name></expr></argument>, <argument><expr><name>tempstr</name></expr></argument>, <argument><expr><name>tempstr</name></expr></argument>, <argument><expr><name>tempstr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>tmp_node</name><operator>.</operator><name>nd_tbl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>idtmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_set_eval_stack</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>base_block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_bind_update_env</name><argument_list>(<argument><expr><name>bindval</name></expr></argument>, <argument><expr><name>bind</name></expr></argument>, <argument><expr><name>envval</name> <operator>=</operator> <call><name>vm_make_env_object</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>rb_env_t</name> <operator>*</operator><operator>)</operator><name>envval</name></expr>;</expr_stmt>

<return>return <expr><name><name>env</name><operator>-&gt;</operator><name>env</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>invoke_block</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt_pc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>arg_size</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>type</name> <operator>|</operator> <name>VM_FRAME_FLAG_FINISH</name></expr></argument>, <argument><expr><name>self</name></expr></argument>,

<argument><expr><call><name>VM_GUARDED_PREV_EP</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cref</name></expr></argument>, 

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>+</operator> <name>opt_pc</name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>+</operator> <name>arg_size</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name>arg_size</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>invoke_bmethod</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt_pc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>arg_size</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>hooks</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_BMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>type</name> <operator>|</operator> <name>VM_FRAME_FLAG_BMETHOD</name></expr></argument>, <argument><expr><name>self</name></expr></argument>,

<argument><expr><call><name>VM_GUARDED_PREV_EP</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>me</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>+</operator> <name>opt_pc</name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>+</operator> <name>arg_size</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name>arg_size</name></expr></argument>,

<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_METHOD_ENTRY_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_CALL</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>(</operator><name>hooks</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>hooks</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name><name>hooks</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>RUBY_EVENT_CALL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_exec_event_hook_orig</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>hooks</name></expr></argument>, <argument><expr><name>RUBY_EVENT_CALL</name></expr></argument>, <argument><expr><name>self</name></expr></argument>,

<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>VM_ENV_FLAGS_SET</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>vm_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>hooks</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>hooks</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>

<name><name>hooks</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>RUBY_EVENT_RETURN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_exec_event_hook_orig</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>hooks</name></expr></argument>, <argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>, <argument><expr><name>self</name></expr></argument>,

<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_METHOD_RETURN_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<macro><name>ALWAYS_INLINE</name><argument_list>(<argument>static VALUE

invoke_iseq_block_from_c(rb_execution_context_t *ec, const struct rb_captured_block *captured,

VALUE self, int argc, const VALUE *argv, int kw_splat, VALUE passed_block_handler,

const rb_cref_t *cref, int is_lambda, const rb_callable_method_entry_t *me)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>invoke_iseq_block_from_c</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_block_handler</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_lambda</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>opt_pc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>type</name> <init>= <expr><name>VM_FRAME_MAGIC_BLOCK</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>is_lambda</name></expr> ?</condition><then> <expr><name>VM_FRAME_FLAG_LAMBDA</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>stack_check</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_VM_STACK_OVERFLOW</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_check_canary</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>sp</name> <operator>+</operator> <name>argc</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>sp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>opt_pc</name> <operator>=</operator> <call><name>vm_yield_setup_args</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>,

<argument><expr><operator>(</operator><ternary><condition><expr><name>is_lambda</name></expr> ?</condition><then> <expr><name>arg_setup_method</name></expr> </then><else>: <expr><name>arg_setup_block</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>invoke_block</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>opt_pc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>invoke_bmethod</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>opt_pc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>invoke_block_from_c_bh</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_block_handler</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>is_lambda</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>force_blockarg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<label><name>again</name>:</label>

<switch>switch <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_handler_type_iseq</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_BH_TO_ISEQ_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>invoke_iseq_block_from_c</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>captured</name></expr></argument>, <argument><expr><name><name>captured</name><operator>-&gt;</operator><name>self</name></name></expr></argument>,

<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>,

<argument><expr><name>cref</name></expr></argument>, <argument><expr><name>is_lambda</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block>

<case>case <expr><name>block_handler_type_ifunc</name></expr>:</case>

<return>return <expr><call><name>vm_yield_with_cfunc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>VM_BH_TO_IFUNC_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>VM_BH_TO_IFUNC_BLOCK</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>self</name></expr></argument>,

<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_handler_type_symbol</name></expr>:</case>

<return>return <expr><call><name>vm_yield_with_symbol</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>VM_BH_TO_SYMBOL</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_handler_type_proc</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>force_blockarg</name> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_lambda</name> <operator>=</operator> <call><name>block_proc_is_lambda</name><argument_list>(<argument><expr><call><name>VM_BH_TO_PROC</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>block_handler</name> <operator>=</operator> <call><name>vm_proc_to_block_handler</name><argument_list>(<argument><expr><call><name>VM_BH_TO_PROC</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>invoke_block_from_c_splattable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>check_block_handler</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>block_handler</name> <init>= <expr><call><name>VM_CF_BLOCK_HANDLER</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_block_handler_verify</name><argument_list>(<argument><expr><name>block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>block_handler</name> <operator>==</operator> <name>VM_BLOCK_HANDLER_NONE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_localjump_error</name><argument_list>(<argument><expr><literal type="string">"no block given"</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>block_handler</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_yield_with_cref</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_lambda</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>invoke_block_from_c_bh</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>check_block_handler</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>VM_BLOCK_HANDLER_NONE</name></expr></argument>,

<argument><expr><name>cref</name></expr></argument>, <argument><expr><name>is_lambda</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_yield</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>invoke_block_from_c_bh</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>check_block_handler</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>VM_BLOCK_HANDLER_NONE</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_yield_with_block</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>invoke_block_from_c_bh</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>check_block_handler</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_yield_force_blockarg</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>invoke_block_from_c_bh</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><call><name>check_block_handler</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>,

<argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>, <argument><expr><name>VM_BLOCK_HANDLER_NONE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>ALWAYS_INLINE</name><argument_list>(<argument>static VALUE

invoke_block_from_c_proc(rb_execution_context_t *ec, const rb_proc_t *proc,

VALUE self, int argc, const VALUE *argv,

int kw_splat, VALUE passed_block_handler, int is_lambda,

const rb_callable_method_entry_t *me)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>invoke_block_from_c_proc</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_block_handler</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_lambda</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_block</name></name> <modifier>*</modifier></type><name>block</name> <init>= <expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>

<switch>switch <condition>(<expr><call><name>vm_block_type</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>block_type_iseq</name></expr>:</case>

<return>return <expr><call><name>invoke_iseq_block_from_c</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name></name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>is_lambda</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_ifunc</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>kw_splat</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>keyword_hash</name> <init>= <expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>keyword_hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>keyword_hash</name> <operator>=</operator> <call><name>rb_to_hash_type</name><argument_list>(<argument><expr><name>keyword_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>keyword_hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argc</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>argv</name><operator>)</operator><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index> <operator>=</operator> <call><name>rb_hash_dup</name><argument_list>(<argument><expr><name>keyword_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>vm_yield_with_cfunc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>captured</name></name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_symbol</name></expr>:</case>

<return>return <expr><call><name>vm_yield_with_symbol</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>symbol</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>block_type_proc</name></expr>:</case>

<expr_stmt><expr><name>is_lambda</name> <operator>=</operator> <call><name>block_proc_is_lambda</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>vm_proc_block</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>VM_UNREACHABLE</name><argument_list>(<argument><expr><name>invoke_block_from_c_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_invoke_proc</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>invoke_block_from_c_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>is_lambda</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_vm_invoke_bmethod</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>invoke_block_from_c_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_vm_invoke_proc</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_block_handler</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name> <init>= <expr><call><name>vm_block_self</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>block</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_block_handler_verify</name><argument_list>(<argument><expr><name>passed_block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>is_from_method</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_vm_invoke_bmethod</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>vm_invoke_proc</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>vm_normal_frame</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name><name>cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RUBY_VM_CONTROL_FRAME_STACK_OVERFLOW_P</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>cfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_cfp_svar_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>vm_normal_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>lep_svar_get</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><ternary><condition><expr><name>cfp</name></expr> ?</condition><then> <expr><call><name>VM_CF_LEP</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_cfp_svar_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>vm_normal_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>lep_svar_set</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><ternary><condition><expr><name>cfp</name></expr> ?</condition><then> <expr><call><name>VM_CF_LEP</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_svar_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_cfp_svar_get</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_svar_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_cfp_svar_set</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_backref_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_svar_get</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>VM_SVAR_BACKREF</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_backref_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_svar_set</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>VM_SVAR_BACKREF</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_lastline_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vm_svar_get</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>VM_SVAR_LASTLINE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_lastline_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_svar_set</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>VM_SVAR_LASTLINE</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_sourcefile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_sourceline</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_vm_get_sourceline</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_source_location</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pline</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>&amp;&amp;</operator> <call><name>VM_FRAME_RUBYFRAME_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pline</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pline</name> <operator>=</operator> <call><name>rb_vm_get_sourceline</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pline</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pline</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_source_location_cstr</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pline</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_source_location</name><argument_list>(<argument><expr><name>pline</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_cref_t</name> <modifier>*</modifier></type>

<name>rb_vm_cref</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>vm_ec_cref</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_cref_t</name> <modifier>*</modifier></type>

<name>rb_vm_cref_replace_with_duplicated_cref</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>vm_cref_replace_with_duplicated_cref</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>cref</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type>

<name>rb_vm_cref_in_context</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cfp</name> <operator>||</operator> <name><name>cfp</name><operator>-&gt;</operator><name>self</name></name> <operator>!=</operator> <name>self</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vm_env_cref_by_cref</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cref</name> <operator>=</operator> <call><name>vm_get_cref</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CREF_CLASS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>cbase</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>cref</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

void

debug_cref(rb_cref_t *cref)

{

while (cref) {

dp(CREF_CLASS(cref));

printf("%ld\n", CREF_VISI(cref));

cref = CREF_NEXT(cref);

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>VALUE</name></type>

<name>rb_vm_cbase</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"Can't call on top of Fiber or Thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>vm_get_cbase</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>make_localjump_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>extern</specifier> <name>VALUE</name></type> <name>rb_eLocalJumpError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_exc_new2</name><argument_list>(<argument><expr><name>rb_eLocalJumpError</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>reason</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TAG_BREAK</name></expr>:</case>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"break"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TAG_REDO</name></expr>:</case>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"redo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TAG_RETRY</name></expr>:</case>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"retry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TAG_NEXT</name></expr>:</case>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"next"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TAG_RETURN</name></expr>:</case>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"return"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"noreason"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_iv_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><literal type="string">"@exit_value"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_iv_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><literal type="string">"@reason"</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>

<name>rb_vm_localjump_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>make_localjump_error</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_vm_make_jump_tag_but_local_jump</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>state</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TAG_RETURN</name></expr>:</case>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <literal type="string">"unexpected return"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TAG_BREAK</name></expr>:</case>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <literal type="string">"unexpected break"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TAG_NEXT</name></expr>:</case>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <literal type="string">"unexpected next"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TAG_REDO</name></expr>:</case>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <literal type="string">"unexpected redo"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TAG_RETRY</name></expr>:</case>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <literal type="string">"retry outside of rescue clause"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>tag</name><operator>-&gt;</operator><name>retval</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>make_localjump_error</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_jump_tag_but_local_jump</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_vm_make_jump_tag_but_local_jump</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type>

<name>next_not_local_frame</name><parameter_list>(<parameter><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>cfp</name></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void vm_iter_break(rb_execution_context_t *ec, VALUE val)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_iter_break</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>next_not_local_frame</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><call><name>VM_CF_PREV_EP</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>target_cfp</name> <init>= <expr><call><name>rb_vm_search_cf_from_ep</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

if (!target_cfp) {

rb_vm_localjump_error("unexpected break", val, TAG_BREAK);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>THROW_DATA_NEW</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>target_cfp</name></expr></argument>, <argument><expr><name>TAG_BREAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TAG_BREAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iter_break</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_iter_break</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iter_break_value</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_iter_break</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>vm_opt_method_table</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>vm_opt_mid_table</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_redefinition_check_flag</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cInteger</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>INTEGER_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cFloat</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FLOAT_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cString</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>STRING_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cArray</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ARRAY_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cHash</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>HASH_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cSymbol</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>SYMBOL_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cTime</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TIME_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cRegexp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REGEXP_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cNilClass</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NIL_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cTrueClass</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cFalseClass</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cProc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PROC_REDEFINED_OP_FLAG</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_vm_check_optimizable_mid</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vm_opt_mid_table</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>vm_opt_mid_table</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_redefinition_check_method_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<return>return <expr><name>TRUE</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_vm_check_redefinition_opt_method</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>bop</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FL_TEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>RICLASS_IS_ORIGIN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_redefinition_check_method_type</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>vm_opt_method_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bop</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><call><name>vm_redefinition_check_flag</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ruby_vm_redefined_flag</name><index>[<expr><name>bop</name></expr>]</index></name> <operator>|=</operator> <name>flag</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>check_redefined_method</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>newme</name> <init>= <expr><call><name>rb_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>newme</name> <operator>!=</operator> <name>me</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_vm_check_redefinition_opt_method</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_check_redefinition_by_prepend</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vm_redefinition_check_flag</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>check_redefined_method</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>add_opt_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>bop</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_method_entry_at</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name> <operator>&amp;&amp;</operator> <call><name>vm_redefinition_check_method_type</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>vm_opt_method_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>me</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>bop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>vm_opt_mid_table</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>mid</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"undefined optimized method: %s"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_init_redefined_flag</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bop</name></decl>;</decl_stmt>

<expr_stmt><expr><name>vm_opt_method_table</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vm_opt_mid_table</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP</name><parameter_list>(<parameter><type><name>mid_</name></type></parameter>, <parameter><type><name>bop_</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(mid = id##mid_, bop = BOP_##bop_, ruby_vm_redefined_flag[bop] = 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>add_opt_method(rb_c##k, mid, bop)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>PLUS</name></expr></argument>, <argument><expr><name>PLUS</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Array</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>MINUS</name></expr></argument>, <argument><expr><name>MINUS</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>MULT</name></expr></argument>, <argument><expr><name>MULT</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>DIV</name></expr></argument>, <argument><expr><name>DIV</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>MOD</name></expr></argument>, <argument><expr><name>MOD</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Eq</name></expr></argument>, <argument><expr><name>EQ</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Symbol</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Eqq</name></expr></argument>, <argument><expr><name>EQQ</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Symbol</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>C</name><argument_list>(<argument><expr><name>NilClass</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>TrueClass</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>FalseClass</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>LT</name></expr></argument>, <argument><expr><name>LT</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>LE</name></expr></argument>, <argument><expr><name>LE</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>GT</name></expr></argument>, <argument><expr><name>GT</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>GE</name></expr></argument>, <argument><expr><name>GE</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Float</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>LTLT</name></expr></argument>, <argument><expr><name>LTLT</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Array</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>AREF</name></expr></argument>, <argument><expr><name>AREF</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Array</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>ASET</name></expr></argument>, <argument><expr><name>ASET</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Array</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Length</name></expr></argument>, <argument><expr><name>LENGTH</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Array</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Size</name></expr></argument>, <argument><expr><name>SIZE</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Array</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>EmptyP</name></expr></argument>, <argument><expr><name>EMPTY_P</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Array</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Succ</name></expr></argument>, <argument><expr><name>SUCC</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>Time</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>EqTilde</name></expr></argument>, <argument><expr><name>MATCH</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Regexp</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Freeze</name></expr></argument>, <argument><expr><name>FREEZE</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>UMinus</name></expr></argument>, <argument><expr><name>UMINUS</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Max</name></expr></argument>, <argument><expr><name>MAX</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Array</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Min</name></expr></argument>, <argument><expr><name>MIN</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Array</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Call</name></expr></argument>, <argument><expr><name>CALL</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Proc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>And</name></expr></argument>, <argument><expr><name>AND</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>Or</name></expr></argument>, <argument><expr><name>OR</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>Integer</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OP</name><argument_list>(<argument><expr><name>NilP</name></expr></argument>, <argument><expr><name>NIL_P</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><operator>(</operator><call><name>C</name><argument_list>(<argument><expr><name>NilClass</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>C</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OP</name></cpp:undef>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VMDEBUG</name></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>vm_frametype_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>VM_FRAME_TYPE</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_FRAME_MAGIC_METHOD</name></expr>:</case> <return>return <expr><literal type="string">"method"</literal></expr>;</return>

<case>case <expr><name>VM_FRAME_MAGIC_BLOCK</name></expr>:</case> <return>return <expr><literal type="string">"block"</literal></expr>;</return>

<case>case <expr><name>VM_FRAME_MAGIC_CLASS</name></expr>:</case> <return>return <expr><literal type="string">"class"</literal></expr>;</return>

<case>case <expr><name>VM_FRAME_MAGIC_TOP</name></expr>:</case> <return>return <expr><literal type="string">"top"</literal></expr>;</return>

<case>case <expr><name>VM_FRAME_MAGIC_CFUNC</name></expr>:</case> <return>return <expr><literal type="string">"cfunc"</literal></expr>;</return>

<case>case <expr><name>VM_FRAME_MAGIC_IFUNC</name></expr>:</case> <return>return <expr><literal type="string">"ifunc"</literal></expr>;</return>

<case>case <expr><name>VM_FRAME_MAGIC_EVAL</name></expr>:</case> <return>return <expr><literal type="string">"eval"</literal></expr>;</return>

<case>case <expr><name>VM_FRAME_MAGIC_RESCUE</name></expr>:</case> <return>return <expr><literal type="string">"rescue"</literal></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unknown frame"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>frame_return_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>THROW_DATA_P</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>THROW_DATA_STATE</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TAG_BREAK</name> <operator>&amp;&amp;</operator>

<call><name>THROW_DATA_CONSUMED_P</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>THROW_DATA_VAL</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static const char *

frame_name(const rb_control_frame_t *cfp)

{

unsigned long type = VM_FRAME_TYPE(cfp);

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (type == VM_FRAME_MAGIC_##t) return #t</cpp:value></cpp:define>

C(METHOD);

C(BLOCK);

C(CLASS);

C(TOP);

C(CFUNC);

C(PROC);

C(IFUNC);

C(EVAL);

C(LAMBDA);

C(RESCUE);

C(DUMMY);

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>C</name></cpp:undef>

return "unknown";

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>hook_before_rewind</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>will_finish_vm_exec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_RAISE</name> <operator>&amp;&amp;</operator> <call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_eSysStackError</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_hook_list_t</name> <modifier>*</modifier></type><name>local_hooks</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>VM_FRAME_TYPE</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_FRAME_MAGIC_METHOD</name></expr>:</case>

<expr_stmt><expr><call><name>RUBY_DTRACE_METHOD_RETURN_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK_AND_POP_FRAME</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>frame_return_value</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>local_hooks</name> <operator>&amp;&amp;</operator> <name><name>local_hooks</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>RUBY_EVENT_RETURN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_exec_event_hook_orig</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>local_hooks</name></expr></argument>, <argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>frame_return_value</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>THROW_DATA_CONSUMED_SET</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_BLOCK</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>VM_FRAME_BMETHOD_P</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_B_RETURN</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>frame_return_value</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>local_hooks</name> <operator>&amp;&amp;</operator> <name><name>local_hooks</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>RUBY_EVENT_B_RETURN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_exec_event_hook_orig</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>local_hooks</name></expr></argument>, <argument><expr><name>RUBY_EVENT_B_RETURN</name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>frame_return_value</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>will_finish_vm_exec</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK_AND_POP_FRAME</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>owner</name></expr></argument>,

<argument><expr><call><name>frame_return_value</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_BMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>local_hooks</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>hooks</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>local_hooks</name> <operator>&amp;&amp;</operator> <name><name>local_hooks</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>RUBY_EVENT_RETURN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_exec_event_hook_orig</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>local_hooks</name></expr></argument>, <argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>owner</name></expr></argument>,

<argument><expr><call><name>frame_return_value</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>THROW_DATA_CONSUMED_SET</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK_AND_POP_FRAME</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_B_RETURN</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>frame_return_value</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>local_hooks</name> <operator>&amp;&amp;</operator> <name><name>local_hooks</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name>RUBY_EVENT_B_RETURN</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_exec_event_hook_orig</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>local_hooks</name></expr></argument>, <argument><expr><name>RUBY_EVENT_B_RETURN</name></expr></argument>,

<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>frame_return_value</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>THROW_DATA_CONSUMED_SET</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>VM_FRAME_MAGIC_CLASS</name></expr>:</case>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK_AND_POP_FRAME</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_END</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_exec_handle_exception</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>errinfo</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>initial</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>VALUE</name></type>

<name>vm_exec</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mjit_enable_p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qundef</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>initial</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>_tag</name><operator>.</operator><name>retval</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mjit_enable_p</name> <operator>||</operator> <operator>(</operator><name>result</name> <operator>=</operator> <call><name>mjit_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>vm_exec_core</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>initial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>vm_loop_start</name>;</goto> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ec_raised_reset</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RAISED_STACKOVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>vm_exec_handle_exception</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>initial</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>vm_exec_core</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>initial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>vm_loop_start</name>:</label>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name></name> <operator>==</operator> <operator>&amp;</operator><name>_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <name><name>_tag</name><operator>.</operator><name>state</name></name><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>_tag</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TAG_NONE</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>vm_exec_handle_exception</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>errinfo</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>initial</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>vm_throw_data</name></name> <modifier>*</modifier></type><name>err</name> <init>= <expr><operator>(</operator>struct <name>vm_throw_data</name> <operator>*</operator><operator>)</operator><name>errinfo</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier></type><name>ct</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>epc</name></decl>, <decl><type ref="prev"/><name>cont_pc</name></decl>, <decl><type ref="prev"/><name>cont_sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>catch_iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>escape_cfp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cont_pc</name> <operator>=</operator> <name>cont_sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>catch_iseq</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><call><name>VM_FRAME_TYPE</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>VM_FRAME_MAGIC_CFUNC</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK_AND_POP_FRAME</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_C_RETURN</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>owner</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_CMETHOD_RETURN_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>owner</name></expr></argument>,

<argument><expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>epc</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_BREAK</name> <operator>||</operator> <name>state</name> <operator>==</operator> <name>TAG_RETURN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <call><name>THROW_DATA_CATCH_FRAME</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>==</operator> <name>escape_cfp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_RETURN</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_FRAME_FINISHED_P</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>THROW_DATA_CATCH_FRAME_SET</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>cfp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>THROW_DATA_STATE_SET</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>state</name> <operator>=</operator> <name>TAG_BREAK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ct</name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name>epc</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;=</operator> <name>epc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_ENSURE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>catch_iseq</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_pc</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>cont</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_sp</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>catch_iseq</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>THROW_DATA_CATCH_FRAME_SET</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>cfp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hook_before_rewind</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>THROW_DATA_VAL</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_STACK_CACHING</name></expr></cpp:if>

<expr_stmt><expr><operator>*</operator><name>initial</name> <operator>=</operator> <call><name>THROW_DATA_VAL</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><operator>*</operator><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>sp</name></name><operator>++</operator> <operator>=</operator> <call><name>THROW_DATA_VAL</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_RAISE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ct</name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name>epc</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;=</operator> <name>epc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_RESCUE</name> <operator>||</operator>

<name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_ENSURE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>catch_iseq</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_pc</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>cont</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_sp</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_RETRY</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ct</name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name>epc</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;=</operator> <name>epc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_ENSURE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>catch_iseq</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_pc</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>cont</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_sp</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_RETRY</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>escape_cfp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>escape_cfp</name> <operator>=</operator> <call><name>THROW_DATA_CATCH_FRAME</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>==</operator> <name>escape_cfp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>+</operator> <name><name>entry</name><operator>-&gt;</operator><name>cont</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_BREAK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>escape_cfp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>CATCH_TYPE_BREAK</name></expr>;</expr_stmt>

<label><name>search_restart_point</name>:</label>

<expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ct</name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name>epc</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;=</operator> <name>epc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_ENSURE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>catch_iseq</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_pc</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>cont</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_sp</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>+</operator> <name><name>entry</name><operator>-&gt;</operator><name>cont</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <call><name>vm_base_ptr</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>entry</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>TAG_REDO</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_STACK_CACHING</name></expr></cpp:if>

<expr_stmt><expr><operator>*</operator><name>initial</name> <operator>=</operator> <call><name>THROW_DATA_VAL</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><operator>*</operator><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>sp</name></name><operator>++</operator> <operator>=</operator> <call><name>THROW_DATA_VAL</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>TAG_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_REDO</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>CATCH_TYPE_REDO</name></expr>;</expr_stmt>

<goto>goto <name>search_restart_point</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>state</name> <operator>==</operator> <name>TAG_NEXT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>CATCH_TYPE_NEXT</name></expr>;</expr_stmt>

<goto>goto <name>search_restart_point</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ct</name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ct</name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ct</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>start</name></name> <operator>&lt;</operator> <name>epc</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>end</name></name> <operator>&gt;=</operator> <name>epc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>CATCH_TYPE_ENSURE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>catch_iseq</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_pc</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>cont</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cont_sp</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>sp</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>catch_iseq</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>arg_size</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name>catch_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>=</operator> <call><name>vm_base_ptr</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>cont_sp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name> <operator>+</operator> <name>cont_pc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>err</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>catch_iseq</name></expr></argument>, <argument><expr><name>VM_FRAME_MAGIC_RESCUE</name></expr></argument>,

<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>,

<argument><expr><call><name>VM_GUARDED_PREV_EP</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, 

<argument><expr><name><name>catch_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></argument>,

<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>sp</name></name> <operator>+</operator> <name>arg_size</name></expr></argument> ,

<argument><expr><name><name>catch_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <name>arg_size</name></expr></argument>,

<argument><expr><name><name>catch_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>TAG_NONE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>hook_before_rewind</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_FRAME_FINISHED_P</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>err</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_eval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_set_top_stack</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>vm_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_eval_main</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_set_main_stack</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>vm_exec</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_vm_control_frame_id_and_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>, <parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>idp</name></decl></parameter>, <parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>called_idp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>klassp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_vm_frame_method_entry</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>idp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>idp</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>called_idp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>called_idp</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>klassp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>klassp</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_ec_frame_method_id_and_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>idp</name></decl></parameter>, <parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>called_idp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>klassp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_vm_control_frame_id_and_class</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>, <argument><expr><name>idp</name></expr></argument>, <argument><expr><name>called_idp</name></expr></argument>, <argument><expr><name>klassp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_frame_method_id_and_class</name><parameter_list>(<parameter><decl><type><name>ID</name> <modifier>*</modifier></type><name>idp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>klassp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_ec_frame_method_id_and_class</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>idp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>klassp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_vm_call_cfunc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>block_handler</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>filename</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_control_frame_t</name> <modifier>*</modifier></type><name>reg_cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>rb_iseq_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ISEQ_TYPE_TOP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>VM_FRAME_MAGIC_TOP</name> <operator>|</operator> <name>VM_ENV_FLAG_LOCAL</name> <operator>|</operator> <name>VM_FRAME_FLAG_FINISH</name></expr></argument>,

<argument><expr><name>recv</name></expr></argument>, <argument><expr><name>block_handler</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>vm_cref_new_toplevel</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></argument>, 

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>reg_cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_pop_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_update_references</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_update_tbl_refs</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>frozen_strings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_MARK_ENTER</name><argument_list>(<argument><expr><literal type="string">"vm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_GC_INFO</name><argument_list>(<argument><expr><literal type="string">"-------------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>obj_ary</name></decl>;</decl_stmt>

<macro><name>list_for_each</name><argument_list>(<argument>&amp;vm-&gt;living_threads</argument>, <argument>th</argument>, <argument>vmlt_node</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>thgroup_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>mark_object_ary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>mark_object_ary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>obj_ary</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>mark_object_ary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>jlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><operator>*</operator><name>obj_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>jlen</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><operator>*</operator><name>obj_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><operator>*</operator><name>obj_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>jlen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>obj_ary</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>load_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>load_path_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>load_path_check_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>expanded_load_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>loaded_features</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>loaded_features_snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>top_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>orig_progname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>coverages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_mark_tbl</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>defined_module_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>loading_table</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_mark_tbl</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>loading_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_hook_list_mark</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>global_hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_values</name><argument_list>(<argument><expr><name>RUBY_NSIG</name></expr></argument>, <argument><expr><name><name>vm</name><operator>-&gt;</operator><name>trap_list</name><operator>.</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mjit_mark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_LEAVE</name><argument_list>(<argument><expr><literal type="string">"vm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_vm_register_special_exception</name></cpp:undef>

<function><type><name>void</name></type>

<name>rb_vm_register_special_exception_str</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>ruby_special_exceptions</name></name></type> <name>sp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cls</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>cls</name></expr></argument>, <argument><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>vm</name><operator>-&gt;</operator><name>special_exceptions</name></name><operator>)</operator><index>[<expr><name>sp</name></expr>]</index> <operator>=</operator> <name>exc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_vm_add_root_module</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>defined_module_hash</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>module</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>free_loading_table_entry</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_DELETE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>ruby_vm_destruct</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_FREE_ENTER</name><argument_list>(<argument><expr><literal type="string">"vm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vm</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><name><name>vm</name><operator>-&gt;</operator><name>main_thread</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_objspace</name></name> <modifier>*</modifier></type><name>objspace</name> <init>= <expr><name><name>vm</name><operator>-&gt;</operator><name>objspace</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>main_thread</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>th</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_fiber_reset_root_local_storage</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_free</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_vm_living_threads_init</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_vm_run_at_exit_hooks</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>loading_table</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>loading_table</name></name></expr></argument>, <argument><expr><name>free_loading_table_entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>loading_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>loading_table</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>-&gt;</operator><name>frozen_strings</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>frozen_strings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>frozen_strings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_vm_gvl_destroy</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_ALTSTACK_FREE</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>main_altstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>objspace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_objspace_free</name><argument_list>(<argument><expr><name>objspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ruby_mimfree</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ruby_current_vm_ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_FREE_LEAVE</name><argument_list>(<argument><expr><literal type="string">"vm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>vm_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_vm_t</name> <modifier>*</modifier></type><name>vmobj</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_vm_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>vmobj</name><operator>-&gt;</operator><name>living_thread_num</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rb_thread_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vmobj</name><operator>-&gt;</operator><name>defined_strings</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name>DEFINED_EXPR</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>vm_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"VM"</literal></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>vm_memsize</name></expr>,}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_default_params</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_hash_aset(result, ID2SYM(rb_intern(#name)), SIZET2NUM(vm-&gt;default_params.name));</cpp:value></cpp:define>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>thread_vm_stack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>thread_machine_stack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>fiber_vm_stack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET</name><argument_list>(<argument><expr><name>fiber_machine_stack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET</name></cpp:undef>

<expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>get_param</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>default_value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>min_value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>envval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr><name>default_value</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>envval</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>val</name> <init>= <expr><call><name>atol</name><argument_list>(<argument><expr><name>envval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <operator>(</operator><name>long</name><operator>)</operator><name>min_value</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>min_value</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>val</name> <operator>-</operator><literal type="number">1</literal> <operator>+</operator> <name>RUBY_VM_SIZE_ALIGN</name><operator>)</operator> <operator>/</operator> <name>RUBY_VM_SIZE_ALIGN</name><operator>)</operator> <operator>*</operator> <name>RUBY_VM_SIZE_ALIGN</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>check_machine_stack_size</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>sizep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTHREAD_STACK_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><operator>*</operator><name>sizep</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTHREAD_STACK_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>PTHREAD_STACK_MIN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <name>PTHREAD_STACK_MIN</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_default_params_setup</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>thread_vm_stack_size</name></name> <operator>=</operator>

<call><name>get_param</name><argument_list>(<argument><expr><literal type="string">"RUBY_THREAD_VM_STACK_SIZE"</literal></expr></argument>,

<argument><expr><name>RUBY_VM_THREAD_VM_STACK_SIZE</name></expr></argument>,

<argument><expr><name>RUBY_VM_THREAD_VM_STACK_SIZE_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>thread_machine_stack_size</name></name> <operator>=</operator>

<call><name>get_param</name><argument_list>(<argument><expr><literal type="string">"RUBY_THREAD_MACHINE_STACK_SIZE"</literal></expr></argument>,

<argument><expr><name>RUBY_VM_THREAD_MACHINE_STACK_SIZE</name></expr></argument>,

<argument><expr><name>RUBY_VM_THREAD_MACHINE_STACK_SIZE_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>fiber_vm_stack_size</name></name> <operator>=</operator>

<call><name>get_param</name><argument_list>(<argument><expr><literal type="string">"RUBY_FIBER_VM_STACK_SIZE"</literal></expr></argument>,

<argument><expr><name>RUBY_VM_FIBER_VM_STACK_SIZE</name></expr></argument>,

<argument><expr><name>RUBY_VM_FIBER_VM_STACK_SIZE_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>fiber_machine_stack_size</name></name> <operator>=</operator>

<call><name>get_param</name><argument_list>(<argument><expr><literal type="string">"RUBY_FIBER_MACHINE_STACK_SIZE"</literal></expr></argument>,

<argument><expr><name>RUBY_VM_FIBER_MACHINE_STACK_SIZE</name></expr></argument>,

<argument><expr><name>RUBY_VM_FIBER_MACHINE_STACK_SIZE_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_machine_stack_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>thread_machine_stack_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_machine_stack_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>fiber_machine_stack_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_init2</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>vm</name></expr></argument>, <argument><expr><name>rb_vm_t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_living_threads_init</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>thread_report_on_exception</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>src_encoding_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_default_params_setup</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_execution_context_update</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>limit_cfp</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>+</operator> <name><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>cfp</name> <operator>!=</operator> <name>limit_cfp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfp</name><operator>-&gt;</operator><name>block_code</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>cfp</name><operator>-&gt;</operator><name>block_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>prev_ep</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name>prev_ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_ESCAPED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>prev_ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>prev_ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>mark_local_storage_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>local</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_execution_context_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>sp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>limit_cfp</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>+</operator> <name><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_vm_stack_values</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>sp</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>cfp</name> <operator>!=</operator> <name>limit_cfp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><name><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><operator>!</operator><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name>ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_ESCAPED</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>vm_ep_in_heap_p_</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>cfp</name><operator>-&gt;</operator><name>block_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VM_ENV_LOCAL_P</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>prev_ep</name> <init>= <expr><call><name>VM_ENV_PREV_EP</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VM_ENV_FLAGS</name><argument_list>(<argument><expr><name>prev_ep</name></expr></argument>, <argument><expr><name>VM_ENV_FLAG_ESCAPED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>prev_ep</name><index>[<expr><name>VM_ENV_DATA_INDEX_ENV</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_start</name></name> <operator>&amp;&amp;</operator> <name><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_end</name></name> <operator>&amp;&amp;</operator>

<name>ec</name> <operator>!=</operator> <call><name>GET_EC</name><argument_list>()</argument_list></call></expr> 

)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark_machine_stack</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_locations</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>regs</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>regs</name></name><operator>)</operator> <operator>+</operator>

<sizeof>sizeof<argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>regs</name></name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>root_svar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>local_storage</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_id_table_foreach_values</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>local_storage</name></name></expr></argument>, <argument><expr><name>mark_local_storage_i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>local_storage_recursive_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>local_storage_recursive_hash_for_trace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>private_const_reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>rb_fiber_mark_self</name><parameter_list>(<parameter><decl><type><name>rb_fiber_t</name> <modifier>*</modifier></type><name>fib</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_fiber_update_self</name><parameter_list>(<parameter><decl><type><name>rb_fiber_t</name> <modifier>*</modifier></type><name>fib</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_threadptr_root_fiber_setup</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_threadptr_root_fiber_release</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>thread_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_fiber_update_self</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>fiber_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>root_fiber</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_fiber_update_self</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>root_fiber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_execution_context_update</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>thread_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_ENTER</name><argument_list>(<argument><expr><literal type="string">"thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_fiber_mark_self</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>fiber_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>invoke_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>thread_invoke_type_proc</name></expr>:</case>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>invoke_arg</name><operator>.</operator><name>proc</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>invoke_arg</name><operator>.</operator><name>proc</name><operator>.</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>thread_invoke_type_func</name></expr>:</case>

<expr_stmt><expr><call><name>rb_gc_mark_maybe</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>th</name><operator>-&gt;</operator><name>invoke_arg</name><operator>.</operator><name>func</name><operator>.</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>thgroup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>pending_interrupt_queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>pending_interrupt_mask_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>top_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>top_wrapper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>root_fiber</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_fiber_mark_self</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>root_fiber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_execution_context_mark</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>stat_insn_usage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>last_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>locking_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_LEAVE</name><argument_list>(<argument><expr><literal type="string">"thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>thread_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RUBY_FREE_ENTER</name><argument_list>(<argument><expr><literal type="string">"thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>locking_mutex</name></name> <operator>!=</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"thread_free: locking_mutex must be NULL (%p:%p)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>th</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>th</name><operator>-&gt;</operator><name>locking_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>keeping_mutexes</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"thread_free: keeping_mutexes must be NULL (%p:%p)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>th</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>th</name><operator>-&gt;</operator><name>keeping_mutexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_threadptr_root_fiber_release</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>vm</name></name> <operator>&amp;&amp;</operator> <name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>main_thread</name></name> <operator>==</operator> <name>th</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RUBY_GC_INFO</name><argument_list>(<argument><expr><literal type="string">"main thread\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RUBY_FREE_LEAVE</name><argument_list>(<argument><expr><literal type="string">"thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>thread_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_thread_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>th</name><operator>-&gt;</operator><name>root_fiber</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>local_storage</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>rb_id_table_memsize</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>local_storage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>thread_data_type</name></cpp:macro> <cpp:value>ruby_threadptr_data_type</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_data_type_t</name></type> <name>ruby_threadptr_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"VM/thread"</literal></expr>,

<expr><block>{

<expr><name>thread_mark</name></expr>,

<expr><name>thread_free</name></expr>,

<expr><name>thread_memsize</name></expr>,

<expr><name>thread_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><name>VALUE</name></type>

<name>rb_obj_is_thread</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_typeddata_is_kind_of</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>thread_data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>thread_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>rb_thread_t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>thread_data_type</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>void</name></type>

<name>rb_ec_set_vm_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_ec_initialize_vm_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_ec_set_vm_stack</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>+</operator> <name><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_push_frame</name><argument_list>(<argument><expr><name>ec</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument> ,

<argument><expr><name>VM_FRAME_MAGIC_DUMMY</name> <operator>|</operator> <name>VM_ENV_FLAG_LOCAL</name> <operator>|</operator> <name>VM_FRAME_FLAG_FINISH</name> <operator>|</operator> <name>VM_FRAME_FLAG_CFRAME</name></expr></argument> ,

<argument><expr><name>Qnil</name></expr></argument> , <argument><expr><name>VM_BLOCK_HANDLER_NONE</name></expr></argument> ,

<argument><expr><literal type="number">0</literal></expr></argument> ,

<argument><expr><literal type="number">0</literal></expr></argument> , <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>

)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_ec_clear_vm_stack</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_ec_set_vm_stack</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>th_init</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <name>self</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_threadptr_root_fiber_setup</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>self</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>thread_vm_stack_size</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ec_initialize_vm_stack</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>, <argument><expr><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>cfp</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>THREAD_RUNNABLE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>last_status</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>errinfo</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>root_svar</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>local_storage_recursive_hash</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>local_storage_recursive_hash_for_trace</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NON_SCALAR_THREAD_ID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id_string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_CALL_THREADED_CODE</name></expr></cpp:if>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>retval</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>report_on_exception</name></name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>thread_report_on_exception</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ruby_thread_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>rb_thread_ptr</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>vm</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>vm</name></name> <operator>=</operator> <name>vm</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>th_init</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>top_wrapper</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>top_self</name></name> <operator>=</operator> <call><name>rb_vm_top_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>root_svar</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_thread_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name> <init>= <expr><call><name>thread_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ruby_thread_init</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REWIND_CFP</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { rb_execution_context_t *ec__ = GET_EC(); VALUE *const curr_sp = (ec__-&gt;cfp++)-&gt;sp; VALUE *const saved_sp = ec__-&gt;cfp-&gt;sp; ec__-&gt;cfp-&gt;sp = curr_sp; expr; (ec__-&gt;cfp--)-&gt;sp = saved_sp; } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>m_core_set_method_alias</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<macro><name>REWIND_CFP</name><argument_list>(<argument>{

rb_alias(cbase, SYM2ID(sym1), SYM2ID(sym2));

}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>m_core_set_variable_alias</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<macro><name>REWIND_CFP</name><argument_list>(<argument>{

rb_alias_variable(SYM2ID(sym1), SYM2ID(sym2));

}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>m_core_undef_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<macro><name>REWIND_CFP</name><argument_list>(<argument>{

ID mid = SYM2ID(sym);

rb_undef(cbase, mid);

rb_clear_method_cache(self, mid);

}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>m_core_set_postexe</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_set_end_proc</name><argument_list>(<argument><expr><name>rb_call_end_proc</name></expr></argument>, <argument><expr><call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>core_hash_merge_kwd</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>kw</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>core_hash_merge</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_bulk_insert</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>m_core_hash_merge_ptr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>REWIND_CFP</name><argument_list>(<argument><expr><name>hash</name> <operator>=</operator> <call><name>core_hash_merge</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>kwmerge_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>m_core_hash_merge_kwd</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>kw</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>REWIND_CFP</name><argument_list>(<argument><expr><name>hash</name> <operator>=</operator> <call><name>core_hash_merge_kwd</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>core_hash_merge_kwd</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>kw</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><call><name>rb_to_hash_type</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kwmerge_i</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mjit_enabled_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><name>mjit_enabled</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mjit_pause_m</name><argument_list>(<argument><expr><name>int</name> <name>argc</name></expr></argument>, <argument><expr><name>VALUE</name> <operator>*</operator><name>argv</name></expr></argument>, <argument><expr><macro><name>RB_UNUSED_VAR</name><argument_list>(<argument>VALUE self</argument>)</argument_list></macro></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>options</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>wait</name> <init>= <expr><name>Qtrue</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"0:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name><name>keyword_ids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>keyword_ids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>keyword_ids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"wait"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>keyword_ids</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>wait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>mjit_pause</name><argument_list>(<argument><expr><call><name>RTEST</name><argument_list>(<argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>mjit_resume_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>mjit_resume</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>extern</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>rb_gc_stack_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>size_t</name></type> <name>rb_gc_stack_maxsize</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sdr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_bugreport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>nsdr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_BACKTRACE</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;execinfo.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_NATIVE_TRACE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name><name>trace</name><index>[<expr><name>MAX_NATIVE_TRACE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>backtrace</name><argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><name>MAX_NATIVE_TRACE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>syms</name> <init>= <expr><call><name>backtrace_symbols</name><argument_list>(<argument><expr><name>trace</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>syms</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name><name>syms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>syms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_COLLECT_USAGE_DETAILS</name></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_insn_start</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_operand_start</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_register_start</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_insn_stop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_operand_stop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_register_stop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_insn_running</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_operand_running</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_register_running</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_insn_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_operand_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>usage_analysis_register_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>f_raise</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_f_raise</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>f_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>f_lambda</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_block_lambda</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_mtbl</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_mtbl_dump</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><call><name>RTEST</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_mtbl2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_mtbl_dump</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>RTEST</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_VM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>fcore</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mjit</name></decl>;</decl_stmt>

<expr_stmt><expr><name>rb_cRubyVM</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"RubyVM"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"stat"</literal></expr></argument>, <argument><expr><name>vm_stat</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_DEBUG_COUNTER</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"reset_debug_counters"</literal></expr></argument>, <argument><expr><name>rb_debug_counter_reset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"show_debug_counters"</literal></expr></argument>, <argument><expr><name>rb_debug_counter_show</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>fcore</name> <operator>=</operator> <call><name>rb_class_new</name><argument_list>(<argument><expr><name>rb_cBasicObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>fcore</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <name>T_ICLASS</name></expr>;</expr_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>fcore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id_core_set_method_alias</name></expr></argument>, <argument><expr><name>m_core_set_method_alias</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id_core_set_variable_alias</name></expr></argument>, <argument><expr><name>m_core_set_variable_alias</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id_core_undef_method</name></expr></argument>, <argument><expr><name>m_core_undef_method</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id_core_set_postexe</name></expr></argument>, <argument><expr><name>m_core_set_postexe</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id_core_hash_merge_ptr</name></expr></argument>, <argument><expr><name>m_core_hash_merge_ptr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id_core_hash_merge_kwd</name></expr></argument>, <argument><expr><name>m_core_hash_merge_kwd</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id_core_raise</name></expr></argument>, <argument><expr><name>f_raise</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>idProc</name></expr></argument>, <argument><expr><name>f_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>idLambda</name></expr></argument>, <argument><expr><name>f_lambda</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>fcore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>fcore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_mRubyVMFrozenCore</name> <operator>=</operator> <name>fcore</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mjit</name> <operator>=</operator> <call><name>rb_define_module_under</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"MJIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>mjit</name></expr></argument>, <argument><expr><literal type="string">"enabled?"</literal></expr></argument>, <argument><expr><name>mjit_enabled_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>mjit</name></expr></argument>, <argument><expr><literal type="string">"pause"</literal></expr></argument>, <argument><expr><name>mjit_pause_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>mjit</name></expr></argument>, <argument><expr><literal type="string">"resume"</literal></expr></argument>, <argument><expr><name>mjit_resume_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cThread</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Thread"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>rb_cThread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_COLLECT_USAGE_DETAILS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>define_usage_analysis_hash</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_define_const(rb_cRubyVM, "USAGE_ANALYSIS_" #name, rb_hash_new())</cpp:value></cpp:define>

<expr_stmt><expr><call><name>define_usage_analysis_hash</name><argument_list>(<argument><expr><name>INSN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_usage_analysis_hash</name><argument_list>(<argument><expr><name>REGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_usage_analysis_hash</name><argument_list>(<argument><expr><name>INSN_BIGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN_START"</literal></expr></argument>, <argument><expr><name>usage_analysis_insn_start</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_OPERAND_START"</literal></expr></argument>, <argument><expr><name>usage_analysis_operand_start</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_REGISTER_START"</literal></expr></argument>, <argument><expr><name>usage_analysis_register_start</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN_STOP"</literal></expr></argument>, <argument><expr><name>usage_analysis_insn_stop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_OPERAND_STOP"</literal></expr></argument>, <argument><expr><name>usage_analysis_operand_stop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_REGISTER_STOP"</literal></expr></argument>, <argument><expr><name>usage_analysis_register_stop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN_RUNNING"</literal></expr></argument>, <argument><expr><name>usage_analysis_insn_running</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_OPERAND_RUNNING"</literal></expr></argument>, <argument><expr><name>usage_analysis_operand_running</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_REGISTER_RUNNING"</literal></expr></argument>, <argument><expr><name>usage_analysis_register_running</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN_CLEAR"</literal></expr></argument>, <argument><expr><name>usage_analysis_insn_clear</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_OPERAND_CLEAR"</literal></expr></argument>, <argument><expr><name>usage_analysis_operand_clear</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_REGISTER_CLEAR"</literal></expr></argument>, <argument><expr><name>usage_analysis_register_clear</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"OPTS"</literal></expr></argument>, <argument><expr><name>opts</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DIRECT_THREADED_CODE</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"direct threaded code"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OPT_TOKEN_THREADED_CODE</name></expr></cpp:elif>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"token threaded code"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>OPT_CALL_THREADED_CODE</name></expr></cpp:elif>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"call threaded code"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_STACK_CACHING</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"stack caching"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_OPERANDS_UNIFICATION</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"operands unification"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INSTRUCTIONS_UNIFICATION</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"instructions unification"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_INLINE_METHOD_CACHE</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"inline method cache"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_BLOCKINLINING</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"block inlining"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"INSTRUCTION_NAMES"</literal></expr></argument>, <argument><expr><call><name>rb_insns_name_array</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT_PARAMS"</literal></expr></argument>, <argument><expr><call><name>vm_default_params</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VMDEBUG</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"SDR"</literal></expr></argument>, <argument><expr><name>sdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"NSDR"</literal></expr></argument>, <argument><expr><name>nsdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"mtbl"</literal></expr></argument>, <argument><expr><name>vm_mtbl</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"mtbl"</literal></expr></argument>, <argument><expr><name>vm_mtbl</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"mtbl2"</literal></expr></argument>, <argument><expr><name>vm_mtbl2</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>sdr</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>nsdr</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vm_mtbl</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vm_mtbl2</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><name>ruby_current_vm_ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>filename</name> <init>= <expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"&lt;main&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>rb_iseq_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ISEQ_TYPE_TOP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vm_data_type</name></expr></argument>, <argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><name>rb_cThread</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>thread_data_type</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>main_thread</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>running_thread</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>vm</name></name> <operator>=</operator> <name>vm</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>top_wrapper</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>top_self</name></name> <operator>=</operator> <call><name>rb_vm_top_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_thread_set_current</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_living_threads_insert</name><argument_list>(<argument><expr><name>vm</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <name>iseq</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>top_self</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ENV_FLAGS_UNSET</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_FRAME_FLAG_CFRAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_STACK_ENV_WRITE</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>cfp</name><operator>-&gt;</operator><name>ep</name></name></expr></argument>, <argument><expr><name>VM_ENV_DATA_INDEX_ME_CREF</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>vm_cref_new</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>METHOD_VISI_PRIVATE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_global_const</name><argument_list>(<argument><expr><literal type="string">"TOPLEVEL_BINDING"</literal></expr></argument>, <argument><expr><call><name>rb_binding_new</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>vm_init_redefined_flag</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_block_param_proxy</name> <operator>=</operator> <call><name>rb_obj_alloc</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>rb_block_param_proxy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idCall</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>OPTIMIZED_METHOD_TYPE_BLOCK_CALL</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>rb_block_param_proxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>rb_block_param_proxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Init_vm_backtrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_set_progname</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>filename</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>main_thread</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>vm_stack</name></name> <operator>+</operator> <name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>vm_stack_size</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>--</operator><name>cfp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_iseq_pathobj_set</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_iseq_realpath</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>rb_fstring_hash_type</name></decl>;</decl_stmt>

<function><type><name>void</name></type>

<name>Init_BareVM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type> <name>vm</name> <init>= <expr><call><name>ruby_mimmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>vm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type> <name>th</name> <init>= <expr><call><name>ruby_mimmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>th</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vm</name> <operator>||</operator> <operator>!</operator><name>th</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[FATAL] failed to allocate memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>rb_thread_t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_init2</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>objspace</name></name> <operator>=</operator> <call><name>rb_objspace_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ruby_current_vm_ptr</name> <operator>=</operator> <name>vm</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Init_native_thread</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>vm</name></name> <operator>=</operator> <name>vm</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>th_init</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_thread_set_current_raw</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_thread_init_stack</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_vm_objects</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>defined_module_hash</name></name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>mark_object_ary</name></name> <operator>=</operator> <call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>loading_table</name></name> <operator>=</operator> <call><name>st_init_strtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>frozen_strings</name></name> <operator>=</operator> <call><name>st_init_table_with_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_fstring_hash_type</name></expr></argument>, <argument><expr><literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_objspace_gc_enable</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>objspace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vm_empty_cc</name> <operator>=</operator> <call><name>vm_cc_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vm_call_general</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_SET_RAW</name><argument_list>(<argument><expr><name>vm_empty_cc</name></expr></argument>, <argument><expr><name>VM_CALLCACHE_UNMARKABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>vm_empty_cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>main_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_vm_top_self</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>top_self</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_top_self</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>top_self</name></name> <operator>=</operator> <call><name>rb_obj_alloc</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><call><name>rb_vm_top_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>main_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><call><name>rb_vm_top_self</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>ruby_vm_verbose_ptr</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>verbose</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name> <modifier>*</modifier></type>

<name>ruby_vm_debug_ptr</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>debug</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name> <modifier>*</modifier></type>

<name>rb_ruby_verbose_ptr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>ruby_vm_verbose_ptr</name><argument_list>(<argument><expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name> <modifier>*</modifier></type>

<name>rb_ruby_debug_ptr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>ruby_vm_debug_ptr</name><argument_list>(<argument><expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><name>VALUE</name></type> <name>rb_insn_operand_intern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op_no</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>op</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>pnop</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>child</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>st_table</name> <modifier>*</modifier></type>

<name>rb_vm_fstring_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>frozen_strings</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_COLLECT_USAGE_DETAILS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ASET</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_hash_aset((h), (st_data_t)(k), (st_data_t)(v))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_analysis_insn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>insn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>usage_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>bigram_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>prev_insn</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>uh</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ihash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>cv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>usage_hash</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>bigram_hash</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN_BIGRAM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uh</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><name>usage_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ihash</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>uh</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ihash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HASH_ASET</name><argument_list>(<argument><expr><name>uh</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ihash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cv</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>ihash</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>HASH_ASET</name><argument_list>(<argument><expr><name>ihash</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>cv</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_insn</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>ary</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>cv</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ary</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>prev_insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ary</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bi</name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ary</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uh</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><name>bigram_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cv</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>uh</name></expr></argument>, <argument><expr><name>bi</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>HASH_ASET</name><argument_list>(<argument><expr><name>uh</name></expr></argument>, <argument><expr><name>bi</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>cv</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>prev_insn</name> <operator>=</operator> <name>insn</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_analysis_operand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>usage_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>uh</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ihash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ophash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>valstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>cv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>usage_hash</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uh</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><name>usage_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ihash</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>uh</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ihash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HASH_ASET</name><argument_list>(<argument><expr><name>uh</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ihash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ophash</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>ihash</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ophash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HASH_ASET</name><argument_list>(<argument><expr><name>ihash</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ophash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>valstr</name> <operator>=</operator> <call><name>rb_insn_operand_intern</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>insn</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cv</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>ophash</name></expr></argument>, <argument><expr><name>valstr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>HASH_ASET</name><argument_list>(<argument><expr><name>ophash</name></expr></argument>, <argument><expr><name>valstr</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>cv</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_analysis_register</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>usage_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>uh</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>valstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>regstrs</name><index>[]</index><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{

<expr><literal type="string">"pc"</literal></expr>, 

<expr><literal type="string">"sp"</literal></expr>, 

<expr><literal type="string">"ep"</literal></expr>, 

<expr><literal type="string">"cfp"</literal></expr>, 

<expr><literal type="string">"self"</literal></expr>, 

<expr><literal type="string">"iseq"</literal></expr>, 

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>getsetstr</name><index>[]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{

<expr><literal type="string">"get"</literal></expr>,

<expr><literal type="string">"set"</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name><name>syms</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>regstrs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>regstrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>cv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>usage_hash</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_REGS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>syms</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">0x10</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>regstrs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>regstrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">0x10</literal></expr></argument>, <argument><expr><literal type="string">"%d %s %-4s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>getsetstr</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>regstrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>syms</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>valstr</name> <operator>=</operator> <name><name>syms</name><index>[<expr><name>reg</name></expr>]</index><index>[<expr><name>isset</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>uh</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><name>usage_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cv</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>uh</name></expr></argument>, <argument><expr><name>valstr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cv</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>HASH_ASET</name><argument_list>(<argument><expr><name>uh</name></expr></argument>, <argument><expr><name>valstr</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>cv</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HASH_ASET</name></cpp:undef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>ruby_vm_collect_usage_func_insn</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>insn</name></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>ruby_vm_collect_usage_func_operand</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>op</name></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>ruby_vm_collect_usage_func_register</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isset</name></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_insn_start</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>ruby_vm_collect_usage_func_insn</name> <operator>=</operator> <name>vm_analysis_insn</name></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_operand_start</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>ruby_vm_collect_usage_func_operand</name> <operator>=</operator> <name>vm_analysis_operand</name></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_register_start</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>ruby_vm_collect_usage_func_register</name> <operator>=</operator> <name>vm_analysis_register</name></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_insn_stop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>ruby_vm_collect_usage_func_insn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_operand_stop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>ruby_vm_collect_usage_func_operand</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_register_stop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>ruby_vm_collect_usage_func_register</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_insn_running</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ruby_vm_collect_usage_func_insn</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_operand_running</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ruby_vm_collect_usage_func_operand</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_register_running</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ruby_vm_collect_usage_func_register</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_insn_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>usage_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>bigram_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>uh</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>bh</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>usage_hash</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>bigram_hash</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN_BIGRAM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uh</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><name>usage_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bh</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><name>bigram_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_clear</name><argument_list>(<argument><expr><name>uh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_clear</name><argument_list>(<argument><expr><name>bh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_operand_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>usage_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>uh</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>usage_hash</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_INSN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uh</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><name>usage_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_clear</name><argument_list>(<argument><expr><name>uh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>usage_analysis_register_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>usage_hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>uh</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>usage_hash</name></expr></argument>, <argument><expr><literal type="string">"USAGE_ANALYSIS_REGS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>uh</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><name>usage_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_clear</name><argument_list>(<argument><expr><name>uh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>MAYBE_UNUSED</name><argument_list>(<argument><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*ruby_vm_collect_usage_func_insn</argument>)</argument_list></macro><operator>(</operator><name>int</name> <name>insn</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MAYBE_UNUSED</name><argument_list>(<argument><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*ruby_vm_collect_usage_func_operand</argument>)</argument_list></macro><operator>(</operator><name>int</name> <name>insn</name><operator>,</operator> <name>int</name> <name>n</name><operator>,</operator> <name>VALUE</name> <name>op</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MAYBE_UNUSED</name><argument_list>(<argument><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*ruby_vm_collect_usage_func_register</argument>)</argument_list></macro><operator>(</operator><name>int</name> <name>reg</name><operator>,</operator> <name>int</name> <name>isset</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_COLLECT_USAGE_DETAILS</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_collect_usage_insn</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>insn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RUBY_DTRACE_INSN_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RUBY_DTRACE_INSN</name><argument_list>(<argument><expr><call><name>rb_insns_name</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ruby_vm_collect_usage_func_insn</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name>ruby_vm_collect_usage_func_insn</name>)<argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_collect_usage_operand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RUBY_DTRACE_INSN_OPERAND_ENABLED</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>valstr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>valstr</name> <operator>=</operator> <call><name>rb_insn_operand_intern</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><name>insn</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_INSN_OPERAND</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>valstr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_insns_name</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>valstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ruby_vm_collect_usage_func_operand</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name>ruby_vm_collect_usage_func_operand</name>)<argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_collect_usage_register</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ruby_vm_collect_usage_func_register</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name>ruby_vm_collect_usage_func_register</name>)<argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>isset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>MJIT_FUNC_EXPORTED</name> <specifier>const</specifier> struct <name>rb_callcache</name> <operator>*</operator>

<macro><name>rb_vm_empty_cc</name><argument_list>(<argument>void</argument>)</argument_list></macro>

<block>{

<return>return <expr><name>vm_empty_cc</name></expr>;</return>

}</block></expr></expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_call_iseq_optimized.inc"</cpp:file></cpp:include> 

</unit>
