<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\method.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/imemo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compilers.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/static_assert.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>END_OF_ENUMERATION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>!</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__STRICT_ANSI__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_OF_ENUMERATION</name><parameter_list>(<parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_OF_ENUMERATION</name><parameter_list>(<parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>END_OF_##key##_PLACEHOLDER = 0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum <block>{

<decl><name>METHOD_VISI_UNDEF</name> <init>= <expr><literal type="number">0x00</literal></expr></init></decl>,

<decl><name>METHOD_VISI_PUBLIC</name> <init>= <expr><literal type="number">0x01</literal></expr></init></decl>,

<decl><name>METHOD_VISI_PRIVATE</name> <init>= <expr><literal type="number">0x02</literal></expr></init></decl>,

<decl><name>METHOD_VISI_PROTECTED</name> <init>= <expr><literal type="number">0x03</literal></expr></init></decl>,

<decl><name>METHOD_VISI_MASK</name> <init>= <expr><literal type="number">0x03</literal></expr></init></decl>

}</block></enum></type> <name>rb_method_visibility_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_scope_visi_struct</name> <block>{

<expr_stmt><expr><call><name>BITFIELD</name><argument_list>(<argument><expr><name>rb_method_visibility_t</name></expr></argument>, <argument><expr><name>method_visi</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>module_func</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

}</block></struct></type> <name>rb_scope_visibility_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_cref_struct</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>refinements</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_cref_struct</name></name> <modifier>*</modifier></type> <name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_scope_visibility_t</name></type> <name>scope_visi</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_cref_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_method_entry_struct</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_method_definition_struct</name></name> <modifier>*</modifier> <specifier>const</specifier></type> <name>def</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>called_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>owner</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_method_entry_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_callable_method_entry_struct</name> <block>{ 

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_method_definition_struct</name></name> <modifier>*</modifier> <specifier>const</specifier></type> <name>def</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>called_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>owner</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_callable_method_entry_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_ENTRY_VISI</name><parameter_list>(<parameter><type><name>me</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(rb_method_visibility_t)(((me)-&gt;flags &amp; (IMEMO_FL_USER0 | IMEMO_FL_USER1)) &gt;&gt; (IMEMO_FL_USHIFT+0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_ENTRY_BASIC</name><parameter_list>(<parameter><type><name>me</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(int) (((me)-&gt;flags &amp; (IMEMO_FL_USER2 )) &gt;&gt; (IMEMO_FL_USHIFT+2))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_ENTRY_COMPLEMENTED</name><parameter_list>(<parameter><type><name>me</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((me)-&gt;flags &amp; IMEMO_FL_USER3)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_ENTRY_COMPLEMENTED_SET</name><parameter_list>(<parameter><type><name>me</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((me)-&gt;flags = (me)-&gt;flags | IMEMO_FL_USER3)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_ENTRY_CACHED</name><parameter_list>(<parameter><type><name>me</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((me)-&gt;flags &amp; IMEMO_FL_USER4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_ENTRY_CACHED_SET</name><parameter_list>(<parameter><type><name>me</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((me)-&gt;flags = (me)-&gt;flags | IMEMO_FL_USER4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_ENTRY_INVALIDATED</name><parameter_list>(<parameter><type><name>me</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((me)-&gt;flags &amp; IMEMO_FL_USER5)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_ENTRY_INVALIDATED_SET</name><parameter_list>(<parameter><type><name>me</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((me)-&gt;flags = (me)-&gt;flags | IMEMO_FL_USER5)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>METHOD_ENTRY_VISI_SET</name><parameter_list>(<parameter><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>visi</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>visi</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>me</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name><name>me</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>IMEMO_FL_USER0</name> <operator>|</operator> <name>IMEMO_FL_USER1</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>visi</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>IMEMO_FL_USHIFT</name><operator>+</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>METHOD_ENTRY_BASIC_SET</name><parameter_list>(<parameter><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>basic</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>basic</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>me</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>(</operator><name><name>me</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>IMEMO_FL_USER2</name> <operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>basic</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>IMEMO_FL_USHIFT</name><operator>+</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>METHOD_ENTRY_FLAGS_SET</name><parameter_list>(<parameter><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>basic</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>visi</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>visi</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>basic</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>me</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator>

<operator>(</operator><name><name>me</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>IMEMO_FL_USER0</name><operator>|</operator><name>IMEMO_FL_USER1</name><operator>|</operator><name>IMEMO_FL_USER2</name><operator>)</operator><operator>)</operator> <operator>|</operator>

<operator>(</operator><operator>(</operator><name>visi</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>IMEMO_FL_USHIFT</name><operator>+</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name>basic</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>IMEMO_FL_USHIFT</name><operator>+</operator><literal type="number">2</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>METHOD_ENTRY_FLAGS_COPY</name><parameter_list>(<parameter><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator>

<operator>(</operator><name><name>dst</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>IMEMO_FL_USER0</name><operator>|</operator><name>IMEMO_FL_USER1</name><operator>|</operator><name>IMEMO_FL_USER2</name><operator>)</operator><operator>)</operator> <operator>|</operator>

<operator>(</operator><name><name>src</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>IMEMO_FL_USER0</name><operator>|</operator><name>IMEMO_FL_USER1</name><operator>|</operator><name>IMEMO_FL_USER2</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{

<decl><name>VM_METHOD_TYPE_ISEQ</name></decl>, 

<decl><name>VM_METHOD_TYPE_CFUNC</name></decl>, 

<decl><name>VM_METHOD_TYPE_ATTRSET</name></decl>, 

<decl><name>VM_METHOD_TYPE_IVAR</name></decl>, 

<decl><name>VM_METHOD_TYPE_BMETHOD</name></decl>,

<decl><name>VM_METHOD_TYPE_ZSUPER</name></decl>,

<decl><name>VM_METHOD_TYPE_ALIAS</name></decl>,

<decl><name>VM_METHOD_TYPE_UNDEF</name></decl>,

<decl><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></decl>,

<decl><name>VM_METHOD_TYPE_OPTIMIZED</name></decl>, 

<decl><name>VM_METHOD_TYPE_MISSING</name></decl>, 

<decl><name>VM_METHOD_TYPE_REFINED</name></decl>, 

<decl><name>END_OF_ENUMERATION</name><argument_list>(<argument><expr><name>VM_METHOD_TYPE</name></expr></argument>)</argument_list></decl>

}</block></enum></type> <name>rb_method_type_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_METHOD_TYPE_MINIMUM_BITS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>VM_METHOD_TYPE_MINIMUM_BITS</name></expr></argument>,

<argument><expr><name>VM_METHOD_TYPE_REFINED</name> <operator>&lt;=</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>VM_METHOD_TYPE_MINIMUM_BITS</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>rb_iseq_t</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name><name>struct</name> <name>rb_iseq_struct</name></name></type> <name>rb_iseq_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_iseq_t</name></cpp:macro> <cpp:value>rb_iseq_t</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>rb_method_iseq_struct</name> <block>{

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type> <name>iseqptr</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type> <name>cref</name></decl>;</decl_stmt> 

}</block></struct></type> <name>rb_method_iseq_t</name>;</typedef> 

<typedef>typedef <type><struct>struct <name>rb_method_cfunc_struct</name> <block>{

<function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>invoker</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_method_cfunc_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_method_attr_struct</name> <block>{

<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>location</name></decl>;</decl_stmt> 

}</block></struct></type> <name>rb_method_attr_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_method_alias_struct</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_method_entry_struct</name></name> <modifier>*</modifier></type> <name>original_me</name></decl>;</decl_stmt> 

}</block></struct></type> <name>rb_method_alias_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_method_refined_struct</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_method_entry_struct</name></name> <modifier>*</modifier></type> <name>orig_me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>owner</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_method_refined_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>rb_method_bmethod_struct</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>rb_hook_list_struct</name></name> <modifier>*</modifier></type><name>hooks</name></decl>;</decl_stmt>

}</block></struct></type> <name>rb_method_bmethod_t</name>;</typedef>

<enum>enum <name>method_optimized_type</name> <block>{

<decl><name>OPTIMIZED_METHOD_TYPE_SEND</name></decl>,

<decl><name>OPTIMIZED_METHOD_TYPE_CALL</name></decl>,

<decl><name>OPTIMIZED_METHOD_TYPE_BLOCK_CALL</name></decl>,

<decl><name>OPTIMIZED_METHOD_TYPE__MAX</name></decl>

}</block>;</enum>

<struct>struct <name>rb_method_definition_struct</name> <block>{

<expr_stmt><expr><call><name>BITFIELD</name><argument_list>(<argument><expr><name>rb_method_type_t</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_MINIMUM_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>alias_count</name> <range>: <expr><literal type="number">28</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>complemented_count</name> <range>: <expr><literal type="number">28</literal></expr></range></decl>;</decl_stmt>

<union>union <block>{

<decl_stmt><decl><type><name>rb_method_iseq_t</name></type> <name>iseq</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_cfunc_t</name></type> <name>cfunc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_attr_t</name></type> <name>attr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_alias_t</name></type> <name>alias</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_refined_t</name></type> <name>refined</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_bmethod_t</name></type> <name>bmethod</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>method_optimized_type</name></name></type> <name>optimize_type</name></decl>;</decl_stmt>

}</block> <decl><name>body</name></decl>;</union>

<decl_stmt><decl><type><name>ID</name></type> <name>original_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uintptr_t</name></type> <name>method_serial</name></decl>;</decl_stmt>

}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>rb_method_definition_struct</name></name></type> <name>rb_method_definition_t</name>;</typedef>

<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>sizeof_method_def</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>rb_method_definition_t</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDEFINED_METHOD_ENTRY_P</name><parameter_list>(<parameter><type><name>me</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!(me) || !(me)-&gt;def || (me)-&gt;def-&gt;type == VM_METHOD_TYPE_UNDEF)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDEFINED_REFINED_METHOD_P</name><parameter_list>(<parameter><type><name>def</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((def)-&gt;type == VM_METHOD_TYPE_REFINED &amp;&amp; UNDEFINED_METHOD_ENTRY_P((def)-&gt;body.refined.orig_me))</cpp:value></cpp:define>

<function_decl><type><name>void</name></type> <name>rb_add_method_cfunc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_add_method_iseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_add_refined_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>refined_class</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_add_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>rb_method_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_method_entry_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>noex</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_method_entry_create</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>called_id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_method_entry_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_method_entry_with_refinements</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_method_entry_without_refinements</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_resolve_refined_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>refinements</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RUBY_SYMBOL_EXPORT_BEGIN</name>

<specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_resolve_me_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>VALUE</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RUBY_SYMBOL_EXPORT_END</name>

<specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>rb_callable_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>rb_callable_method_entry_with_refinements</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>rb_callable_method_entry_without_refinements</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_method_entry_arity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_method_entry_eq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>m1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>m2</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>st_index_t</name></type> <name>rb_hash_method_entry</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_method_entry_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_free_method_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_method_entry_clone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>rb_method_entry_complement_defined_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>src_me</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>called_id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>defined_class</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_method_entry_copy</name><parameter_list>(<parameter><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_scope_visibility_set</name><parameter_list>(<parameter><decl><type><name>rb_method_visibility_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_unnamed_parameters</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>arity</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_clear_method_cache</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass_or_module</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_clear_method_cache_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

</unit>
