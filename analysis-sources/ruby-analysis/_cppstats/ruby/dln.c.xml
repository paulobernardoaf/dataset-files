<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\dln.c"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_EXPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/ruby.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dln_notimplement</name></cpp:macro> <cpp:value>rb_notimplement</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dln_memerror</name></cpp:macro> <cpp:value>rb_memerror</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dln_exit</name></cpp:macro> <cpp:value>rb_exit</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dln_loaderror</name></cpp:macro> <cpp:value>rb_loaderror</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dln_notimplement</name></cpp:macro> <cpp:value>---&gt;&gt;&gt; dln not implemented &lt;&lt;&lt;---</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dln_memerror</name></cpp:macro> <cpp:value>abort</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dln_exit</name></cpp:macro> <cpp:value>exit</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dln_loaderror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dln.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_DLN_A_OUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dln_argv0</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ALLOCA_H</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRING_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>xmalloc</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xmalloc</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xcalloc</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>xrealloc</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>free</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>free</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>xfree(x)</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"missing/file.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISDIR</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFDIR)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_PARAM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHLEN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>getenv</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DLOPEN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MACOSX_DLOPEN</name></cpp:macro></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MACOSX_DYLD</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>dln_loaderror</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>

<name>dln_loaderror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DLOPEN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_DLN_A_OUT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MACOSX_DYLD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_UNICOSMP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_DLN_DLOPEN</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__hp9000s300</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__ELF__</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>NeXT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MACOSX_DYLD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERNAL_PREFIX</name></cpp:macro> <cpp:value>"_"</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERNAL_PREFIX</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCNAME_PREFIX</name></cpp:macro> <cpp:value>EXTERNAL_PREFIX"Init_"</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__CYGWIN__</name> <operator>||</operator> <name>defined</name> <name>DOSISH</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isdirsep</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == '/' || (x) == '\\')</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isdirsep</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == '/')</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>init_funcname_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>file</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>base</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>dot</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dot</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>base</name> <operator>=</operator> <name>p</name><operator>+</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>dot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><name>dot</name></expr> ?</condition><then> <expr><name>dot</name></expr> </then><else>: <expr><name>p</name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name>base</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>funcname_prefix</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>FUNCNAME_PREFIX</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <init>= <expr><name>FUNCNAME_PREFIX</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>init_funcname</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>file</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {const char *base = (file);const size_t flen = init_funcname_len(&amp;base);const size_t plen = sizeof(funcname_prefix);char *const tmp = ALLOCA_N(char, plen+flen+1);if (!tmp) {dln_memerror();}memcpy(tmp, funcname_prefix, plen);memcpy(tmp+plen, base, flen);tmp[plen+flen] = '\0';*(buf) = tmp;} while (0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_DLN_A_OUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LIBC_NAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIBC_NAME</name></cpp:macro> <cpp:value>"libc.a"</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>DLN_DEFAULT_LIB_PATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_DEFAULT_LIB_PATH</name></cpp:macro> <cpp:value>"/lib:/usr/lib:/usr/local/lib:."</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dln_errno</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_ENOEXEC</name></cpp:macro> <cpp:value>ENOEXEC</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_ECONFL</name></cpp:macro> <cpp:value>1201</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_ENOINIT</name></cpp:macro> <cpp:value>1202</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_EUNDEF</name></cpp:macro> <cpp:value>1203</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_ENOTLIB</name></cpp:macro> <cpp:value>1204</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_EBADLIB</name></cpp:macro> <cpp:value>1205</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_EINIT</name></cpp:macro> <cpp:value>1206</cpp:value></cpp:define> 

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dln_init_p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ar.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;a.out.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>N_COMM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_COMM</name></cpp:macro> <cpp:value>0x12</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>N_MAGIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_MAGIC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x).a_magic</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_OBJECT</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(N_MAGIC(h) != OMAGIC)</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/st.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>sym_tbl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>undef_tbl</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>load_lib</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>load_header</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>exec</name></name> <modifier>*</modifier></type><name>hdrp</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>disp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>hdrp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>exec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>exec</name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <call><name>N_BADMAG</name><argument_list>(<argument><expr><operator>*</operator><name>hdrp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_ENOEXEC</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>sequent</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_SYMBOL</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_symbolnum)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_MEMORY_SUB_P</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_bsr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_PCREL_P</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_pcrel || (r)-&gt;r_bsr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_TARGET_SIZE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_length)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RELOC_ADDRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_ADDRESS</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_address)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_EXTERN_P</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_extern)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_SYMBOL</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_symbolnum)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_MEMORY_SUB_P</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_PCREL_P</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_pcrel)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RELOC_TARGET_SIZE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_length)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sparc</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>relocation_info</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>relocation_info</name></cpp:macro> <cpp:value>reloc_info_sparc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_RIGHTSHIFT</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(reloc_r_rightshift[(r)-&gt;r_type])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_BITSIZE</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(reloc_r_bitsize[(r)-&gt;r_type])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_LENGTH</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(reloc_r_length[(r)-&gt;r_type])</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>reloc_r_rightshift</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>reloc_r_bitsize</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="number">8</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">22</literal></expr>, <expr><literal type="number">13</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">16</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>reloc_r_length</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_PCREL</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_type &gt;= RELOC_DISP8 &amp;&amp; (r)-&gt;r_type &lt;= RELOC_WDISP22)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_SYMBOL</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_index)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>sequent</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_SYMBOL</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_symbolnum)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_MEMORY_SUB</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_bsr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_PCREL</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_pcrel || (r)-&gt;r_bsr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_LENGTH</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_length)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>R_SYMBOL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_SYMBOL</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_symbolnum)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_MEMORY_SUB</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_PCREL</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_pcrel)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_LENGTH</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)-&gt;r_length)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>relocation_info</name></name> <modifier>*</modifier></type>

<name>load_reloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>exec</name></name> <modifier>*</modifier></type><name>hdrp</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>disp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>relocation_info</name></name> <modifier>*</modifier></type><name>reloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>disp</name> <operator>+</operator> <call><name>N_TXTOFF</name><argument_list>(<argument><expr><operator>*</operator><name>hdrp</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_text</name></name> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_trsize</name></name> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_drsize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>reloc</name> <operator>=</operator> <operator>(</operator>struct <name>relocation_info</name><operator>*</operator><operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>reloc</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>reloc</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>reloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>reloc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type>

<name>load_sym</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>exec</name></name> <modifier>*</modifier></type><name>hdrp</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>disp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type> <name>buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type> <name>sym</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type> <name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>displ</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>N_SYMOFF</name><argument_list>(<argument><expr><operator>*</operator><name>hdrp</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_syms</name></name> <operator>+</operator> <name>disp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<goto>goto <name>err_noexec</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator>struct <name>nlist</name><operator>*</operator><operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name><name>hdrp</name><operator>-&gt;</operator><name>a_syms</name></name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>disp</name> <operator>+</operator> <call><name>N_SYMOFF</name><argument_list>(<argument><expr><operator>*</operator><name>hdrp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>hdrp</name><operator>-&gt;</operator><name>a_syms</name></name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_syms</name></name> <operator>+</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>err_noexec</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>sym</name> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_syms</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>nlist</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>displ</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>buffer</name> <operator>+</operator> <operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name><name>hdrp</name><operator>-&gt;</operator><name>a_syms</name></name><operator>)</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_strx</name></name> <operator>+</operator> <name>displ</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>buffer</name></expr>;</return>

<label><name>err_noexec</name>:</label>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_ENOEXEC</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type>

<name>sym_hash</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>exec</name></name> <modifier>*</modifier></type><name>hdrp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>syms</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>sym</name> <init>= <expr><name>syms</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>syms</name> <operator>+</operator> <operator>(</operator><name><name>hdrp</name><operator>-&gt;</operator><name>a_syms</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>nlist</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>st_init_strtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tbl</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>tbl</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>dln_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prog</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>, <decl><type ref="prev"/><name><name>fbuf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>exec</name></name></type> <name>hdr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>syms</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dln_init_p</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>dln_find_exe_r</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>load_header</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>syms</name> <operator>=</operator> <call><name>load_sym</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>syms</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sym_tbl</name> <operator>=</operator> <call><name>sym_hash</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><name>syms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sym_tbl</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>syms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_noexec</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'!'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_noexec</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_noexec</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\t'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name><operator>-</operator><name>buf</name> <operator>&gt;=</operator> <name>MAXPATHLEN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>ENAMETOOLONG</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><call><name>dln_init</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dln_init_p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>undef_tbl</name> <operator>=</operator> <call><name>st_init_strtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err_noexec</name>:</label>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_ENOEXEC</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>load_text_data</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>exec</name></name> <modifier>*</modifier></type><name>hdrp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bss</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>disp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>addr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>disp</name> <operator>+</operator> <call><name>N_TXTOFF</name><argument_list>(<argument><expr><operator>*</operator><name>hdrp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_text</name></name> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_data</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bss</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_bss</name></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>bss</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>size</name> <operator>+=</operator> <name>bss</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bss</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_text</name></name> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>hdrp</name><operator>-&gt;</operator><name>a_bss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>bss</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_text</name></name> <operator>+</operator> <name><name>hdrp</name><operator>-&gt;</operator><name>a_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>long</name><operator>)</operator><name>addr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>undef_print</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dln_print_undef</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" Undefined symbols:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>undef_tbl</name></expr></argument>, <argument><expr><name>undef_print</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dln_undefined</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>undef_tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"dln: Calling undefined function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dln_print_undef</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dln_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>undef</name> <block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>relocation_info</name></name></type> <name>reloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>

<union>union <block>{

<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>short</name></type> <name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>

}</block> <decl><name>u</name></decl>;</union>

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>reloc_tbl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>link_undef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>relocation_info</name></name> <modifier>*</modifier></type><name>reloc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>u_no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>undef</name></name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>reloc</name><operator>-&gt;</operator><name>r_address</name></name> <operator>+</operator> <name>base</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <operator>(</operator>struct <name>undef</name><operator>*</operator><operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>undef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>reloc</name></name> <operator>=</operator> <operator>*</operator><name>reloc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>R_LENGTH</name><argument_list>(<argument><expr><name>reloc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>=</operator> <operator>*</operator><name>addr</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>short</name><operator>*</operator><operator>)</operator><name>addr</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> 

<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>long</name><operator>*</operator><operator>)</operator><name>addr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>reloc_tbl</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reloc_tbl</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>reloc_tbl</name></expr></argument>, <argument><expr><name>u_no</name><operator>++</operator></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>reloc_arg</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>value</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>reloc_undef</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>no</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>undef</name></name> <modifier>*</modifier></type><name>undef</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>reloc_arg</name></name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>datum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>address</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sparc</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>undef</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>address</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>undef</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>undef</name><operator>-&gt;</operator><name>reloc</name><operator>.</operator><name>r_address</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>R_PCREL</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>undef</name><operator>-&gt;</operator><name>reloc</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>datum</name> <operator>-=</operator> <name><name>undef</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sparc</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>datum</name> <operator>+=</operator> <name><name>undef</name><operator>-&gt;</operator><name>reloc</name><operator>.</operator><name>r_addend</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>datum</name> <operator>&gt;&gt;=</operator> <call><name>R_RIGHTSHIFT</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>undef</name><operator>-&gt;</operator><name>reloc</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>R_BITSIZE</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>undef</name><operator>-&gt;</operator><name>reloc</name></name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>mask</name> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>datum</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>R_LENGTH</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>undef</name><operator>-&gt;</operator><name>reloc</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>address</name> <operator>=</operator> <name><name>undef</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>address</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>address</name> <operator>|=</operator> <name>datum</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>short</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>=</operator> <name><name>undef</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>short</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>short</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>|=</operator> <name>datum</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>=</operator> <name><name>undef</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>|=</operator> <name>datum</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<switch>switch <condition>(<expr><call><name>R_LENGTH</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>undef</name><operator>-&gt;</operator><name>reloc</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>R_MEMORY_SUB</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>undef</name><operator>-&gt;</operator><name>reloc</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>address</name> <operator>=</operator> <name>datum</name> <operator>-</operator> <operator>*</operator><name>address</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>address</name> <operator>=</operator> <name><name>undef</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name></name> <operator>+</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>R_MEMORY_SUB</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>undef</name><operator>-&gt;</operator><name>reloc</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>short</name><operator>*</operator><operator>)</operator><name>address</name> <operator>=</operator> <name>datum</name> <operator>-</operator> <operator>*</operator><operator>(</operator><name>short</name><operator>*</operator><operator>)</operator><name>address</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>short</name><operator>*</operator><operator>)</operator><name>address</name> <operator>=</operator> <name><name>undef</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>s</name></name> <operator>+</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>R_MEMORY_SUB</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>undef</name><operator>-&gt;</operator><name>reloc</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>long</name><operator>*</operator><operator>)</operator><name>address</name> <operator>=</operator> <name>datum</name> <operator>-</operator> <operator>*</operator><operator>(</operator><name>long</name><operator>*</operator><operator>)</operator><name>address</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name>long</name><operator>*</operator><operator>)</operator><name>address</name> <operator>=</operator> <name><name>undef</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name></name> <operator>+</operator> <name>datum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>undef</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>undef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_DELETE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>unlink_undef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>reloc_arg</name></name></type> <name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>reloc_tbl</name></expr></argument>, <argument><expr><name>reloc_undef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>N_INDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>indr_data</name> <block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name1</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>reloc_repl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>no</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>undef</name></name> <modifier>*</modifier></type><name>undef</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>indr_data</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>name0</name></name></expr></argument>, <argument><expr><name><name>undef</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>undef</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>undef</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>name1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>load_1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>disp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>need_init</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>libc</name> <init>= <expr><name>LIBC_NAME</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>exec</name></name></type> <name>hdr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>relocation_info</name></name> <modifier>*</modifier></type><name>reloc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>block</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>new_common</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>syms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>sym</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>init_p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>load_header</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>INVALID_OBJECT</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_ENOEXEC</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>reloc</name> <operator>=</operator> <call><name>load_reloc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>reloc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>syms</name> <operator>=</operator> <call><name>load_sym</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>syms</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>reloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <name>syms</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>syms</name> <operator>+</operator> <operator>(</operator><name><name>hdr</name><operator>.</operator><name>a_syms</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>nlist</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>old_sym</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>value</name> <init>= <expr><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>N_INDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <operator>(</operator><name>N_INDR</name> <operator>|</operator> <name>N_EXT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>sym_tbl</name></expr></argument>, <argument><expr><name><name>sym</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_sym</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>st_delete</name><argument_list>(<argument><expr><name>undef_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>unlink_undef</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>old_sym</name><operator>-&gt;</operator><name>n_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>indr_data</name></name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>name0</name></name> <operator>=</operator> <name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>name1</name></name> <operator>=</operator> <name><name>sym</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>n_un</name><operator>.</operator><name>n_name</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>reloc_tbl</name></expr></argument>, <argument><expr><name>reloc_repl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>undef_tbl</name></expr></argument>, <argument><expr><call><name>strdup</name><argument_list>(<argument><expr><name><name>sym</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_delete</name><argument_list>(<argument><expr><name>undef_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>sym</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <operator>(</operator><name>N_UNDF</name> <operator>|</operator> <name>N_EXT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>sym_tbl</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_sym</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>old_sym</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>old_sym</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_type</name></name> <operator>=</operator> <name>N_EXT</name> <operator>|</operator> <name>N_COMM</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name> <operator>=</operator> <name><name>old_sym</name><operator>-&gt;</operator><name>n_value</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rnd</name> <init>=

<expr><ternary><condition><expr><name>value</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>

</then><else>: <expr><ternary><condition><expr><name>value</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>

</then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_type</name></name> <operator>=</operator> <name>N_COMM</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_common</name> <operator>+=</operator> <name>rnd</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_common</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>long</name><operator>)</operator><name>rnd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name> <operator>=</operator> <name>new_common</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_common</name> <operator>+=</operator> <name>value</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>old_sym</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_type</name></name> <operator>=</operator> <name>N_EXT</name> <operator>|</operator> <name>N_COMM</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name> <operator>=</operator> <name><name>old_sym</name><operator>-&gt;</operator><name>n_value</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>dln_undefined</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>undef_tbl</name></expr></argument>, <argument><expr><call><name>strdup</name><argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>load_text_data</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>.</operator><name>a_bss</name></name> <operator>+</operator> <name>new_common</name></expr></argument>, <argument><expr><name>disp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>block</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_exit</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <name>syms</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>new_sym</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>n_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>N_COMM</name></expr>:</case>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name> <operator>+=</operator> <name><name>hdr</name><operator>.</operator><name>a_text</name></name> <operator>+</operator> <name><name>hdr</name><operator>.</operator><name>a_data</name></name></expr>;</expr_stmt>

<case>case <expr><name>N_TEXT</name><operator>|</operator><name>N_EXT</name></expr>:</case>

<case>case <expr><name>N_DATA</name><operator>|</operator><name>N_EXT</name></expr>:</case>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name> <operator>+=</operator> <name>block</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>sym_tbl</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_sym</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <name><name>new_sym</name><operator>-&gt;</operator><name>n_value</name></name> <operator>!=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>dln_undefined</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_ECONFL</name></expr>;</expr_stmt>

<goto>goto <name>err_exit</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_delete</name><argument_list>(<argument><expr><name>undef_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>unlink_undef</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>new_sym</name> <operator>=</operator> <operator>(</operator>struct <name>nlist</name><operator>*</operator><operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>nlist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>new_sym</name> <operator>=</operator> <operator>*</operator><name>sym</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>sym_tbl</name></expr></argument>, <argument><expr><name><name>new_sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>, <argument><expr><name>new_sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>N_TEXT</name></expr>:</case>

<case>case <expr><name>N_DATA</name></expr>:</case>

<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name> <operator>+=</operator> <name>block</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>relocation_info</name></name> <modifier>*</modifier></type> <name>rel</name> <init>= <expr><name>reloc</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>relocation_info</name></name> <modifier>*</modifier></type> <name>rel_beg</name> <init>= <expr><name>reloc</name> <operator>+</operator>

<operator>(</operator><name><name>hdr</name><operator>.</operator><name>a_trsize</name></name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>relocation_info</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>relocation_info</name></name> <modifier>*</modifier></type> <name>rel_end</name> <init>= <expr><name>reloc</name> <operator>+</operator>

<operator>(</operator><name><name>hdr</name><operator>.</operator><name>a_trsize</name></name><operator>+</operator><name><name>hdr</name><operator>.</operator><name>a_drsize</name></name><operator>)</operator><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>relocation_info</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>rel</name> <operator>&lt;</operator> <name>rel_end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>address</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>r_address</name></name> <operator>+</operator> <name>block</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>datum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sparc</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>&gt;=</operator> <name>rel_beg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>address</name> <operator>+=</operator> <name><name>hdr</name><operator>.</operator><name>a_text</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>r_extern</name></name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>sym</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>syms</name><index>[<expr><call><name>R_SYMBOL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>n_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>N_EXT</name><operator>|</operator><name>N_UNDF</name></expr>:</case>

<expr_stmt><expr><call><name>link_undef</name><argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>N_EXT</name><operator>|</operator><name>N_COMM</name></expr>:</case>

<case>case <expr><name>N_COMM</name></expr>:</case>

<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<goto>goto <name>err_exit</name>;</goto>

</block_content>}</block></switch>

</block_content>}</block></if> 

<else>else <block>{<block_content> 

<switch>switch <condition>(<expr><call><name>R_SYMBOL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>N_TEXT</name></expr>:</case>

<case>case <expr><name>N_DATA</name></expr>:</case>

<expr_stmt><expr><name>datum</name> <operator>=</operator> <name>block</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>N_BSS</name></expr>:</case>

<expr_stmt><expr><name>datum</name> <operator>=</operator> <name>block</name> <operator>+</operator> <name>new_common</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>N_ABS</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>R_PCREL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>datum</name> <operator>-=</operator> <name>block</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sparc</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>datum</name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>r_addend</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>datum</name> <operator>&gt;&gt;=</operator> <call><name>R_RIGHTSHIFT</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mask</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>R_BITSIZE</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>mask</name> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>datum</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>R_LENGTH</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>address</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>address</name> <operator>|=</operator> <name>datum</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>short</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>short</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>|=</operator> <name>datum</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>|=</operator> <name>datum</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<switch>switch <condition>(<expr><call><name>R_LENGTH</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>datum</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">128</literal> <operator>||</operator> <name>datum</name></expr></argument> &gt;</argument_list></name> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_exit</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>address</name> <operator>+=</operator> <name>datum</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>short</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>+=</operator> <name>datum</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> 

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><name>address</name> <operator>+=</operator> <name>datum</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>rel</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>need_init</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>libs_to_be_linked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>undef_tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>load_lib</name><argument_list>(<argument><expr><name>libc</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_exit</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>init_funcname</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>need_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>sym</name> <operator>=</operator> <name>syms</name></expr>;</init> <condition><expr><name>sym</name><operator>&lt;</operator><name>end</name></expr>;</condition> <incr><expr><name>sym</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name> <operator>&gt;=</operator> <name>block</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"dln_libs_to_be_linked"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>libs_to_be_linked</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>init_p</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>()</argument_list></call><operator>)</operator><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name><operator>)</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>libs_to_be_linked</name> <operator>&amp;&amp;</operator> <name><name>undef_tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>libs_to_be_linked</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>load_lib</name><argument_list>(<argument><expr><operator>*</operator><name>libs_to_be_linked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>libs_to_be_linked</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>reloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>syms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_init</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>init_p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_ENOINIT</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>undef_tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>load_lib</name><argument_list>(<argument><expr><name>libc</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err_exit</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>undef_tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_EUNDEF</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err_exit</name>:</label>

<if_stmt><if>if <condition>(<expr><name>syms</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>syms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>reloc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>reloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>block</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>target_offset</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>search_undef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>lib_tbl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>offset</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>lib_tbl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>target_offset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

<return>return <expr><name>ST_STOP</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>symdef</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>rb_str_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lib_offset</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dln_librrb_ary_path</name> <init>= <expr><name>DLN_DEFAULT_LIB_PATH</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>load_lib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>file</name></decl>, <decl><type ref="prev"/><name><name>fbuf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>envpath</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>armagic</name><index>[<expr><name>SARMAG</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ar_hdr</name></name></type> <name>ahdr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>lib_tbl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>data</name></decl>, <decl><type ref="prev"/><name>nsym</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>symdef</name></name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_base</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dln_init_p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_ENOINIT</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>undef_tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_EBADLIB</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lib</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>lib</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>lib</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"lib%s.a"</literal></expr></argument>, <argument><expr><name>lib</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lib</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"DLN_LIBRARY_PATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name> <operator>=</operator> <name>dln_librrb_ary_path</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>path</name> <operator>=</operator> <name>envpath</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>dln_find_file_r</name><argument_list>(<argument><expr><name>lib</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>envpath</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>envpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>syserr</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>armagic</name></expr></argument>, <argument><expr><name>SARMAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>syserr</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>SARMAG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>DLN_ENOTLIB</name></expr>;</expr_stmt>

<goto>goto <name>badlib</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ahdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ahdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>syserr</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ahdr</name></expr></argument>)</argument_list></sizeof> <operator>||</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name><name>ahdr</name><operator>.</operator><name>ar_size</name></name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>badlib</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ahdr</name><operator>.</operator><name>ar_name</name></name></expr></argument>, <argument><expr><literal type="string">"__.SYMDEF"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lib_tbl</name> <operator>=</operator> <call><name>st_init_strtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>xmalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>syserr</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nsym</name> <operator>=</operator> <operator>*</operator><name>data</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>symdef</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <operator>(</operator>struct <name>symdef</name><operator>*</operator><operator>)</operator><operator>(</operator><name>data</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>name_base</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>base</name> <operator>+</operator> <name>nsym</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<while>while <condition>(<expr><name>nsym</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>name_base</name> <operator>+</operator> <name><name>base</name><operator>-&gt;</operator><name>rb_str_index</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>lib_tbl</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>base</name><operator>-&gt;</operator><name>lib_offset</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ahdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nsym</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><name>target_offset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>undef_tbl</name></expr></argument>, <argument><expr><name>search_undef</name></expr></argument>, <argument><expr><name>lib_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>target_offset</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>load_1</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>target_offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>lib_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>badlib</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>undef_tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>lib_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name>SARMAG</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>exec</name></name></type> <name>hdr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>syms</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sym</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>undef_tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ahdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ahdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>syserr</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ahdr</name></expr></argument>)</argument_list></sizeof>

<operator>||</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name><name>ahdr</name><operator>.</operator><name>ar_size</name></name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>badlib</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ahdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>load_header</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>badlib</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>syms</name> <operator>=</operator> <call><name>load_sym</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>syms</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>badlib</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <name>syms</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>syms</name> <operator>+</operator> <operator>(</operator><name><name>hdr</name><operator>.</operator><name>a_syms</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>nlist</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><name>sym</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>n_type</name></name> <operator>==</operator> <name>N_EXT</name><operator>|</operator><name>N_TEXT</name>

<operator>&amp;&amp;</operator> <call><name>st_lookup</name><argument_list>(<argument><expr><name>undef_tbl</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>n_un</name><operator>.</operator><name>n_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>sym</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>found</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>syms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>load_1</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>badlib</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>syserr</name>:</label>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<label><name>badlib</name>:</label>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>load</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dln_init_p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>dln_init</name><argument_list>(<argument><expr><name>dln_argv0</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>file</name><index>[<expr><name>result</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>load_lib</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dln_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>load_1</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type>

<name>dln_sym</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>nlist</name></name> <modifier>*</modifier></type><name>sym</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>sym_tbl</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name><name>sym</name><operator>-&gt;</operator><name>n_value</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_DLN_DLOPEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__hpux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dl.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include> 

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ldr.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NeXT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NS_TARGET_MAJOR</name> <operator>&lt;</operator> <literal type="number">4</literal></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/rld.h&gt;</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/dyld.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NSLINKMODULE_OPTION_BINDNOW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSLINKMODULE_OPTION_BINDNOW</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOSX_DYLD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/dyld.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;imagehlp.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>dln_strerror</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>message</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="string">"%d: "</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>format_message</name><parameter_list>(<parameter><type><name>sublang</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, error, MAKELANGID(LANG_NEUTRAL, (sublang)), message + len, size - len, NULL)</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><call><name>format_message</name><argument_list>(<argument><expr><name>SUBLANG_ENGLISH_US</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>format_message</name><argument_list>(<argument><expr><name>SUBLANG_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>message</name> <operator>+</operator> <name>len</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>message</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dln_strerror</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>dln_strerror(message, sizeof message)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator> <name>defined</name> <name>_AIX</name></expr></cpp:elif>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>dln_strerror</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_DLN_A_OUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>strerror</name><parameter_list>()</parameter_list>;</function_decl>

<switch>switch <condition>(<expr><name>dln_errno</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLN_ECONFL</name></expr>:</case>

<return>return <expr><literal type="string">"Symbol name conflict"</literal></expr>;</return>

<case>case <expr><name>DLN_ENOINIT</name></expr>:</case>

<return>return <expr><literal type="string">"No initializer given"</literal></expr>;</return>

<case>case <expr><name>DLN_EUNDEF</name></expr>:</case>

<return>return <expr><literal type="string">"Unresolved symbols"</literal></expr>;</return>

<case>case <expr><name>DLN_ENOTLIB</name></expr>:</case>

<return>return <expr><literal type="string">"Not a library file"</literal></expr>;</return>

<case>case <expr><name>DLN_EBADLIB</name></expr>:</case>

<return>return <expr><literal type="string">"Malformed library file"</literal></expr>;</return>

<case>case <expr><name>DLN_EINIT</name></expr>:</case>

<return>return <expr><literal type="string">"Not initialized"</literal></expr>;</return>

<default>default:</default>

<return>return <expr><call><name>strerror</name><argument_list>(<argument><expr><name>dln_errno</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_DLN_DLOPEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>dlerror</name><argument_list>()</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>aix_loaderror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>message</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>errbuf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRBUF_APPEND</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strlcat(errbuf, (s), sizeof(errbuf))</cpp:value></cpp:define>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"load failed - %s. "</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>loadquery</name><argument_list>(<argument><expr><name>L_GETMESSAGES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>message</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ERRBUF_APPEND</name><argument_list>(<argument><expr><literal type="string">"Please issue below command for detailed reasons:\n\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ERRBUF_APPEND</name><argument_list>(<argument><expr><literal type="string">"/usr/sbin/execerror ruby "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>message</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ERRBUF_APPEND</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ERRBUF_APPEND</name><argument_list>(<argument><expr><name><name>message</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ERRBUF_APPEND</name><argument_list>(<argument><expr><literal type="string">"\" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ERRBUF_APPEND</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ERRBUF_APPEND</name><argument_list>(<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ERRBUF_APPEND</name><argument_list>(<argument><expr><literal type="string">"[loadquery failed]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>dln_loaderror</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>RUBY_EXPORT</name></expr></cpp:if>

<function_decl><type><name>HANDLE</name></type> <name>rb_libruby_handle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_w32_check_imported</name><parameter_list>(<parameter><decl><type><name>HMODULE</name></type> <name>ext</name></decl></parameter>, <parameter><decl><type><name>HMODULE</name></type> <name>mine</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ULONG</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>IMAGE_IMPORT_DESCRIPTOR</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>ImageDirectoryEntryToData</name><argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>IMAGE_DIRECTORY_ENTRY_IMPORT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>desc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name><name>desc</name><operator>-&gt;</operator><name>Name</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>PIMAGE_THUNK_DATA</name></type> <name>pint</name> <init>= <expr><operator>(</operator><name>PIMAGE_THUNK_DATA</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ext</name> <operator>+</operator> <name><name>desc</name><operator>-&gt;</operator><name>Characteristics</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PIMAGE_THUNK_DATA</name></type> <name>piat</name> <init>= <expr><operator>(</operator><name>PIMAGE_THUNK_DATA</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ext</name> <operator>+</operator> <name><name>desc</name><operator>-&gt;</operator><name>FirstThunk</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name><name>piat</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>Function</name></name></expr>;</condition> <incr><expr><name>piat</name><operator>++</operator></expr><operator>,</operator> <expr><name>pint</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>prefix</name><index>[]</index></name> <init>= <expr><literal type="string">"rb_"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PIMAGE_IMPORT_BY_NAME</name></type> <name>pii</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IMAGE_SNAP_BY_ORDINAL</name><argument_list>(<argument><expr><name><name>pint</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>Ordinal</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pii</name> <operator>=</operator> <operator>(</operator><name>PIMAGE_IMPORT_BY_NAME</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ext</name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>pint</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>AddressOfData</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>pii</name><operator>-&gt;</operator><name>Name</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>FARPROC</name></type> <name>addr</name> <init>= <expr><call><name>GetProcAddress</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>FARPROC</name><operator>)</operator><name><name>piat</name><operator>-&gt;</operator><name>u1</name><operator>.</operator><name>Function</name></name> <operator>==</operator> <name>addr</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>desc</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DLN_NEEDS_ALT_SEPARATOR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>DLN_NEEDS_ALT_SEPARATOR</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>translit_separator</name><parameter_list>(<parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { char *tmp = ALLOCA_N(char, strlen(src) + 1), *p = tmp, c; do { *p++ = ((c = *file++) == '/') ? DLN_NEEDS_ALT_SEPARATOR : c; } while (c); (src) = tmp; } while (0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>translit_separator</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(str)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_DLN_DLOPEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/stdbool.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/warnings.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>COMPILER_WARNING_PUSH</name></type>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>GCC_VERSION_SINCE</name><argument_list>(<argument><expr><literal type="number">4</literal><operator>,</operator> <literal type="number">2</literal><operator>,</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr></cpp:if>

<name>COMPILER_WARNING_IGNORED</name><argument_list>(<argument><expr><operator>-</operator><name>Wpedantic</name></expr></argument>)</argument_list>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static <name>bool</name>

<name>dln_incompatible_library_p</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>handle</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ex</name> <init>= <expr><call><name>dlsym</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>EXTERNAL_PREFIX</name><literal type="string">"ruby_xmalloc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier></type> <name>fp</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ruby_xmalloc</name></expr></init></decl>;</decl_stmt>

<return>return <expr><name>ex</name> <operator>&amp;&amp;</operator> <name>ex</name> <operator>!=</operator> <name>fp</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><name>COMPILER_WARNING_POP</name>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>void</name><modifier>*</modifier></type>

<name>dln_load</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>_WIN32</name> <operator>||</operator> <name>defined</name> <name>USE_DLN_DLOPEN</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>defined</name> <name>RUBY_EXPORT</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>incompatible</name><index>[]</index></name> <init>= <expr><literal type="string">"incompatible library version"</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NeXT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:if>

<decl_stmt><decl><type><name>HINSTANCE</name></type> <name>handle</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>winfile</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>message</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>init_fct</name>)<parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_funcname</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>winfile</name> <operator>=</operator> <call><name>rb_w32_mbstr_to_wstr</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>winfile</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>dln_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>LoadLibraryW</name><argument_list>(<argument><expr><name>winfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>winfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>handle</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>dln_strerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>failed</name>;</goto>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>RUBY_EXPORT</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_w32_check_imported</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><call><name>rb_libruby_handle</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>error</name> <operator>=</operator> <name>incompatible</name></expr>;</expr_stmt>

<goto>goto <name>failed</name>;</goto>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>init_fct</name> <operator>=</operator> <operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>()</argument_list></call><operator>)</operator><call><name>GetProcAddress</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>dln_loaderror</name><argument_list>(<argument><expr><literal type="string">"%s - %s\n%s"</literal></expr></argument>, <argument><expr><call><name>dln_strerror</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>init_fct</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>handle</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_DLN_A_OUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>load</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>dln_strerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>failed</name>;</goto>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_funcname</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>translit_separator</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_DLN_DLOPEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_DEFINED</name></cpp:macro></cpp:define>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>init_fct</name>)<parameter_list>()</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RTLD_LAZY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTLD_LAZY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__INTERIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RTLD_GLOBAL</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>RTLD_GLOBAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTLD_GLOBAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>handle</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><call><name>dlopen</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>RTLD_LAZY</name><operator>|</operator><name>RTLD_GLOBAL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>dln_strerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>failed</name>;</goto>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>RUBY_EXPORT</name></expr></cpp:if>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>dln_incompatible_library_p</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__APPLE__</name> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MAC_OS_X_VERSION_MIN_REQUIRED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>MAC_OS_X_VERSION_MIN_REQUIRED</name> <operator>&lt;</operator> <name>MAC_OS_X_VERSION_10_11</name><operator>)</operator></expr></cpp:if>

<expr_stmt><expr><call><name>rb_fatal</name><argument_list>(<argument><expr><literal type="string">"%s - %s"</literal></expr></argument>, <argument><expr><name>incompatible</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>error</name> <operator>=</operator> <name>incompatible</name></expr>;</expr_stmt>

<goto>goto <name>failed</name>;</goto>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>init_fct</name> <operator>=</operator> <operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>()</argument_list></call><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>dlsym</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>init_fct</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>errlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>error</name> <operator>=</operator> <call><name>dln_strerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>memcpy</name><argument_list>(<argument><expr><call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>errlen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><name>errlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>failed</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>init_fct</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>handle</name></expr>;</return>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__hpux</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_DEFINED</name></cpp:macro></cpp:define>

<block>{<block_content>

<decl_stmt><decl><type><name>shl_t</name></type> <name>lib</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>init_fct</name>)<parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>BIND_DEFERRED</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lib</name> <operator>=</operator> <call><name>shl_load</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lib</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>errno</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>dln_loaderror</name><argument_list>(<argument><expr><literal type="string">"%s - %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>shl_findsym</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lib</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>TYPE_PROCEDURE</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>init_fct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>init_fct</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>shl_findsym</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lib</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>TYPE_UNDEFINED</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>init_fct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>init_fct</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSYM</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dln_loaderror</name><argument_list>(<argument><expr><literal type="string">"%s - %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>ENOSYM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>init_fct</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>lib</name></expr>;</return>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_DEFINED</name></cpp:macro></cpp:define>

<block>{<block_content>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>init_fct</name>)<parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>init_fct</name> <operator>=</operator> <operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>()</argument_list></call><operator>)</operator><call><name>load</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>file</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>init_fct</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>aix_loaderror</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>loadbind</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>dln_load</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>init_fct</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>aix_loaderror</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>init_fct</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>init_fct</name></expr>;</return>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOSX_DYLD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLN_DEFINED</name></cpp:macro></cpp:define>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>dyld_result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>NSObjectFileImage</name></type> <name>obj_file</name></decl>;</decl_stmt> 

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>init_fct</name>)<parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>dyld_result</name> <operator>=</operator> <call><name>NSCreateObjectFileImageFromFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dyld_result</name> <operator>!=</operator> <name>NSObjectFileImageSuccess</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>dln_loaderror</name><argument_list>(<argument><expr><literal type="string">"Failed to load %.200s"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>NSLinkModule</name><argument_list>(<argument><expr><name>obj_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>NSLINKMODULE_OPTION_BINDNOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NSIsSymbolNameDefined</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>dln_loaderror</name><argument_list>(<argument><expr><literal type="string">"Failed to lookup Init function %.200s"</literal></expr></argument>,<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>init_fct</name> <operator>=</operator> <call><name>NSAddressOfSymbol</name><argument_list>(<argument><expr><call><name>NSLookupAndBindSymbol</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>init_fct</name>)<argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>init_fct</name></expr>;</return>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>DLN_DEFINED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>dln_notimplement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NeXT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<label><name>failed</name>:</label>

<expr_stmt><expr><call><name>dln_loaderror</name><argument_list>(<argument><expr><literal type="string">"%s - %s"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return> 

</block_content>}</block></function>

</unit>
