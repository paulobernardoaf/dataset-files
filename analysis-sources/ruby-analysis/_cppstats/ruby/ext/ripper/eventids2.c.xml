<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\ext\ripper\eventids2.c"><enum>enum <block>{

<decl><name>tIGNORED_NL</name> <init>= <expr><name>tLAST_TOKEN</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>,

<decl><name>tCOMMENT</name></decl>,

<decl><name>tEMBDOC_BEG</name></decl>,

<decl><name>tEMBDOC</name></decl>,

<decl><name>tEMBDOC_END</name></decl>,

<decl><name>tHEREDOC_BEG</name></decl>,

<decl><name>tHEREDOC_END</name></decl>,

<decl><name>k__END__</name></decl>

}</block>;</enum>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_backref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_backtick</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_comma</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_const</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_cvar</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_embexpr_beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_embexpr_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_embvar</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_float</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_gvar</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_ident</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_imaginary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_int</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_ivar</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_kw</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_lbrace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_lbracket</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_lparen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_nl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_op</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_period</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_rbrace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_rbracket</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_rparen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_semicolon</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_symbeg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_tstring_beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_tstring_content</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_tstring_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_words_beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_qwords_beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_qsymbols_beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_symbols_beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_words_sep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_rational</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_regexp_beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_regexp_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_label</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_label_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_tlambda</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_tlambeg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_ignored_nl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_comment</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_embdoc_beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_embdoc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_embdoc_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_heredoc_beg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_heredoc_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id___end__</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ripper_id_CHAR</name></decl>;</decl_stmt>

}</block></struct></type> <name>ripper_scanner_ids_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ripper_scanner_ids_t</name></type> <name>ripper_scanner_ids</name></decl>;</decl_stmt>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eventids2table.c"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ripper_init_eventids2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>set_id2</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ripper_scanner_ids.ripper_id_##name = rb_intern_const("on_"#name)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>backtick</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><specifier>const</specifier></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>cvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>embexpr_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>embexpr_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>embvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>gvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>imaginary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>ivar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>lbrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>lbracket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>lparen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>nl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>period</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>rbrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>rbracket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>rparen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>semicolon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>symbeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>tstring_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>tstring_content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>tstring_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>words_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>qwords_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>qsymbols_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>symbols_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>words_sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>rational</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>regexp_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>regexp_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>label_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>tlambda</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>tlambeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>ignored_nl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>embdoc_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>embdoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>embdoc_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>heredoc_beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>heredoc_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>__end__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_id2</name><argument_list>(<argument><expr><name>CHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>k__END___range</name></expr></argument>, <argument><expr><name>k__END__</name> <operator>&lt;</operator> <name>SHRT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>ripper_scanner_ids_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ripper_scanner_ids</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name>SHRT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><specifier>static</specifier> <name>ID</name></type>

<name>ripper_token2eventid</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>yytokentype</name></name></type> <name>tok</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O</name><parameter_list>(<parameter><type><name>member</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(int)offsetof(ripper_scanner_ids_t, ripper_id_##member)+1</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name><name>offsets</name><index>[]</index></name> <init>= <expr><block>{

<expr><index>[<expr><literal type="char">' '</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>words_sep</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'!'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'%'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'&amp;'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'*'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'+'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'-'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'/'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'&lt;'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'='</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'&gt;'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'?'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'^'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'|'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'~'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">':'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">','</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'.'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>period</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">';'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>semicolon</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'`'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>backtick</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'\n'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>nl</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_alias</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_and</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_begin</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_break</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_case</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_class</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_def</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_defined</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_do</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_do_block</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_do_cond</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_else</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_elsif</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_end</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_ensure</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_false</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_for</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_if</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>modifier_if</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_in</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_module</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_next</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_nil</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_not</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_or</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_redo</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_rescue</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>modifier_rescue</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_retry</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_return</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_self</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_super</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_then</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_true</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_undef</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_unless</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>modifier_unless</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_until</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>modifier_until</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_when</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_while</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>modifier_while</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_yield</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword__FILE__</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword__LINE__</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword__ENCODING__</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_BEGIN</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_END</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>keyword_do_LAMBDA</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tAMPER</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tANDOP</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tAREF</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tASET</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tASSOC</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tBACK_REF</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tCHAR</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>CHAR</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tCMP</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tCOLON2</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tCOLON3</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tCONSTANT</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><specifier>const</specifier></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tCVAR</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>cvar</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tDOT2</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tDOT3</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tBDOT2</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tBDOT3</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tEQ</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tEQQ</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tFID</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tFLOAT</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tGEQ</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tGVAR</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>gvar</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tIDENTIFIER</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tIMAGINARY</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>imaginary</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tINTEGER</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tIVAR</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>ivar</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLBRACE</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>lbrace</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLBRACE_ARG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>lbrace</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'{'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>lbrace</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'}'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>rbrace</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLBRACK</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>lbracket</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'['</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>lbracket</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">']'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>rbracket</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLEQ</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLPAREN</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>lparen</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLPAREN_ARG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>lparen</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">'('</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>lparen</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><literal type="char">')'</literal></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>rparen</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLSHFT</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tMATCH</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tNEQ</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tNMATCH</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tNTH_REF</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tOP_ASGN</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tOROP</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tPOW</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tQWORDS_BEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>qwords_beg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tQSYMBOLS_BEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>qsymbols_beg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSYMBOLS_BEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>symbols_beg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tRATIONAL</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>rational</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tREGEXP_BEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>regexp_beg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tREGEXP_END</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>regexp_end</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tRPAREN</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>rparen</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tRSHFT</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSTAR</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tDSTAR</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tANDDOT</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSTRING_BEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>tstring_beg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSTRING_CONTENT</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>tstring_content</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSTRING_DBEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>embexpr_beg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSTRING_DEND</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>embexpr_end</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSTRING_DVAR</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>embvar</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSTRING_END</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>tstring_end</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSYMBEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>symbeg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tUMINUS</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tUMINUS_NUM</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tUPLUS</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tWORDS_BEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>words_beg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tXSTRING_BEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>backtick</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLABEL</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLABEL_END</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>label_end</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLAMBDA</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>tlambda</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tLAMBEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>tlambeg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tIGNORED_NL</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>ignored_nl</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tCOMMENT</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tEMBDOC_BEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>embdoc_beg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tEMBDOC</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>embdoc</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tEMBDOC_END</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>embdoc_end</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tSP</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tHEREDOC_BEG</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>heredoc_beg</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>tHEREDOC_END</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>heredoc_end</name></expr></argument>)</argument_list></call></expr>,

<expr><index>[<expr><name>k__END__</name></expr>]</index> <operator>=</operator> <call><name>O</name><argument_list>(<argument><expr><name>__end__</name></expr></argument>)</argument_list></call></expr>,

}</block></expr></init></decl>;</decl_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>O</name></cpp:undef>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>tok</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>offsets</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>=</operator> <name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>ID</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ripper_scanner_ids</name><operator>-</operator><literal type="number">1</literal><operator>+</operator><name>i</name><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>ripper_scanner_ids</name><operator>.</operator><name>ripper_id_CHAR</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"[Ripper FATAL] unknown token %d"</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
