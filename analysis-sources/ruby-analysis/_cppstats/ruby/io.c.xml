<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\io.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/ruby.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/io.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_POLL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD_version</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>__FreeBSD_version</name> <operator>&gt;=</operator> <literal type="number">1100000</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_POLL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_POLL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>free</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>free</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>xfree(x)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_NET_SOCKET_H</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net/socket.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_SYS_SOCKET_H</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BOW__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_SAFE_RENAME</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__DragonFly__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_nec_ews</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_SETVBUF</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__QNXNTO__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unix.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_IOCTL_H</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL_H</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/fcntl.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_OFF_T</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>off_t</name></cpp:macro> <cpp:value>long</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_PARAM_H</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__HIUX_MPP__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>NOFILE</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOFILE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCALL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syscall.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_SYS_SYSCALL_H</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/syscall.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_UIO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/uio.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_WAIT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_COPYFILE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;copyfile.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dln.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"encindex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/inits.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/numeric.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/process.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/stdbool.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ccan/list/list.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/transcode.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/variable.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_atomic.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>USE_POLL</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>O_ACCMODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_ACCMODE</name></cpp:macro> <cpp:value>(O_RDONLY | O_WRONLY | O_RDWR)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_OFF_T</name> <operator>&gt;</operator> <name>SIZEOF_LONG</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:error>#<cpp:directive>error</cpp:directive> off_t is bigger than long, but you have no long long...</cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PIPE_BUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_PIPE_BUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PIPE_BUF</name></cpp:macro> <cpp:value>_POSIX_PIPE_BUF</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PIPE_BUF</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EWOULDBLOCK</name></cpp:macro> <cpp:value>EAGAIN</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE___SYSCALL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<function_decl><type><name>off_t</name></type> <name>__syscall</name><parameter_list>(<parameter><decl><type><name>quad_t</name></type> <name>number</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IO_RBUF_CAPA_MIN</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IO_CBUF_CAPA_MIN</name></cpp:macro> <cpp:value>(128*1024)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IO_RBUF_CAPA_FOR</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(NEED_READCONV(fptr) ? IO_CBUF_CAPA_MIN : IO_RBUF_CAPA_MIN)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IO_WBUF_CAPA_MIN</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>open</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>open</name></cpp:macro> <cpp:value>rb_w32_uopen</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rename</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rename</name><parameter_list>(<parameter><type><name>f</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_urename((f), (t))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_PIPE_NONBLOCK_DEFAULT</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_PIPE_NONBLOCK_DEFAULT</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_PIPE_NONBLOCK_DEFAULT</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cIO</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eEOFError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eIOError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_mWaitReadable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_mWaitWritable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eEAGAINWaitReadable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eEAGAINWaitWritable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eEWOULDBLOCKWaitReadable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eEWOULDBLOCKWaitWritable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eEINPROGRESSWaitWritable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eEINPROGRESSWaitReadable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_stdin</name></decl>, <decl><type ref="prev"/><name>rb_stdout</name></decl>, <decl><type ref="prev"/><name>rb_stderr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>orig_stdout</name></decl>, <decl><type ref="prev"/><name>orig_stderr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_output_fs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_rs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_output_rs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_default_rs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>argf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_write</name></decl>, <decl><type ref="prev"/><name>id_read</name></decl>, <decl><type ref="prev"/><name>id_getc</name></decl>, <decl><type ref="prev"/><name>id_flush</name></decl>, <decl><type ref="prev"/><name>id_readpartial</name></decl>, <decl><type ref="prev"/><name>id_set_encoding</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_mode</name></decl>, <decl><type ref="prev"/><name>sym_perm</name></decl>, <decl><type ref="prev"/><name>sym_flags</name></decl>, <decl><type ref="prev"/><name>sym_extenc</name></decl>, <decl><type ref="prev"/><name>sym_intenc</name></decl>, <decl><type ref="prev"/><name>sym_encoding</name></decl>, <decl><type ref="prev"/><name>sym_open_args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_textmode</name></decl>, <decl><type ref="prev"/><name>sym_binmode</name></decl>, <decl><type ref="prev"/><name>sym_autoclose</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_SET</name></decl>, <decl><type ref="prev"/><name>sym_CUR</name></decl>, <decl><type ref="prev"/><name>sym_END</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_wait_readable</name></decl>, <decl><type ref="prev"/><name>sym_wait_writable</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SEEK_DATA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_DATA</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SEEK_HOLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_HOLE</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>argf</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>filename</name></decl>, <decl><type ref="prev"/><name>current_file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>last_lineno</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>lineno</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>inplace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_io_enc_t</name></name></type> <name>encs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int8_t</name></type> <name>init_p</name></decl>, <decl><type ref="prev"/><name>next_p</name></decl>, <decl><type ref="prev"/><name>binmode</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_atomic_t</name></type> <name>max_file_descriptor</name> <init>= <expr><name>NOFILE</name></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>

<name>rb_update_max_fd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>afd</name> <init>= <expr><operator>(</operator><name>rb_atomic_t</name><operator>)</operator><name>fd</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>max_fd</name> <init>= <expr><name>max_file_descriptor</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>afd</name> <operator>&lt;=</operator> <name>max_fd</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EBADF</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_update_max_fd: invalid fd (%d) given."</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>max_fd</name> <operator>&lt;</operator> <name>afd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max_fd</name> <operator>=</operator> <call><name>ATOMIC_CAS</name><argument_list>(<argument><expr><name>max_file_descriptor</name></expr></argument>, <argument><expr><name>max_fd</name></expr></argument>, <argument><expr><name>afd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_maygvl_fd_fix_cloexec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_SETFD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>, <decl><type ref="prev"/><name>flags2</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_maygvl_fd_fix_cloexec: fcntl(%d, F_GETFD) failed: %s"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags2</name> <operator>=</operator> <name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>FD_CLOEXEC</name></expr>;</expr_stmt></block_content></block></if> 

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>flags2</name> <operator>=</operator> <name>flags</name> <operator>|</operator> <name>FD_CLOEXEC</name></expr>;</expr_stmt></block_content></block></else></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>flags2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><name>flags2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_maygvl_fd_fix_cloexec: fcntl(%d, F_SETFD, %d) failed: %s"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>flags2</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_fd_fix_cloexec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_maygvl_fd_fix_cloexec</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_update_max_fd</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_fix_detect_o_cloexec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_fix_detect_o_cloexec: fcntl(%d, F_GETFD) failed: %s"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FD_CLOEXEC</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<expr_stmt><expr><call><name>rb_maygvl_fd_fix_cloexec</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_cloexec_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>mode_t</name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>o_cloexec_state</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>retry_interval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>retry_max_count</name> <init>= <expr><literal type="number">10000</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retry_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_CLOEXEC</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>O_NOINHERIT</name></expr></cpp:elif>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_NOINHERIT</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>!=</operator> <name>EAGAIN</name> <operator>&amp;&amp;</operator> <name>e</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>retry_count</name><operator>++</operator> <operator>&gt;=</operator> <name>retry_max_count</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><name>retry_interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">2</literal> <operator>||</operator> <name>o_cloexec_state</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_maygvl_fd_fix_cloexec</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>o_cloexec_state</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>o_cloexec_state</name> <operator>=</operator> <call><name>rb_fix_detect_o_cloexec</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_cloexec_dup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>oldfd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_cloexec_fcntl_dupfd</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_cloexec_dup2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>oldfd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newfd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>oldfd</name> <operator>==</operator> <name>newfd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>newfd</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DUP3</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>try_dup3</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">2</literal> <operator>&lt;</operator> <name>newfd</name> <operator>&amp;&amp;</operator> <name>try_dup3</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dup3</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOSYS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>try_dup3</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dup2</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dup2</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dup2</name><argument_list>(<argument><expr><name>oldfd</name></expr></argument>, <argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_maygvl_fd_fix_cloexec</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_fd_set_nonblock</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>rb_w32_set_nonblock</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<decl_stmt><decl><type><name>int</name></type> <name>oflags</name> <init>= <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>oflags</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>oflags</name> <operator>&amp;</operator> <name>O_NONBLOCK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>oflags</name> <operator>|=</operator> <name>O_NONBLOCK</name></expr>;</expr_stmt>

<return>return <expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>oflags</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_cloexec_pipe</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name><name>fildes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PIPE2</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>try_pipe2</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>try_pipe2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pipe2</name><argument_list>(<argument><expr><name>fildes</name></expr></argument>, <argument><expr><name>O_CLOEXEC</name> <operator>|</operator> <name>RUBY_PIPE_NONBLOCK_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOSYS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>try_pipe2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pipe</name><argument_list>(<argument><expr><name>fildes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pipe</name><argument_list>(<argument><expr><name>fildes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pipe</name><argument_list>(<argument><expr><name>fildes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fildes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>fildes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fildes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENFILE</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_maygvl_fd_fix_cloexec</name><argument_list>(<argument><expr><name><name>fildes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_maygvl_fd_fix_cloexec</name><argument_list>(<argument><expr><name><name>fildes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>RUBY_PIPE_NONBLOCK_DEFAULT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_fd_set_nonblock</name><argument_list>(<argument><expr><name><name>fildes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_fd_set_nonblock</name><argument_list>(<argument><expr><name><name>fildes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_cloexec_fcntl_dupfd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>minfd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_DUPFD_CLOEXEC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_DUPFD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>try_dupfd_cloexec</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>try_dupfd_cloexec</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_DUPFD_CLOEXEC</name></expr></argument>, <argument><expr><name>minfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_maygvl_fd_fix_cloexec</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_DUPFD</name></expr></argument>, <argument><expr><name>minfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>try_dupfd_cloexec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_DUPFD</name></expr></argument>, <argument><expr><name>minfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_DUPFD</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_DUPFD</name></expr></argument>, <argument><expr><name>minfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DUP</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ret</name> <operator>&lt;</operator> <name>minfd</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>prev_fd</name> <init>= <expr><name>ret</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_cloexec_fcntl_dupfd</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>minfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>prev_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"dup() or fcntl(F_DUPFD) must be supported."</cpp:literal></cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_maygvl_fd_fix_cloexec</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>argf_of</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*(struct argf *)DATA_PTR(obj))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGF</name></cpp:macro> <cpp:value>argf_of(argf)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GetWriteIO</name><parameter_list>(<parameter><type><name>io</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_io_get_write_io(io)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_DATA_PENDING</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;rbuf.len)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_DATA_PENDING_COUNT</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;rbuf.len)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_DATA_PENDING_PTR</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;rbuf.ptr+(fptr)-&gt;rbuf.off)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_DATA_BUFFERED</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>READ_DATA_PENDING(fptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_PENDING</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;cbuf.len)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_PENDING_COUNT</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;cbuf.len)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_PENDING_PTR</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;cbuf.ptr+(fptr)-&gt;cbuf.off)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_FD_IN_WIN32</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(rb_w32_io_cancelable_p((fptr)-&gt;fd) ? 0 : rb_thread_wait_fd((fptr)-&gt;fd))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_FD_IN_WIN32</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHECK</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (!READ_DATA_PENDING(fptr)) {WAIT_FD_IN_WIN32(fptr);rb_io_check_closed(fptr);}} while(0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_S_ISSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISSOCK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_S_ISSOCK(m)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_S_IFSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISSOCK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == _S_IFSOCK)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IFSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISSOCK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFSOCK)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>io_fflush</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>rb_io_t</name> <modifier>*</modifier></type><name>flush_before_seek</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_NEWLINE_DECORATOR_ON_READ</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;mode &amp; FMODE_TEXTMODE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_NEWLINE_DECORATOR_ON_WRITE</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;mode &amp; FMODE_TEXTMODE)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_TEST_CRLF_ENVIRONMENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TEXTMODE</name></cpp:macro> <cpp:value>FMODE_TEXTMODE</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEXTMODE_NEWLINE_DECORATOR_ON_WRITE</name></cpp:macro> <cpp:value>ECONV_CRLF_NEWLINE_DECORATOR</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_READCONV</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;encs.enc2 != NULL || (fptr)-&gt;encs.ecflags &amp; ~ECONV_CRLF_NEWLINE_DECORATOR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITECONV_MASK</name></cpp:macro> <cpp:value>( (ECONV_DECORATOR_MASK &amp; ~ECONV_CRLF_NEWLINE_DECORATOR)|ECONV_STATEFUL_DECORATOR_MASK|0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_WRITECONV</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((fptr)-&gt;encs.enc != NULL &amp;&amp; (fptr)-&gt;encs.enc != rb_ascii8bit_encoding()) || ((fptr)-&gt;encs.ecflags &amp; WRITECONV_MASK) || 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_BINARY_MODE</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>setmode((fptr)-&gt;fd, O_BINARY)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_NEWLINE_DECORATOR_ON_READ_CHECK</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (NEED_NEWLINE_DECORATOR_ON_READ(fptr)) {if (((fptr)-&gt;mode &amp; FMODE_READABLE) &amp;&amp;!((fptr)-&gt;encs.ecflags &amp; ECONV_NEWLINE_DECORATOR_MASK)) {setmode((fptr)-&gt;fd, O_BINARY);}else {setmode((fptr)-&gt;fd, O_TEXT);}}} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2</name><parameter_list>(<parameter><type><name>enc2</name></type></parameter>, <parameter><type><name>ecflags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if ((enc2) &amp;&amp; ((ecflags) &amp; ECONV_DEFAULT_NEWLINE_DECORATOR)) {(ecflags) |= ECONV_UNIVERSAL_NEWLINE_DECORATOR;}} while(0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>io_unread</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>off_t</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>read_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>newlines</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>extra_max</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_DUPLEX</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_w32_fd_is_text</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ESPIPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <name>FMODE_DUPLEX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ESPIPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <name>FMODE_DUPLEX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>extra_max</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>pos</name> <operator>-</operator> <name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>ptr</name></name> <operator>+</operator> <name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>ptr</name></name> <operator>+</operator> <name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>capa</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>newlines</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newlines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>extra_max</name> <operator>==</operator> <name>newlines</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>+</operator> <name>newlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>newlines</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>pos</name> <operator>-</operator> <name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>newlines</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newlines</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>newlines</name><operator>--</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>read_size</name> <operator>=</operator> <call><name>_read</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>+</operator> <name>newlines</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>read_size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>read_size</name> <operator>==</operator> <name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>lseek</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>newlines</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>set_binary_mode_with_seek_cur</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_w32_fd_is_text</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>O_BINARY</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_DUPLEX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>setmode</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>flush_before_seek</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>setmode</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_BINARY_MODE_WITH_SEEK_CUR</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>set_binary_mode_with_seek_cur(fptr)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_TEXTMODE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_READCONV</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fptr)-&gt;encs.enc2 != NULL || NEED_NEWLINE_DECORATOR_ON_READ(fptr))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_WRITECONV</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((fptr)-&gt;encs.enc != NULL &amp;&amp; (fptr)-&gt;encs.enc != rb_ascii8bit_encoding()) || NEED_NEWLINE_DECORATOR_ON_WRITE(fptr) || ((fptr)-&gt;encs.ecflags &amp; (ECONV_DECORATOR_MASK|ECONV_STATEFUL_DECORATOR_MASK)) || 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_BINARY_MODE</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(fptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_NEWLINE_DECORATOR_ON_READ_CHECK</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(fptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2</name><parameter_list>(<parameter><type><name>enc2</name></type></parameter>, <parameter><type><name>ecflags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)(enc2), (void)(ecflags))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_BINARY_MODE_WITH_SEEK_CUR</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(fptr)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>HAVE_SHUTDOWN</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>shutdown</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>shutdown</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_socket</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>, <parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_is_socket(fd)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISSOCK</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_socket</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>, <parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>is_socket</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sbuf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>S_ISSOCK</name><argument_list>(<argument><expr><name><name>sbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>closed_stream</name><index>[]</index></name> <init>= <expr><literal type="string">"closed stream"</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>io_fd_check_closed</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_check_ints</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><name>closed_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_eof_error</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEOFError</name></expr></argument>, <argument><expr><literal type="string">"end of file reached"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_io_taint_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>io</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_io_check_initialized</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized stream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_io_check_closed</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_io_check_initialized</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>io_fd_check_closed</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_io_t</name> <modifier>*</modifier></type>

<name>rb_io_get_fptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><call><name>RFILE</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_io_check_initialized</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>fptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_io_get_io</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_convert_type_with_id</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>T_FILE</name></expr></argument>, <argument><expr><literal type="string">"IO"</literal></expr></argument>, <argument><expr><name>idTo_io</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_io_check_io</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_convert_type_with_id</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>T_FILE</name></expr></argument>, <argument><expr><literal type="string">"IO"</literal></expr></argument>, <argument><expr><name>idTo_io</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_io_get_write_io</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>write_io</name></decl>;</decl_stmt>

<expr_stmt><expr><name>write_io</name> <operator>=</operator> <call><name>rb_io_get_fptr</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tied_io_for_writing</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>write_io</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>write_io</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>io</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_io_set_write_io</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>w</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>write_io</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><call><name>rb_io_get_fptr</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>GetWriteIO</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>write_io</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>tied_io_for_writing</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>tied_io_for_writing</name></name> <operator>=</operator> <name>w</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>write_io</name></expr> ?</condition><then> <expr><name>write_io</name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_io_s_try_convert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_io_check_io</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_TEST_CRLF_ENVIRONMENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>io_unread</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>off_t</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_DUPLEX</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lseek</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ESPIPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <name>FMODE_DUPLEX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type><name>io_input_encoding</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>io_ungetbyte</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>min_capa</name> <init>= <expr><call><name>IO_RBUF_CAPA_FOR</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&gt;</operator> <name>SIZEOF_INT</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><literal type="string">"ungetbyte failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>min_capa</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>min_capa</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>capa</name></name> <operator>&lt;</operator> <name>len</name> <operator>+</operator> <name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><literal type="string">"ungetbyte failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>capa</name></name><operator>-</operator><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name></expr></argument>,

<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name></expr></argument>,

<argument><expr><name>char</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>capa</name></name><operator>-</operator><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name><operator>-=</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name><operator>+=</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>off</name></name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_io_t</name> <modifier>*</modifier></type>

<name>flush_before_seek</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>io_fflush</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>io_unread</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>fptr</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>io_seek</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>, <parameter><type><name>ofs</name></type></parameter>, <parameter><type><name>whence</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(errno = 0, lseek(flush_before_seek(fptr)-&gt;fd, (ofs), (whence)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>io_tell</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>lseek(flush_before_seek(fptr)-&gt;fd, 0, SEEK_CUR)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEEK_SET</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEEK_CUR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEEK_END</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_io_check_char_readable</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_READABLE</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><literal type="string">"not opened for reading"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>io_fflush</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>tied_io_for_writing</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>wfptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>tied_io_for_writing</name></name></expr></argument>, <argument><expr><name>wfptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>io_fflush</name><argument_list>(<argument><expr><name>wfptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_io_check_byte_readable</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_io_check_char_readable</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>READ_CHAR_PENDING</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><literal type="string">"byte oriented read for character buffered IO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_io_check_readable</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_io_check_byte_readable</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name><modifier>*</modifier></type>

<name>io_read_encoding</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name><modifier>*</modifier></type>

<name>io_input_encoding</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc2</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc2</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>io_read_encoding</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_io_check_writable</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_WRITABLE</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><literal type="string">"not opened for writing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>rbuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>io_unread</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_io_read_pending</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>READ_CHAR_PENDING</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 

<return>return <expr><call><name>READ_DATA_PENDING</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_io_read_check</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>READ_DATA_PENDING</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_thread_wait_fd</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_gc_for_fd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EMFILE</name> <operator>||</operator> <name>err</name> <operator>==</operator> <name>ENFILE</name> <operator>||</operator> <name>err</name> <operator>==</operator> <name>ENOMEM</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ruby_dup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>rb_cloexec_dup</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_gc_for_fd</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>rb_cloexec_dup</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_syserr_fail</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_update_max_fd</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>fd</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>NEWOBJ_OF</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr>struct <name>RFile</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>io</name><operator>-&gt;</operator><name>fptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>io</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISREG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISREG</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFREG)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>io_internal_read_struct</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nonblock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>capa</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>io_internal_write_struct</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>capa</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WRITEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>io_internal_writev_struct</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iovcnt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iovec</name></name> <modifier>*</modifier></type><name>iov</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>nogvl_wait_for_single_fd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>events</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>internal_read_func</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_internal_read_struct</name></name> <modifier>*</modifier></type><name>iis</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>r</name></decl>;</decl_stmt>

<label><name>retry</name>:</label>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>iis</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>iis</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>iis</name><operator>-&gt;</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>iis</name><operator>-&gt;</operator><name>nonblock</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>nogvl_wait_for_single_fd</name><argument_list>(<argument><expr><name><name>iis</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>RB_WAITFD_IN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>retry</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__APPLE__</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>do_write_retry</name><parameter_list>(<parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {ret = code;} while (ret == -1 &amp;&amp; errno == EPROTOTYPE)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>do_write_retry</name><parameter_list>(<parameter><type><name>code</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ret = code</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>internal_write_func</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_internal_write_struct</name></name> <modifier>*</modifier></type><name>iis</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>do_write_retry</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name><name>iis</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>iis</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>iis</name><operator>-&gt;</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type>

<name>internal_write_func2</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><call><name>internal_write_func</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WRITEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>internal_writev_func</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_internal_writev_struct</name></name> <modifier>*</modifier></type><name>iis</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>do_write_retry</name><argument_list>(<argument><expr><call><name>writev</name><argument_list>(<argument><expr><name><name>iis</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>iis</name><operator>-&gt;</operator><name>iov</name></name></expr></argument>, <argument><expr><name><name>iis</name><operator>-&gt;</operator><name>iovcnt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>

<name>rb_read_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_internal_read_struct</name></name></type> <name>iis</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>nonblock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>rb_thread_io_blocking_region</name><argument_list>(<argument><expr><name>internal_read_func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iis</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>

<name>rb_write_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_internal_write_struct</name></name></type> <name>iis</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>rb_thread_io_blocking_region</name><argument_list>(<argument><expr><name>internal_write_func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iis</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>

<name>rb_write_internal2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_internal_write_struct</name></name></type> <name>iis</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>rb_thread_call_without_gvl2</name><argument_list>(<argument><expr><name>internal_write_func2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iis</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WRITEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>

<name>rb_writev_internal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iovec</name></name> <modifier>*</modifier></type><name>iov</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iovcnt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>io_internal_writev_struct</name></name></type> <name>iis</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>iov</name></name> <operator>=</operator> <name>iov</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iis</name><operator>.</operator><name>iovcnt</name></name> <operator>=</operator> <name>iovcnt</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>rb_thread_io_blocking_region</name><argument_list>(<argument><expr><name>internal_writev_func</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iis</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_flush_buffer_sync</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>r</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type>

<name>io_flush_buffer_sync2</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>io_flush_buffer_sync</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><operator>!</operator><name>result</name></expr> ?</condition><then> <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>result</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_flush_buffer_async</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><operator>(</operator><name>rb_io_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_thread_io_blocking_region</name><argument_list>(<argument><expr><name>io_flush_buffer_sync</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_flush_buffer_async2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><operator>(</operator><name>rb_io_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl2</name><argument_list>(<argument><expr><name>io_flush_buffer_sync2</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>io_flush_buffer</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_mutex_owned_p</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>io_flush_buffer_async2</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>fptr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rb_mutex_synchronize</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr></argument>, <argument><expr><name>io_flush_buffer_async2</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>fptr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>io_flush_buffer_async</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>fptr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>io_fflush</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>io_flush_buffer</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_io_wait_writable</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_io_wait_readable</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>f</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>io_fd_check_closed</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>errno</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EINTR</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ERESTART</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>ERESTART</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_thread_check_ints</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

<case>case <expr><name>EAGAIN</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name></expr></cpp:if>

<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_thread_wait_fd</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_io_wait_writable</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>f</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>io_fd_check_closed</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>errno</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EINTR</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ERESTART</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>ERESTART</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_thread_check_ints</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

<case>case <expr><name>EAGAIN</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name></expr></cpp:if>

<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_thread_fd_writable</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>make_writeconv</name><parameter_list>(<parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_initialized</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>senc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>denc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ecflags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ecopts</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_initialized</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ecflags</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>ecflags</name></name> <operator>&amp;</operator> <operator>~</operator><name>ECONV_NEWLINE_DECORATOR_READ_MASK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ecopts</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>ecopts</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc</name></name> <operator>||</operator> <operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc</name></name> <operator>==</operator> <call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc2</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecopts</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv</name></name> <operator>=</operator> <call><name>rb_econv_open_opts</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fptr</name><operator>-&gt;</operator><name>writeconv</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_econv_open_exc</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_asciicompat</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <ternary><condition><expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc2</name></name></expr> ?</condition><then> <expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc2</name></name></expr> </then><else>: <expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>senc</name> <operator>=</operator> <call><name>rb_econv_asciicompat_encoding</name><argument_list>(<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>senc</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>ecflags</name></name> <operator>&amp;</operator> <name>ECONV_STATEFUL_DECORATOR_MASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecflags</name></name> <operator>=</operator> <name>ecflags</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecopts</name></name> <operator>=</operator> <name>ecopts</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_asciicompat</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecflags</name></name> <operator>=</operator> <name>ecflags</name> <operator>&amp;</operator> <operator>~</operator><name>ECONV_STATEFUL_DECORATOR_MASK</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecopts</name></name> <operator>=</operator> <name>ecopts</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>senc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>denc</name> <operator>=</operator> <call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_asciicompat</name></name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><name>senc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>senc</name> <operator>=</operator> <name>denc</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_asciicompat</name></name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ecflags</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>ecflags</name></name> <operator>&amp;</operator> <operator>(</operator><name>ECONV_ERROR_HANDLER_MASK</name><operator>|</operator><name>ECONV_STATEFUL_DECORATOR_MASK</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>ecopts</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>ecopts</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv</name></name> <operator>=</operator> <call><name>rb_econv_open_opts</name><argument_list>(<argument><expr><name>senc</name></expr></argument>, <argument><expr><name>denc</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fptr</name><operator>-&gt;</operator><name>writeconv</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_econv_open_exc</name><argument_list>(<argument><expr><name>senc</name></expr></argument>, <argument><expr><name>denc</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>binwrite_arg</name> <block>{

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>length</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>write_arg</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>io</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nosync</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WRITEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_binwrite_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>binwrite_arg</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator>struct <name>binwrite_arg</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>fptr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name></type> <name><name>iov</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_writev_internal</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>iov</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>-=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_write_internal</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_binwrite_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>binwrite_arg</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator>struct <name>binwrite_arg</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>fptr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <name>len</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name><operator>+</operator><name>len</name> <operator>&lt;=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>capa</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>capa</name></name> <operator>&lt;</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name><operator>+</operator><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>io_fflush</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">2L</literal></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>stdio_file</name></name> <operator>!=</operator> <name>stderr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_thread_fd_writable</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_write_internal</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>io_binwrite</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nosync</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_thread_check_ints</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <name>len</name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>n</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>!</operator><name>nosync</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_SYNC</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>IO_WBUF_CAPA_MIN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name> <operator>=</operator> <call><name>rb_mutex_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_mutex_allow_trap</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>nosync</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>FMODE_SYNC</name><operator>|</operator><name>FMODE_TTY</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>capa</name></name> <operator>&lt;=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>+</operator> <name>len</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>binwrite_arg</name></name></type> <name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>fptr</name></name> <operator>=</operator> <name>fptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<label><name>retry</name>:</label>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_mutex_synchronize</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr></argument>, <argument><expr><name>io_binwrite_string</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>io_binwrite_string</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>-=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <operator>-</operator><literal type="number">2L</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1L</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_io_wait_writable</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1L</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name><operator>+</operator><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>ptr</name><operator>+</operator><name>offset</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_BTMODE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fmode &amp; FMODE_BINMODE) ? (b) : (fmode &amp; FMODE_TEXTMODE) ? (c) : (a))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_BTXMODE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>e</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fmode &amp; FMODE_EXCL) ? MODE_BTMODE(d, e, f) : MODE_BTMODE(a, b, c))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>do_writeconv</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>converted</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NEED_WRITECONV</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>common_encoding</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SET_BINARY_MODE</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>make_writeconv</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv</name></name></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fmode</name></cpp:macro> <cpp:value>(fptr-&gt;mode)</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_asciicompat</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>common_encoding</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>writeconv_asciicompat</name></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>MODE_BTMODE</name><argument_list>(<argument><expr><name>DEFAULT_TEXTMODE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"ASCII incompatible string written for text mode IO without encoding conversion: %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fmode</name></cpp:undef>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc2</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>common_encoding</name> <operator>=</operator> <call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc</name></name> <operator>!=</operator> <call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>common_encoding</name> <operator>=</operator> <call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>common_encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_encode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>common_encoding</name></expr></argument>,

<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecflags</name></name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv_pre_ecopts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>converted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_econv_str_convert</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>writeconv</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>ECONV_PARTIAL_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>converted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_TEST_CRLF_ENVIRONMENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fmode</name></cpp:macro> <cpp:value>(fptr-&gt;mode)</cpp:value></cpp:define>

<if type="elseif">else if <condition>(<expr><call><name>MODE_BTMODE</name><argument_list>(<argument><expr><name>DEFAULT_TEXTMODE</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_READABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>!</operator><operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>encs</name><operator>.</operator><name>ecflags</name></name> <operator>&amp;</operator> <name>ECONV_NEWLINE_DECORATOR_MASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>setmode</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>setmode</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"ASCII incompatible string written for text mode IO without encoding conversion: %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fmode</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>io_fwrite</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nosync</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>converted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_TTY</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>rb_w32_write_console</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>do_writeconv</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>converted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>converted</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_tmp_frozen_acquire</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>io_binwrite</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><name>nosync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_tmp_frozen_release</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>n</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ssize_t</name></type>

<name>rb_io_bufwrite</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_io_check_writable</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>io_binwrite</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>size</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_write</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nosync</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>io</name> <operator>=</operator> <call><name>GetWriteIO</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_io_check_io</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>id_write</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>io</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_io_check_writable</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>io_fwrite</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><name>nosync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WRITEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>binwritev_arg</name> <block>{

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iovec</name></name> <modifier>*</modifier></type><name>iov</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iovcnt</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_writev_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>binwritev_arg</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator>struct <name>binwritev_arg</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_writev_internal</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iov</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>iovcnt</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>io_binwritev</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iovec</name></name> <modifier>*</modifier></type><name>iov</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iovcnt</name></decl></parameter>, <parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>written_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_thread_check_ints</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>iovcnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iovcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>iov</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iov_len</name></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_SYNC</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>IO_WBUF_CAPA_MIN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name> <operator>=</operator> <call><name>rb_mutex_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_mutex_allow_trap</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>offset</name> <init>= <expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>+</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <name>total</name> <operator>&lt;=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>capa</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iovcnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name><operator>+</operator><name>offset</name></expr></argument>, <argument><expr><name><name>iov</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iov_base</name></expr></argument>, <argument><expr><name><name>iov</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iov_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>iov</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>iov_len</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <name>total</name></expr>;</expr_stmt>

<return>return <expr><name>total</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name> <operator>+</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>iov</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>--</operator><name>iovcnt</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<label><name>retry</name>:</label>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>binwritev_arg</name></name></type> <name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>fptr</name></name> <operator>=</operator> <name>fptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>iov</name></name> <operator>=</operator> <name>iov</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>iovcnt</name></name> <operator>=</operator> <name>iovcnt</name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_mutex_synchronize</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>write_lock</name></name></expr></argument>, <argument><expr><name>call_writev_internal</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_writev_internal</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>iov</name></expr></argument>, <argument><expr><name>iovcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>written_len</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>ptr</name></name> <operator>&amp;&amp;</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>written_len</name> <operator>&lt;</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <name>r</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>written_len</name> <operator>-=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>off</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fptr</name><operator>-&gt;</operator><name>wbuf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>written_len</name> <operator>==</operator> <name>total</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>total</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>r</name> <operator>&gt;=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name><name>iov</name><operator>-&gt;</operator><name>iov_len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>-=</operator> <name><name>iov</name><operator>-&gt;</operator><name>iov_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iov</name><operator>-&gt;</operator><name>iov_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>iov</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>--</operator><name>iovcnt</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>total</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>iov</name><operator>-&gt;</operator><name>iov_base</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>iov</name><operator>-&gt;</operator><name>iov_base</name></name> <operator>+</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iov</name><operator>-&gt;</operator><name>iov_len</name></name> <operator>-=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EAGAIN</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_io_wait_writable</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>retry</name>;</goto>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1L</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>io_fwritev</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>converted</name></decl>, <decl><type ref="prev"/><name>iovcnt</name> <init>= <expr><name>argc</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v1</name></decl>, <decl><type ref="prev"/><name>v2</name></decl>, <decl><type ref="prev"/><name>str</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp_array</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name> <modifier>*</modifier></type><name>iov</name></decl>;</decl_stmt>

<expr_stmt><expr><name>iov</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr>struct <name>iovec</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>iovcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp_array</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>converted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>do_writeconv</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>converted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>converted</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_tmp_frozen_acquire</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iov</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iov</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>io_binwritev</name><argument_list>(<argument><expr><name>iov</name></expr></argument>, <argument><expr><name>iovcnt</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v1</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_tmp_frozen_release</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tmp_array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>v2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>n</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iovcnt_ok</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>iovcnt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IOV_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>iovcnt</name> <operator>&lt;</operator> <name>IOV_MAX</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<return>return <expr><literal type="number">1</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_writev</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>total</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>cnt</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>io</name> <operator>=</operator> <call><name>GetWriteIO</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_io_check_io</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>id_write</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>io</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_io_check_writable</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>cnt</name></expr></incr>)</control> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WRITEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>FMODE_SYNC</name><operator>|</operator><name>FMODE_TTY</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>iovcnt_ok</name><argument_list>(<argument><expr><name>cnt</name> <operator>=</operator> <name>argc</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>io_fwritev</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>io_fwrite</name><argument_list>(<argument><expr><call><name>rb_obj_as_string</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name>argc</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0L</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>total</name> <operator>=</operator> <call><name>rb_fix_plus</name><argument_list>(<argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>total</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_write_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>io_writev</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>io_write</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_io_write</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>id_write</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_io_writev</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>io</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>rb_obj_method_arity</name><argument_list>(<argument><expr><name>io</name></expr></argument>, <argument><expr><name>id_write</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>io</name> <operator>!=</operator> <name>rb_stderr</name> <operator>&amp;&amp;</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>sep</name> <init>= <expr><ternary><condition><expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>klass</name> <operator>=</operator> <name>io</name>, <literal type="char">'.'</literal><operator>)</operator></expr> </then><else>: <expr><literal type="char">'#'</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<macro><name>rb_warning</name><argument_list>(<argument><literal type="string">"%+"</literal>PRIsVALUE<literal type="string">"%c""</literal>write is outdated interface<literal type="string">"

"</literal> which accepts just one argument<literal type="string">",

klass, sep);

}

do rb_io_write(io, *argv++); while (--argc);

return argv[0]; /* unused right now */

}

return rb_funcallv(io, id_write, argc, argv);

}

/*

* call-seq:

* ios &lt;&lt; obj -&gt; ios

*

* String Output---Writes &lt;i&gt;obj&lt;/i&gt; to &lt;em&gt;ios&lt;/em&gt;.

* &lt;i&gt;obj&lt;/i&gt; will be converted to a string using

* &lt;code&gt;to_s&lt;/code&gt;.

*

* $stdout &lt;&lt; "</literal>Hello <literal type="string">" &lt;&lt; "</literal>world!\n<literal type="string">"

*

* &lt;em&gt;produces:&lt;/em&gt;

*

* Hello world!

*/

VALUE

rb_io_addstr(VALUE io, VALUE str)

{

rb_io_write(io, str);

return io;

}

#if defined(HAVE_FSYNC)
static VALUE

nogvl_fsync(void *ptr)

{

rb_io_t *fptr = ptr;

#if defined(_WIN32)
if (GetFileType((HANDLE)rb_w32_get_osfhandle(fptr-&gt;fd)) != FILE_TYPE_DISK)

return 0;

#endif

return (VALUE)fsync(fptr-&gt;fd);

}

#endif

VALUE

rb_io_flush_raw(VALUE io, int sync)

{

rb_io_t *fptr;

if (!RB_TYPE_P(io, T_FILE)) {

return rb_funcall(io, id_flush, 0);

}

io = GetWriteIO(io);

GetOpenFile(io, fptr);

if (fptr-&gt;mode &amp; FMODE_WRITABLE) {

if (io_fflush(fptr) &lt; 0)

rb_sys_fail(0);

}

if (fptr-&gt;mode &amp; FMODE_READABLE) {

io_unread(fptr);

}

return io;

}

/*

* call-seq:

* ios.flush -&gt; ios

*

* Flushes any buffered data within &lt;em&gt;ios&lt;/em&gt; to the underlying

* operating system (note that this is Ruby internal buffering only;

* the OS may buffer the data as well).

*

* $stdout.print "</literal>no newline<literal type="string">"

* $stdout.flush

*

* &lt;em&gt;produces:&lt;/em&gt;

*

* no newline

*/

VALUE

rb_io_flush(VALUE io)

{

return rb_io_flush_raw(io, 1);

}

/*

* call-seq:

* ios.pos -&gt; integer

* ios.tell -&gt; integer

*

* Returns the current offset (in bytes) of &lt;em&gt;ios&lt;/em&gt;.

*

* f = File.new("</literal>testfile<literal type="string">")

* f.pos #=&gt; 0

* f.gets #=&gt; "</literal>This is line one\n<literal type="string">"

* f.pos #=&gt; 17

*/

static VALUE

rb_io_tell(VALUE io)

{

rb_io_t *fptr;

off_t pos;

GetOpenFile(io, fptr);

pos = io_tell(fptr);

if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

pos -= fptr-&gt;rbuf.len;

return OFFT2NUM(pos);

}

static VALUE

rb_io_seek(VALUE io, VALUE offset, int whence)

{

rb_io_t *fptr;

off_t pos;

pos = NUM2OFFT(offset);

GetOpenFile(io, fptr);

pos = io_seek(fptr, pos, whence);

if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

return INT2FIX(0);

}

static int

interpret_seek_whence(VALUE vwhence)

{

if (vwhence == sym_SET)

return SEEK_SET;

if (vwhence == sym_CUR)

return SEEK_CUR;

if (vwhence == sym_END)

return SEEK_END;

#if defined(SEEK_DATA)
if (vwhence == sym_DATA)

return SEEK_DATA;

#endif

#if defined(SEEK_HOLE)
if (vwhence == sym_HOLE)

return SEEK_HOLE;

#endif

return NUM2INT(vwhence);

}

/*

* call-seq:

* ios.seek(amount, whence=IO::SEEK_SET) -&gt; 0

*

* Seeks to a given offset &lt;i&gt;anInteger&lt;/i&gt; in the stream according to

* the value of &lt;i&gt;whence&lt;/i&gt;:

*

* :CUR or IO::SEEK_CUR | Seeks to _amount_ plus current position

* ----------------------+--------------------------------------------------

* :END or IO::SEEK_END | Seeks to _amount_ plus end of stream (you

* | probably want a negative value for _amount_)

* ----------------------+--------------------------------------------------

* :SET or IO::SEEK_SET | Seeks to the absolute location given by _amount_

*

* Example:

*

* f = File.new("</literal>testfile<literal type="string">")

* f.seek(-13, IO::SEEK_END) #=&gt; 0

* f.readline #=&gt; "</literal>And so on...\n<literal type="string">"

*/

static VALUE

rb_io_seek_m(int argc, VALUE *argv, VALUE io)

{

VALUE offset, ptrname;

int whence = SEEK_SET;

if (rb_scan_args(argc, argv, "</literal><literal type="number">11</literal><literal type="string">", &amp;offset, &amp;ptrname) == 2) {

whence = interpret_seek_whence(ptrname);

}

return rb_io_seek(io, offset, whence);

}

/*

* call-seq:

* ios.pos = integer -&gt; integer

*

* Seeks to the given position (in bytes) in &lt;em&gt;ios&lt;/em&gt;.

* It is not guaranteed that seeking to the right position when &lt;em&gt;ios&lt;/em&gt;

* is textmode.

*

* f = File.new("</literal>testfile<literal type="string">")

* f.pos = 17

* f.gets #=&gt; "</literal>This is line two\n<literal type="string">"

*/

static VALUE

rb_io_set_pos(VALUE io, VALUE offset)

{

rb_io_t *fptr;

off_t pos;

pos = NUM2OFFT(offset);

GetOpenFile(io, fptr);

pos = io_seek(fptr, pos, SEEK_SET);

if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

return OFFT2NUM(pos);

}

static void clear_readconv(rb_io_t *fptr);

/*

* call-seq:

* ios.rewind -&gt; 0

*

* Positions &lt;em&gt;ios&lt;/em&gt; to the beginning of input, resetting

* #lineno to zero.

*

* f = File.new("</literal>testfile<literal type="string">")

* f.readline #=&gt; "</literal>This is line one\n<literal type="string">"

* f.rewind #=&gt; 0

* f.lineno #=&gt; 0

* f.readline #=&gt; "</literal>This is line one\n<literal type="string">"

*

* Note that it cannot be used with streams such as pipes, ttys, and sockets.

*/

static VALUE

rb_io_rewind(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

if (io_seek(fptr, 0L, 0) &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

if (io == ARGF.current_file) {

ARGF.lineno -= fptr-&gt;lineno;

}

fptr-&gt;lineno = 0;

if (fptr-&gt;readconv) {

clear_readconv(fptr);

}

return INT2FIX(0);

}

static int

fptr_wait_readable(rb_io_t *fptr)

{

int ret = rb_io_wait_readable(fptr-&gt;fd);

if (ret)

rb_io_check_closed(fptr);

return ret;

}

static int

io_fillbuf(rb_io_t *fptr)

{

ssize_t r;

if (fptr-&gt;rbuf.ptr == NULL) {

fptr-&gt;rbuf.off = 0;

fptr-&gt;rbuf.len = 0;

fptr-&gt;rbuf.capa = IO_RBUF_CAPA_FOR(fptr);

fptr-&gt;rbuf.ptr = ALLOC_N(char, fptr-&gt;rbuf.capa);

#if defined(_WIN32)
fptr-&gt;rbuf.capa--;

#endif

}

if (fptr-&gt;rbuf.len == 0) {

retry:

{

r = rb_read_internal(fptr-&gt;fd, fptr-&gt;rbuf.ptr, fptr-&gt;rbuf.capa);

}

if (r &lt; 0) {

if (fptr_wait_readable(fptr))

goto retry;

{

int e = errno;

VALUE path = rb_sprintf("</literal>fd:%d <literal type="string">", fptr-&gt;fd);

if (!NIL_P(fptr-&gt;pathv)) {

rb_str_append(path, fptr-&gt;pathv);

}

rb_syserr_fail_path(e, path);

}

}

if (r &gt; 0) rb_io_check_closed(fptr);

fptr-&gt;rbuf.off = 0;

fptr-&gt;rbuf.len = (int)r; /* r should be &lt;= rbuf_capa */

if (r == 0)

return -1; /* EOF */

}

return 0;

}

/*

* call-seq:

* ios.eof -&gt; true or false

* ios.eof? -&gt; true or false

*

* Returns true if &lt;em&gt;ios&lt;/em&gt; is at end of file that means

* there are no more data to read.

* The stream must be opened for reading or an IOError will be

* raised.

*

* f = File.new("</literal>testfile<literal type="string">")

* dummy = f.readlines

* f.eof #=&gt; true

*

* If &lt;em&gt;ios&lt;/em&gt; is a stream such as pipe or socket, IO#eof?

* blocks until the other end sends some data or closes it.

*

* r, w = IO.pipe

* Thread.new { sleep 1; w.close }

* r.eof? #=&gt; true after 1 second blocking

*

* r, w = IO.pipe

* Thread.new { sleep 1; w.puts "</literal>a<literal type="string">" }

* r.eof? #=&gt; false after 1 second blocking

*

* r, w = IO.pipe

* r.eof? #blocks forever

*

* Note that IO#eof? reads data to the input byte buffer. So

* IO#sysread may not behave as you intend with IO#eof?, unless you

* call IO#rewind first (which is not available for some streams).

*/

VALUE

rb_io_eof(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

rb_io_check_char_readable(fptr);

if (READ_CHAR_PENDING(fptr)) return Qfalse;

if (READ_DATA_PENDING(fptr)) return Qfalse;

READ_CHECK(fptr);

#if defined(RUBY_TEST_CRLF_ENVIRONMENT) || defined(_WIN32)

if (!NEED_READCONV(fptr) &amp;&amp; NEED_NEWLINE_DECORATOR_ON_READ(fptr)) {

return eof(fptr-&gt;fd) ? Qtrue : Qfalse;

}

#endif

if (io_fillbuf(fptr) &lt; 0) {

return Qtrue;

}

return Qfalse;

}

/*

* call-seq:

* ios.sync -&gt; true or false

*

* Returns the current ``sync mode'' of &lt;em&gt;ios&lt;/em&gt;. When sync mode is

* true, all output is immediately flushed to the underlying operating

* system and is not buffered by Ruby internally. See also

* IO#fsync.

*

* f = File.new("</literal>testfile<literal type="string">")

* f.sync #=&gt; false

*/

static VALUE

rb_io_sync(VALUE io)

{

rb_io_t *fptr;

io = GetWriteIO(io);

GetOpenFile(io, fptr);

return (fptr-&gt;mode &amp; FMODE_SYNC) ? Qtrue : Qfalse;

}

#if defined(HAVE_FSYNC)
/*

* call-seq:

* ios.sync = boolean -&gt; boolean

*

* Sets the ``sync mode'' to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.

* When sync mode is true, all output is immediately flushed to the

* underlying operating system and is not buffered internally. Returns

* the new state. See also IO#fsync.

*

* f = File.new("</literal>testfile<literal type="string">")

* f.sync = true

*/

static VALUE

rb_io_set_sync(VALUE io, VALUE sync)

{

rb_io_t *fptr;

io = GetWriteIO(io);

GetOpenFile(io, fptr);

if (RTEST(sync)) {

fptr-&gt;mode |= FMODE_SYNC;

}

else {

fptr-&gt;mode &amp;= ~FMODE_SYNC;

}

return sync;

}

/*

* call-seq:

* ios.fsync -&gt; 0 or nil

*

* Immediately writes all buffered data in &lt;em&gt;ios&lt;/em&gt; to disk.

* Note that #fsync differs from using IO#sync=. The latter ensures

* that data is flushed from Ruby's buffers, but does not guarantee

* that the underlying operating system actually writes it to disk.

*

* NotImplementedError is raised

* if the underlying operating system does not support &lt;em&gt;fsync(2)&lt;/em&gt;.

*/

static VALUE

rb_io_fsync(VALUE io)

{

rb_io_t *fptr;

io = GetWriteIO(io);

GetOpenFile(io, fptr);

if (io_fflush(fptr) &lt; 0)

rb_sys_fail(0);

if ((int)rb_thread_io_blocking_region(nogvl_fsync, fptr, fptr-&gt;fd) &lt; 0)

rb_sys_fail_path(fptr-&gt;pathv);

return INT2FIX(0);

}

#else

#define rb_io_fsync rb_f_notimplement

#define rb_io_sync rb_f_notimplement

static VALUE

rb_io_set_sync(VALUE io, VALUE sync)

{

rb_notimplement();

UNREACHABLE;

}

#endif

#if defined(HAVE_FDATASYNC)
static VALUE

nogvl_fdatasync(void *ptr)

{

rb_io_t *fptr = ptr;

#if defined(_WIN32)
if (GetFileType((HANDLE)rb_w32_get_osfhandle(fptr-&gt;fd)) != FILE_TYPE_DISK)

return 0;

#endif

return (VALUE)fdatasync(fptr-&gt;fd);

}

/*

* call-seq:

* ios.fdatasync -&gt; 0 or nil

*

* Immediately writes all buffered data in &lt;em&gt;ios&lt;/em&gt; to disk.

*

* If the underlying operating system does not support &lt;em&gt;fdatasync(2)&lt;/em&gt;,

* IO#fsync is called instead (which might raise a

* NotImplementedError).

*/

static VALUE

rb_io_fdatasync(VALUE io)

{

rb_io_t *fptr;

io = GetWriteIO(io);

GetOpenFile(io, fptr);

if (io_fflush(fptr) &lt; 0)

rb_sys_fail(0);

if ((int)rb_thread_io_blocking_region(nogvl_fdatasync, fptr, fptr-&gt;fd) == 0)

return INT2FIX(0);

/* fall back */

return rb_io_fsync(io);

}

#else

#define rb_io_fdatasync rb_io_fsync

#endif

/*

* call-seq:

* ios.fileno -&gt; integer

* ios.to_i -&gt; integer

*

* Returns an integer representing the numeric file descriptor for

* &lt;em&gt;ios&lt;/em&gt;.

*

* $stdin.fileno #=&gt; 0

* $stdout.fileno #=&gt; 1

*/

static VALUE

rb_io_fileno(VALUE io)

{

rb_io_t *fptr = RFILE(io)-&gt;fptr;

int fd;

rb_io_check_closed(fptr);

fd = fptr-&gt;fd;

return INT2FIX(fd);

}

/*

* call-seq:

* ios.pid -&gt; integer

*

* Returns the process ID of a child process associated with

* &lt;em&gt;ios&lt;/em&gt;. This will be set by IO.popen.

*

* pipe = IO.popen("</literal>-<literal type="string">")

* if pipe

* $stderr.puts "</literal>In parent</argument>, <argument>child pid is #{pipe.pid}<literal type="string">"

* else

* $stderr.puts "</literal>In child</argument>, <argument>pid is #{$$}<literal type="string">"

* end

*

* &lt;em&gt;produces:&lt;/em&gt;

*

* In child, pid is 26209

* In parent, child pid is 26209

*/

static VALUE

rb_io_pid(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

if (!fptr-&gt;pid)

return Qnil;

return PIDT2NUM(fptr-&gt;pid);

}

/*

* call-seq:

* ios.inspect -&gt; string

*

* Return a string describing this IO object.

*/

static VALUE

rb_io_inspect(VALUE obj)

{

rb_io_t *fptr;

VALUE result;

static const char closed[] = "</literal> (closed)<literal type="string">";

fptr = RFILE(obj)-&gt;fptr;

if (!fptr) return rb_any_to_s(obj);

result = rb_str_new_cstr("</literal>#&lt;<literal type="string">");

rb_str_append(result, rb_class_name(CLASS_OF(obj)));

rb_str_cat2(result, "</literal>:<literal type="string">");

if (NIL_P(fptr-&gt;pathv)) {

if (fptr-&gt;fd &lt; 0) {

rb_str_cat(result, closed+1, strlen(closed)-1);

}

else {

rb_str_catf(result, "</literal>fd %d<literal type="string">", fptr-&gt;fd);

}

}

else {

rb_str_append(result, fptr-&gt;pathv);

if (fptr-&gt;fd &lt; 0) {

rb_str_cat(result, closed, strlen(closed));

}

}

return rb_str_cat2(result, "</literal>&gt;<literal type="string">");

}

/*

* call-seq:

* ios.to_io -&gt; ios

*

* Returns &lt;em&gt;ios&lt;/em&gt;.

*/

static VALUE

rb_io_to_io(VALUE io)

{

return io;

}

/* reading functions */

static long

read_buffered_data(char *ptr, long len, rb_io_t *fptr)

{

int n;

n = READ_DATA_PENDING_COUNT(fptr);

if (n &lt;= 0) return 0;

if (n &gt; len) n = (int)len;

MEMMOVE(ptr, fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off, char, n);

fptr-&gt;rbuf.off += n;

fptr-&gt;rbuf.len -= n;

return n;

}

static long

io_bufread(char *ptr, long len, rb_io_t *fptr)

{

long offset = 0;

long n = len;

long c;

if (READ_DATA_PENDING(fptr) == 0) {

while (n &gt; 0) {

again:

c = rb_read_internal(fptr-&gt;fd, ptr+offset, n);

if (c == 0) break;

if (c &lt; 0) {

if (fptr_wait_readable(fptr))

goto again;

return -1;

}

offset += c;

if ((n -= c) &lt;= 0) break;

}

return len - n;

}

while (n &gt; 0) {

c = read_buffered_data(ptr+offset, n, fptr);

if (c &gt; 0) {

offset += c;

if ((n -= c) &lt;= 0) break;

}

rb_io_check_closed(fptr);

if (io_fillbuf(fptr) &lt; 0) {

break;

}

}

return len - n;

}

static int io_setstrbuf(VALUE *str, long len);

struct bufread_arg {

char *str_ptr;

long len;

rb_io_t *fptr;

};

static VALUE

bufread_call(VALUE arg)

{

struct bufread_arg *p = (struct bufread_arg *)arg;

p-&gt;len = io_bufread(p-&gt;str_ptr, p-&gt;len, p-&gt;fptr);

return Qundef;

}

static long

io_fread(VALUE str, long offset, long size, rb_io_t *fptr)

{

long len;

struct bufread_arg arg;

io_setstrbuf(&amp;str, offset + size);

arg.str_ptr = RSTRING_PTR(str) + offset;

arg.len = size;

arg.fptr = fptr;

rb_str_locktmp_ensure(str, bufread_call, (VALUE)&amp;arg);

len = arg.len;

if (len &lt; 0) rb_sys_fail_path(fptr-&gt;pathv);

return len;

}

static long

remain_size(rb_io_t *fptr)

{

struct stat st;

off_t siz = READ_DATA_PENDING_COUNT(fptr);

off_t pos;

if (fstat(fptr-&gt;fd, &amp;st) == 0 &amp;&amp; S_ISREG(st.st_mode)

#if defined(__HAIKU__)

&amp;&amp; (st.st_dev &gt; 3)

#endif

)

{

if (io_fflush(fptr) &lt; 0)

rb_sys_fail(0);

pos = lseek(fptr-&gt;fd, 0, SEEK_CUR);

if (st.st_size &gt;= pos &amp;&amp; pos &gt;= 0) {

siz += st.st_size - pos;

if (siz &gt; LONG_MAX) {

rb_raise(rb_eIOError, "</literal>file too big for single read<literal type="string">");

}

}

}

else {

siz += BUFSIZ;

}

return (long)siz;

}

static VALUE

io_enc_str(VALUE str, rb_io_t *fptr)

{

rb_enc_associate(str, io_read_encoding(fptr));

return str;

}

static void

make_readconv(rb_io_t *fptr, int size)

{

if (!fptr-&gt;readconv) {

int ecflags;

VALUE ecopts;

const char *sname, *dname;

ecflags = fptr-&gt;encs.ecflags &amp; ~ECONV_NEWLINE_DECORATOR_WRITE_MASK;

ecopts = fptr-&gt;encs.ecopts;

if (fptr-&gt;encs.enc2) {

sname = rb_enc_name(fptr-&gt;encs.enc2);

dname = rb_enc_name(fptr-&gt;encs.enc);

}

else {

sname = dname = ""</literal>;

}

fptr-&gt;readconv = rb_econv_open_opts(sname, dname, ecflags, ecopts);

if (!fptr-&gt;readconv)

rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

fptr-&gt;cbuf.off = <literal type="number">0</literal>;

fptr-&gt;cbuf.len = <literal type="number">0</literal>;

if (size &lt; IO_CBUF_CAPA_MIN) size = IO_CBUF_CAPA_MIN;

fptr-&gt;cbuf.capa = size;

fptr-&gt;cbuf.ptr = ALLOC_N(char, fptr-&gt;cbuf.capa);

}

}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MORE_CHAR_SUSPENDED</name></cpp:macro> <cpp:value>Qtrue</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MORE_CHAR_FINISHED</name></cpp:macro> <cpp:value>Qnil</cpp:value></cpp:define>

static VALUE

fill_cbuf(rb_io_t *fptr, int ec_flags)

{

const unsigned char *ss</argument>, <argument>*sp</argument>, <argument>*se;

unsigned char *ds</argument>, <argument>*dp</argument>, <argument>*de;

rb_econv_result_t res;

int putbackable;

int cbuf_len0;

VALUE exc;

ec_flags |= ECONV_PARTIAL_INPUT;

if (fptr-&gt;cbuf.len == fptr-&gt;cbuf.capa)

return MORE_CHAR_SUSPENDED; 

if (fptr-&gt;cbuf.len == <literal type="number">0</literal>)

fptr-&gt;cbuf.off = <literal type="number">0</literal>;

else if (fptr-&gt;cbuf.off + fptr-&gt;cbuf.len == fptr-&gt;cbuf.capa) {

memmove(fptr-&gt;cbuf.ptr, fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off, fptr-&gt;cbuf.len);

fptr-&gt;cbuf.off = <literal type="number">0</literal>;

}

cbuf_len0 = fptr-&gt;cbuf.len;

while (<literal type="number">1</literal>) {

ss = sp = (const unsigned char *)fptr-&gt;rbuf.ptr + fptr-&gt;rbuf.off;

se = sp + fptr-&gt;rbuf.len;

ds = dp = (unsigned char *)fptr-&gt;cbuf.ptr + fptr-&gt;cbuf.off + fptr-&gt;cbuf.len;

de = (unsigned char *)fptr-&gt;cbuf.ptr + fptr-&gt;cbuf.capa;

res = rb_econv_convert(fptr-&gt;readconv, &amp;sp, se, &amp;dp, de, ec_flags);

fptr-&gt;rbuf.off += (int)(sp - ss);

fptr-&gt;rbuf.len -= (int)(sp - ss);

fptr-&gt;cbuf.len += (int)(dp - ds);

putbackable = rb_econv_putbackable(fptr-&gt;readconv);

if (putbackable) {

rb_econv_putback(fptr-&gt;readconv, (unsigned char *)fptr-&gt;rbuf.ptr + fptr-&gt;rbuf.off - putbackable, putbackable);

fptr-&gt;rbuf.off -= putbackable;

fptr-&gt;rbuf.len += putbackable;

}

exc = rb_econv_make_exception(fptr-&gt;readconv);

if (!NIL_P(exc))

return exc;

if (cbuf_len0 != fptr-&gt;cbuf.len)

return MORE_CHAR_SUSPENDED;

if (res == econv_finished) {

return MORE_CHAR_FINISHED;

}

if (res == econv_source_buffer_empty) {

if (fptr-&gt;rbuf.len == <literal type="number">0</literal>) {

READ_CHECK(fptr);

if (io_fillbuf(fptr) &lt; <literal type="number">0</literal>) {

if (!fptr-&gt;readconv) {

return MORE_CHAR_FINISHED;

}

ds = dp = (unsigned char *)fptr-&gt;cbuf.ptr + fptr-&gt;cbuf.off + fptr-&gt;cbuf.len;

de = (unsigned char *)fptr-&gt;cbuf.ptr + fptr-&gt;cbuf.capa;

res = rb_econv_convert(fptr-&gt;readconv, NULL, NULL, &amp;dp, de, <literal type="number">0</literal>);

fptr-&gt;cbuf.len += (int)(dp - ds);

rb_econv_check_error(fptr-&gt;readconv);

break;

}

}

}

}

if (cbuf_len0 != fptr-&gt;cbuf.len)

return MORE_CHAR_SUSPENDED;

return MORE_CHAR_FINISHED;

}

static VALUE

more_char(rb_io_t *fptr)

{

VALUE v;

v = fill_cbuf(fptr, ECONV_AFTER_OUTPUT);

if (v != MORE_CHAR_SUSPENDED &amp;&amp; v != MORE_CHAR_FINISHED)

rb_exc_raise(v);

return v;

}

static VALUE

io_shift_cbuf(rb_io_t *fptr, int len, VALUE *strp)

{

VALUE str = Qnil;

if (strp) {

str = *strp;

if (NIL_P(str)) {

*strp = str = rb_str_new(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off, len);

}

else {

rb_str_cat(str, fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off, len);

}

rb_enc_associate(str, fptr-&gt;encs.enc);

}

fptr-&gt;cbuf.off += len;

fptr-&gt;cbuf.len -= len;

if (fptr-&gt;cbuf.len == <literal type="number">0</literal>)

fptr-&gt;cbuf.off = <literal type="number">0</literal>;

else if (fptr-&gt;cbuf.capa/<literal type="number">2</literal> &lt; fptr-&gt;cbuf.off) {

memmove(fptr-&gt;cbuf.ptr, fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off, fptr-&gt;cbuf.len);

fptr-&gt;cbuf.off = <literal type="number">0</literal>;

}

return str;

}

static int

io_setstrbuf(VALUE *str, long len)

{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
len = (len + <literal type="number">1</literal>) &amp; ~<literal type="number">1L</literal>; 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (NIL_P(*str)) {

*str = rb_str_new(<literal type="number">0</literal>, len);

return TRUE;

}

else {

VALUE s = StringValue(*str);

long clen = RSTRING_LEN(s);

if (clen &gt;= len) {

rb_str_modify(s);

return FALSE;

}

len -= clen;

}

rb_str_modify_expand(*str, len);

return FALSE;

}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REALLOC_GAP</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

static void

io_shrink_read_string(VALUE str, long n)

{

if (rb_str_capacity(str) - n &gt; MAX_REALLOC_GAP) {

rb_str_resize(str, n);

}

}

static void

io_set_read_length(VALUE str, long n, int shrinkable)

{

if (RSTRING_LEN(str) != n) {

rb_str_modify(str);

rb_str_set_len(str, n);

if (shrinkable) io_shrink_read_string(str, n);

}

}

static VALUE

read_all(rb_io_t *fptr, long siz, VALUE str)

{

long bytes;

long n;

long pos;

rb_encoding *enc;

int cr;

int shrinkable;

if (NEED_READCONV(fptr)) {

int first = !NIL_P(str);

SET_BINARY_MODE(fptr);

shrinkable = io_setstrbuf(&amp;str,<literal type="number">0</literal>);

make_readconv(fptr, <literal type="number">0</literal>);

while (<literal type="number">1</literal>) {

VALUE v;

if (fptr-&gt;cbuf.len) {

if (first) rb_str_set_len(str, first = <literal type="number">0</literal>);

io_shift_cbuf(fptr, fptr-&gt;cbuf.len, &amp;str);

}

v = fill_cbuf(fptr, <literal type="number">0</literal>);

if (v != MORE_CHAR_SUSPENDED &amp;&amp; v != MORE_CHAR_FINISHED) {

if (fptr-&gt;cbuf.len) {

if (first) rb_str_set_len(str, first = <literal type="number">0</literal>);

io_shift_cbuf(fptr, fptr-&gt;cbuf.len, &amp;str);

}

rb_exc_raise(v);

}

if (v == MORE_CHAR_FINISHED) {

clear_readconv(fptr);

if (first) rb_str_set_len(str, first = <literal type="number">0</literal>);

if (shrinkable) io_shrink_read_string(str, RSTRING_LEN(str));

return io_enc_str(str, fptr);

}

}

}

NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);

bytes = <literal type="number">0</literal>;

pos = <literal type="number">0</literal>;

enc = io_read_encoding(fptr);

cr = <literal type="number">0</literal>;

if (siz == <literal type="number">0</literal>) siz = BUFSIZ;

shrinkable = io_setstrbuf(&amp;str, siz);

for (;;) {

READ_CHECK(fptr);

n = io_fread(str, bytes, siz - bytes, fptr);

if (n == <literal type="number">0</literal> &amp;&amp; bytes == <literal type="number">0</literal>) {

rb_str_set_len(str, <literal type="number">0</literal>);

break;

}

bytes += n;

rb_str_set_len(str, bytes);

if (cr != ENC_CODERANGE_BROKEN)

pos += rb_str_coderange_scan_restartable(RSTRING_PTR(str) + pos, RSTRING_PTR(str) + bytes, enc, &amp;cr);

if (bytes &lt; siz) break;

siz += BUFSIZ;

rb_str_modify_expand(str, BUFSIZ);

}

if (shrinkable) io_shrink_read_string(str, RSTRING_LEN(str));

str = io_enc_str(str, fptr);

ENC_CODERANGE_SET(str, cr);

return str;

}

void

rb_io_set_nonblock(rb_io_t *fptr)

{

if (rb_fd_set_nonblock(fptr-&gt;fd) != <literal type="number">0</literal>) {

rb_sys_fail_path(fptr-&gt;pathv);

}

}

static VALUE

read_internal_call(VALUE arg)

{

struct io_internal_read_struct *iis = (struct io_internal_read_struct *)arg;

return rb_thread_io_blocking_region(internal_read_func, iis, iis-&gt;fd);

}

static long

read_internal_locktmp(VALUE str, struct io_internal_read_struct *iis)

{

return (long)rb_str_locktmp_ensure(str, read_internal_call, (VALUE)iis);

}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>no_exception_p</name><parameter_list>(<parameter><type><name>opts</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>!rb_opts_exception_p((opts), TRUE)</cpp:value></cpp:define>

static VALUE

io_getpartial(int argc, VALUE *argv, VALUE io, int no_exception, int nonblock)

{

rb_io_t *fptr;

VALUE length</argument>, <argument>str;

long n</argument>, <argument>len;

struct io_internal_read_struct iis;

int shrinkable;

rb_scan_args(argc, argv, <literal type="string">"11"</literal>, &amp;length, &amp;str);

if ((len = NUM2LONG(length)) &lt; <literal type="number">0</literal>) {

rb_raise(rb_eArgError, <literal type="string">"negative length %ld given"</literal>, len);

}

shrinkable = io_setstrbuf(&amp;str, len);

GetOpenFile(io, fptr);

rb_io_check_byte_readable(fptr);

if (len == <literal type="number">0</literal>)

return str;

if (!nonblock)

READ_CHECK(fptr);

n = read_buffered_data(RSTRING_PTR(str), len, fptr);

if (n &lt;= <literal type="number">0</literal>) {

again:

if (nonblock) {

rb_io_set_nonblock(fptr);

}

io_setstrbuf(&amp;str, len);

iis.fd = fptr-&gt;fd;

iis.nonblock = nonblock;

iis.buf = RSTRING_PTR(str);

iis.capa = len;

n = read_internal_locktmp(str, &amp;iis);

if (n &lt; <literal type="number">0</literal>) {

int e = errno;

if (!nonblock &amp;&amp; fptr_wait_readable(fptr))

goto again;

if (nonblock &amp;&amp; (e == EWOULDBLOCK || e == EAGAIN)) {

if (no_exception)

return sym_wait_readable;

else

rb_readwrite_syserr_fail(RB_IO_WAIT_READABLE,

e, <literal type="string">"read would block"</literal>);

}

rb_syserr_fail_path(e, fptr-&gt;pathv);

}

}

io_set_read_length(str, n, shrinkable);

if (n == <literal type="number">0</literal>)

return Qnil;

else

return str;

}

static VALUE

io_readpartial(int argc, VALUE *argv, VALUE io)

{

VALUE ret;

ret = io_getpartial(argc, argv, io, Qnil, <literal type="number">0</literal>);

if (NIL_P(ret))

rb_eof_error();

return ret;

}

static VALUE

io_nonblock_eof(int no_exception)

{

if (!no_exception) {

rb_eof_error();

}

return Qnil;

}

static VALUE

io_read_nonblock(rb_execution_context_t *ec, VALUE io, VALUE length, VALUE str, VALUE ex)

{

rb_io_t *fptr;

long n</argument>, <argument>len;

struct io_internal_read_struct iis;

int shrinkable;

if ((len = NUM2LONG(length)) &lt; <literal type="number">0</literal>) {

rb_raise(rb_eArgError, <literal type="string">"negative length %ld given"</literal>, len);

}

shrinkable = io_setstrbuf(&amp;str, len);

rb_bool_expected(ex, <literal type="string">"exception"</literal>);

GetOpenFile(io, fptr);

rb_io_check_byte_readable(fptr);

if (len == <literal type="number">0</literal>)

return str;

n = read_buffered_data(RSTRING_PTR(str), len, fptr);

if (n &lt;= <literal type="number">0</literal>) {

rb_io_set_nonblock(fptr);

shrinkable |= io_setstrbuf(&amp;str, len);

iis.fd = fptr-&gt;fd;

iis.nonblock = <literal type="number">1</literal>;

iis.buf = RSTRING_PTR(str);

iis.capa = len;

n = read_internal_locktmp(str, &amp;iis);

if (n &lt; <literal type="number">0</literal>) {

int e = errno;

if ((e == EWOULDBLOCK || e == EAGAIN)) {

if (!ex) return sym_wait_readable;

rb_readwrite_syserr_fail(RB_IO_WAIT_READABLE,

e, <literal type="string">"read would block"</literal>);

}

rb_syserr_fail_path(e, fptr-&gt;pathv);

}

}

io_set_read_length(str, n, shrinkable);

if (n == <literal type="number">0</literal>) {

if (!ex) return Qnil;

rb_eof_error();

}

return str;

}

static VALUE

io_write_nonblock(rb_execution_context_t *ec, VALUE io, VALUE str, VALUE ex)

{

rb_io_t *fptr;

long n;

if (!RB_TYPE_P(str, T_STRING))

str = rb_obj_as_string(str);

rb_bool_expected(ex, <literal type="string">"exception"</literal>);

io = GetWriteIO(io);

GetOpenFile(io, fptr);

rb_io_check_writable(fptr);

if (io_fflush(fptr) &lt; <literal type="number">0</literal>)

rb_sys_fail(<literal type="number">0</literal>);

rb_io_set_nonblock(fptr);

n = write(fptr-&gt;fd, RSTRING_PTR(str), RSTRING_LEN(str));

RB_GC_GUARD(str);

if (n &lt; <literal type="number">0</literal>) {

int e = errno;

if (e == EWOULDBLOCK || e == EAGAIN) {

if (!ex) {

return sym_wait_writable;

}

else {

rb_readwrite_syserr_fail(RB_IO_WAIT_WRITABLE, e, <literal type="string">"write would block"</literal>);

}

}

rb_syserr_fail_path(e, fptr-&gt;pathv);

}

return LONG2FIX(n);

}

static VALUE

io_read(int argc, VALUE *argv, VALUE io)

{

rb_io_t *fptr;

long n</argument>, <argument>len;

VALUE length</argument>, <argument>str;

int shrinkable;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_TEST_CRLF_ENVIRONMENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

int previous_mode;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_scan_args(argc, argv, <literal type="string">"02"</literal>, &amp;length, &amp;str);

if (NIL_P(length)) {

GetOpenFile(io, fptr);

rb_io_check_char_readable(fptr);

return read_all(fptr, remain_size(fptr), str);

}

len = NUM2LONG(length);

if (len &lt; <literal type="number">0</literal>) {

rb_raise(rb_eArgError, <literal type="string">"negative length %ld given"</literal>, len);

}

shrinkable = io_setstrbuf(&amp;str,len);

GetOpenFile(io, fptr);

rb_io_check_byte_readable(fptr);

if (len == <literal type="number">0</literal>) {

io_set_read_length(str, <literal type="number">0</literal>, shrinkable);

return str;

}

READ_CHECK(fptr);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_TEST_CRLF_ENVIRONMENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

previous_mode = set_binary_mode_with_seek_cur(fptr);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

n = io_fread(str, <literal type="number">0</literal>, len, fptr);

io_set_read_length(str, n, shrinkable);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_TEST_CRLF_ENVIRONMENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

if (previous_mode == O_TEXT) {

setmode(fptr-&gt;fd, O_TEXT);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (n == <literal type="number">0</literal>) return Qnil;

return str;

}

static void

rscheck(const char *rsptr, long rslen, VALUE rs)

{

if (!rs) return;

if (RSTRING_PTR(rs) != rsptr &amp;&amp; RSTRING_LEN(rs) != rslen)

rb_raise(rb_eRuntimeError, <literal type="string">"rs modified"</literal>);

}

static int

appendline(rb_io_t *fptr, int delim, VALUE *strp, long *lp)

{

VALUE str = *strp;

long limit = *lp;

if (NEED_READCONV(fptr)) {

SET_BINARY_MODE(fptr);

make_readconv(fptr, <literal type="number">0</literal>);

do {

const char *p</argument>, <argument>*e;

int searchlen = READ_CHAR_PENDING_COUNT(fptr);

if (searchlen) {

p = READ_CHAR_PENDING_PTR(fptr);

if (<literal type="number">0</literal> &lt; limit &amp;&amp; limit &lt; searchlen)

searchlen = (int)limit;

e = memchr(p, delim, searchlen);

if (e) {

int len = (int)(e-p+<literal type="number">1</literal>);

if (NIL_P(str))

*strp = str = rb_str_new(p, len);

else

rb_str_buf_cat(str, p, len);

fptr-&gt;cbuf.off += len;

fptr-&gt;cbuf.len -= len;

limit -= len;

*lp = limit;

return delim;

}

if (NIL_P(str))

*strp = str = rb_str_new(p, searchlen);

else

rb_str_buf_cat(str, p, searchlen);

fptr-&gt;cbuf.off += searchlen;

fptr-&gt;cbuf.len -= searchlen;

limit -= searchlen;

if (limit == <literal type="number">0</literal>) {

*lp = limit;

return (unsigned char)RSTRING_PTR(str)[RSTRING_LEN(str)-<literal type="number">1</literal>];

}

}

} while (more_char(fptr) != MORE_CHAR_FINISHED);

clear_readconv(fptr);

*lp = limit;

return EOF;

}

NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);

do {

long pending = READ_DATA_PENDING_COUNT(fptr);

if (pending &gt; <literal type="number">0</literal>) {

const char *p = READ_DATA_PENDING_PTR(fptr);

const char *e;

long last;

if (limit &gt; <literal type="number">0</literal> &amp;&amp; pending &gt; limit) pending = limit;

e = memchr(p, delim, pending);

if (e) pending = e - p + <literal type="number">1</literal>;

if (!NIL_P(str)) {

last = RSTRING_LEN(str);

rb_str_resize(str, last + pending);

}

else {

last = <literal type="number">0</literal>;

*strp = str = rb_str_buf_new(pending);

rb_str_set_len(str, pending);

}

read_buffered_data(RSTRING_PTR(str) + last, pending, fptr); 

limit -= pending;

*lp = limit;

if (e) return delim;

if (limit == <literal type="number">0</literal>)

return (unsigned char)RSTRING_PTR(str)[RSTRING_LEN(str)-<literal type="number">1</literal>];

}

READ_CHECK(fptr);

} while (io_fillbuf(fptr) &gt;= <literal type="number">0</literal>);

*lp = limit;

return EOF;

}

static inline int

swallow(rb_io_t *fptr, int term)

{

if (NEED_READCONV(fptr)) {

rb_encoding *enc = io_read_encoding(fptr);

int needconv = rb_enc_mbminlen(enc) != <literal type="number">1</literal>;

SET_BINARY_MODE(fptr);

make_readconv(fptr, <literal type="number">0</literal>);

do {

size_t cnt;

while ((cnt = READ_CHAR_PENDING_COUNT(fptr)) &gt; <literal type="number">0</literal>) {

const char *p = READ_CHAR_PENDING_PTR(fptr);

int i;

if (!needconv) {

if (*p != term) return TRUE;

i = (int)cnt;

while (--i &amp;&amp; *++p == term);

}

else {

const char *e = p + cnt;

if (rb_enc_ascget(p, e, &amp;i, enc) != term) return TRUE;

while ((p += i) &lt; e &amp;&amp; rb_enc_ascget(p, e, &amp;i, enc) == term);

i = (int)(e - p);

}

io_shift_cbuf(fptr, (int)cnt - i, NULL);

}

} while (more_char(fptr) != MORE_CHAR_FINISHED);

return FALSE;

}

NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);

do {

size_t cnt;

while ((cnt = READ_DATA_PENDING_COUNT(fptr)) &gt; <literal type="number">0</literal>) {

char buf[<literal type="number">1024</literal>];

const char *p = READ_DATA_PENDING_PTR(fptr);

int i;

if (cnt &gt; sizeof buf) cnt = sizeof buf;

if (*p != term) return TRUE;

i = (int)cnt;

while (--i &amp;&amp; *++p == term);

if (!read_buffered_data(buf, cnt - i, fptr)) 

rb_sys_fail_path(fptr-&gt;pathv);

}

READ_CHECK(fptr);

} while (io_fillbuf(fptr) == <literal type="number">0</literal>);

return FALSE;

}

static VALUE

rb_io_getline_fast(rb_io_t *fptr, rb_encoding *enc, int chomp)

{

VALUE str = Qnil;

int len = <literal type="number">0</literal>;

long pos = <literal type="number">0</literal>;

int cr = <literal type="number">0</literal>;

do {

int pending = READ_DATA_PENDING_COUNT(fptr);

if (pending &gt; <literal type="number">0</literal>) {

const char *p = READ_DATA_PENDING_PTR(fptr);

const char *e;

int chomplen = <literal type="number">0</literal>;

e = memchr(p, <literal type="char">'\n'</literal>, pending);

if (e) {

pending = (int)(e - p + <literal type="number">1</literal>);

if (chomp) {

chomplen = (pending &gt; <literal type="number">1</literal> &amp;&amp; *(e-<literal type="number">1</literal>) == <literal type="char">'\r'</literal>) + <literal type="number">1</literal>;

}

}

if (NIL_P(str)) {

str = rb_str_new(p, pending - chomplen);

fptr-&gt;rbuf.off += pending;

fptr-&gt;rbuf.len -= pending;

}

else {

rb_str_resize(str, len + pending - chomplen);

read_buffered_data(RSTRING_PTR(str)+len, pending - chomplen, fptr);

fptr-&gt;rbuf.off += chomplen;

fptr-&gt;rbuf.len -= chomplen;

if (pending == <literal type="number">1</literal> &amp;&amp; chomplen == <literal type="number">1</literal> &amp;&amp; len &gt; <literal type="number">0</literal>) {

if (RSTRING_PTR(str)[len-<literal type="number">1</literal>] == <literal type="char">'\r'</literal>) {

rb_str_resize(str, --len);

break;

}

}

}

len += pending - chomplen;

if (cr != ENC_CODERANGE_BROKEN)

pos += rb_str_coderange_scan_restartable(RSTRING_PTR(str) + pos, RSTRING_PTR(str) + len, enc, &amp;cr);

if (e) break;

}

READ_CHECK(fptr);

} while (io_fillbuf(fptr) &gt;= <literal type="number">0</literal>);

if (NIL_P(str)) return Qnil;

str = io_enc_str(str, fptr);

ENC_CODERANGE_SET(str, cr);

fptr-&gt;lineno++;

return str;

}

struct getline_arg {

VALUE io;

VALUE rs;

long limit;

unsigned int chomp: <literal type="number">1</literal>;

};

static void

extract_getline_opts(VALUE opts, struct getline_arg *args)

{

int chomp = FALSE;

if (!NIL_P(opts)) {

static ID kwds[<literal type="number">1</literal>];

VALUE vchomp;

if (!kwds[<literal type="number">0</literal>]) {

kwds[<literal type="number">0</literal>] = rb_intern_const(<literal type="string">"chomp"</literal>);

}

rb_get_kwargs(opts, kwds, <literal type="number">0</literal>, -<literal type="number">2</literal>, &amp;vchomp);

chomp = (vchomp != Qundef) &amp;&amp; RTEST(vchomp);

}

args-&gt;chomp = chomp;

}

static void

extract_getline_args(int argc, VALUE *argv, struct getline_arg *args)

{

VALUE rs = rb_rs</argument>, <argument>lim = Qnil;

if (argc == <literal type="number">1</literal>) {

VALUE tmp = Qnil;

if (NIL_P(argv[<literal type="number">0</literal>]) || !NIL_P(tmp = rb_check_string_type(argv[<literal type="number">0</literal>]))) {

rs = tmp;

}

else {

lim = argv[<literal type="number">0</literal>];

}

}

else if (<literal type="number">2</literal> &lt;= argc) {

rs = argv[<literal type="number">0</literal>]</argument>, <argument>lim = argv[<literal type="number">1</literal>];

if (!NIL_P(rs))

StringValue(rs);

}

args-&gt;rs = rs;

args-&gt;limit = NIL_P(lim) ? -<literal type="number">1L</literal> : NUM2LONG(lim);

}

static void

check_getline_args(VALUE *rsp, long *limit, VALUE io)

{

rb_io_t *fptr;

VALUE rs = *rsp;

if (!NIL_P(rs)) {

rb_encoding *enc_rs</argument>, <argument>*enc_io;

GetOpenFile(io, fptr);

enc_rs = rb_enc_get(rs);

enc_io = io_read_encoding(fptr);

if (enc_io != enc_rs &amp;&amp;

(rb_enc_str_coderange(rs) != ENC_CODERANGE_7BIT ||

(RSTRING_LEN(rs) &gt; <literal type="number">0</literal> &amp;&amp; !rb_enc_asciicompat(enc_io)))) {

if (rs == rb_default_rs) {

rs = rb_enc_str_new(<literal type="number">0</literal>, <literal type="number">0</literal>, enc_io);

rb_str_buf_cat_ascii(rs, <literal type="string">"\n"</literal>);

*rsp = rs;

}

else {

rb_raise(rb_eArgError, <literal type="string">"encoding mismatch: %s IO with %s RS"</literal>,

rb_enc_name(enc_io),

rb_enc_name(enc_rs));

}

}

}

}

static void

prepare_getline_args(int argc, VALUE *argv, struct getline_arg *args, VALUE io)

{

VALUE opts;

argc = rb_scan_args(argc, argv, <literal type="string">"02:"</literal>, NULL, NULL, &amp;opts);

extract_getline_args(argc, argv, args);

extract_getline_opts(opts, args);

check_getline_args(&amp;args-&gt;rs, &amp;args-&gt;limit, io);

}

static VALUE

rb_io_getline_0(VALUE rs, long limit, int chomp, rb_io_t *fptr)

{

VALUE str = Qnil;

int nolimit = <literal type="number">0</literal>;

rb_encoding *enc;

rb_io_check_char_readable(fptr);

if (NIL_P(rs) &amp;&amp; limit &lt; <literal type="number">0</literal>) {

str = read_all(fptr, <literal type="number">0</literal>, Qnil);

if (RSTRING_LEN(str) == <literal type="number">0</literal>) return Qnil;

if (chomp) rb_str_chomp_string(str, rb_default_rs);

}

else if (limit == <literal type="number">0</literal>) {

return rb_enc_str_new(<literal type="number">0</literal>, <literal type="number">0</literal>, io_read_encoding(fptr));

}

else if (rs == rb_default_rs &amp;&amp; limit &lt; <literal type="number">0</literal> &amp;&amp; !NEED_READCONV(fptr) &amp;&amp;

rb_enc_asciicompat(enc = io_read_encoding(fptr))) {

NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);

return rb_io_getline_fast(fptr, enc, chomp);

}

else {

int c</argument>, <argument>newline = -<literal type="number">1</literal>;

const char *rsptr = <literal type="number">0</literal>;

long rslen = <literal type="number">0</literal>;

int rspara = <literal type="number">0</literal>;

int extra_limit = <literal type="number">16</literal>;

int chomp_cr = chomp;

SET_BINARY_MODE(fptr);

enc = io_read_encoding(fptr);

if (!NIL_P(rs)) {

rslen = RSTRING_LEN(rs);

if (rslen == <literal type="number">0</literal>) {

rsptr = <literal type="string">"\n\n"</literal>;

rslen = <literal type="number">2</literal>;

rspara = <literal type="number">1</literal>;

swallow(fptr, <literal type="char">'\n'</literal>);

rs = <literal type="number">0</literal>;

if (!rb_enc_asciicompat(enc)) {

rs = rb_usascii_str_new(rsptr, rslen);

rs = rb_str_encode(rs, rb_enc_from_encoding(enc), <literal type="number">0</literal>, Qnil);

OBJ_FREEZE(rs);

rsptr = RSTRING_PTR(rs);

rslen = RSTRING_LEN(rs);

}

}

else {

rsptr = RSTRING_PTR(rs);

}

newline = (unsigned char)rsptr[rslen - <literal type="number">1</literal>];

chomp_cr = chomp &amp;&amp; rslen == <literal type="number">1</literal> &amp;&amp; newline == <literal type="char">'\n'</literal>;

}

while ((c = appendline(fptr, newline, &amp;str, &amp;limit)) != EOF) {

const char *s</argument>, <argument>*p</argument>, <argument>*pp</argument>, <argument>*e;

if (c == newline) {

if (RSTRING_LEN(str) &lt; rslen) continue;

s = RSTRING_PTR(str);

e = RSTRING_END(str);

p = e - rslen;

pp = rb_enc_left_char_head(s, p, e, enc);

if (pp != p) continue;

if (!rspara) rscheck(rsptr, rslen, rs);

if (memcmp(p, rsptr, rslen) == <literal type="number">0</literal>) {

if (chomp) {

if (chomp_cr &amp;&amp; p &gt; s &amp;&amp; *(p-<literal type="number">1</literal>) == <literal type="char">'\r'</literal>) --p;

rb_str_set_len(str, p - s);

}

break;

}

}

if (limit == <literal type="number">0</literal>) {

s = RSTRING_PTR(str);

p = RSTRING_END(str);

pp = rb_enc_left_char_head(s, p-<literal type="number">1</literal>, p, enc);

if (extra_limit &amp;&amp;

MBCLEN_NEEDMORE_P(rb_enc_precise_mbclen(pp, p, enc))) {

limit = <literal type="number">1</literal>;

extra_limit--;

}

else {

nolimit = <literal type="number">1</literal>;

break;

}

}

}

if (rspara &amp;&amp; c != EOF)

swallow(fptr, <literal type="char">'\n'</literal>);

if (!NIL_P(str))

str = io_enc_str(str, fptr);

}

if (!NIL_P(str) &amp;&amp; !nolimit) {

fptr-&gt;lineno++;

}

return str;

}

static VALUE

rb_io_getline_1(VALUE rs, long limit, int chomp, VALUE io)

{

rb_io_t *fptr;

int old_lineno</argument>, <argument>new_lineno;

VALUE str;

GetOpenFile(io, fptr);

old_lineno = fptr-&gt;lineno;

str = rb_io_getline_0(rs, limit, chomp, fptr);

if (!NIL_P(str) &amp;&amp; (new_lineno = fptr-&gt;lineno) != old_lineno) {

if (io == ARGF.current_file) {

ARGF.lineno += new_lineno - old_lineno;

ARGF.last_lineno = ARGF.lineno;

}

else {

ARGF.last_lineno = new_lineno;

}

}

return str;

}

static VALUE

rb_io_getline(int argc, VALUE *argv, VALUE io)

{

struct getline_arg args;

prepare_getline_args(argc, argv, &amp;args, io);

return rb_io_getline_1(args.rs, args.limit, args.chomp, io);

}

VALUE

rb_io_gets(VALUE io)

{

return rb_io_getline_1(rb_default_rs, -<literal type="number">1</literal>, FALSE, io);

}

VALUE

rb_io_gets_internal(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

return rb_io_getline_0(rb_default_rs, -<literal type="number">1</literal>, FALSE, fptr);

}

static VALUE

rb_io_gets_m(int argc, VALUE *argv, VALUE io)

{

VALUE str;

str = rb_io_getline(argc, argv, io);

rb_lastline_set(str);

return str;

}

static VALUE

rb_io_lineno(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

rb_io_check_char_readable(fptr);

return INT2NUM(fptr-&gt;lineno);

}

static VALUE

rb_io_set_lineno(VALUE io, VALUE lineno)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

rb_io_check_char_readable(fptr);

fptr-&gt;lineno = NUM2INT(lineno);

return lineno;

}

static VALUE

rb_io_readline(int argc, VALUE *argv, VALUE io)

{

VALUE line = rb_io_gets_m(argc, argv, io);

if (NIL_P(line)) {

rb_eof_error();

}

return line;

}

static VALUE io_readlines(const struct getline_arg *arg, VALUE io);

static VALUE

rb_io_readlines(int argc, VALUE *argv, VALUE io)

{

struct getline_arg args;

prepare_getline_args(argc, argv, &amp;args, io);

return io_readlines(&amp;args, io);

}

static VALUE

io_readlines(const struct getline_arg *arg, VALUE io)

{

VALUE line</argument>, <argument>ary;

if (arg-&gt;limit == <literal type="number">0</literal>)

rb_raise(rb_eArgError, <literal type="string">"invalid limit: 0 for readlines"</literal>);

ary = rb_ary_new();

while (!NIL_P(line = rb_io_getline_1(arg-&gt;rs, arg-&gt;limit, arg-&gt;chomp, io))) {

rb_ary_push(ary, line);

}

return ary;

}

static VALUE

rb_io_each_line(int argc, VALUE *argv, VALUE io)

{

VALUE str;

struct getline_arg args;

RETURN_ENUMERATOR(io, argc, argv);

prepare_getline_args(argc, argv, &amp;args, io);

if (args.limit == <literal type="number">0</literal>)

rb_raise(rb_eArgError, <literal type="string">"invalid limit: 0 for each_line"</literal>);

while (!NIL_P(str = rb_io_getline_1(args.rs, args.limit, args.chomp, io))) {

rb_yield(str);

}

return io;

}

static VALUE

rb_io_lines(int argc, VALUE *argv, VALUE io)

{

rb_warn_deprecated(<literal type="string">"IO#lines"</literal>, <literal type="string">"#each_line"</literal>);

if (!rb_block_given_p())

return rb_enumeratorize(io, ID2SYM(rb_intern(<literal type="string">"each_line"</literal>)), argc, argv);

return rb_io_each_line(argc, argv, io);

}

static VALUE

rb_io_each_byte(VALUE io)

{

rb_io_t *fptr;

RETURN_ENUMERATOR(io, <literal type="number">0</literal>, <literal type="number">0</literal>);

GetOpenFile(io, fptr);

do {

while (fptr-&gt;rbuf.len &gt; <literal type="number">0</literal>) {

char *p = fptr-&gt;rbuf.ptr + fptr-&gt;rbuf.off++;

fptr-&gt;rbuf.len--;

rb_yield(INT2FIX(*p &amp; <literal type="number">0xff</literal>));

errno = <literal type="number">0</literal>;

}

rb_io_check_byte_readable(fptr);

READ_CHECK(fptr);

} while (io_fillbuf(fptr) &gt;= <literal type="number">0</literal>);

return io;

}

static VALUE

rb_io_bytes(VALUE io)

{

rb_warn_deprecated(<literal type="string">"IO#bytes"</literal>, <literal type="string">"#each_byte"</literal>);

if (!rb_block_given_p())

return rb_enumeratorize(io, ID2SYM(rb_intern(<literal type="string">"each_byte"</literal>)), <literal type="number">0</literal>, <literal type="number">0</literal>);

return rb_io_each_byte(io);

}

static VALUE

io_getc(rb_io_t *fptr, rb_encoding *enc)

{

int r</argument>, <argument>n</argument>, <argument>cr = <literal type="number">0</literal>;

VALUE str;

if (NEED_READCONV(fptr)) {

rb_encoding *read_enc = io_read_encoding(fptr);

str = Qnil;

SET_BINARY_MODE(fptr);

make_readconv(fptr, <literal type="number">0</literal>);

while (<literal type="number">1</literal>) {

if (fptr-&gt;cbuf.len) {

r = rb_enc_precise_mbclen(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,

fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off+fptr-&gt;cbuf.len,

read_enc);

if (!MBCLEN_NEEDMORE_P(r))

break;

if (fptr-&gt;cbuf.len == fptr-&gt;cbuf.capa) {

rb_raise(rb_eIOError, <literal type="string">"too long character"</literal>);

}

}

if (more_char(fptr) == MORE_CHAR_FINISHED) {

if (fptr-&gt;cbuf.len == <literal type="number">0</literal>) {

clear_readconv(fptr);

return Qnil;

}

str = rb_enc_str_new(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off, <literal type="number">1</literal>, read_enc);

fptr-&gt;cbuf.off += <literal type="number">1</literal>;

fptr-&gt;cbuf.len -= <literal type="number">1</literal>;

if (fptr-&gt;cbuf.len == <literal type="number">0</literal>) clear_readconv(fptr);

ENC_CODERANGE_SET(str, ENC_CODERANGE_BROKEN);

return str;

}

}

if (MBCLEN_INVALID_P(r)) {

r = rb_enc_mbclen(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,

fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off+fptr-&gt;cbuf.len,

read_enc);

io_shift_cbuf(fptr, r, &amp;str);

cr = ENC_CODERANGE_BROKEN;

}

else {

io_shift_cbuf(fptr, MBCLEN_CHARFOUND_LEN(r), &amp;str);

cr = ENC_CODERANGE_VALID;

if (MBCLEN_CHARFOUND_LEN(r) == <literal type="number">1</literal> &amp;&amp; rb_enc_asciicompat(read_enc) &amp;&amp;

ISASCII(RSTRING_PTR(str)[<literal type="number">0</literal>])) {

cr = ENC_CODERANGE_7BIT;

}

}

str = io_enc_str(str, fptr);

ENC_CODERANGE_SET(str, cr);

return str;

}

NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);

if (io_fillbuf(fptr) &lt; <literal type="number">0</literal>) {

return Qnil;

}

if (rb_enc_asciicompat(enc) &amp;&amp; ISASCII(fptr-&gt;rbuf.ptr[fptr-&gt;rbuf.off])) {

str = rb_str_new(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off, <literal type="number">1</literal>);

fptr-&gt;rbuf.off += <literal type="number">1</literal>;

fptr-&gt;rbuf.len -= <literal type="number">1</literal>;

cr = ENC_CODERANGE_7BIT;

}

else {

r = rb_enc_precise_mbclen(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off, fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off+fptr-&gt;rbuf.len, enc);

if (MBCLEN_CHARFOUND_P(r) &amp;&amp;

(n = MBCLEN_CHARFOUND_LEN(r)) &lt;= fptr-&gt;rbuf.len) {

str = rb_str_new(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off, n);

fptr-&gt;rbuf.off += n;

fptr-&gt;rbuf.len -= n;

cr = ENC_CODERANGE_VALID;

}

else if (MBCLEN_NEEDMORE_P(r)) {

str = rb_str_new(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off, fptr-&gt;rbuf.len);

fptr-&gt;rbuf.len = <literal type="number">0</literal>;

getc_needmore:

if (io_fillbuf(fptr) != -<literal type="number">1</literal>) {

rb_str_cat(str, fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off, <literal type="number">1</literal>);

fptr-&gt;rbuf.off++;

fptr-&gt;rbuf.len--;

r = rb_enc_precise_mbclen(RSTRING_PTR(str), RSTRING_PTR(str)+RSTRING_LEN(str), enc);

if (MBCLEN_NEEDMORE_P(r)) {

goto getc_needmore;

}

else if (MBCLEN_CHARFOUND_P(r)) {

cr = ENC_CODERANGE_VALID;

}

}

}

else {

str = rb_str_new(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off, <literal type="number">1</literal>);

fptr-&gt;rbuf.off++;

fptr-&gt;rbuf.len--;

}

}

if (!cr) cr = ENC_CODERANGE_BROKEN;

str = io_enc_str(str, fptr);

ENC_CODERANGE_SET(str, cr);

return str;

}

static VALUE

rb_io_each_char(VALUE io)

{

rb_io_t *fptr;

rb_encoding *enc;

VALUE c;

RETURN_ENUMERATOR(io, <literal type="number">0</literal>, <literal type="number">0</literal>);

GetOpenFile(io, fptr);

rb_io_check_char_readable(fptr);

enc = io_input_encoding(fptr);

READ_CHECK(fptr);

while (!NIL_P(c = io_getc(fptr, enc))) {

rb_yield(c);

}

return io;

}

static VALUE

rb_io_chars(VALUE io)

{

rb_warn_deprecated(<literal type="string">"IO#chars"</literal>, <literal type="string">"#each_char"</literal>);

if (!rb_block_given_p())

return rb_enumeratorize(io, ID2SYM(rb_intern(<literal type="string">"each_char"</literal>)), <literal type="number">0</literal>, <literal type="number">0</literal>);

return rb_io_each_char(io);

}

static VALUE

rb_io_each_codepoint(VALUE io)

{

rb_io_t *fptr;

rb_encoding *enc;

unsigned int c;

int r</argument>, <argument>n;

RETURN_ENUMERATOR(io, <literal type="number">0</literal>, <literal type="number">0</literal>);

GetOpenFile(io, fptr);

rb_io_check_char_readable(fptr);

READ_CHECK(fptr);

if (NEED_READCONV(fptr)) {

SET_BINARY_MODE(fptr);

r = <literal type="number">1</literal>; 

for (;;) {

make_readconv(fptr, <literal type="number">0</literal>);

for (;;) {

if (fptr-&gt;cbuf.len) {

if (fptr-&gt;encs.enc)

r = rb_enc_precise_mbclen(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,

fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off+fptr-&gt;cbuf.len,

fptr-&gt;encs.enc);

else

r = ONIGENC_CONSTRUCT_MBCLEN_CHARFOUND(<literal type="number">1</literal>);

if (!MBCLEN_NEEDMORE_P(r))

break;

if (fptr-&gt;cbuf.len == fptr-&gt;cbuf.capa) {

rb_raise(rb_eIOError, <literal type="string">"too long character"</literal>);

}

}

if (more_char(fptr) == MORE_CHAR_FINISHED) {

clear_readconv(fptr);

if (!MBCLEN_CHARFOUND_P(r)) {

enc = fptr-&gt;encs.enc;

goto invalid;

}

return io;

}

}

if (MBCLEN_INVALID_P(r)) {

enc = fptr-&gt;encs.enc;

goto invalid;

}

n = MBCLEN_CHARFOUND_LEN(r);

if (fptr-&gt;encs.enc) {

c = rb_enc_codepoint(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,

fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off+fptr-&gt;cbuf.len,

fptr-&gt;encs.enc);

}

else {

c = (unsigned char)fptr-&gt;cbuf.ptr[fptr-&gt;cbuf.off];

}

fptr-&gt;cbuf.off += n;

fptr-&gt;cbuf.len -= n;

rb_yield(UINT2NUM(c));

}

}

NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);

enc = io_input_encoding(fptr);

while (io_fillbuf(fptr) &gt;= <literal type="number">0</literal>) {

r = rb_enc_precise_mbclen(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off,

fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off+fptr-&gt;rbuf.len, enc);

if (MBCLEN_CHARFOUND_P(r) &amp;&amp;

(n = MBCLEN_CHARFOUND_LEN(r)) &lt;= fptr-&gt;rbuf.len) {

c = rb_enc_codepoint(fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off,

fptr-&gt;rbuf.ptr+fptr-&gt;rbuf.off+fptr-&gt;rbuf.len, enc);

fptr-&gt;rbuf.off += n;

fptr-&gt;rbuf.len -= n;

rb_yield(UINT2NUM(c));

}

else if (MBCLEN_INVALID_P(r)) {

invalid:

rb_raise(rb_eArgError, <literal type="string">"invalid byte sequence in %s"</literal>, rb_enc_name(enc));

}

else if (MBCLEN_NEEDMORE_P(r)) {

char cbuf[<literal type="number">8</literal>]</argument>, <argument>*p = cbuf;

int more = MBCLEN_NEEDMORE_LEN(r);

if (more &gt; numberof(cbuf)) goto invalid;

more += n = fptr-&gt;rbuf.len;

if (more &gt; numberof(cbuf)) goto invalid;

while ((n = (int)read_buffered_data(p, more, fptr)) &gt; <literal type="number">0</literal> &amp;&amp;

(p += n, (more -= n) &gt; <literal type="number">0</literal>)) {

if (io_fillbuf(fptr) &lt; <literal type="number">0</literal>) goto invalid;

if ((n = fptr-&gt;rbuf.len) &gt; more) n = more;

}

r = rb_enc_precise_mbclen(cbuf, p, enc);

if (!MBCLEN_CHARFOUND_P(r)) goto invalid;

c = rb_enc_codepoint(cbuf, p, enc);

rb_yield(UINT2NUM(c));

}

else {

continue;

}

}

return io;

}

static VALUE

rb_io_codepoints(VALUE io)

{

rb_warn_deprecated(<literal type="string">"IO#codepoints"</literal>, <literal type="string">"#each_codepoint"</literal>);

if (!rb_block_given_p())

return rb_enumeratorize(io, ID2SYM(rb_intern(<literal type="string">"each_codepoint"</literal>)), <literal type="number">0</literal>, <literal type="number">0</literal>);

return rb_io_each_codepoint(io);

}

static VALUE

rb_io_getc(VALUE io)

{

rb_io_t *fptr;

rb_encoding *enc;

GetOpenFile(io, fptr);

rb_io_check_char_readable(fptr);

enc = io_input_encoding(fptr);

READ_CHECK(fptr);

return io_getc(fptr, enc);

}

static VALUE

rb_io_readchar(VALUE io)

{

VALUE c = rb_io_getc(io);

if (NIL_P(c)) {

rb_eof_error();

}

return c;

}

VALUE

rb_io_getbyte(VALUE io)

{

rb_io_t *fptr;

int c;

GetOpenFile(io, fptr);

rb_io_check_byte_readable(fptr);

READ_CHECK(fptr);

if (fptr-&gt;fd == <literal type="number">0</literal> &amp;&amp; (fptr-&gt;mode &amp; FMODE_TTY) &amp;&amp; RB_TYPE_P(rb_stdout, T_FILE)) {

rb_io_t *ofp;

GetOpenFile(rb_stdout, ofp);

if (ofp-&gt;mode &amp; FMODE_TTY) {

rb_io_flush(rb_stdout);

}

}

if (io_fillbuf(fptr) &lt; <literal type="number">0</literal>) {

return Qnil;

}

fptr-&gt;rbuf.off++;

fptr-&gt;rbuf.len--;

c = (unsigned char)fptr-&gt;rbuf.ptr[fptr-&gt;rbuf.off-<literal type="number">1</literal>];

return INT2FIX(c &amp; <literal type="number">0xff</literal>);

}

static VALUE

rb_io_readbyte(VALUE io)

{

VALUE c = rb_io_getbyte(io);

if (NIL_P(c)) {

rb_eof_error();

}

return c;

}

VALUE

rb_io_ungetbyte(VALUE io, VALUE b)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

rb_io_check_byte_readable(fptr);

switch (TYPE(b)) {

case T_NIL:

return Qnil;

case T_FIXNUM:

case T_BIGNUM: ;

VALUE v = rb_int_modulo(b, INT2FIX(<literal type="number">256</literal>));

unsigned char c = NUM2INT(v) &amp; <literal type="number">0xFF</literal>;

b = rb_str_new((const char *)&amp;c, <literal type="number">1</literal>);

break;

default:

SafeStringValue(b);

}

io_ungetbyte(b, fptr);

return Qnil;

}

VALUE

rb_io_ungetc(VALUE io, VALUE c)

{

rb_io_t *fptr;

long len;

GetOpenFile(io, fptr);

rb_io_check_char_readable(fptr);

if (FIXNUM_P(c)) {

c = rb_enc_uint_chr(FIX2UINT(c), io_read_encoding(fptr));

}

else if (RB_TYPE_P(c, T_BIGNUM)) {

c = rb_enc_uint_chr(NUM2UINT(c), io_read_encoding(fptr));

}

else {

SafeStringValue(c);

}

if (NEED_READCONV(fptr)) {

SET_BINARY_MODE(fptr);

len = RSTRING_LEN(c);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&gt;</operator> <name>SIZEOF_INT</name></expr></cpp:if>

if (len &gt; INT_MAX)

rb_raise(rb_eIOError, <literal type="string">"ungetc failed"</literal>);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

make_readconv(fptr, (int)len);

if (fptr-&gt;cbuf.capa - fptr-&gt;cbuf.len &lt; len)

rb_raise(rb_eIOError, <literal type="string">"ungetc failed"</literal>);

if (fptr-&gt;cbuf.off &lt; len) {

MEMMOVE(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.capa-fptr-&gt;cbuf.len,

fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off,

char, fptr-&gt;cbuf.len);

fptr-&gt;cbuf.off = fptr-&gt;cbuf.capa-fptr-&gt;cbuf.len;

}

fptr-&gt;cbuf.off -= (int)len;

fptr-&gt;cbuf.len += (int)len;

MEMMOVE(fptr-&gt;cbuf.ptr+fptr-&gt;cbuf.off, RSTRING_PTR(c), char, len);

}

else {

NEED_NEWLINE_DECORATOR_ON_READ_CHECK(fptr);

io_ungetbyte(c, fptr);

}

return Qnil;

}

static VALUE

rb_io_isatty(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

if (isatty(fptr-&gt;fd) == <literal type="number">0</literal>)

return Qfalse;

return Qtrue;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_SETFD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

static VALUE

rb_io_close_on_exec_p(VALUE io)

{

rb_io_t *fptr;

VALUE write_io;

int fd</argument>, <argument>ret;

write_io = GetWriteIO(io);

if (io != write_io) {

GetOpenFile(write_io, fptr);

if (fptr &amp;&amp; <literal type="number">0</literal> &lt;= (fd = fptr-&gt;fd)) {

if ((ret = fcntl(fd, F_GETFD)) == -<literal type="number">1</literal>) rb_sys_fail_path(fptr-&gt;pathv);

if (!(ret &amp; FD_CLOEXEC)) return Qfalse;

}

}

GetOpenFile(io, fptr);

if (fptr &amp;&amp; <literal type="number">0</literal> &lt;= (fd = fptr-&gt;fd)) {

if ((ret = fcntl(fd, F_GETFD)) == -<literal type="number">1</literal>) rb_sys_fail_path(fptr-&gt;pathv);

if (!(ret &amp; FD_CLOEXEC)) return Qfalse;

}

return Qtrue;

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_io_close_on_exec_p</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_SETFD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

static VALUE

rb_io_set_close_on_exec(VALUE io, VALUE arg)

{

int flag = RTEST(arg) ? FD_CLOEXEC : <literal type="number">0</literal>;

rb_io_t *fptr;

VALUE write_io;

int fd</argument>, <argument>ret;

write_io = GetWriteIO(io);

if (io != write_io) {

GetOpenFile(write_io, fptr);

if (fptr &amp;&amp; <literal type="number">0</literal> &lt;= (fd = fptr-&gt;fd)) {

if ((ret = fcntl(fptr-&gt;fd, F_GETFD)) == -<literal type="number">1</literal>) rb_sys_fail_path(fptr-&gt;pathv);

if ((ret &amp; FD_CLOEXEC) != flag) {

ret = (ret &amp; ~FD_CLOEXEC) | flag;

ret = fcntl(fd, F_SETFD, ret);

if (ret != <literal type="number">0</literal>) rb_sys_fail_path(fptr-&gt;pathv);

}

}

}

GetOpenFile(io, fptr);

if (fptr &amp;&amp; <literal type="number">0</literal> &lt;= (fd = fptr-&gt;fd)) {

if ((ret = fcntl(fd, F_GETFD)) == -<literal type="number">1</literal>) rb_sys_fail_path(fptr-&gt;pathv);

if ((ret &amp; FD_CLOEXEC) != flag) {

ret = (ret &amp; ~FD_CLOEXEC) | flag;

ret = fcntl(fd, F_SETFD, ret);

if (ret != <literal type="number">0</literal>) rb_sys_fail_path(fptr-&gt;pathv);

}

}

return Qnil;

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_io_set_close_on_exec</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FMODE_PREP</name></cpp:macro> <cpp:value>(1&lt;&lt;16)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_PREP_STDIO</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((f)-&gt;mode &amp; FMODE_PREP)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREP_STDIO_NAME</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(RSTRING_PTR((f)-&gt;pathv))</cpp:value></cpp:define>

static VALUE

finish_writeconv(rb_io_t *fptr, int noalloc)

{

unsigned char *ds</argument>, <argument>*dp</argument>, <argument>*de;

rb_econv_result_t res;

if (!fptr-&gt;wbuf.ptr) {

unsigned char buf[<literal type="number">1024</literal>];

long r;

res = econv_destination_buffer_full;

while (res == econv_destination_buffer_full) {

ds = dp = buf;

de = buf + sizeof(buf);

res = rb_econv_convert(fptr-&gt;writeconv, NULL, NULL, &amp;dp, de, <literal type="number">0</literal>);

while (dp-ds) {

retry:

if (fptr-&gt;write_lock &amp;&amp; rb_mutex_owned_p(fptr-&gt;write_lock))

r = rb_write_internal2(fptr-&gt;fd, ds, dp-ds);

else

r = rb_write_internal(fptr-&gt;fd, ds, dp-ds);

if (r == dp-ds)

break;

if (<literal type="number">0</literal> &lt;= r) {

ds += r;

}

if (rb_io_wait_writable(fptr-&gt;fd)) {

if (fptr-&gt;fd &lt; <literal type="number">0</literal>)

return noalloc ? Qtrue : rb_exc_new3(rb_eIOError, rb_str_new_cstr(closed_stream));

goto retry;

}

return noalloc ? Qtrue : INT2NUM(errno);

}

if (res == econv_invalid_byte_sequence ||

res == econv_incomplete_input ||

res == econv_undefined_conversion) {

return noalloc ? Qtrue : rb_econv_make_exception(fptr-&gt;writeconv);

}

}

return Qnil;

}

res = econv_destination_buffer_full;

while (res == econv_destination_buffer_full) {

if (fptr-&gt;wbuf.len == fptr-&gt;wbuf.capa) {

if (io_fflush(fptr) &lt; <literal type="number">0</literal>)

return noalloc ? Qtrue : INT2NUM(errno);

}

ds = dp = (unsigned char *)fptr-&gt;wbuf.ptr + fptr-&gt;wbuf.off + fptr-&gt;wbuf.len;

de = (unsigned char *)fptr-&gt;wbuf.ptr + fptr-&gt;wbuf.capa;

res = rb_econv_convert(fptr-&gt;writeconv, NULL, NULL, &amp;dp, de, <literal type="number">0</literal>);

fptr-&gt;wbuf.len += (int)(dp - ds);

if (res == econv_invalid_byte_sequence ||

res == econv_incomplete_input ||

res == econv_undefined_conversion) {

return noalloc ? Qtrue : rb_econv_make_exception(fptr-&gt;writeconv);

}

}

return Qnil;

}

struct finish_writeconv_arg {

rb_io_t *fptr;

int noalloc;

};

static VALUE

finish_writeconv_sync(VALUE arg)

{

struct finish_writeconv_arg *p = (struct finish_writeconv_arg *)arg;

return finish_writeconv(p-&gt;fptr, p-&gt;noalloc);

}

static void*

nogvl_close(void *ptr)

{

int *fd = ptr;

return (void*)(intptr_t)close(*fd);

}

static int

maygvl_close(int fd, int keepgvl)

{

if (keepgvl)

return close(fd);

return (int)(intptr_t)rb_thread_call_without_gvl(nogvl_close, &amp;fd, RUBY_UBF_IO, <literal type="number">0</literal>);

}

static void*

nogvl_fclose(void *ptr)

{

FILE *file = ptr;

return (void*)(intptr_t)fclose(file);

}

static int

maygvl_fclose(FILE *file, int keepgvl)

{

if (keepgvl)

return fclose(file);

return (int)(intptr_t)rb_thread_call_without_gvl(nogvl_fclose, file, RUBY_UBF_IO, <literal type="number">0</literal>);

}

static void free_io_buffer(rb_io_buffer_t *buf);

static void clear_codeconv(rb_io_t *fptr);

static void

fptr_finalize_flush(rb_io_t *fptr, int noraise, int keepgvl,

struct list_head *busy)

{

VALUE err = Qnil;

int fd = fptr-&gt;fd;

FILE *stdio_file = fptr-&gt;stdio_file;

int mode = fptr-&gt;mode;

if (fptr-&gt;writeconv) {

if (fptr-&gt;write_lock &amp;&amp; !noraise) {

struct finish_writeconv_arg arg;

arg.fptr = fptr;

arg.noalloc = noraise;

err = rb_mutex_synchronize(fptr-&gt;write_lock, finish_writeconv_sync, (VALUE)&amp;arg);

}

else {

err = finish_writeconv(fptr, noraise);

}

}

if (fptr-&gt;wbuf.len) {

if (noraise) {

io_flush_buffer_sync(fptr);

}

else {

if (io_fflush(fptr) &lt; <literal type="number">0</literal> &amp;&amp; NIL_P(err))

err = INT2NUM(errno);

}

}

fptr-&gt;fd = -<literal type="number">1</literal>;

fptr-&gt;stdio_file = <literal type="number">0</literal>;

fptr-&gt;mode &amp;= ~(FMODE_READABLE|FMODE_WRITABLE);

if (busy) {

do rb_thread_schedule(); while (!list_empty(busy));

}

if (IS_PREP_STDIO(fptr) || fd &lt;= <literal type="number">2</literal>) {

}

else if (stdio_file) {

if ((maygvl_fclose(stdio_file, noraise) &lt; <literal type="number">0</literal>) &amp;&amp; NIL_P(err))

if (!noraise) err = INT2NUM(errno);

}

else if (<literal type="number">0</literal> &lt;= fd) {

keepgvl |= !(mode &amp; FMODE_WRITABLE);

keepgvl |= noraise;

if ((maygvl_close(fd, keepgvl) &lt; <literal type="number">0</literal>) &amp;&amp; NIL_P(err))

if (!noraise) err = INT2NUM(errno);

}

if (!NIL_P(err) &amp;&amp; !noraise) {

if (RB_INTEGER_TYPE_P(err))

rb_syserr_fail_path(NUM2INT(err), fptr-&gt;pathv);

else

rb_exc_raise(err);

}

}

static void

fptr_finalize(rb_io_t *fptr, int noraise)

{

fptr_finalize_flush(fptr, noraise, FALSE, <literal type="number">0</literal>);

free_io_buffer(&amp;fptr-&gt;rbuf);

free_io_buffer(&amp;fptr-&gt;wbuf);

clear_codeconv(fptr);

}

static void

rb_io_fptr_cleanup(rb_io_t *fptr, int noraise)

{

if (fptr-&gt;finalize) {

(*fptr-&gt;finalize)(fptr, noraise);

}

else {

fptr_finalize(fptr, noraise);

}

}

static void

free_io_buffer(rb_io_buffer_t *buf)

{

if (buf-&gt;ptr) {

ruby_sized_xfree(buf-&gt;ptr, (size_t)buf-&gt;capa);

buf-&gt;ptr = NULL;

}

}

static void

clear_readconv(rb_io_t *fptr)

{

if (fptr-&gt;readconv) {

rb_econv_close(fptr-&gt;readconv);

fptr-&gt;readconv = NULL;

}

free_io_buffer(&amp;fptr-&gt;cbuf);

}

static void

clear_writeconv(rb_io_t *fptr)

{

if (fptr-&gt;writeconv) {

rb_econv_close(fptr-&gt;writeconv);

fptr-&gt;writeconv = NULL;

}

fptr-&gt;writeconv_initialized = <literal type="number">0</literal>;

}

static void

clear_codeconv(rb_io_t *fptr)

{

clear_readconv(fptr);

clear_writeconv(fptr);

}

void

rb_io_fptr_finalize_internal(void *ptr)

{

rb_io_t *fptr = ptr;

if (!ptr) return;

fptr-&gt;pathv = Qnil;

if (<literal type="number">0</literal> &lt;= fptr-&gt;fd)

rb_io_fptr_cleanup(fptr, TRUE);

fptr-&gt;write_lock = <literal type="number">0</literal>;

free_io_buffer(&amp;fptr-&gt;rbuf);

free_io_buffer(&amp;fptr-&gt;wbuf);

clear_codeconv(fptr);

free(fptr);

}

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_io_fptr_finalize</name></cpp:undef>

int

rb_io_fptr_finalize(rb_io_t *fptr)

{

if (!fptr) {

return <literal type="number">0</literal>;

}

else {

rb_io_fptr_finalize_internal(fptr);

return <literal type="number">1</literal>;

}

}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_io_fptr_finalize</name><parameter_list>(<parameter><type><name>fptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_io_fptr_finalize_internal(fptr)</cpp:value></cpp:define>

RUBY_FUNC_EXPORTED size_t

rb_io_memsize(const rb_io_t *fptr)

{

size_t size = sizeof(rb_io_t);

size += fptr-&gt;rbuf.capa;

size += fptr-&gt;wbuf.capa;

size += fptr-&gt;cbuf.capa;

if (fptr-&gt;readconv) size += rb_econv_memsize(fptr-&gt;readconv);

if (fptr-&gt;writeconv) size += rb_econv_memsize(fptr-&gt;writeconv);

return size;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEEPGVL</name></cpp:macro> <cpp:value>TRUE</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEEPGVL</name></cpp:macro> <cpp:value>FALSE</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

int rb_notify_fd_close(int fd, struct list_head *);

static rb_io_t *

io_close_fptr(VALUE io)

{

rb_io_t *fptr;

VALUE write_io;

rb_io_t *write_fptr;

struct list_head busy;

list_head_init(&amp;busy);

write_io = GetWriteIO(io);

if (io != write_io) {

write_fptr = RFILE(write_io)-&gt;fptr;

if (write_fptr &amp;&amp; <literal type="number">0</literal> &lt;= write_fptr-&gt;fd) {

rb_io_fptr_cleanup(write_fptr, TRUE);

}

}

fptr = RFILE(io)-&gt;fptr;

if (!fptr) return <literal type="number">0</literal>;

if (fptr-&gt;fd &lt; <literal type="number">0</literal>) return <literal type="number">0</literal>;

if (rb_notify_fd_close(fptr-&gt;fd, &amp;busy)) {

fptr_finalize_flush(fptr, FALSE, KEEPGVL, &amp;busy);

}

rb_io_fptr_cleanup(fptr, FALSE);

return fptr;

}

static void

fptr_waitpid(rb_io_t *fptr, int nohang)

{

int status;

if (fptr-&gt;pid) {

rb_last_status_clear();

rb_waitpid(fptr-&gt;pid, &amp;status, nohang ? WNOHANG : <literal type="number">0</literal>);

fptr-&gt;pid = <literal type="number">0</literal>;

}

}

VALUE

rb_io_close(VALUE io)

{

rb_io_t *fptr = io_close_fptr(io);

if (fptr) fptr_waitpid(fptr, <literal type="number">0</literal>);

return Qnil;

}

static VALUE

rb_io_close_m(VALUE io)

{

rb_io_t *fptr = rb_io_get_fptr(io);

if (fptr-&gt;fd &lt; <literal type="number">0</literal>) {

return Qnil;

}

rb_io_close(io);

return Qnil;

}

static VALUE

io_call_close(VALUE io)

{

rb_check_funcall(io, rb_intern(<literal type="string">"close"</literal>), <literal type="number">0</literal>, <literal type="number">0</literal>);

return io;

}

static VALUE

ignore_closed_stream(VALUE io, VALUE exc)

{

enum {mesg_len = sizeof(closed_stream)-<literal type="number">1</literal>};

VALUE mesg = rb_attr_get(exc, idMesg);

if (!RB_TYPE_P(mesg, T_STRING) ||

RSTRING_LEN(mesg) != mesg_len ||

memcmp(RSTRING_PTR(mesg), closed_stream, mesg_len)) {

rb_exc_raise(exc);

}

return io;

}

static VALUE

io_close(VALUE io)

{

VALUE closed = rb_check_funcall(io, rb_intern(<literal type="string">"closed?"</literal>), <literal type="number">0</literal>, <literal type="number">0</literal>);

if (closed != Qundef &amp;&amp; RTEST(closed)) return io;

rb_rescue2(io_call_close, io, ignore_closed_stream, io,

rb_eIOError, (VALUE)<literal type="number">0</literal>);

return io;

}

static VALUE

rb_io_closed(VALUE io)

{

rb_io_t *fptr;

VALUE write_io;

rb_io_t *write_fptr;

write_io = GetWriteIO(io);

if (io != write_io) {

write_fptr = RFILE(write_io)-&gt;fptr;

if (write_fptr &amp;&amp; <literal type="number">0</literal> &lt;= write_fptr-&gt;fd) {

return Qfalse;

}

}

fptr = rb_io_get_fptr(io);

return <literal type="number">0</literal> &lt;= fptr-&gt;fd ? Qfalse : Qtrue;

}

static VALUE

rb_io_close_read(VALUE io)

{

rb_io_t *fptr;

VALUE write_io;

fptr = rb_io_get_fptr(rb_io_taint_check(io));

if (fptr-&gt;fd &lt; <literal type="number">0</literal>) return Qnil;

if (is_socket(fptr-&gt;fd, fptr-&gt;pathv)) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SHUT_RD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHUT_RD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (shutdown(fptr-&gt;fd, SHUT_RD) &lt; <literal type="number">0</literal>)

rb_sys_fail_path(fptr-&gt;pathv);

fptr-&gt;mode &amp;= ~FMODE_READABLE;

if (!(fptr-&gt;mode &amp; FMODE_WRITABLE))

return rb_io_close(io);

return Qnil;

}

write_io = GetWriteIO(io);

if (io != write_io) {

rb_io_t *wfptr;

wfptr = rb_io_get_fptr(rb_io_taint_check(write_io));

wfptr-&gt;pid = fptr-&gt;pid;

fptr-&gt;pid = <literal type="number">0</literal>;

RFILE(io)-&gt;fptr = wfptr;

fptr-&gt;tied_io_for_writing = <literal type="number">0</literal>;

RFILE(write_io)-&gt;fptr = fptr;

rb_io_fptr_cleanup(fptr, FALSE);

return Qnil;

}

if ((fptr-&gt;mode &amp; (FMODE_DUPLEX|FMODE_WRITABLE)) == FMODE_WRITABLE) {

rb_raise(rb_eIOError, <literal type="string">"closing non-duplex IO for reading"</literal>);

}

return rb_io_close(io);

}

static VALUE

rb_io_close_write(VALUE io)

{

rb_io_t *fptr;

VALUE write_io;

write_io = GetWriteIO(io);

fptr = rb_io_get_fptr(rb_io_taint_check(write_io));

if (fptr-&gt;fd &lt; <literal type="number">0</literal>) return Qnil;

if (is_socket(fptr-&gt;fd, fptr-&gt;pathv)) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHUT_WR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (shutdown(fptr-&gt;fd, SHUT_WR) &lt; <literal type="number">0</literal>)

rb_sys_fail_path(fptr-&gt;pathv);

fptr-&gt;mode &amp;= ~FMODE_WRITABLE;

if (!(fptr-&gt;mode &amp; FMODE_READABLE))

return rb_io_close(write_io);

return Qnil;

}

if ((fptr-&gt;mode &amp; (FMODE_DUPLEX|FMODE_READABLE)) == FMODE_READABLE) {

rb_raise(rb_eIOError, <literal type="string">"closing non-duplex IO for writing"</literal>);

}

if (io != write_io) {

fptr = rb_io_get_fptr(rb_io_taint_check(io));

fptr-&gt;tied_io_for_writing = <literal type="number">0</literal>;

}

rb_io_close(write_io);

return Qnil;

}

static VALUE

rb_io_sysseek(int argc, VALUE *argv, VALUE io)

{

VALUE offset</argument>, <argument>ptrname;

int whence = SEEK_SET;

rb_io_t *fptr;

off_t pos;

if (rb_scan_args(argc, argv, <literal type="string">"11"</literal>, &amp;offset, &amp;ptrname) == <literal type="number">2</literal>) {

whence = interpret_seek_whence(ptrname);

}

pos = NUM2OFFT(offset);

GetOpenFile(io, fptr);

if ((fptr-&gt;mode &amp; FMODE_READABLE) &amp;&amp;

(READ_DATA_BUFFERED(fptr) || READ_CHAR_PENDING(fptr))) {

rb_raise(rb_eIOError, <literal type="string">"sysseek for buffered IO"</literal>);

}

if ((fptr-&gt;mode &amp; FMODE_WRITABLE) &amp;&amp; fptr-&gt;wbuf.len) {

rb_warn(<literal type="string">"sysseek for buffered IO"</literal>);

}

errno = <literal type="number">0</literal>;

pos = lseek(fptr-&gt;fd, pos, whence);

if (pos &lt; <literal type="number">0</literal> &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

return OFFT2NUM(pos);

}

static VALUE

rb_io_syswrite(VALUE io, VALUE str)

{

VALUE tmp;

rb_io_t *fptr;

long n</argument>, <argument>len;

const char *ptr;

if (!RB_TYPE_P(str, T_STRING))

str = rb_obj_as_string(str);

io = GetWriteIO(io);

GetOpenFile(io, fptr);

rb_io_check_writable(fptr);

if (fptr-&gt;wbuf.len) {

rb_warn(<literal type="string">"syswrite for buffered IO"</literal>);

}

tmp = rb_str_tmp_frozen_acquire(str);

RSTRING_GETMEM(tmp, ptr, len);

n = rb_write_internal(fptr-&gt;fd, ptr, len);

if (n &lt; <literal type="number">0</literal>) rb_sys_fail_path(fptr-&gt;pathv);

rb_str_tmp_frozen_release(str, tmp);

return LONG2FIX(n);

}

static VALUE

rb_io_sysread(int argc, VALUE *argv, VALUE io)

{

VALUE len</argument>, <argument>str;

rb_io_t *fptr;

long n</argument>, <argument>ilen;

struct io_internal_read_struct iis;

int shrinkable;

rb_scan_args(argc, argv, <literal type="string">"11"</literal>, &amp;len, &amp;str);

ilen = NUM2LONG(len);

shrinkable = io_setstrbuf(&amp;str, ilen);

if (ilen == <literal type="number">0</literal>) return str;

GetOpenFile(io, fptr);

rb_io_check_byte_readable(fptr);

if (READ_DATA_BUFFERED(fptr)) {

rb_raise(rb_eIOError, <literal type="string">"sysread for buffered IO"</literal>);

}

rb_thread_wait_fd(fptr-&gt;fd);

rb_io_check_closed(fptr);

io_setstrbuf(&amp;str, ilen);

iis.fd = fptr-&gt;fd;

iis.nonblock = <literal type="number">1</literal>; 

iis.buf = RSTRING_PTR(str);

iis.capa = ilen;

n = read_internal_locktmp(str, &amp;iis);

if (n &lt; <literal type="number">0</literal>) {

rb_sys_fail_path(fptr-&gt;pathv);

}

io_set_read_length(str, n, shrinkable);

if (n == <literal type="number">0</literal> &amp;&amp; ilen &gt; <literal type="number">0</literal>) {

rb_eof_error();

}

return str;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PREAD</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PWRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>

struct prdwr_internal_arg {

int fd;

void *buf;

size_t count;

off_t offset;

};

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>

static VALUE

internal_pread_func(void *arg)

{

struct prdwr_internal_arg *p = arg;

return (VALUE)pread(p-&gt;fd, p-&gt;buf, p-&gt;count, p-&gt;offset);

}

static VALUE

pread_internal_call(VALUE arg)

{

struct prdwr_internal_arg *p = (struct prdwr_internal_arg *)arg;

return rb_thread_io_blocking_region(internal_pread_func, p, p-&gt;fd);

}

static VALUE

rb_io_pread(int argc, VALUE *argv, VALUE io)

{

VALUE len</argument>, <argument>offset</argument>, <argument>str;

rb_io_t *fptr;

ssize_t n;

struct prdwr_internal_arg arg;

int shrinkable;

rb_scan_args(argc, argv, <literal type="string">"21"</literal>, &amp;len, &amp;offset, &amp;str);

arg.count = NUM2SIZET(len);

arg.offset = NUM2OFFT(offset);

shrinkable = io_setstrbuf(&amp;str, (long)arg.count);

if (arg.count == <literal type="number">0</literal>) return str;

arg.buf = RSTRING_PTR(str);

GetOpenFile(io, fptr);

rb_io_check_byte_readable(fptr);

arg.fd = fptr-&gt;fd;

rb_io_check_closed(fptr);

rb_str_locktmp(str);

n = (ssize_t)rb_ensure(pread_internal_call, (VALUE)&amp;arg, rb_str_unlocktmp, str);

if (n &lt; <literal type="number">0</literal>) {

rb_sys_fail_path(fptr-&gt;pathv);

}

io_set_read_length(str, n, shrinkable);

if (n == <literal type="number">0</literal> &amp;&amp; arg.count &gt; <literal type="number">0</literal>) {

rb_eof_error();

}

return str;

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_io_pread</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PWRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>

static VALUE

internal_pwrite_func(void *ptr)

{

struct prdwr_internal_arg *arg = ptr;

return (VALUE)pwrite(arg-&gt;fd, arg-&gt;buf, arg-&gt;count, arg-&gt;offset);

}

static VALUE

rb_io_pwrite(VALUE io, VALUE str, VALUE offset)

{

rb_io_t *fptr;

ssize_t n;

struct prdwr_internal_arg arg;

VALUE tmp;

if (!RB_TYPE_P(str, T_STRING))

str = rb_obj_as_string(str);

arg.offset = NUM2OFFT(offset);

io = GetWriteIO(io);

GetOpenFile(io, fptr);

rb_io_check_writable(fptr);

arg.fd = fptr-&gt;fd;

tmp = rb_str_tmp_frozen_acquire(str);

arg.buf = RSTRING_PTR(tmp);

arg.count = (size_t)RSTRING_LEN(tmp);

n = (ssize_t)rb_thread_io_blocking_region(internal_pwrite_func, &amp;arg, fptr-&gt;fd);

if (n &lt; <literal type="number">0</literal>) rb_sys_fail_path(fptr-&gt;pathv);

rb_str_tmp_frozen_release(str, tmp);

return SSIZET2NUM(n);

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_io_pwrite</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

VALUE

rb_io_binmode(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

if (fptr-&gt;readconv)

rb_econv_binmode(fptr-&gt;readconv);

if (fptr-&gt;writeconv)

rb_econv_binmode(fptr-&gt;writeconv);

fptr-&gt;mode |= FMODE_BINMODE;

fptr-&gt;mode &amp;= ~FMODE_TEXTMODE;

fptr-&gt;writeconv_pre_ecflags &amp;= ~ECONV_NEWLINE_DECORATOR_MASK;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (!fptr-&gt;readconv) {

SET_BINARY_MODE_WITH_SEEK_CUR(fptr);

}

else {

setmode(fptr-&gt;fd, O_BINARY);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return io;

}

static void

io_ascii8bit_binmode(rb_io_t *fptr)

{

if (fptr-&gt;readconv) {

rb_econv_close(fptr-&gt;readconv);

fptr-&gt;readconv = NULL;

}

if (fptr-&gt;writeconv) {

rb_econv_close(fptr-&gt;writeconv);

fptr-&gt;writeconv = NULL;

}

fptr-&gt;mode |= FMODE_BINMODE;

fptr-&gt;mode &amp;= ~FMODE_TEXTMODE;

SET_BINARY_MODE_WITH_SEEK_CUR(fptr);

fptr-&gt;encs.enc = rb_ascii8bit_encoding();

fptr-&gt;encs.enc2 = NULL;

fptr-&gt;encs.ecflags = <literal type="number">0</literal>;

fptr-&gt;encs.ecopts = Qnil;

clear_codeconv(fptr);

}

VALUE

rb_io_ascii8bit_binmode(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

io_ascii8bit_binmode(fptr);

return io;

}

static VALUE

rb_io_binmode_m(VALUE io)

{

VALUE write_io;

rb_io_ascii8bit_binmode(io);

write_io = GetWriteIO(io);

if (write_io != io)

rb_io_ascii8bit_binmode(write_io);

return io;

}

static VALUE

rb_io_binmode_p(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

return fptr-&gt;mode &amp; FMODE_BINMODE ? Qtrue : Qfalse;

}

static const char*

rb_io_fmode_modestr(int fmode)

{

if (fmode &amp; FMODE_APPEND) {

if ((fmode &amp; FMODE_READWRITE) == FMODE_READWRITE) {

return MODE_BTMODE(<literal type="string">"a+"</literal>, <literal type="string">"ab+"</literal>, <literal type="string">"at+"</literal>);

}

return MODE_BTMODE(<literal type="string">"a"</literal>, <literal type="string">"ab"</literal>, <literal type="string">"at"</literal>);

}

switch (fmode &amp; FMODE_READWRITE) {

default:

rb_raise(rb_eArgError, <literal type="string">"invalid access fmode 0x%x"</literal>, fmode);

case FMODE_READABLE:

return MODE_BTMODE(<literal type="string">"r"</literal>, <literal type="string">"rb"</literal>, <literal type="string">"rt"</literal>);

case FMODE_WRITABLE:

return MODE_BTXMODE(<literal type="string">"w"</literal>, <literal type="string">"wb"</literal>, <literal type="string">"wt"</literal>, <literal type="string">"wx"</literal>, <literal type="string">"wbx"</literal>, <literal type="string">"wtx"</literal>);

case FMODE_READWRITE:

if (fmode &amp; FMODE_CREATE) {

return MODE_BTXMODE(<literal type="string">"w+"</literal>, <literal type="string">"wb+"</literal>, <literal type="string">"wt+"</literal>, <literal type="string">"w+x"</literal>, <literal type="string">"wb+x"</literal>, <literal type="string">"wt+x"</literal>);

}

return MODE_BTMODE(<literal type="string">"r+"</literal>, <literal type="string">"rb+"</literal>, <literal type="string">"rt+"</literal>);

}

}

static const char bom_prefix[] = <literal type="string">"bom|"</literal>;

static const char utf_prefix[] = <literal type="string">"utf-"</literal>;

enum {bom_prefix_len = (int)sizeof(bom_prefix) - <literal type="number">1</literal>};

enum {utf_prefix_len = (int)sizeof(utf_prefix) - <literal type="number">1</literal>};

static int

io_encname_bom_p(const char *name, long len)

{

return len &gt; bom_prefix_len &amp;&amp; STRNCASECMP(name, bom_prefix, bom_prefix_len) == <literal type="number">0</literal>;

}

int

rb_io_modestr_fmode(const char *modestr)

{

int fmode = <literal type="number">0</literal>;

const char *m = modestr</argument>, <argument>*p = NULL;

switch (*m++) {

case <literal type="char">'r'</literal>:

fmode |= FMODE_READABLE;

break;

case <literal type="char">'w'</literal>:

fmode |= FMODE_WRITABLE | FMODE_TRUNC | FMODE_CREATE;

break;

case <literal type="char">'a'</literal>:

fmode |= FMODE_WRITABLE | FMODE_APPEND | FMODE_CREATE;

break;

default:

error:

rb_raise(rb_eArgError, <literal type="string">"invalid access mode %s"</literal>, modestr);

}

while (*m) {

switch (*m++) {

case <literal type="char">'b'</literal>:

fmode |= FMODE_BINMODE;

break;

case <literal type="char">'t'</literal>:

fmode |= FMODE_TEXTMODE;

break;

case <literal type="char">'+'</literal>:

fmode |= FMODE_READWRITE;

break;

case <literal type="char">'x'</literal>:

if (modestr[<literal type="number">0</literal>] != <literal type="char">'w'</literal>)

goto error;

fmode |= FMODE_EXCL;

break;

default:

goto error;

case <literal type="char">':'</literal>:

p = strchr(m, <literal type="char">':'</literal>);

if (io_encname_bom_p(m, p ? (long)(p - m) : (long)strlen(m)))

fmode |= FMODE_SETENC_BY_BOM;

goto finished;

}

}

finished:

if ((fmode &amp; FMODE_BINMODE) &amp;&amp; (fmode &amp; FMODE_TEXTMODE))

goto error;

return fmode;

}

int

rb_io_oflags_fmode(int oflags)

{

int fmode = <literal type="number">0</literal>;

switch (oflags &amp; O_ACCMODE) {

case O_RDONLY:

fmode = FMODE_READABLE;

break;

case O_WRONLY:

fmode = FMODE_WRITABLE;

break;

case O_RDWR:

fmode = FMODE_READWRITE;

break;

}

if (oflags &amp; O_APPEND) {

fmode |= FMODE_APPEND;

}

if (oflags &amp; O_TRUNC) {

fmode |= FMODE_TRUNC;

}

if (oflags &amp; O_CREAT) {

fmode |= FMODE_CREATE;

}

if (oflags &amp; O_EXCL) {

fmode |= FMODE_EXCL;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (oflags &amp; O_BINARY) {

fmode |= FMODE_BINMODE;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return fmode;

}

static int

rb_io_fmode_oflags(int fmode)

{

int oflags = <literal type="number">0</literal>;

switch (fmode &amp; FMODE_READWRITE) {

case FMODE_READABLE:

oflags |= O_RDONLY;

break;

case FMODE_WRITABLE:

oflags |= O_WRONLY;

break;

case FMODE_READWRITE:

oflags |= O_RDWR;

break;

}

if (fmode &amp; FMODE_APPEND) {

oflags |= O_APPEND;

}

if (fmode &amp; FMODE_TRUNC) {

oflags |= O_TRUNC;

}

if (fmode &amp; FMODE_CREATE) {

oflags |= O_CREAT;

}

if (fmode &amp; FMODE_EXCL) {

oflags |= O_EXCL;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (fmode &amp; FMODE_BINMODE) {

oflags |= O_BINARY;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return oflags;

}

int

rb_io_modestr_oflags(const char *modestr)

{

return rb_io_fmode_oflags(rb_io_modestr_fmode(modestr));

}

static const char*

rb_io_oflags_modestr(int oflags)

{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_BINARY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((oflags &amp; O_BINARY) ? (b) : (a))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODE_BINARY</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(a)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

int accmode;

if (oflags &amp; O_EXCL) {

rb_raise(rb_eArgError, <literal type="string">"exclusive access mode is not supported"</literal>);

}

accmode = oflags &amp; (O_RDONLY|O_WRONLY|O_RDWR);

if (oflags &amp; O_APPEND) {

if (accmode == O_WRONLY) {

return MODE_BINARY(<literal type="string">"a"</literal>, <literal type="string">"ab"</literal>);

}

if (accmode == O_RDWR) {

return MODE_BINARY(<literal type="string">"a+"</literal>, <literal type="string">"ab+"</literal>);

}

}

switch (accmode) {

default:

rb_raise(rb_eArgError, <literal type="string">"invalid access oflags 0x%x"</literal>, oflags);

case O_RDONLY:

return MODE_BINARY(<literal type="string">"r"</literal>, <literal type="string">"rb"</literal>);

case O_WRONLY:

return MODE_BINARY(<literal type="string">"w"</literal>, <literal type="string">"wb"</literal>);

case O_RDWR:

if (oflags &amp; O_TRUNC) {

return MODE_BINARY(<literal type="string">"w+"</literal>, <literal type="string">"wb+"</literal>);

}

return MODE_BINARY(<literal type="string">"r+"</literal>, <literal type="string">"rb+"</literal>);

}

}

static void

rb_io_ext_int_to_encs(rb_encoding *ext, rb_encoding *intern, rb_encoding **enc, rb_encoding **enc2, int fmode)

{

int default_ext = <literal type="number">0</literal>;

if (ext == NULL) {

ext = rb_default_external_encoding();

default_ext = <literal type="number">1</literal>;

}

if (ext == rb_ascii8bit_encoding()) {

intern = NULL;

}

else if (intern == NULL) {

intern = rb_default_internal_encoding();

}

if (intern == NULL || intern == (rb_encoding *)Qnil ||

(!(fmode &amp; FMODE_SETENC_BY_BOM) &amp;&amp; (intern == ext))) {

*enc = (default_ext &amp;&amp; intern != ext) ? NULL : ext;

*enc2 = NULL;

}

else {

*enc = intern;

*enc2 = ext;

}

}

static void

unsupported_encoding(const char *name, rb_encoding *enc)

{

rb_enc_warn(enc, <literal type="string">"Unsupported encoding %s ignored"</literal>, name);

}

static void

parse_mode_enc(const char *estr, rb_encoding *estr_enc,

rb_encoding **enc_p, rb_encoding **enc2_p, int *fmode_p)

{

const char *p;

char encname[ENCODING_MAXNAMELEN+<literal type="number">1</literal>];

int idx</argument>, <argument>idx2;

int fmode = fmode_p ? *fmode_p : <literal type="number">0</literal>;

rb_encoding *ext_enc</argument>, <argument>*int_enc;

long len;

p = strrchr(estr, <literal type="char">':'</literal>);

len = p ? (p++ - estr) : (long)strlen(estr);

if ((fmode &amp; FMODE_SETENC_BY_BOM) || io_encname_bom_p(estr, len)) {

estr += bom_prefix_len;

len -= bom_prefix_len;

if (!STRNCASECMP(estr, utf_prefix, utf_prefix_len)) {

fmode |= FMODE_SETENC_BY_BOM;

}

else {

rb_enc_warn(estr_enc, <literal type="string">"BOM with non-UTF encoding %s is nonsense"</literal>, estr);

fmode &amp;= ~FMODE_SETENC_BY_BOM;

}

}

if (len == <literal type="number">0</literal> || len &gt; ENCODING_MAXNAMELEN) {

idx = -<literal type="number">1</literal>;

}

else {

if (p) {

memcpy(encname, estr, len);

encname[len] = <literal type="char">'\0'</literal>;

estr = encname;

}

idx = rb_enc_find_index(estr);

}

if (fmode_p) *fmode_p = fmode;

if (idx &gt;= <literal type="number">0</literal>)

ext_enc = rb_enc_from_index(idx);

else {

if (idx != -<literal type="number">2</literal>)

unsupported_encoding(estr, estr_enc);

ext_enc = NULL;

}

int_enc = NULL;

if (p) {

if (*p == <literal type="char">'-'</literal> &amp;&amp; *(p+<literal type="number">1</literal>) == <literal type="char">'\0'</literal>) {

int_enc = (rb_encoding *)Qnil;

}

else {

idx2 = rb_enc_find_index(p);

if (idx2 &lt; <literal type="number">0</literal>)

unsupported_encoding(p, estr_enc);

else if (!(fmode &amp; FMODE_SETENC_BY_BOM) &amp;&amp; (idx2 == idx)) {

int_enc = (rb_encoding *)Qnil;

}

else

int_enc = rb_enc_from_index(idx2);

}

}

rb_io_ext_int_to_encs(ext_enc, int_enc, enc_p, enc2_p, fmode);

}

int

rb_io_extract_encoding_option(VALUE opt, rb_encoding **enc_p, rb_encoding **enc2_p, int *fmode_p)

{

VALUE encoding=Qnil</argument>, <argument>extenc=Qundef</argument>, <argument>intenc=Qundef</argument>, <argument>tmp;

int extracted = <literal type="number">0</literal>;

rb_encoding *extencoding = NULL;

rb_encoding *intencoding = NULL;

if (!NIL_P(opt)) {

VALUE v;

v = rb_hash_lookup2(opt, sym_encoding, Qnil);

if (v != Qnil) encoding = v;

v = rb_hash_lookup2(opt, sym_extenc, Qundef);

if (v != Qnil) extenc = v;

v = rb_hash_lookup2(opt, sym_intenc, Qundef);

if (v != Qundef) intenc = v;

}

if ((extenc != Qundef || intenc != Qundef) &amp;&amp; !NIL_P(encoding)) {

if (!NIL_P(ruby_verbose)) {

int idx = rb_to_encoding_index(encoding);

if (idx &gt;= <literal type="number">0</literal>) encoding = rb_enc_from_encoding(rb_enc_from_index(idx));

rb_warn(<literal type="string">"Ignoring encoding parameter '%"</literal>PRIsVALUE<literal type="string">"': %s_encoding is used"</literal>,

encoding, extenc == Qundef ? <literal type="string">"internal"</literal> : <literal type="string">"external"</literal>);

}

encoding = Qnil;

}

if (extenc != Qundef &amp;&amp; !NIL_P(extenc)) {

extencoding = rb_to_encoding(extenc);

}

if (intenc != Qundef) {

if (NIL_P(intenc)) {

intencoding = (rb_encoding *)Qnil;

}

else if (!NIL_P(tmp = rb_check_string_type(intenc))) {

char *p = StringValueCStr(tmp);

if (*p == <literal type="char">'-'</literal> &amp;&amp; *(p+<literal type="number">1</literal>) == <literal type="char">'\0'</literal>) {

intencoding = (rb_encoding *)Qnil;

}

else {

intencoding = rb_to_encoding(intenc);

}

}

else {

intencoding = rb_to_encoding(intenc);

}

if (extencoding == intencoding) {

intencoding = (rb_encoding *)Qnil;

}

}

if (!NIL_P(encoding)) {

extracted = <literal type="number">1</literal>;

if (!NIL_P(tmp = rb_check_string_type(encoding))) {

parse_mode_enc(StringValueCStr(tmp), rb_enc_get(tmp),

enc_p, enc2_p, fmode_p);

}

else {

rb_io_ext_int_to_encs(rb_to_encoding(encoding), NULL, enc_p, enc2_p, <literal type="number">0</literal>);

}

}

else if (extenc != Qundef || intenc != Qundef) {

extracted = <literal type="number">1</literal>;

rb_io_ext_int_to_encs(extencoding, intencoding, enc_p, enc2_p, <literal type="number">0</literal>);

}

return extracted;

}

typedef struct rb_io_enc_t convconfig_t;

static void

validate_enc_binmode(int *fmode_p, int ecflags, rb_encoding *enc, rb_encoding *enc2)

{

int fmode = *fmode_p;

if ((fmode &amp; FMODE_READABLE) &amp;&amp;

!enc2 &amp;&amp;

!(fmode &amp; FMODE_BINMODE) &amp;&amp;

!rb_enc_asciicompat(enc ? enc : rb_default_external_encoding()))

rb_raise(rb_eArgError, <literal type="string">"ASCII incompatible encoding needs binmode"</literal>);

if ((fmode &amp; FMODE_BINMODE) &amp;&amp; (ecflags &amp; ECONV_NEWLINE_DECORATOR_MASK)) {

rb_raise(rb_eArgError, <literal type="string">"newline decorator with binary mode"</literal>);

}

if (!(fmode &amp; FMODE_BINMODE) &amp;&amp;

(DEFAULT_TEXTMODE || (ecflags &amp; ECONV_NEWLINE_DECORATOR_MASK))) {

fmode |= FMODE_TEXTMODE;

*fmode_p = fmode;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>DEFAULT_TEXTMODE</name></expr></cpp:if>

else if (!(ecflags &amp; ECONV_NEWLINE_DECORATOR_MASK)) {

fmode &amp;= ~FMODE_TEXTMODE;

*fmode_p = fmode;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

static void

extract_binmode(VALUE opthash, int *fmode)

{

if (!NIL_P(opthash)) {

VALUE v;

v = rb_hash_aref(opthash, sym_textmode);

if (!NIL_P(v)) {

if (*fmode &amp; FMODE_TEXTMODE)

rb_raise(rb_eArgError, <literal type="string">"textmode specified twice"</literal>);

if (*fmode &amp; FMODE_BINMODE)

rb_raise(rb_eArgError, <literal type="string">"both textmode and binmode specified"</literal>);

if (RTEST(v))

*fmode |= FMODE_TEXTMODE;

}

v = rb_hash_aref(opthash, sym_binmode);

if (!NIL_P(v)) {

if (*fmode &amp; FMODE_BINMODE)

rb_raise(rb_eArgError, <literal type="string">"binmode specified twice"</literal>);

if (*fmode &amp; FMODE_TEXTMODE)

rb_raise(rb_eArgError, <literal type="string">"both textmode and binmode specified"</literal>);

if (RTEST(v))

*fmode |= FMODE_BINMODE;

}

if ((*fmode &amp; FMODE_BINMODE) &amp;&amp; (*fmode &amp; FMODE_TEXTMODE))

rb_raise(rb_eArgError, <literal type="string">"both textmode and binmode specified"</literal>);

}

}

void

rb_io_extract_modeenc(VALUE *vmode_p, VALUE *vperm_p, VALUE opthash,

int *oflags_p, int *fmode_p, convconfig_t *convconfig_p)

{

VALUE vmode;

int oflags</argument>, <argument>fmode;

rb_encoding *enc</argument>, <argument>*enc2;

int ecflags;

VALUE ecopts;

int has_enc = <literal type="number">0</literal></argument>, <argument>has_vmode = <literal type="number">0</literal>;

VALUE intmode;

vmode = *vmode_p;

rb_io_ext_int_to_encs(NULL, NULL, &amp;enc, &amp;enc2, <literal type="number">0</literal>);

vmode_handle:

if (NIL_P(vmode)) {

fmode = FMODE_READABLE;

oflags = O_RDONLY;

}

else if (!NIL_P(intmode = rb_check_to_integer(vmode, <literal type="string">"to_int"</literal>))) {

vmode = intmode;

oflags = NUM2INT(intmode);

fmode = rb_io_oflags_fmode(oflags);

}

else {

const char *p;

SafeStringValue(vmode);

p = StringValueCStr(vmode);

fmode = rb_io_modestr_fmode(p);

oflags = rb_io_fmode_oflags(fmode);

p = strchr(p, <literal type="char">':'</literal>);

if (p) {

has_enc = <literal type="number">1</literal>;

parse_mode_enc(p+<literal type="number">1</literal>, rb_enc_get(vmode), &amp;enc, &amp;enc2, &amp;fmode);

}

else {

rb_encoding *e;

e = (fmode &amp; FMODE_BINMODE) ? rb_ascii8bit_encoding() : NULL;

rb_io_ext_int_to_encs(e, NULL, &amp;enc, &amp;enc2, fmode);

}

}

if (NIL_P(opthash)) {

ecflags = (fmode &amp; FMODE_READABLE) ?

MODE_BTMODE(ECONV_DEFAULT_NEWLINE_DECORATOR,

<literal type="number">0</literal>, ECONV_UNIVERSAL_NEWLINE_DECORATOR) : <literal type="number">0</literal>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEXTMODE_NEWLINE_DECORATOR_ON_WRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
ecflags |= (fmode &amp; FMODE_WRITABLE) ?

MODE_BTMODE(TEXTMODE_NEWLINE_DECORATOR_ON_WRITE,

<literal type="number">0</literal>, TEXTMODE_NEWLINE_DECORATOR_ON_WRITE) : <literal type="number">0</literal>;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(enc2, ecflags);

ecopts = Qnil;

if (fmode &amp; FMODE_BINMODE) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
oflags |= O_BINARY;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (!has_enc)

rb_io_ext_int_to_encs(rb_ascii8bit_encoding(), NULL, &amp;enc, &amp;enc2, fmode);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_TEXTMODE</name></expr></cpp:if>

else if (NIL_P(vmode)) {

fmode |= DEFAULT_TEXTMODE;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

else {

VALUE v;

if (!has_vmode) {

v = rb_hash_aref(opthash, sym_mode);

if (!NIL_P(v)) {

if (!NIL_P(vmode)) {

rb_raise(rb_eArgError, <literal type="string">"mode specified twice"</literal>);

}

has_vmode = <literal type="number">1</literal>;

vmode = v;

goto vmode_handle;

}

}

v = rb_hash_aref(opthash, sym_flags);

if (!NIL_P(v)) {

v = rb_to_int(v);

oflags |= NUM2INT(v);

vmode = INT2NUM(oflags);

fmode = rb_io_oflags_fmode(oflags);

}

extract_binmode(opthash, &amp;fmode);

if (fmode &amp; FMODE_BINMODE) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
oflags |= O_BINARY;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (!has_enc)

rb_io_ext_int_to_encs(rb_ascii8bit_encoding(), NULL, &amp;enc, &amp;enc2, fmode);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_TEXTMODE</name></expr></cpp:if>

else if (NIL_P(vmode)) {

fmode |= DEFAULT_TEXTMODE;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

v = rb_hash_aref(opthash, sym_perm);

if (!NIL_P(v)) {

if (vperm_p) {

if (!NIL_P(*vperm_p)) {

rb_raise(rb_eArgError, <literal type="string">"perm specified twice"</literal>);

}

*vperm_p = v;

}

else {

}

}

ecflags = (fmode &amp; FMODE_READABLE) ?

MODE_BTMODE(ECONV_DEFAULT_NEWLINE_DECORATOR,

<literal type="number">0</literal>, ECONV_UNIVERSAL_NEWLINE_DECORATOR) : <literal type="number">0</literal>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEXTMODE_NEWLINE_DECORATOR_ON_WRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
ecflags |= (fmode &amp; FMODE_WRITABLE) ?

MODE_BTMODE(TEXTMODE_NEWLINE_DECORATOR_ON_WRITE,

<literal type="number">0</literal>, TEXTMODE_NEWLINE_DECORATOR_ON_WRITE) : <literal type="number">0</literal>;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (rb_io_extract_encoding_option(opthash, &amp;enc, &amp;enc2, &amp;fmode)) {

if (has_enc) {

rb_raise(rb_eArgError, <literal type="string">"encoding specified twice"</literal>);

}

}

SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(enc2, ecflags);

ecflags = rb_econv_prepare_options(opthash, &amp;ecopts, ecflags);

}

validate_enc_binmode(&amp;fmode, ecflags, enc, enc2);

*vmode_p = vmode;

*oflags_p = oflags;

*fmode_p = fmode;

convconfig_p-&gt;enc = enc;

convconfig_p-&gt;enc2 = enc2;

convconfig_p-&gt;ecflags = ecflags;

convconfig_p-&gt;ecopts = ecopts;

}

struct sysopen_struct {

VALUE fname;

int oflags;

mode_t perm;

};

static void *

sysopen_func(void *ptr)

{

const struct sysopen_struct *data = ptr;

const char *fname = RSTRING_PTR(data-&gt;fname);

return (void *)(VALUE)rb_cloexec_open(fname, data-&gt;oflags, data-&gt;perm);

}

static inline int

rb_sysopen_internal(struct sysopen_struct *data)

{

int fd;

fd = (int)(VALUE)rb_thread_call_without_gvl(sysopen_func, data, RUBY_UBF_IO, <literal type="number">0</literal>);

if (<literal type="number">0</literal> &lt;= fd)

rb_update_max_fd(fd);

return fd;

}

static int

rb_sysopen(VALUE fname, int oflags, mode_t perm)

{

int fd;

struct sysopen_struct data;

data.fname = rb_str_encode_ospath(fname);

StringValueCStr(data.fname);

data.oflags = oflags;

data.perm = perm;

fd = rb_sysopen_internal(&amp;data);

if (fd &lt; <literal type="number">0</literal>) {

int e = errno;

if (rb_gc_for_fd(e)) {

fd = rb_sysopen_internal(&amp;data);

}

if (fd &lt; <literal type="number">0</literal>) {

rb_syserr_fail_path(e, fname);

}

}

return fd;

}

FILE *

rb_fdopen(int fd, const char *modestr)

{

FILE *file;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if>

errno = <literal type="number">0</literal>;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

file = fdopen(fd, modestr);

if (!file) {

int e = errno;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if>

if (e == <literal type="number">0</literal>) {

rb_gc();

errno = <literal type="number">0</literal>;

file = fdopen(fd, modestr);

}

else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (rb_gc_for_fd(e)) {

file = fdopen(fd, modestr);

}

if (!file) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (e == <literal type="number">0</literal>) e = EINVAL;

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:elif>

if (e == <literal type="number">0</literal>) e = EMFILE;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_syserr_fail(e, <literal type="number">0</literal>);

}

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SETVBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (setvbuf(file, NULL, _IOFBF, <literal type="number">0</literal>) != <literal type="number">0</literal>)

rb_warn(<literal type="string">"setvbuf() can't be honoured (fd=%d)"</literal>, fd);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return file;

}

static int

io_check_tty(rb_io_t *fptr)

{

int t = isatty(fptr-&gt;fd);

if (t)

fptr-&gt;mode |= FMODE_TTY|FMODE_DUPLEX;

return t;

}

static VALUE rb_io_internal_encoding(VALUE);

static void io_encoding_set(rb_io_t *, VALUE, VALUE, VALUE);

static int

io_strip_bom(VALUE io)

{

VALUE b1</argument>, <argument>b2</argument>, <argument>b3</argument>, <argument>b4;

rb_io_t *fptr;

GetOpenFile(io, fptr);

if (!(fptr-&gt;mode &amp; FMODE_READABLE)) return <literal type="number">0</literal>;

if (NIL_P(b1 = rb_io_getbyte(io))) return <literal type="number">0</literal>;

switch (b1) {

case INT2FIX(<literal type="number">0xEF</literal>):

if (NIL_P(b2 = rb_io_getbyte(io))) break;

if (b2 == INT2FIX(<literal type="number">0xBB</literal>) &amp;&amp; !NIL_P(b3 = rb_io_getbyte(io))) {

if (b3 == INT2FIX(<literal type="number">0xBF</literal>)) {

return rb_utf8_encindex();

}

rb_io_ungetbyte(io, b3);

}

rb_io_ungetbyte(io, b2);

break;

case INT2FIX(<literal type="number">0xFE</literal>):

if (NIL_P(b2 = rb_io_getbyte(io))) break;

if (b2 == INT2FIX(<literal type="number">0xFF</literal>)) {

return ENCINDEX_UTF_16BE;

}

rb_io_ungetbyte(io, b2);

break;

case INT2FIX(<literal type="number">0xFF</literal>):

if (NIL_P(b2 = rb_io_getbyte(io))) break;

if (b2 == INT2FIX(<literal type="number">0xFE</literal>)) {

b3 = rb_io_getbyte(io);

if (b3 == INT2FIX(<literal type="number">0</literal>) &amp;&amp; !NIL_P(b4 = rb_io_getbyte(io))) {

if (b4 == INT2FIX(<literal type="number">0</literal>)) {

return ENCINDEX_UTF_32LE;

}

rb_io_ungetbyte(io, b4);

}

rb_io_ungetbyte(io, b3);

return ENCINDEX_UTF_16LE;

}

rb_io_ungetbyte(io, b2);

break;

case INT2FIX(<literal type="number">0</literal>):

if (NIL_P(b2 = rb_io_getbyte(io))) break;

if (b2 == INT2FIX(<literal type="number">0</literal>) &amp;&amp; !NIL_P(b3 = rb_io_getbyte(io))) {

if (b3 == INT2FIX(<literal type="number">0xFE</literal>) &amp;&amp; !NIL_P(b4 = rb_io_getbyte(io))) {

if (b4 == INT2FIX(<literal type="number">0xFF</literal>)) {

return ENCINDEX_UTF_32BE;

}

rb_io_ungetbyte(io, b4);

}

rb_io_ungetbyte(io, b3);

}

rb_io_ungetbyte(io, b2);

break;

}

rb_io_ungetbyte(io, b1);

return <literal type="number">0</literal>;

}

static rb_encoding *

io_set_encoding_by_bom(VALUE io)

{

int idx = io_strip_bom(io);

rb_io_t *fptr;

rb_encoding *extenc = NULL;

GetOpenFile(io, fptr);

if (idx) {

extenc = rb_enc_from_index(idx);

io_encoding_set(fptr, rb_enc_from_encoding(extenc),

rb_io_internal_encoding(io), Qnil);

}

else {

fptr-&gt;encs.enc2 = NULL;

}

return extenc;

}

static VALUE

rb_file_open_generic(VALUE io, VALUE filename, int oflags, int fmode,

const convconfig_t *convconfig, mode_t perm)

{

VALUE pathv;

rb_io_t *fptr;

convconfig_t cc;

if (!convconfig) {

rb_io_ext_int_to_encs(NULL, NULL, &amp;cc.enc, &amp;cc.enc2, fmode);

cc.ecflags = <literal type="number">0</literal>;

cc.ecopts = Qnil;

convconfig = &amp;cc;

}

validate_enc_binmode(&amp;fmode, convconfig-&gt;ecflags,

convconfig-&gt;enc, convconfig-&gt;enc2);

MakeOpenFile(io, fptr);

fptr-&gt;mode = fmode;

fptr-&gt;encs = *convconfig;

pathv = rb_str_new_frozen(filename);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_TMPFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (!(oflags &amp; O_TMPFILE)) {

fptr-&gt;pathv = pathv;

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

fptr-&gt;pathv = pathv;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

fptr-&gt;fd = rb_sysopen(pathv, oflags, perm);

io_check_tty(fptr);

if (fmode &amp; FMODE_SETENC_BY_BOM) io_set_encoding_by_bom(io);

return io;

}

static VALUE

rb_file_open_internal(VALUE io, VALUE filename, const char *modestr)

{

int fmode = rb_io_modestr_fmode(modestr);

const char *p = strchr(modestr, <literal type="char">':'</literal>);

convconfig_t convconfig;

if (p) {

parse_mode_enc(p+<literal type="number">1</literal>, rb_usascii_encoding(),

&amp;convconfig.enc, &amp;convconfig.enc2, &amp;fmode);

convconfig.ecflags = <literal type="number">0</literal>;

convconfig.ecopts = Qnil;

}

else {

rb_encoding *e;

e = (fmode &amp; FMODE_BINMODE) ? rb_ascii8bit_encoding() : NULL;

rb_io_ext_int_to_encs(e, NULL, &amp;convconfig.enc, &amp;convconfig.enc2, fmode);

convconfig.ecflags = <literal type="number">0</literal>;

convconfig.ecopts = Qnil;

}

return rb_file_open_generic(io, filename,

rb_io_fmode_oflags(fmode),

fmode,

&amp;convconfig,

<literal type="number">0666</literal>);

}

VALUE

rb_file_open_str(VALUE fname, const char *modestr)

{

FilePathValue(fname);

return rb_file_open_internal(io_alloc(rb_cFile), fname, modestr);

}

VALUE

rb_file_open(const char *fname, const char *modestr)

{

return rb_file_open_internal(io_alloc(rb_cFile), rb_str_new_cstr(fname), modestr);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

static struct pipe_list {

rb_io_t *fptr;

struct pipe_list *next;

} *pipe_list;

static void

pipe_add_fptr(rb_io_t *fptr)

{

struct pipe_list *list;

list = ALLOC(struct pipe_list);

list-&gt;fptr = fptr;

list-&gt;next = pipe_list;

pipe_list = list;

}

static void

pipe_del_fptr(rb_io_t *fptr)

{

struct pipe_list **prev = &amp;pipe_list;

struct pipe_list *tmp;

while ((tmp = *prev) != <literal type="number">0</literal>) {

if (tmp-&gt;fptr == fptr) {

*prev = tmp-&gt;next;

free(tmp);

return;

}

prev = &amp;tmp-&gt;next;

}

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

static void

pipe_atexit(void)

{

struct pipe_list *list = pipe_list;

struct pipe_list *tmp;

while (list) {

tmp = list-&gt;next;

rb_io_fptr_finalize(list-&gt;fptr);

list = tmp;

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static void

pipe_finalize(rb_io_t *fptr, int noraise)

{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

int status = <literal type="number">0</literal>;

if (fptr-&gt;stdio_file) {

status = pclose(fptr-&gt;stdio_file);

}

fptr-&gt;fd = -<literal type="number">1</literal>;

fptr-&gt;stdio_file = <literal type="number">0</literal>;

rb_last_status_set(status, fptr-&gt;pid);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

fptr_finalize(fptr, noraise);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

pipe_del_fptr(fptr);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static void

fptr_copy_finalizer(rb_io_t *fptr, const rb_io_t *orig)

{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

void (*const old_finalize)(struct rb_io_t*,int) = fptr-&gt;finalize;

if (old_finalize == orig-&gt;finalize) return;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

fptr-&gt;finalize = orig-&gt;finalize;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

if (old_finalize != pipe_finalize) {

struct pipe_list *list;

for (list = pipe_list; list; list = list-&gt;next) {

if (list-&gt;fptr == fptr) break;

}

if (!list) pipe_add_fptr(fptr);

}

else {

pipe_del_fptr(fptr);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

void

rb_io_synchronized(rb_io_t *fptr)

{

rb_io_check_initialized(fptr);

fptr-&gt;mode |= FMODE_SYNC;

}

void

rb_io_unbuffered(rb_io_t *fptr)

{

rb_io_synchronized(fptr);

}

int

rb_pipe(int *pipes)

{

int ret;

ret = rb_cloexec_pipe(pipes);

if (ret &lt; <literal type="number">0</literal>) {

if (rb_gc_for_fd(errno)) {

ret = rb_cloexec_pipe(pipes);

}

}

if (ret == <literal type="number">0</literal>) {

rb_update_max_fd(pipes[<literal type="number">0</literal>]);

rb_update_max_fd(pipes[<literal type="number">1</literal>]);

}

return ret;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_SPAWNV</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spawnv</name><parameter_list>(<parameter><type><name>mode</name></type></parameter>, <parameter><type><name>cmd</name></type></parameter>, <parameter><type><name>args</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_uaspawn((mode), (cmd), (args))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>spawn</name><parameter_list>(<parameter><type><name>mode</name></type></parameter>, <parameter><type><name>cmd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_uspawn((mode), (cmd), 0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>

struct popen_arg {

VALUE execarg_obj;

struct rb_execarg *eargp;

int modef;

int pair[<literal type="number">2</literal>];

int write_pair[<literal type="number">2</literal>];

};

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
static void

popen_redirect(struct popen_arg *p)

{

if ((p-&gt;modef &amp; FMODE_READABLE) &amp;&amp; (p-&gt;modef &amp; FMODE_WRITABLE)) {

close(p-&gt;write_pair[<literal type="number">1</literal>]);

if (p-&gt;write_pair[<literal type="number">0</literal>] != <literal type="number">0</literal>) {

dup2(p-&gt;write_pair[<literal type="number">0</literal>], <literal type="number">0</literal>);

close(p-&gt;write_pair[<literal type="number">0</literal>]);

}

close(p-&gt;pair[<literal type="number">0</literal>]);

if (p-&gt;pair[<literal type="number">1</literal>] != <literal type="number">1</literal>) {

dup2(p-&gt;pair[<literal type="number">1</literal>], <literal type="number">1</literal>);

close(p-&gt;pair[<literal type="number">1</literal>]);

}

}

else if (p-&gt;modef &amp; FMODE_READABLE) {

close(p-&gt;pair[<literal type="number">0</literal>]);

if (p-&gt;pair[<literal type="number">1</literal>] != <literal type="number">1</literal>) {

dup2(p-&gt;pair[<literal type="number">1</literal>], <literal type="number">1</literal>);

close(p-&gt;pair[<literal type="number">1</literal>]);

}

}

else {

close(p-&gt;pair[<literal type="number">1</literal>]);

if (p-&gt;pair[<literal type="number">0</literal>] != <literal type="number">0</literal>) {

dup2(p-&gt;pair[<literal type="number">0</literal>], <literal type="number">0</literal>);

close(p-&gt;pair[<literal type="number">0</literal>]);

}

}

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>

static int

linux_get_maxfd(void)

{

int fd;

char buf[<literal type="number">4096</literal>]</argument>, <argument>*p</argument>, <argument>*np</argument>, <argument>*e;

ssize_t ss;

fd = rb_cloexec_open(<literal type="string">"/proc/self/status"</literal>, O_RDONLY|O_NOCTTY, <literal type="number">0</literal>);

if (fd &lt; <literal type="number">0</literal>) return fd;

ss = read(fd, buf, sizeof(buf));

if (ss &lt; <literal type="number">0</literal>) goto err;

p = buf;

e = buf + ss;

while ((int)sizeof(<literal type="string">"FDSize:\t0\n"</literal>)-<literal type="number">1</literal> &lt;= e-p &amp;&amp;

(np = memchr(p, <literal type="char">'\n'</literal>, e-p)) != NULL) {

if (memcmp(p, <literal type="string">"FDSize:"</literal>, sizeof(<literal type="string">"FDSize:"</literal>)-<literal type="number">1</literal>) == <literal type="number">0</literal>) {

int fdsize;

p += sizeof(<literal type="string">"FDSize:"</literal>)-<literal type="number">1</literal>;

*np = <literal type="char">'\0'</literal>;

fdsize = (int)ruby_strtoul(p, (char **)NULL, <literal type="number">10</literal>);

close(fd);

return fdsize;

}

p = np+<literal type="number">1</literal>;

}

err:

close(fd);

return (int)ss;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

void

rb_close_before_exec(int lowfd, int maxhint, VALUE noclose_fds)

{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_SETFD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

int fd</argument>, <argument>ret;

int max = (int)max_file_descriptor;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_MAXFD</name></expr></argument>)</argument_list></call></expr></cpp:if>
ret = fcntl(<literal type="number">0</literal>, F_MAXFD); 

if (ret != -<literal type="number">1</literal>)

maxhint = max = ret;

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:elif>

ret = linux_get_maxfd();

if (maxhint &lt; ret)

maxhint = ret;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (max &lt; maxhint)

max = maxhint;

for (fd = lowfd; fd &lt;= max; fd++) {

if (!NIL_P(noclose_fds) &amp;&amp;

RTEST(rb_hash_lookup(noclose_fds, INT2FIX(fd)))) 

continue;

ret = fcntl(fd, F_GETFD); 

if (ret != -<literal type="number">1</literal> &amp;&amp; !(ret &amp; FD_CLOEXEC)) {

fcntl(fd, F_SETFD, ret|FD_CLOEXEC); 

}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONTIGUOUS_CLOSED_FDS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

if (ret != -<literal type="number">1</literal>) {

if (max &lt; fd + CONTIGUOUS_CLOSED_FDS)

max = fd + CONTIGUOUS_CLOSED_FDS;

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

static int

popen_exec(void *pp, char *errmsg, size_t errmsg_len)

{

struct popen_arg *p = (struct popen_arg*)pp;

return rb_exec_async_signal_safe(p-&gt;eargp, errmsg, errmsg_len);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>

static VALUE

rb_execarg_fixup_v(VALUE execarg_obj)

{

rb_execarg_parent_start(execarg_obj);

return Qnil;

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

char *rb_execarg_commandline(const struct rb_execarg *eargp, VALUE *prog);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static VALUE

pipe_open(VALUE execarg_obj, const char *modestr, int fmode,

const convconfig_t *convconfig)

{

struct rb_execarg *eargp = NIL_P(execarg_obj) ? NULL : rb_execarg_get(execarg_obj);

VALUE prog = eargp ? (eargp-&gt;use_shell ? eargp-&gt;invoke.sh.shell_script : eargp-&gt;invoke.cmd.command_name) : Qfalse ;

rb_pid_t pid = <literal type="number">0</literal>;

rb_io_t *fptr;

VALUE port;

rb_io_t *write_fptr;

VALUE write_port;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

int status;

char errmsg[<literal type="number">80</literal>] = { <literal type="char">'\0'</literal> };

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>

int state;

struct popen_arg arg;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

int e = <literal type="number">0</literal>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNVE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_SPAWN</name><parameter_list>(<parameter><type><name>cmd</name></type></parameter>, <parameter><type><name>args</name></type></parameter>, <parameter><type><name>envp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((args) ? spawnve(P_NOWAIT, (cmd), (args), (envp)) : spawne(P_NOWAIT, (cmd), (envp)))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_SPAWN</name><parameter_list>(<parameter><type><name>cmd</name></type></parameter>, <parameter><type><name>args</name></type></parameter>, <parameter><type><name>envp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((args) ? spawnv(P_NOWAIT, (cmd), (args)) : spawn(P_NOWAIT, (cmd)))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

char **args = NULL;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNVE</name></expr></argument>)</argument_list></call></expr></cpp:if>

char **envp = NULL;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

struct rb_execarg sarg</argument>, <argument>*sargp = &amp;sarg;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

FILE *fp = <literal type="number">0</literal>;

int fd = -<literal type="number">1</literal>;

int write_fd = -<literal type="number">1</literal>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

const char *cmd = <literal type="number">0</literal>;

if (prog)

cmd = StringValueCStr(prog);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNV</name></expr></argument>)</argument_list></call></expr></cpp:if>

arg.execarg_obj = execarg_obj;

arg.eargp = eargp;

arg.modef = fmode;

arg.pair[<literal type="number">0</literal>] = arg.pair[<literal type="number">1</literal>] = -<literal type="number">1</literal>;

arg.write_pair[<literal type="number">0</literal>] = arg.write_pair[<literal type="number">1</literal>] = -<literal type="number">1</literal>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

if (eargp &amp;&amp; !eargp-&gt;use_shell) {

args = ARGVSTR2ARGV(eargp-&gt;invoke.cmd.argv_str);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

switch (fmode &amp; (FMODE_READABLE|FMODE_WRITABLE)) {

case FMODE_READABLE|FMODE_WRITABLE:

if (rb_pipe(arg.write_pair) &lt; <literal type="number">0</literal>)

rb_sys_fail_str(prog);

if (rb_pipe(arg.pair) &lt; <literal type="number">0</literal>) {

e = errno;

close(arg.write_pair[<literal type="number">0</literal>]);

close(arg.write_pair[<literal type="number">1</literal>]);

rb_syserr_fail_str(e, prog);

}

if (eargp) {

rb_execarg_addopt(execarg_obj, INT2FIX(<literal type="number">0</literal>), INT2FIX(arg.write_pair[<literal type="number">0</literal>]));

rb_execarg_addopt(execarg_obj, INT2FIX(<literal type="number">1</literal>), INT2FIX(arg.pair[<literal type="number">1</literal>]));

}

break;

case FMODE_READABLE:

if (rb_pipe(arg.pair) &lt; <literal type="number">0</literal>)

rb_sys_fail_str(prog);

if (eargp)

rb_execarg_addopt(execarg_obj, INT2FIX(<literal type="number">1</literal>), INT2FIX(arg.pair[<literal type="number">1</literal>]));

break;

case FMODE_WRITABLE:

if (rb_pipe(arg.pair) &lt; <literal type="number">0</literal>)

rb_sys_fail_str(prog);

if (eargp)

rb_execarg_addopt(execarg_obj, INT2FIX(<literal type="number">0</literal>), INT2FIX(arg.pair[<literal type="number">0</literal>]));

break;

default:

rb_sys_fail_str(prog);

}

if (!NIL_P(execarg_obj)) {

rb_protect(rb_execarg_fixup_v, execarg_obj, &amp;state);

if (state) {

if (<literal type="number">0</literal> &lt;= arg.write_pair[<literal type="number">0</literal>]) close(arg.write_pair[<literal type="number">0</literal>]);

if (<literal type="number">0</literal> &lt;= arg.write_pair[<literal type="number">1</literal>]) close(arg.write_pair[<literal type="number">1</literal>]);

if (<literal type="number">0</literal> &lt;= arg.pair[<literal type="number">0</literal>]) close(arg.pair[<literal type="number">0</literal>]);

if (<literal type="number">0</literal> &lt;= arg.pair[<literal type="number">1</literal>]) close(arg.pair[<literal type="number">1</literal>]);

rb_execarg_parent_end(execarg_obj);

rb_jump_tag(state);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

pid = rb_fork_async_signal_safe(&amp;status, popen_exec, &amp;arg, arg.eargp-&gt;redirect_fds, errmsg, sizeof(errmsg));

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

rb_execarg_run_options(eargp, sargp, NULL, <literal type="number">0</literal>);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SPAWNVE</name></expr></argument>)</argument_list></call></expr></cpp:if>

if (eargp-&gt;envp_str) envp = (char **)RSTRING_PTR(eargp-&gt;envp_str);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

while ((pid = DO_SPAWN(cmd, args, envp)) &lt; <literal type="number">0</literal>) {

switch (e = errno) {

case EAGAIN:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name></expr></cpp:if>

case EWOULDBLOCK:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_thread_sleep(<literal type="number">1</literal>);

continue;

}

break;

}

if (eargp)

rb_execarg_run_options(sargp, NULL, NULL, <literal type="number">0</literal>);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_execarg_parent_end(execarg_obj);

}

else {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

pid = rb_fork_ruby(&amp;status);

if (pid == <literal type="number">0</literal>) { 

rb_thread_atfork();

popen_redirect(&amp;arg);

rb_io_synchronized(RFILE(orig_stdout)-&gt;fptr);

rb_io_synchronized(RFILE(orig_stderr)-&gt;fptr);

return Qnil;

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

rb_notimplement();

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

if (pid &lt; <literal type="number">0</literal>) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

e = errno;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

close(arg.pair[<literal type="number">0</literal>]);

close(arg.pair[<literal type="number">1</literal>]);

if ((fmode &amp; (FMODE_READABLE|FMODE_WRITABLE)) == (FMODE_READABLE|FMODE_WRITABLE)) {

close(arg.write_pair[<literal type="number">0</literal>]);

close(arg.write_pair[<literal type="number">1</literal>]);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

if (errmsg[<literal type="number">0</literal>])

rb_syserr_fail(e, errmsg);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_syserr_fail_str(e, prog);

}

if ((fmode &amp; FMODE_READABLE) &amp;&amp; (fmode &amp; FMODE_WRITABLE)) {

close(arg.pair[<literal type="number">1</literal>]);

fd = arg.pair[<literal type="number">0</literal>];

close(arg.write_pair[<literal type="number">0</literal>]);

write_fd = arg.write_pair[<literal type="number">1</literal>];

}

else if (fmode &amp; FMODE_READABLE) {

close(arg.pair[<literal type="number">1</literal>]);

fd = arg.pair[<literal type="number">0</literal>];

}

else {

close(arg.pair[<literal type="number">0</literal>]);

fd = arg.pair[<literal type="number">1</literal>];

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

cmd = rb_execarg_commandline(eargp, &amp;prog);

if (!NIL_P(execarg_obj)) {

rb_execarg_parent_start(execarg_obj);

rb_execarg_run_options(eargp, sargp, NULL, <literal type="number">0</literal>);

}

fp = popen(cmd, modestr);

e = errno;

if (eargp) {

rb_execarg_parent_end(execarg_obj);

rb_execarg_run_options(sargp, NULL, NULL, <literal type="number">0</literal>);

}

if (!fp) rb_syserr_fail_path(e, prog);

fd = fileno(fp);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

port = io_alloc(rb_cIO);

MakeOpenFile(port, fptr);

fptr-&gt;fd = fd;

fptr-&gt;stdio_file = fp;

fptr-&gt;mode = fmode | FMODE_SYNC|FMODE_DUPLEX;

if (convconfig) {

fptr-&gt;encs = *convconfig;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_TEST_CRLF_ENVIRONMENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

if (fptr-&gt;encs.ecflags &amp; ECONV_DEFAULT_NEWLINE_DECORATOR) {

fptr-&gt;encs.ecflags |= ECONV_UNIVERSAL_NEWLINE_DECORATOR;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

else {

if (NEED_NEWLINE_DECORATOR_ON_READ(fptr)) {

fptr-&gt;encs.ecflags |= ECONV_UNIVERSAL_NEWLINE_DECORATOR;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEXTMODE_NEWLINE_DECORATOR_ON_WRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (NEED_NEWLINE_DECORATOR_ON_WRITE(fptr)) {

fptr-&gt;encs.ecflags |= TEXTMODE_NEWLINE_DECORATOR_ON_WRITE;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

fptr-&gt;pid = pid;

if (<literal type="number">0</literal> &lt;= write_fd) {

write_port = io_alloc(rb_cIO);

MakeOpenFile(write_port, write_fptr);

write_fptr-&gt;fd = write_fd;

write_fptr-&gt;mode = (fmode &amp; ~FMODE_READABLE)| FMODE_SYNC|FMODE_DUPLEX;

fptr-&gt;mode &amp;= ~FMODE_WRITABLE;

fptr-&gt;tied_io_for_writing = write_port;

rb_ivar_set(port, rb_intern(<literal type="string">"@tied_io_for_writing"</literal>), write_port);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

fptr-&gt;finalize = pipe_finalize;

pipe_add_fptr(fptr);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return port;

}

static int

is_popen_fork(VALUE prog)

{

if (RSTRING_LEN(prog) == <literal type="number">1</literal> &amp;&amp; RSTRING_PTR(prog)[<literal type="number">0</literal>] == <literal type="char">'-'</literal>) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>

rb_raise(rb_eNotImpError,

<literal type="string">"fork() function is unimplemented on this machine"</literal>);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

return TRUE;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

return FALSE;

}

static VALUE

pipe_open_s(VALUE prog, const char *modestr, int fmode,

const convconfig_t *convconfig)

{

int argc = <literal type="number">1</literal>;

VALUE *argv = &amp;prog;

VALUE execarg_obj = Qnil;

if (!is_popen_fork(prog))

execarg_obj = rb_execarg_new(argc, argv, TRUE, FALSE);

return pipe_open(execarg_obj, modestr, fmode, convconfig);

}

static VALUE

pipe_close(VALUE io)

{

rb_io_t *fptr = io_close_fptr(io);

if (fptr) {

fptr_waitpid(fptr, rb_thread_to_be_killed(rb_thread_current()));

}

return Qnil;

}

static VALUE

rb_io_s_popen(int argc, VALUE *argv, VALUE klass)

{

const char *modestr;

VALUE pname</argument>, <argument>pmode = Qnil</argument>, <argument>port</argument>, <argument>tmp</argument>, <argument>opt = Qnil</argument>, <argument>env = Qnil</argument>, <argument>execarg_obj = Qnil;

int oflags</argument>, <argument>fmode;

convconfig_t convconfig;

if (argc &gt; <literal type="number">1</literal> &amp;&amp; !NIL_P(opt = rb_check_hash_type(argv[argc-<literal type="number">1</literal>]))) --argc;

if (argc &gt; <literal type="number">1</literal> &amp;&amp; !NIL_P(env = rb_check_hash_type(argv[<literal type="number">0</literal>]))) --argc</argument>, <argument>++argv;

switch (argc) {

case <literal type="number">2</literal>:

pmode = argv[<literal type="number">1</literal>];

case <literal type="number">1</literal>:

pname = argv[<literal type="number">0</literal>];

break;

default:

{

int ex = !NIL_P(opt);

rb_error_arity(argc + ex, <literal type="number">1</literal> + ex, <literal type="number">2</literal> + ex);

}

}

tmp = rb_check_array_type(pname);

if (!NIL_P(tmp)) {

long len = RARRAY_LEN(tmp);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&gt;</operator> <name>SIZEOF_INT</name></expr></cpp:if>

if (len &gt; INT_MAX) {

rb_raise(rb_eArgError, <literal type="string">"too many arguments"</literal>);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

execarg_obj = rb_execarg_new((int)len, RARRAY_CONST_PTR(tmp), FALSE, FALSE);

RB_GC_GUARD(tmp);

}

else {

SafeStringValue(pname);

execarg_obj = Qnil;

if (!is_popen_fork(pname))

execarg_obj = rb_execarg_new(<literal type="number">1</literal>, &amp;pname, TRUE, FALSE);

}

if (!NIL_P(execarg_obj)) {

if (!NIL_P(opt))

opt = rb_execarg_extract_options(execarg_obj, opt);

if (!NIL_P(env))

rb_execarg_setenv(execarg_obj, env);

}

rb_io_extract_modeenc(&amp;pmode, <literal type="number">0</literal>, opt, &amp;oflags, &amp;fmode, &amp;convconfig);

modestr = rb_io_oflags_modestr(oflags);

port = pipe_open(execarg_obj, modestr, fmode, &amp;convconfig);

if (NIL_P(port)) {

if (rb_block_given_p()) {

rb_yield(Qnil);

rb_io_flush(rb_stdout);

rb_io_flush(rb_stderr);

_exit(<literal type="number">0</literal>);

}

return Qnil;

}

RBASIC_SET_CLASS(port, klass);

if (rb_block_given_p()) {

return rb_ensure(rb_yield, port, pipe_close, port);

}

return port;

}

static void

rb_scan_open_args(int argc, const VALUE *argv,

VALUE *fname_p, int *oflags_p, int *fmode_p,

convconfig_t *convconfig_p, mode_t *perm_p)

{

VALUE opt</argument>, <argument>fname</argument>, <argument>vmode</argument>, <argument>vperm;

int oflags</argument>, <argument>fmode;

mode_t perm;

argc = rb_scan_args(argc, argv, <literal type="string">"12:"</literal>, &amp;fname, &amp;vmode, &amp;vperm, &amp;opt);

FilePathValue(fname);

rb_io_extract_modeenc(&amp;vmode, &amp;vperm, opt, &amp;oflags, &amp;fmode, convconfig_p);

perm = NIL_P(vperm) ? <literal type="number">0666</literal> : NUM2MODET(vperm);

*fname_p = fname;

*oflags_p = oflags;

*fmode_p = fmode;

*perm_p = perm;

}

static VALUE

rb_open_file(int argc, const VALUE *argv, VALUE io)

{

VALUE fname;

int oflags</argument>, <argument>fmode;

convconfig_t convconfig;

mode_t perm;

rb_scan_open_args(argc, argv, &amp;fname, &amp;oflags, &amp;fmode, &amp;convconfig, &amp;perm);

rb_file_open_generic(io, fname, oflags, fmode, &amp;convconfig, perm);

return io;

}

static VALUE

rb_io_s_open(int argc, VALUE *argv, VALUE klass)

{

VALUE io = rb_class_new_instance_kw(argc, argv, klass, RB_PASS_CALLED_KEYWORDS);

if (rb_block_given_p()) {

return rb_ensure(rb_yield, io, io_close, io);

}

return io;

}

static VALUE

rb_io_s_sysopen(int argc, VALUE *argv, VALUE _)

{

VALUE fname</argument>, <argument>vmode</argument>, <argument>vperm;

VALUE intmode;

int oflags</argument>, <argument>fd;

mode_t perm;

rb_scan_args(argc, argv, <literal type="string">"12"</literal>, &amp;fname, &amp;vmode, &amp;vperm);

FilePathValue(fname);

if (NIL_P(vmode))

oflags = O_RDONLY;

else if (!NIL_P(intmode = rb_check_to_integer(vmode, <literal type="string">"to_int"</literal>)))

oflags = NUM2INT(intmode);

else {

SafeStringValue(vmode);

oflags = rb_io_modestr_oflags(StringValueCStr(vmode));

}

if (NIL_P(vperm)) perm = <literal type="number">0666</literal>;

else perm = NUM2MODET(vperm);

RB_GC_GUARD(fname) = rb_str_new4(fname);

fd = rb_sysopen(fname, oflags, perm);

return INT2NUM(fd);

}

static VALUE

check_pipe_command(VALUE filename_or_command)

{

char *s = RSTRING_PTR(filename_or_command);

long l = RSTRING_LEN(filename_or_command);

char *e = s + l;

int chlen;

if (rb_enc_ascget(s, e, &amp;chlen, rb_enc_get(filename_or_command)) == <literal type="char">'|'</literal>) {

VALUE cmd = rb_str_new(s+chlen, l-chlen);

return cmd;

}

return Qnil;

}

static VALUE

rb_f_open(int argc, VALUE *argv, VALUE _)

{

ID to_open = <literal type="number">0</literal>;

int redirect = FALSE;

if (argc &gt;= <literal type="number">1</literal>) {

CONST_ID(to_open, <literal type="string">"to_open"</literal>);

if (rb_respond_to(argv[<literal type="number">0</literal>], to_open)) {

redirect = TRUE;

}

else {

VALUE tmp = argv[<literal type="number">0</literal>];

FilePathValue(tmp);

if (NIL_P(tmp)) {

redirect = TRUE;

}

else {

VALUE cmd = check_pipe_command(tmp);

if (!NIL_P(cmd)) {

argv[<literal type="number">0</literal>] = cmd;

return rb_io_s_popen(argc, argv, rb_cIO);

}

}

}

}

if (redirect) {

VALUE io = rb_funcallv_kw(argv[<literal type="number">0</literal>], to_open, argc-<literal type="number">1</literal>, argv+<literal type="number">1</literal>, RB_PASS_CALLED_KEYWORDS);

if (rb_block_given_p()) {

return rb_ensure(rb_yield, io, io_close, io);

}

return io;

}

return rb_io_s_open(argc, argv, rb_cFile);

}

static VALUE rb_io_open_generic(VALUE, VALUE, int, int, const convconfig_t *, mode_t);

static VALUE

rb_io_open(VALUE io, VALUE filename, VALUE vmode, VALUE vperm, VALUE opt)

{

int oflags</argument>, <argument>fmode;

convconfig_t convconfig;

mode_t perm;

rb_io_extract_modeenc(&amp;vmode, &amp;vperm, opt, &amp;oflags, &amp;fmode, &amp;convconfig);

perm = NIL_P(vperm) ? <literal type="number">0666</literal> : NUM2MODET(vperm);

return rb_io_open_generic(io, filename, oflags, fmode, &amp;convconfig, perm);

}

static VALUE

rb_io_open_generic(VALUE klass, VALUE filename, int oflags, int fmode,

const convconfig_t *convconfig, mode_t perm)

{

VALUE cmd;

if (klass == rb_cIO &amp;&amp; !NIL_P(cmd = check_pipe_command(filename))) {

return pipe_open_s(cmd, rb_io_oflags_modestr(oflags), fmode, convconfig);

}

else {

return rb_file_open_generic(io_alloc(klass), filename,

oflags, fmode, convconfig, perm);

}

}

static VALUE

io_reopen(VALUE io, VALUE nfile)

{

rb_io_t *fptr</argument>, <argument>*orig;

int fd</argument>, <argument>fd2;

off_t pos = <literal type="number">0</literal>;

nfile = rb_io_get_io(nfile);

GetOpenFile(io, fptr);

GetOpenFile(nfile, orig);

if (fptr == orig) return io;

if (IS_PREP_STDIO(fptr)) {

if ((fptr-&gt;stdio_file == stdin &amp;&amp; !(orig-&gt;mode &amp; FMODE_READABLE)) ||

(fptr-&gt;stdio_file == stdout &amp;&amp; !(orig-&gt;mode &amp; FMODE_WRITABLE)) ||

(fptr-&gt;stdio_file == stderr &amp;&amp; !(orig-&gt;mode &amp; FMODE_WRITABLE))) {

rb_raise(rb_eArgError,

<literal type="string">"%s can't change access mode from \"%s\" to \"%s\""</literal>,

PREP_STDIO_NAME(fptr), rb_io_fmode_modestr(fptr-&gt;mode),

rb_io_fmode_modestr(orig-&gt;mode));

}

}

if (fptr-&gt;mode &amp; FMODE_WRITABLE) {

if (io_fflush(fptr) &lt; <literal type="number">0</literal>)

rb_sys_fail(<literal type="number">0</literal>);

}

else {

flush_before_seek(fptr);

}

if (orig-&gt;mode &amp; FMODE_READABLE) {

pos = io_tell(orig);

}

if (orig-&gt;mode &amp; FMODE_WRITABLE) {

if (io_fflush(orig) &lt; <literal type="number">0</literal>)

rb_sys_fail(<literal type="number">0</literal>);

}

fptr-&gt;mode = orig-&gt;mode | (fptr-&gt;mode &amp; FMODE_PREP);

fptr-&gt;pid = orig-&gt;pid;

fptr-&gt;lineno = orig-&gt;lineno;

if (RTEST(orig-&gt;pathv)) fptr-&gt;pathv = orig-&gt;pathv;

else if (!IS_PREP_STDIO(fptr)) fptr-&gt;pathv = Qnil;

fptr_copy_finalizer(fptr, orig);

fd = fptr-&gt;fd;

fd2 = orig-&gt;fd;

if (fd != fd2) {

if (IS_PREP_STDIO(fptr) || fd &lt;= <literal type="number">2</literal> || !fptr-&gt;stdio_file) {

if (rb_cloexec_dup2(fd2, fd) &lt; <literal type="number">0</literal>)

rb_sys_fail_path(orig-&gt;pathv);

rb_update_max_fd(fd);

}

else {

fclose(fptr-&gt;stdio_file);

fptr-&gt;stdio_file = <literal type="number">0</literal>;

fptr-&gt;fd = -<literal type="number">1</literal>;

if (rb_cloexec_dup2(fd2, fd) &lt; <literal type="number">0</literal>)

rb_sys_fail_path(orig-&gt;pathv);

rb_update_max_fd(fd);

fptr-&gt;fd = fd;

}

rb_thread_fd_close(fd);

if ((orig-&gt;mode &amp; FMODE_READABLE) &amp;&amp; pos &gt;= <literal type="number">0</literal>) {

if (io_seek(fptr, pos, SEEK_SET) &lt; <literal type="number">0</literal> &amp;&amp; errno) {

rb_sys_fail_path(fptr-&gt;pathv);

}

if (io_seek(orig, pos, SEEK_SET) &lt; <literal type="number">0</literal> &amp;&amp; errno) {

rb_sys_fail_path(orig-&gt;pathv);

}

}

}

if (fptr-&gt;mode &amp; FMODE_BINMODE) {

rb_io_binmode(io);

}

RBASIC_SET_CLASS(io, rb_obj_class(nfile));

return io;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
int rb_freopen(VALUE fname, const char *mode, FILE *fp);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

static int

rb_freopen(VALUE fname, const char *mode, FILE *fp)

{

if (!freopen(RSTRING_PTR(fname), mode, fp)) {

RB_GC_GUARD(fname);

return errno;

}

return <literal type="number">0</literal>;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static VALUE

rb_io_reopen(int argc, VALUE *argv, VALUE file)

{

VALUE fname</argument>, <argument>nmode</argument>, <argument>opt;

int oflags;

rb_io_t *fptr;

if (rb_scan_args(argc, argv, <literal type="string">"11:"</literal>, &amp;fname, &amp;nmode, &amp;opt) == <literal type="number">1</literal>) {

VALUE tmp = rb_io_check_io(fname);

if (!NIL_P(tmp)) {

return io_reopen(file, tmp);

}

}

FilePathValue(fname);

rb_io_taint_check(file);

fptr = RFILE(file)-&gt;fptr;

if (!fptr) {

fptr = RFILE(file)-&gt;fptr = ZALLOC(rb_io_t);

}

if (!NIL_P(nmode) || !NIL_P(opt)) {

int fmode;

convconfig_t convconfig;

rb_io_extract_modeenc(&amp;nmode, <literal type="number">0</literal>, opt, &amp;oflags, &amp;fmode, &amp;convconfig);

if (IS_PREP_STDIO(fptr) &amp;&amp;

((fptr-&gt;mode &amp; FMODE_READWRITE) &amp; (fmode &amp; FMODE_READWRITE)) !=

(fptr-&gt;mode &amp; FMODE_READWRITE)) {

rb_raise(rb_eArgError,

<literal type="string">"%s can't change access mode from \"%s\" to \"%s\""</literal>,

PREP_STDIO_NAME(fptr), rb_io_fmode_modestr(fptr-&gt;mode),

rb_io_fmode_modestr(fmode));

}

fptr-&gt;mode = fmode;

fptr-&gt;encs = convconfig;

}

else {

oflags = rb_io_fmode_oflags(fptr-&gt;mode);

}

fptr-&gt;pathv = fname;

if (fptr-&gt;fd &lt; <literal type="number">0</literal>) {

fptr-&gt;fd = rb_sysopen(fptr-&gt;pathv, oflags, <literal type="number">0666</literal>);

fptr-&gt;stdio_file = <literal type="number">0</literal>;

return file;

}

if (fptr-&gt;mode &amp; FMODE_WRITABLE) {

if (io_fflush(fptr) &lt; <literal type="number">0</literal>)

rb_sys_fail(<literal type="number">0</literal>);

}

fptr-&gt;rbuf.off = fptr-&gt;rbuf.len = <literal type="number">0</literal>;

if (fptr-&gt;stdio_file) {

int e = rb_freopen(rb_str_encode_ospath(fptr-&gt;pathv),

rb_io_oflags_modestr(oflags),

fptr-&gt;stdio_file);

if (e) rb_syserr_fail_path(e, fptr-&gt;pathv);

fptr-&gt;fd = fileno(fptr-&gt;stdio_file);

rb_fd_fix_cloexec(fptr-&gt;fd);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SETVBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (setvbuf(fptr-&gt;stdio_file, NULL, _IOFBF, <literal type="number">0</literal>) != <literal type="number">0</literal>)

rb_warn(<literal type="string">"setvbuf() can't be honoured for %"</literal>PRIsVALUE, fptr-&gt;pathv);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (fptr-&gt;stdio_file == stderr) {

if (setvbuf(fptr-&gt;stdio_file, NULL, _IONBF, BUFSIZ) != <literal type="number">0</literal>)

rb_warn(<literal type="string">"setvbuf() can't be honoured for %"</literal>PRIsVALUE, fptr-&gt;pathv);

}

else if (fptr-&gt;stdio_file == stdout &amp;&amp; isatty(fptr-&gt;fd)) {

if (setvbuf(fptr-&gt;stdio_file, NULL, _IOLBF, BUFSIZ) != <literal type="number">0</literal>)

rb_warn(<literal type="string">"setvbuf() can't be honoured for %"</literal>PRIsVALUE, fptr-&gt;pathv);

}

}

else {

int tmpfd = rb_sysopen(fptr-&gt;pathv, oflags, <literal type="number">0666</literal>);

int err = <literal type="number">0</literal>;

if (rb_cloexec_dup2(tmpfd, fptr-&gt;fd) &lt; <literal type="number">0</literal>)

err = errno;

(void)close(tmpfd);

if (err) {

rb_syserr_fail_path(err, fptr-&gt;pathv);

}

}

return file;

}

static VALUE

rb_io_init_copy(VALUE dest, VALUE io)

{

rb_io_t *fptr</argument>, <argument>*orig;

int fd;

VALUE write_io;

off_t pos;

io = rb_io_get_io(io);

if (!OBJ_INIT_COPY(dest, io)) return dest;

GetOpenFile(io, orig);

MakeOpenFile(dest, fptr);

rb_io_flush(io);

fptr-&gt;mode = orig-&gt;mode &amp; ~FMODE_PREP;

fptr-&gt;encs = orig-&gt;encs;

fptr-&gt;pid = orig-&gt;pid;

fptr-&gt;lineno = orig-&gt;lineno;

if (!NIL_P(orig-&gt;pathv)) fptr-&gt;pathv = orig-&gt;pathv;

fptr_copy_finalizer(fptr, orig);

fd = ruby_dup(orig-&gt;fd);

fptr-&gt;fd = fd;

pos = io_tell(orig);

if (<literal type="number">0</literal> &lt;= pos)

io_seek(fptr, pos, SEEK_SET);

if (fptr-&gt;mode &amp; FMODE_BINMODE) {

rb_io_binmode(dest);

}

write_io = GetWriteIO(io);

if (io != write_io) {

write_io = rb_obj_dup(write_io);

fptr-&gt;tied_io_for_writing = write_io;

rb_ivar_set(dest, rb_intern(<literal type="string">"@tied_io_for_writing"</literal>), write_io);

}

return dest;

}

VALUE

rb_io_printf(int argc, const VALUE *argv, VALUE out)

{

rb_io_write(out, rb_f_sprintf(argc, argv));

return Qnil;

}

static VALUE

rb_f_printf(int argc, VALUE *argv, VALUE _)

{

VALUE out;

if (argc == <literal type="number">0</literal>) return Qnil;

if (RB_TYPE_P(argv[<literal type="number">0</literal>], T_STRING)) {

out = rb_stdout;

}

else {

out = argv[<literal type="number">0</literal>];

argv++;

argc--;

}

rb_io_write(out, rb_f_sprintf(argc, argv));

return Qnil;

}

static void

deprecated_str_setter(VALUE val, ID id, VALUE *var)

{

rb_str_setter(val, id, &amp;val);

if (!NIL_P(val)) {

rb_warn_deprecated(<literal type="string">"`%s'"</literal>, NULL, rb_id2name(id));

}

*var = val;

}

VALUE

rb_io_print(int argc, const VALUE *argv, VALUE out)

{

int i;

VALUE line;

if (argc == <literal type="number">0</literal>) {

argc = <literal type="number">1</literal>;

line = rb_lastline_get();

argv = &amp;line;

}

if (argc &gt; <literal type="number">1</literal> &amp;&amp; !NIL_P(rb_output_fs)) {

rb_warn(<literal type="string">"$, is set to non-nil value"</literal>);

}

for (i=<literal type="number">0</literal>; i&lt;argc; i++) {

if (!NIL_P(rb_output_fs) &amp;&amp; i&gt;<literal type="number">0</literal>) {

rb_io_write(out, rb_output_fs);

}

rb_io_write(out, argv[i]);

}

if (argc &gt; <literal type="number">0</literal> &amp;&amp; !NIL_P(rb_output_rs)) {

rb_io_write(out, rb_output_rs);

}

return Qnil;

}

static VALUE

rb_f_print(int argc, const VALUE *argv, VALUE _)

{

rb_io_print(argc, argv, rb_stdout);

return Qnil;

}

static VALUE

rb_io_putc(VALUE io, VALUE ch)

{

VALUE str;

if (RB_TYPE_P(ch, T_STRING)) {

str = rb_str_substr(ch, <literal type="number">0</literal>, <literal type="number">1</literal>);

}

else {

char c = NUM2CHR(ch);

str = rb_str_new(&amp;c, <literal type="number">1</literal>);

}

rb_io_write(io, str);

return ch;

}

static VALUE

rb_f_putc(VALUE recv, VALUE ch)

{

if (recv == rb_stdout) {

return rb_io_putc(recv, ch);

}

return rb_funcallv(rb_stdout, rb_intern(<literal type="string">"putc"</literal>), <literal type="number">1</literal>, &amp;ch);

}

int

rb_str_end_with_asciichar(VALUE str, int c)

{

long len = RSTRING_LEN(str);

const char *ptr = RSTRING_PTR(str);

rb_encoding *enc = rb_enc_from_index(ENCODING_GET(str));

int n;

if (len == <literal type="number">0</literal>) return <literal type="number">0</literal>;

if ((n = rb_enc_mbminlen(enc)) == <literal type="number">1</literal>) {

return ptr[len - <literal type="number">1</literal>] == c;

}

return rb_enc_ascget(ptr + ((len - <literal type="number">1</literal>) / n) * n, ptr + len, &amp;n, enc) == c;

}

static VALUE

io_puts_ary(VALUE ary, VALUE out, int recur)

{

VALUE tmp;

long i;

if (recur) {

tmp = rb_str_new2(<literal type="string">"[...]"</literal>);

rb_io_puts(<literal type="number">1</literal>, &amp;tmp, out);

return Qtrue;

}

ary = rb_check_array_type(ary);

if (NIL_P(ary)) return Qfalse;

for (i=<literal type="number">0</literal>; i&lt;RARRAY_LEN(ary); i++) {

tmp = RARRAY_AREF(ary, i);

rb_io_puts(<literal type="number">1</literal>, &amp;tmp, out);

}

return Qtrue;

}

VALUE

rb_io_puts(int argc, const VALUE *argv, VALUE out)

{

int i</argument>, <argument>n;

VALUE line</argument>, <argument>args[<literal type="number">2</literal>];

if (argc == <literal type="number">0</literal>) {

rb_io_write(out, rb_default_rs);

return Qnil;

}

for (i=<literal type="number">0</literal>; i&lt;argc; i++) {

if (RB_TYPE_P(argv[i], T_STRING)) {

line = argv[i];

goto string;

}

if (rb_exec_recursive(io_puts_ary, argv[i], out)) {

continue;

}

line = rb_obj_as_string(argv[i]);

string:

n = <literal type="number">0</literal>;

args[n++] = line;

if (RSTRING_LEN(line) == <literal type="number">0</literal> ||

!rb_str_end_with_asciichar(line, <literal type="char">'\n'</literal>)) {

args[n++] = rb_default_rs;

}

rb_io_writev(out, n, args);

}

return Qnil;

}

static VALUE

rb_f_puts(int argc, VALUE *argv, VALUE recv)

{

if (recv == rb_stdout) {

return rb_io_puts(argc, argv, recv);

}

return rb_funcallv(rb_stdout, rb_intern(<literal type="string">"puts"</literal>), argc, argv);

}

void

rb_p(VALUE obj) 

{

VALUE args[<literal type="number">2</literal>];

args[<literal type="number">0</literal>] = rb_obj_as_string(rb_inspect(obj));

args[<literal type="number">1</literal>] = rb_default_rs;

if (RB_TYPE_P(rb_stdout, T_FILE) &amp;&amp;

rb_method_basic_definition_p(CLASS_OF(rb_stdout), id_write)) {

io_writev(<literal type="number">2</literal>, args, rb_stdout);

}

else {

rb_io_writev(rb_stdout, <literal type="number">2</literal>, args);

}

}

struct rb_f_p_arg {

int argc;

VALUE *argv;

};

static VALUE

rb_f_p_internal(VALUE arg)

{

struct rb_f_p_arg *arg1 = (struct rb_f_p_arg*)arg;

int argc = arg1-&gt;argc;

VALUE *argv = arg1-&gt;argv;

int i;

VALUE ret = Qnil;

for (i=<literal type="number">0</literal>; i&lt;argc; i++) {

rb_p(argv[i]);

}

if (argc == <literal type="number">1</literal>) {

ret = argv[<literal type="number">0</literal>];

}

else if (argc &gt; <literal type="number">1</literal>) {

ret = rb_ary_new4(argc, argv);

}

if (RB_TYPE_P(rb_stdout, T_FILE)) {

rb_io_flush(rb_stdout);

}

return ret;

}

static VALUE

rb_f_p(int argc, VALUE *argv, VALUE self)

{

struct rb_f_p_arg arg;

arg.argc = argc;

arg.argv = argv;

return rb_uninterruptible(rb_f_p_internal, (VALUE)&amp;arg);

}

static VALUE

rb_obj_display(int argc, VALUE *argv, VALUE self)

{

VALUE out;

out = (!rb_check_arity(argc, <literal type="number">0</literal>, <literal type="number">1</literal>) ? rb_stdout : argv[<literal type="number">0</literal>]);

rb_io_write(out, self);

return Qnil;

}

static int

rb_stderr_to_original_p(void)

{

return (rb_stderr == orig_stderr || RFILE(orig_stderr)-&gt;fptr-&gt;fd &lt; <literal type="number">0</literal>);

}

void

rb_write_error2(const char *mesg, long len)

{

if (rb_stderr_to_original_p()) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (isatty(fileno(stderr))) {

if (rb_w32_write_console(rb_str_new(mesg, len), fileno(stderr)) &gt; <literal type="number">0</literal>) return;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (fwrite(mesg, sizeof(char), (size_t)len, stderr) &lt; (size_t)len) {

return;

}

}

else {

rb_io_write(rb_stderr, rb_str_new(mesg, len));

}

}

void

rb_write_error(const char *mesg)

{

rb_write_error2(mesg, strlen(mesg));

}

void

rb_write_error_str(VALUE mesg)

{

if (rb_stderr_to_original_p()) {

size_t len = (size_t)RSTRING_LEN(mesg);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (isatty(fileno(stderr))) {

if (rb_w32_write_console(mesg, fileno(stderr)) &gt; <literal type="number">0</literal>) return;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (fwrite(RSTRING_PTR(mesg), sizeof(char), len, stderr) &lt; len) {

RB_GC_GUARD(mesg);

return;

}

}

else {

rb_io_write(rb_stderr, mesg);

}

}

int

rb_stderr_tty_p(void)

{

if (rb_stderr_to_original_p())

return isatty(fileno(stderr));

return <literal type="number">0</literal>;

}

static void

must_respond_to(ID mid, VALUE val, ID id)

{

if (!rb_respond_to(val, mid)) {

rb_raise(rb_eTypeError, <literal type="string">"%"</literal>PRIsVALUE<literal type="string">" must have %"</literal>PRIsVALUE<literal type="string">" method, %"</literal>PRIsVALUE<literal type="string">" given"</literal>,

rb_id2str(id), rb_id2str(mid),

rb_obj_class(val));

}

}

static void

stdout_setter(VALUE val, ID id, VALUE *variable)

{

must_respond_to(id_write, val, id);

*variable = val;

}

static VALUE

prep_io(int fd, int fmode, VALUE klass, const char *path)

{

rb_io_t *fp;

VALUE io = io_alloc(klass);

MakeOpenFile(io, fp);

fp-&gt;fd = fd;

fp-&gt;mode = fmode;

if (!io_check_tty(fp)) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
fp-&gt;mode |= FMODE_BINMODE;

setmode(fd, O_BINARY);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

if (path) fp-&gt;pathv = rb_obj_freeze(rb_str_new_cstr(path));

rb_update_max_fd(fd);

return io;

}

VALUE

rb_io_fdopen(int fd, int oflags, const char *path)

{

VALUE klass = rb_cIO;

if (path &amp;&amp; strcmp(path, <literal type="string">"-"</literal>)) klass = rb_cFile;

return prep_io(fd, rb_io_oflags_fmode(oflags), klass, path);

}

static VALUE

prep_stdio(FILE *f, int fmode, VALUE klass, const char *path)

{

rb_io_t *fptr;

VALUE io = prep_io(fileno(f), fmode|FMODE_PREP|DEFAULT_TEXTMODE, klass, path);

GetOpenFile(io, fptr);

fptr-&gt;encs.ecflags |= ECONV_DEFAULT_NEWLINE_DECORATOR;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEXTMODE_NEWLINE_DECORATOR_ON_WRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
fptr-&gt;encs.ecflags |= TEXTMODE_NEWLINE_DECORATOR_ON_WRITE;

if (fmode &amp; FMODE_READABLE) {

fptr-&gt;encs.ecflags |= ECONV_UNIVERSAL_NEWLINE_DECORATOR;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

fptr-&gt;stdio_file = f;

return io;

}

FILE *

rb_io_stdio_file(rb_io_t *fptr)

{

if (!fptr-&gt;stdio_file) {

int oflags = rb_io_fmode_oflags(fptr-&gt;mode) &amp; ~O_EXCL;

fptr-&gt;stdio_file = rb_fdopen(fptr-&gt;fd, rb_io_oflags_modestr(oflags));

}

return fptr-&gt;stdio_file;

}

static inline void

rb_io_buffer_init(rb_io_buffer_t *buf)

{

buf-&gt;ptr = NULL;

buf-&gt;off = <literal type="number">0</literal>;

buf-&gt;len = <literal type="number">0</literal>;

buf-&gt;capa = <literal type="number">0</literal>;

}

static inline rb_io_t *

rb_io_fptr_new(void)

{

rb_io_t *fp = ALLOC(rb_io_t);

fp-&gt;fd = -<literal type="number">1</literal>;

fp-&gt;stdio_file = NULL;

fp-&gt;mode = <literal type="number">0</literal>;

fp-&gt;pid = <literal type="number">0</literal>;

fp-&gt;lineno = <literal type="number">0</literal>;

fp-&gt;pathv = Qnil;

fp-&gt;finalize = <literal type="number">0</literal>;

rb_io_buffer_init(&amp;fp-&gt;wbuf);

rb_io_buffer_init(&amp;fp-&gt;rbuf);

rb_io_buffer_init(&amp;fp-&gt;cbuf);

fp-&gt;readconv = NULL;

fp-&gt;writeconv = NULL;

fp-&gt;writeconv_asciicompat = Qnil;

fp-&gt;writeconv_pre_ecflags = <literal type="number">0</literal>;

fp-&gt;writeconv_pre_ecopts = Qnil;

fp-&gt;writeconv_initialized = <literal type="number">0</literal>;

fp-&gt;tied_io_for_writing = <literal type="number">0</literal>;

fp-&gt;encs.enc = NULL;

fp-&gt;encs.enc2 = NULL;

fp-&gt;encs.ecflags = <literal type="number">0</literal>;

fp-&gt;encs.ecopts = Qnil;

fp-&gt;write_lock = <literal type="number">0</literal>;

return fp;

}

rb_io_t *

rb_io_make_open_file(VALUE obj)

{

rb_io_t *fp = <literal type="number">0</literal>;

Check_Type(obj, T_FILE);

if (RFILE(obj)-&gt;fptr) {

rb_io_close(obj);

rb_io_fptr_finalize(RFILE(obj)-&gt;fptr);

RFILE(obj)-&gt;fptr = <literal type="number">0</literal>;

}

fp = rb_io_fptr_new();

RFILE(obj)-&gt;fptr = fp;

return fp;

}

static VALUE

rb_io_initialize(int argc, VALUE *argv, VALUE io)

{

VALUE fnum</argument>, <argument>vmode;

rb_io_t *fp;

int fd</argument>, <argument>fmode</argument>, <argument>oflags = O_RDONLY;

convconfig_t convconfig;

VALUE opt;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr></cpp:if>

int ofmode;

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

struct stat st;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

argc = rb_scan_args(argc, argv, <literal type="string">"11:"</literal>, &amp;fnum, &amp;vmode, &amp;opt);

rb_io_extract_modeenc(&amp;vmode, <literal type="number">0</literal>, opt, &amp;oflags, &amp;fmode, &amp;convconfig);

fd = NUM2INT(fnum);

if (rb_reserved_fd_p(fd)) {

rb_raise(rb_eArgError, <literal type="string">"The given fd is not accessible because RubyVM reserves it"</literal>);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr></cpp:if>

oflags = fcntl(fd, F_GETFL);

if (oflags == -<literal type="number">1</literal>) rb_sys_fail(<literal type="number">0</literal>);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

if (fstat(fd, &amp;st) &lt; <literal type="number">0</literal>) rb_sys_fail(<literal type="number">0</literal>);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_update_max_fd(fd);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr></cpp:if>

ofmode = rb_io_oflags_fmode(oflags);

if (NIL_P(vmode)) {

fmode = ofmode;

}

else if ((~ofmode &amp; fmode) &amp; FMODE_READWRITE) {

VALUE error = INT2FIX(EINVAL);

rb_exc_raise(rb_class_new_instance(<literal type="number">1</literal>, &amp;error, rb_eSystemCallError));

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (!NIL_P(opt) &amp;&amp; rb_hash_aref(opt, sym_autoclose) == Qfalse) {

fmode |= FMODE_PREP;

}

MakeOpenFile(io, fp);

fp-&gt;fd = fd;

fp-&gt;mode = fmode;

fp-&gt;encs = convconfig;

clear_codeconv(fp);

io_check_tty(fp);

if (fileno(stdin) == fd)

fp-&gt;stdio_file = stdin;

else if (fileno(stdout) == fd)

fp-&gt;stdio_file = stdout;

else if (fileno(stderr) == fd)

fp-&gt;stdio_file = stderr;

if (fmode &amp; FMODE_SETENC_BY_BOM) io_set_encoding_by_bom(io);

return io;

}

static VALUE

rb_io_set_encoding_by_bom(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

if (!(fptr-&gt;mode &amp; FMODE_BINMODE)) {

rb_raise(rb_eArgError, <literal type="string">"ASCII incompatible encoding needs binmode"</literal>);

}

if (fptr-&gt;encs.enc2) {

rb_raise(rb_eArgError, <literal type="string">"encoding conversion is set"</literal>);

}

else if (fptr-&gt;encs.enc &amp;&amp; fptr-&gt;encs.enc != rb_ascii8bit_encoding()) {

rb_raise(rb_eArgError, <literal type="string">"encoding is set to %s already"</literal>,

rb_enc_name(fptr-&gt;encs.enc));

}

if (!io_set_encoding_by_bom(io)) return Qnil;

return rb_enc_from_encoding(fptr-&gt;encs.enc);

}

static VALUE

rb_file_initialize(int argc, VALUE *argv, VALUE io)

{

if (RFILE(io)-&gt;fptr) {

rb_raise(rb_eRuntimeError, <literal type="string">"reinitializing File"</literal>);

}

if (<literal type="number">0</literal> &lt; argc &amp;&amp; argc &lt; <literal type="number">3</literal>) {

VALUE fd = rb_check_to_int(argv[<literal type="number">0</literal>]);

if (!NIL_P(fd)) {

argv[<literal type="number">0</literal>] = fd;

return rb_io_initialize(argc, argv, io);

}

}

rb_open_file(argc, argv, io);

return io;

}

static VALUE

rb_io_s_new(int argc, VALUE *argv, VALUE klass)

{

if (rb_block_given_p()) {

VALUE cname = rb_obj_as_string(klass);

rb_warn(<literal type="string">"%"</literal>PRIsVALUE<literal type="string">"::new() does not take block; use %"</literal>PRIsVALUE<literal type="string">"::open() instead"</literal>,

cname, cname);

}

return rb_class_new_instance_kw(argc, argv, klass, RB_PASS_CALLED_KEYWORDS);

}

static VALUE

rb_io_s_for_fd(int argc, VALUE *argv, VALUE klass)

{

VALUE io = rb_obj_alloc(klass);

rb_io_initialize(argc, argv, io);

return io;

}

static VALUE

rb_io_autoclose_p(VALUE io)

{

rb_io_t *fptr = RFILE(io)-&gt;fptr;

rb_io_check_closed(fptr);

return (fptr-&gt;mode &amp; FMODE_PREP) ? Qfalse : Qtrue;

}

static VALUE

rb_io_set_autoclose(VALUE io, VALUE autoclose)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

if (!RTEST(autoclose))

fptr-&gt;mode |= FMODE_PREP;

else

fptr-&gt;mode &amp;= ~FMODE_PREP;

return autoclose;

}

static void

argf_mark(void *ptr)

{

struct argf *p = ptr;

rb_gc_mark(p-&gt;filename);

rb_gc_mark(p-&gt;current_file);

rb_gc_mark(p-&gt;argv);

rb_gc_mark(p-&gt;inplace);

rb_gc_mark(p-&gt;encs.ecopts);

}

static size_t

argf_memsize(const void *ptr)

{

const struct argf *p = ptr;

size_t size = sizeof(*p);

return size;

}

static const rb_data_type_t argf_type = {

<literal type="string">"ARGF"</literal></argument>,

<argument>{argf_mark</argument>, <argument>RUBY_TYPED_DEFAULT_FREE</argument>, <argument>argf_memsize}</argument>,

<argument><literal type="number">0</literal></argument>, <argument><literal type="number">0</literal></argument>, <argument>RUBY_TYPED_FREE_IMMEDIATELY

};

static inline void

argf_init(struct argf *p, VALUE v)

{

p-&gt;filename = Qnil;

p-&gt;current_file = Qnil;

p-&gt;lineno = <literal type="number">0</literal>;

p-&gt;argv = v;

}

static VALUE

argf_alloc(VALUE klass)

{

struct argf *p;

VALUE argf = TypedData_Make_Struct(klass, struct argf, &amp;argf_type, p);

argf_init(p, Qnil);

return argf;

}

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_argv</name></cpp:undef>

static VALUE

argf_initialize(VALUE argf, VALUE argv)

{

memset(&amp;ARGF, <literal type="number">0</literal>, sizeof(ARGF));

argf_init(&amp;ARGF, argv);

return argf;

}

static VALUE

argf_initialize_copy(VALUE argf, VALUE orig)

{

if (!OBJ_INIT_COPY(argf, orig)) return argf;

ARGF = argf_of(orig);

ARGF.argv = rb_obj_dup(ARGF.argv);

return argf;

}

static VALUE

argf_set_lineno(VALUE argf, VALUE val)

{

ARGF.lineno = NUM2INT(val);

ARGF.last_lineno = ARGF.lineno;

return Qnil;

}

static VALUE

argf_lineno(VALUE argf)

{

return INT2FIX(ARGF.lineno);

}

static VALUE

argf_forward(int argc, VALUE *argv, VALUE argf)

{

return rb_funcall3(ARGF.current_file, rb_frame_this_func(), argc, argv);

}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next_argv</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>argf_next_argv(argf)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGF_GENERIC_INPUT_P</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(ARGF.current_file == rb_stdin &amp;&amp; !RB_TYPE_P(ARGF.current_file, T_FILE))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGF_FORWARD</name><parameter_list>(<parameter><type><name>argc</name></type></parameter>, <parameter><type><name>argv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (ARGF_GENERIC_INPUT_P())return argf_forward((argc), (argv), argf);} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_ARGF_FORWARD</name><parameter_list>(<parameter><type><name>argc</name></type></parameter>, <parameter><type><name>argv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (!next_argv()) return Qnil;ARGF_FORWARD((argc), (argv));} while (0)</cpp:value></cpp:define>

static void

argf_close(VALUE argf)

{

VALUE file = ARGF.current_file;

if (file == rb_stdin) return;

if (RB_TYPE_P(file, T_FILE)) {

rb_io_set_write_io(file, Qnil);

}

io_close(file);

ARGF.init_p = -<literal type="number">1</literal>;

}

static int

argf_next_argv(VALUE argf)

{

char *fn;

rb_io_t *fptr;

int stdout_binmode = <literal type="number">0</literal>;

int fmode;

if (RB_TYPE_P(rb_stdout, T_FILE)) {

GetOpenFile(rb_stdout, fptr);

if (fptr-&gt;mode &amp; FMODE_BINMODE)

stdout_binmode = <literal type="number">1</literal>;

}

if (ARGF.init_p == <literal type="number">0</literal>) {

if (!NIL_P(ARGF.argv) &amp;&amp; RARRAY_LEN(ARGF.argv) &gt; <literal type="number">0</literal>) {

ARGF.next_p = <literal type="number">1</literal>;

}

else {

ARGF.next_p = -<literal type="number">1</literal>;

}

ARGF.init_p = <literal type="number">1</literal>;

}

else {

if (NIL_P(ARGF.argv)) {

ARGF.next_p = -<literal type="number">1</literal>;

}

else if (ARGF.next_p == -<literal type="number">1</literal> &amp;&amp; RARRAY_LEN(ARGF.argv) &gt; <literal type="number">0</literal>) {

ARGF.next_p = <literal type="number">1</literal>;

}

}

if (ARGF.next_p == <literal type="number">1</literal>) {

if (ARGF.init_p == <literal type="number">1</literal>) argf_close(argf);

retry:

if (RARRAY_LEN(ARGF.argv) &gt; <literal type="number">0</literal>) {

VALUE filename = rb_ary_shift(ARGF.argv);

FilePathValue(filename);

ARGF.filename = filename;

filename = rb_str_encode_ospath(filename);

fn = StringValueCStr(filename);

if (RSTRING_LEN(filename) == <literal type="number">1</literal> &amp;&amp; fn[<literal type="number">0</literal>] == <literal type="char">'-'</literal>) {

ARGF.current_file = rb_stdin;

if (ARGF.inplace) {

rb_warn(<literal type="string">"Can't do inplace edit for stdio; skipping"</literal>);

goto retry;

}

}

else {

VALUE write_io = Qnil;

int fr = rb_sysopen(filename, O_RDONLY, <literal type="number">0</literal>);

if (ARGF.inplace) {

struct stat st;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_SAFE_RENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
struct stat st2;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

VALUE str;

int fw;

if (RB_TYPE_P(rb_stdout, T_FILE) &amp;&amp; rb_stdout != orig_stdout) {

rb_io_close(rb_stdout);

}

fstat(fr, &amp;st);

str = filename;

if (!NIL_P(ARGF.inplace)) {

VALUE suffix = ARGF.inplace;

str = rb_str_dup(str);

if (NIL_P(rb_str_cat_conv_enc_opts(str, RSTRING_LEN(str),

RSTRING_PTR(suffix), RSTRING_LEN(suffix),

rb_enc_get(suffix), <literal type="number">0</literal>, Qnil))) {

rb_str_append(str, suffix);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_SAFE_RENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
(void)close(fr);

(void)unlink(RSTRING_PTR(str));

if (rename(fn, RSTRING_PTR(str)) &lt; <literal type="number">0</literal>) {

rb_warn(<literal type="string">"Can't rename %"</literal>PRIsVALUE<literal type="string">" to %"</literal>PRIsVALUE<literal type="string">": %s, skipping file"</literal>,

filename, str, strerror(errno));

goto retry;

}

fr = rb_sysopen(str, O_RDONLY, <literal type="number">0</literal>);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

if (rename(fn, RSTRING_PTR(str)) &lt; <literal type="number">0</literal>) {

rb_warn(<literal type="string">"Can't rename %"</literal>PRIsVALUE<literal type="string">" to %"</literal>PRIsVALUE<literal type="string">": %s, skipping file"</literal>,

filename, str, strerror(errno));

close(fr);

goto retry;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

else {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_SAFE_RENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
rb_fatal(<literal type="string">"Can't do inplace edit without backup"</literal>);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

if (unlink(fn) &lt; <literal type="number">0</literal>) {

rb_warn(<literal type="string">"Can't remove %"</literal>PRIsVALUE<literal type="string">": %s, skipping file"</literal>,

filename, strerror(errno));

close(fr);

goto retry;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

fw = rb_sysopen(filename, O_WRONLY|O_CREAT|O_TRUNC, <literal type="number">0666</literal>);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_SAFE_RENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
fstat(fw, &amp;st2);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHMOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
fchmod(fw, st.st_mode);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

chmod(fn, st.st_mode);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (st.st_uid!=st2.st_uid || st.st_gid!=st2.st_gid) {

int err;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
err = fchown(fw, st.st_uid, st.st_gid);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

err = chown(fn, st.st_uid, st.st_gid);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (err &amp;&amp; getuid() == <literal type="number">0</literal> &amp;&amp; st2.st_uid == <literal type="number">0</literal>) {

const char *wkfn = RSTRING_PTR(filename);

rb_warn(<literal type="string">"Can't set owner/group of %"</literal>PRIsVALUE<literal type="string">" to same as %"</literal>PRIsVALUE<literal type="string">": %s, skipping file"</literal>,

filename, str, strerror(errno));

(void)close(fr);

(void)close(fw);

(void)unlink(wkfn);

goto retry;

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

write_io = prep_io(fw, FMODE_WRITABLE, rb_cFile, fn);

rb_stdout = write_io;

if (stdout_binmode) rb_io_binmode(rb_stdout);

}

fmode = FMODE_READABLE;

if (!ARGF.binmode) {

fmode |= DEFAULT_TEXTMODE;

}

ARGF.current_file = prep_io(fr, fmode, rb_cFile, fn);

if (!NIL_P(write_io)) {

rb_io_set_write_io(ARGF.current_file, write_io);

}

RB_GC_GUARD(filename);

}

if (ARGF.binmode) rb_io_ascii8bit_binmode(ARGF.current_file);

GetOpenFile(ARGF.current_file, fptr);

if (ARGF.encs.enc) {

fptr-&gt;encs = ARGF.encs;

clear_codeconv(fptr);

}

else {

fptr-&gt;encs.ecflags &amp;= ~ECONV_NEWLINE_DECORATOR_MASK;

if (!ARGF.binmode) {

fptr-&gt;encs.ecflags |= ECONV_DEFAULT_NEWLINE_DECORATOR;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEXTMODE_NEWLINE_DECORATOR_ON_WRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
fptr-&gt;encs.ecflags |= TEXTMODE_NEWLINE_DECORATOR_ON_WRITE;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

}

ARGF.next_p = <literal type="number">0</literal>;

}

else {

ARGF.next_p = <literal type="number">1</literal>;

return FALSE;

}

}

else if (ARGF.next_p == -<literal type="number">1</literal>) {

ARGF.current_file = rb_stdin;

ARGF.filename = rb_str_new2(<literal type="string">"-"</literal>);

if (ARGF.inplace) {

rb_warn(<literal type="string">"Can't do inplace edit for stdio"</literal>);

rb_stdout = orig_stdout;

}

}

if (ARGF.init_p == -<literal type="number">1</literal>) ARGF.init_p = <literal type="number">1</literal>;

return TRUE;

}

static VALUE

argf_getline(int argc, VALUE *argv, VALUE argf)

{

VALUE line;

long lineno = ARGF.lineno;

retry:

if (!next_argv()) return Qnil;

if (ARGF_GENERIC_INPUT_P()) {

line = rb_funcall3(ARGF.current_file, idGets, argc, argv);

}

else {

if (argc == <literal type="number">0</literal> &amp;&amp; rb_rs == rb_default_rs) {

line = rb_io_gets(ARGF.current_file);

}

else {

line = rb_io_getline(argc, argv, ARGF.current_file);

}

if (NIL_P(line) &amp;&amp; ARGF.next_p != -<literal type="number">1</literal>) {

argf_close(argf);

ARGF.next_p = <literal type="number">1</literal>;

goto retry;

}

}

if (!NIL_P(line)) {

ARGF.lineno = ++lineno;

ARGF.last_lineno = ARGF.lineno;

}

return line;

}

static VALUE

argf_lineno_getter(ID id, VALUE *var)

{

VALUE argf = *var;

return INT2FIX(ARGF.last_lineno);

}

static void

argf_lineno_setter(VALUE val, ID id, VALUE *var)

{

VALUE argf = *var;

int n = NUM2INT(val);

ARGF.last_lineno = ARGF.lineno = n;

}

static VALUE argf_gets(int, VALUE *, VALUE);

static VALUE

rb_f_gets(int argc, VALUE *argv, VALUE recv)

{

if (recv == argf) {

return argf_gets(argc, argv, argf);

}

return rb_funcallv(argf, idGets, argc, argv);

}

static VALUE

argf_gets(int argc, VALUE *argv, VALUE argf)

{

VALUE line;

line = argf_getline(argc, argv, argf);

rb_lastline_set(line);

return line;

}

VALUE

rb_gets(void)

{

VALUE line;

if (rb_rs != rb_default_rs) {

return rb_f_gets(<literal type="number">0</literal>, <literal type="number">0</literal>, argf);

}

retry:

if (!next_argv()) return Qnil;

line = rb_io_gets(ARGF.current_file);

if (NIL_P(line) &amp;&amp; ARGF.next_p != -<literal type="number">1</literal>) {

rb_io_close(ARGF.current_file);

ARGF.next_p = <literal type="number">1</literal>;

goto retry;

}

rb_lastline_set(line);

if (!NIL_P(line)) {

ARGF.lineno++;

ARGF.last_lineno = ARGF.lineno;

}

return line;

}

static VALUE argf_readline(int, VALUE *, VALUE);

static VALUE

rb_f_readline(int argc, VALUE *argv, VALUE recv)

{

if (recv == argf) {

return argf_readline(argc, argv, argf);

}

return rb_funcallv(argf, rb_intern(<literal type="string">"readline"</literal>), argc, argv);

}

static VALUE

argf_readline(int argc, VALUE *argv, VALUE argf)

{

VALUE line;

if (!next_argv()) rb_eof_error();

ARGF_FORWARD(argc, argv);

line = argf_gets(argc, argv, argf);

if (NIL_P(line)) {

rb_eof_error();

}

return line;

}

static VALUE argf_readlines(int, VALUE *, VALUE);

static VALUE

rb_f_readlines(int argc, VALUE *argv, VALUE recv)

{

if (recv == argf) {

return argf_readlines(argc, argv, argf);

}

return rb_funcallv(argf, rb_intern(<literal type="string">"readlines"</literal>), argc, argv);

}

static VALUE

argf_readlines(int argc, VALUE *argv, VALUE argf)

{

long lineno = ARGF.lineno;

VALUE lines</argument>, <argument>ary;

ary = rb_ary_new();

while (next_argv()) {

if (ARGF_GENERIC_INPUT_P()) {

lines = rb_funcall3(ARGF.current_file, rb_intern(<literal type="string">"readlines"</literal>), argc, argv);

}

else {

lines = rb_io_readlines(argc, argv, ARGF.current_file);

argf_close(argf);

}

ARGF.next_p = <literal type="number">1</literal>;

rb_ary_concat(ary, lines);

ARGF.lineno = lineno + RARRAY_LEN(ary);

ARGF.last_lineno = ARGF.lineno;

}

ARGF.init_p = <literal type="number">0</literal>;

return ary;

}

static VALUE

rb_f_backquote(VALUE obj, VALUE str)

{

VALUE port;

VALUE result;

rb_io_t *fptr;

SafeStringValue(str);

rb_last_status_clear();

port = pipe_open_s(str, <literal type="string">"r"</literal>, FMODE_READABLE|DEFAULT_TEXTMODE, NULL);

if (NIL_P(port)) return rb_str_new(<literal type="number">0</literal>,<literal type="number">0</literal>);

GetOpenFile(port, fptr);

result = read_all(fptr, remain_size(fptr), Qnil);

rb_io_close(port);

RFILE(port)-&gt;fptr = NULL;

rb_io_fptr_finalize(fptr);

rb_gc_force_recycle(port); 

return result;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_SELECT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static VALUE

select_internal(VALUE read, VALUE write, VALUE except, struct timeval *tp, rb_fdset_t *fds)

{

VALUE res</argument>, <argument>list;

rb_fdset_t *rp</argument>, <argument>*wp</argument>, <argument>*ep;

rb_io_t *fptr;

long i;

int max = <literal type="number">0</literal></argument>, <argument>n;

int pending = <literal type="number">0</literal>;

struct timeval timerec;

if (!NIL_P(read)) {

Check_Type(read, T_ARRAY);

for (i=<literal type="number">0</literal>; i&lt;RARRAY_LEN(read); i++) {

GetOpenFile(rb_io_get_io(RARRAY_AREF(read, i)), fptr);

rb_fd_set(fptr-&gt;fd, &amp;fds[<literal type="number">0</literal>]);

if (READ_DATA_PENDING(fptr) || READ_CHAR_PENDING(fptr)) { 

pending++;

rb_fd_set(fptr-&gt;fd, &amp;fds[<literal type="number">3</literal>]);

}

if (max &lt; fptr-&gt;fd) max = fptr-&gt;fd;

}

if (pending) { 

timerec.tv_sec = timerec.tv_usec = <literal type="number">0</literal>;

tp = &amp;timerec;

}

rp = &amp;fds[<literal type="number">0</literal>];

}

else

rp = <literal type="number">0</literal>;

if (!NIL_P(write)) {

Check_Type(write, T_ARRAY);

for (i=<literal type="number">0</literal>; i&lt;RARRAY_LEN(write); i++) {

VALUE write_io = GetWriteIO(rb_io_get_io(RARRAY_AREF(write, i)));

GetOpenFile(write_io, fptr);

rb_fd_set(fptr-&gt;fd, &amp;fds[<literal type="number">1</literal>]);

if (max &lt; fptr-&gt;fd) max = fptr-&gt;fd;

}

wp = &amp;fds[<literal type="number">1</literal>];

}

else

wp = <literal type="number">0</literal>;

if (!NIL_P(except)) {

Check_Type(except, T_ARRAY);

for (i=<literal type="number">0</literal>; i&lt;RARRAY_LEN(except); i++) {

VALUE io = rb_io_get_io(RARRAY_AREF(except, i));

VALUE write_io = GetWriteIO(io);

GetOpenFile(io, fptr);

rb_fd_set(fptr-&gt;fd, &amp;fds[<literal type="number">2</literal>]);

if (max &lt; fptr-&gt;fd) max = fptr-&gt;fd;

if (io != write_io) {

GetOpenFile(write_io, fptr);

rb_fd_set(fptr-&gt;fd, &amp;fds[<literal type="number">2</literal>]);

if (max &lt; fptr-&gt;fd) max = fptr-&gt;fd;

}

}

ep = &amp;fds[<literal type="number">2</literal>];

}

else {

ep = <literal type="number">0</literal>;

}

max++;

n = rb_thread_fd_select(max, rp, wp, ep, tp);

if (n &lt; <literal type="number">0</literal>) {

rb_sys_fail(<literal type="number">0</literal>);

}

if (!pending &amp;&amp; n == <literal type="number">0</literal>) return Qnil; 

res = rb_ary_new2(<literal type="number">3</literal>);

rb_ary_push(res, rp?rb_ary_new():rb_ary_new2(<literal type="number">0</literal>));

rb_ary_push(res, wp?rb_ary_new():rb_ary_new2(<literal type="number">0</literal>));

rb_ary_push(res, ep?rb_ary_new():rb_ary_new2(<literal type="number">0</literal>));

if (rp) {

list = RARRAY_AREF(res, <literal type="number">0</literal>);

for (i=<literal type="number">0</literal>; i&lt; RARRAY_LEN(read); i++) {

VALUE obj = rb_ary_entry(read, i);

VALUE io = rb_io_get_io(obj);

GetOpenFile(io, fptr);

if (rb_fd_isset(fptr-&gt;fd, &amp;fds[<literal type="number">0</literal>]) ||

rb_fd_isset(fptr-&gt;fd, &amp;fds[<literal type="number">3</literal>])) {

rb_ary_push(list, obj);

}

}

}

if (wp) {

list = RARRAY_AREF(res, <literal type="number">1</literal>);

for (i=<literal type="number">0</literal>; i&lt; RARRAY_LEN(write); i++) {

VALUE obj = rb_ary_entry(write, i);

VALUE io = rb_io_get_io(obj);

VALUE write_io = GetWriteIO(io);

GetOpenFile(write_io, fptr);

if (rb_fd_isset(fptr-&gt;fd, &amp;fds[<literal type="number">1</literal>])) {

rb_ary_push(list, obj);

}

}

}

if (ep) {

list = RARRAY_AREF(res, <literal type="number">2</literal>);

for (i=<literal type="number">0</literal>; i&lt; RARRAY_LEN(except); i++) {

VALUE obj = rb_ary_entry(except, i);

VALUE io = rb_io_get_io(obj);

VALUE write_io = GetWriteIO(io);

GetOpenFile(io, fptr);

if (rb_fd_isset(fptr-&gt;fd, &amp;fds[<literal type="number">2</literal>])) {

rb_ary_push(list, obj);

}

else if (io != write_io) {

GetOpenFile(write_io, fptr);

if (rb_fd_isset(fptr-&gt;fd, &amp;fds[<literal type="number">2</literal>])) {

rb_ary_push(list, obj);

}

}

}

}

return res; 

}

struct select_args {

VALUE read</argument>, <argument>write</argument>, <argument>except;

struct timeval *timeout;

rb_fdset_t fdsets[<literal type="number">4</literal>];

};

static VALUE

select_call(VALUE arg)

{

struct select_args *p = (struct select_args *)arg;

return select_internal(p-&gt;read, p-&gt;write, p-&gt;except, p-&gt;timeout, p-&gt;fdsets);

}

static VALUE

select_end(VALUE arg)

{

struct select_args *p = (struct select_args *)arg;

int i;

for (i = <literal type="number">0</literal>; i &lt; numberof(p-&gt;fdsets); ++i)

rb_fd_term(&amp;p-&gt;fdsets[i]);

return Qnil;

}

static VALUE sym_normal</argument>, <argument>sym_sequential</argument>, <argument>sym_random</argument>,

<argument>sym_willneed</argument>, <argument>sym_dontneed</argument>, <argument>sym_noreuse;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POSIX_FADVISE</name></expr></argument>)</argument_list></call></expr></cpp:if>
struct io_advise_struct {

int fd;

int advice;

off_t offset;

off_t len;

};

static VALUE

io_advise_internal(void *arg)

{

struct io_advise_struct *ptr = arg;

return posix_fadvise(ptr-&gt;fd, ptr-&gt;offset, ptr-&gt;len, ptr-&gt;advice);

}

static VALUE

io_advise_sym_to_const(VALUE sym)

{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_NORMAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (sym == sym_normal)

return INT2NUM(POSIX_FADV_NORMAL);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_RANDOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (sym == sym_random)

return INT2NUM(POSIX_FADV_RANDOM);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_SEQUENTIAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (sym == sym_sequential)

return INT2NUM(POSIX_FADV_SEQUENTIAL);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_WILLNEED</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (sym == sym_willneed)

return INT2NUM(POSIX_FADV_WILLNEED);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_DONTNEED</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (sym == sym_dontneed)

return INT2NUM(POSIX_FADV_DONTNEED);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_FADV_NOREUSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (sym == sym_noreuse)

return INT2NUM(POSIX_FADV_NOREUSE);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return Qnil;

}

static VALUE

do_io_advise(rb_io_t *fptr, VALUE advice, off_t offset, off_t len)

{

int rv;

struct io_advise_struct ias;

VALUE num_adv;

num_adv = io_advise_sym_to_const(advice);

if (NIL_P(num_adv))

return Qnil;

ias.fd = fptr-&gt;fd;

ias.advice = NUM2INT(num_adv);

ias.offset = offset;

ias.len = len;

rv = (int)rb_thread_io_blocking_region(io_advise_internal, &amp;ias, fptr-&gt;fd);

if (rv &amp;&amp; rv != ENOSYS) {

VALUE message = rb_sprintf(<literal type="string">"%"</literal>PRIsVALUE<literal type="string">" "</literal>

<literal type="string">"(%"</literal>PRI_OFFT_PREFIX<literal type="string">"d, "</literal>

<literal type="string">"%"</literal>PRI_OFFT_PREFIX<literal type="string">"d, "</literal>

<literal type="string">"%"</literal>PRIsVALUE<literal type="string">")"</literal>,

fptr-&gt;pathv, offset, len, advice);

rb_syserr_fail_str(rv, message);

}

return Qnil;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

static void

advice_arg_check(VALUE advice)

{

if (!SYMBOL_P(advice))

rb_raise(rb_eTypeError, <literal type="string">"advice must be a Symbol"</literal>);

if (advice != sym_normal &amp;&amp;

advice != sym_sequential &amp;&amp;

advice != sym_random &amp;&amp;

advice != sym_willneed &amp;&amp;

advice != sym_dontneed &amp;&amp;

advice != sym_noreuse) {

rb_raise(rb_eNotImpError, <literal type="string">"Unsupported advice: %+"</literal>PRIsVALUE, advice);

}

}

static VALUE

rb_io_advise(int argc, VALUE *argv, VALUE io)

{

VALUE advice</argument>, <argument>offset</argument>, <argument>len;

off_t off</argument>, <argument>l;

rb_io_t *fptr;

rb_scan_args(argc, argv, <literal type="string">"12"</literal>, &amp;advice, &amp;offset, &amp;len);

advice_arg_check(advice);

io = GetWriteIO(io);

GetOpenFile(io, fptr);

off = NIL_P(offset) ? <literal type="number">0</literal> : NUM2OFFT(offset);

l = NIL_P(len) ? <literal type="number">0</literal> : NUM2OFFT(len);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POSIX_FADVISE</name></expr></argument>)</argument_list></call></expr></cpp:if>
return do_io_advise(fptr, advice, off, l);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

((void)off, (void)l); 

return Qnil;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

static VALUE

rb_f_select(int argc, VALUE *argv, VALUE obj)

{

VALUE timeout;

struct select_args args;

struct timeval timerec;

int i;

rb_scan_args(argc, argv, <literal type="string">"13"</literal>, &amp;args.read, &amp;args.write, &amp;args.except, &amp;timeout);

if (NIL_P(timeout)) {

args.timeout = <literal type="number">0</literal>;

}

else {

timerec = rb_time_interval(timeout);

args.timeout = &amp;timerec;

}

for (i = <literal type="number">0</literal>; i &lt; numberof(args.fdsets); ++i)

rb_fd_init(&amp;args.fdsets[i]);

return rb_ensure(select_call, (VALUE)&amp;args, select_end, (VALUE)&amp;args);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__ANDROID__</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>

typedef unsigned long ioctl_req_t;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2IOCTLREQ</name><parameter_list>(<parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2ULONG(num)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

typedef int ioctl_req_t;

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2IOCTLREQ</name><parameter_list>(<parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int)NUM2LONG(num))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_IOCTL</name></expr></argument>)</argument_list></call></expr></cpp:if>
struct ioctl_arg {

int fd;

ioctl_req_t cmd;

long narg;

};

static VALUE

nogvl_ioctl(void *ptr)

{

struct ioctl_arg *arg = ptr;

return (VALUE)ioctl(arg-&gt;fd, arg-&gt;cmd, arg-&gt;narg);

}

static int

do_ioctl(int fd, ioctl_req_t cmd, long narg)

{

int retval;

struct ioctl_arg arg;

arg.fd = fd;

arg.cmd = cmd;

arg.narg = narg;

retval = (int)rb_thread_io_blocking_region(nogvl_ioctl, &amp;arg, fd);

return retval;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFULT_IOCTL_NARG_LEN</name></cpp:macro> <cpp:value>(256)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_IOC_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>

static long

linux_iocparm_len(ioctl_req_t cmd)

{

long len;

if ((cmd &amp; <literal type="number">0xFFFF0000</literal>) == <literal type="number">0</literal>) {

return DEFULT_IOCTL_NARG_LEN;

}

len = _IOC_SIZE(cmd);

if (len &lt; DEFULT_IOCTL_NARG_LEN)

len = DEFULT_IOCTL_NARG_LEN;

return len;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static long

ioctl_narg_len(ioctl_req_t cmd)

{

long len;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IOCPARM_MASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IOCPARM_LEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOCPARM_LEN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((x) &gt;&gt; 16) &amp; IOCPARM_MASK)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IOCPARM_LEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
len = IOCPARM_LEN(cmd); 

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_IOC_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:elif>

len = linux_iocparm_len(cmd);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

len = DEFULT_IOCTL_NARG_LEN;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return len;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
typedef long fcntl_arg_t;

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

typedef int fcntl_arg_t;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static long

fcntl_narg_len(int cmd)

{

long len;

switch (cmd) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_DUPFD</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_DUPFD:

len = sizeof(fcntl_arg_t);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_DUP2FD</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_DUP2FD:

len = sizeof(int);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_DUPFD_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_DUPFD_CLOEXEC:

len = sizeof(fcntl_arg_t);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_GETFD:

len = <literal type="number">1</literal>;

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_SETFD</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_SETFD:

len = sizeof(fcntl_arg_t);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_GETFL:

len = <literal type="number">1</literal>;

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_SETFL</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_SETFL:

len = sizeof(fcntl_arg_t);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_GETOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_GETOWN:

len = <literal type="number">1</literal>;

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_SETOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_SETOWN:

len = sizeof(fcntl_arg_t);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_GETOWN_EX</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_GETOWN_EX:

len = sizeof(struct f_owner_ex);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_SETOWN_EX</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_SETOWN_EX:

len = sizeof(struct f_owner_ex);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_GETLK</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_GETLK:

len = sizeof(struct flock);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_SETLK</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_SETLK:

len = sizeof(struct flock);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_SETLKW</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_SETLKW:

len = sizeof(struct flock);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_READAHEAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_READAHEAD:

len = sizeof(int);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_RDAHEAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_RDAHEAD:

len = sizeof(int);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_GETSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_GETSIG:

len = <literal type="number">1</literal>;

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_SETSIG</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_SETSIG:

len = sizeof(fcntl_arg_t);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_GETLEASE</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_GETLEASE:

len = <literal type="number">1</literal>;

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_SETLEASE</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_SETLEASE:

len = sizeof(fcntl_arg_t);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_NOTIFY</name></expr></argument>)</argument_list></call></expr></cpp:if>
case F_NOTIFY:

len = sizeof(fcntl_arg_t);

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

default:

len = <literal type="number">256</literal>;

break;

}

return len;

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

static long

fcntl_narg_len(int cmd)

{

return <literal type="number">0</literal>;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

static long

setup_narg(ioctl_req_t cmd, VALUE *argp, int io_p)

{

long narg = <literal type="number">0</literal>;

VALUE arg = *argp;

if (NIL_P(arg) || arg == Qfalse) {

narg = <literal type="number">0</literal>;

}

else if (FIXNUM_P(arg)) {

narg = FIX2LONG(arg);

}

else if (arg == Qtrue) {

narg = <literal type="number">1</literal>;

}

else {

VALUE tmp = rb_check_string_type(arg);

if (NIL_P(tmp)) {

narg = NUM2LONG(arg);

}

else {

char *ptr;

long len</argument>, <argument>slen;

*argp = arg = tmp;

if (io_p)

len = ioctl_narg_len(cmd);

else

len = fcntl_narg_len((int)cmd);

rb_str_modify(arg);

slen = RSTRING_LEN(arg);

if (slen &lt; len+<literal type="number">1</literal>) {

rb_str_resize(arg, len+<literal type="number">1</literal>);

MEMZERO(RSTRING_PTR(arg)+slen, char, len-slen);

slen = len+<literal type="number">1</literal>;

}

ptr = RSTRING_PTR(arg);

ptr[slen - <literal type="number">1</literal>] = <literal type="number">17</literal>;

narg = (long)(SIGNED_VALUE)ptr;

}

}

return narg;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_IOCTL</name></expr></argument>)</argument_list></call></expr></cpp:if>
static VALUE

rb_ioctl(VALUE io, VALUE req, VALUE arg)

{

ioctl_req_t cmd = NUM2IOCTLREQ(req);

rb_io_t *fptr;

long narg;

int retval;

narg = setup_narg(cmd, &amp;arg, <literal type="number">1</literal>);

GetOpenFile(io, fptr);

retval = do_ioctl(fptr-&gt;fd, cmd, narg);

if (retval &lt; <literal type="number">0</literal>) rb_sys_fail_path(fptr-&gt;pathv);

if (RB_TYPE_P(arg, T_STRING)) {

char *ptr;

long slen;

RSTRING_GETMEM(arg, ptr, slen);

if (ptr[slen-<literal type="number">1</literal>] != <literal type="number">17</literal>)

rb_raise(rb_eArgError, <literal type="string">"return value overflowed string"</literal>);

ptr[slen-<literal type="number">1</literal>] = <literal type="char">'\0'</literal>;

}

return INT2NUM(retval);

}

static VALUE

rb_io_ioctl(int argc, VALUE *argv, VALUE io)

{

VALUE req</argument>, <argument>arg;

rb_scan_args(argc, argv, <literal type="string">"11"</literal>, &amp;req, &amp;arg);

return rb_ioctl(io, req, arg);

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_io_ioctl</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL</name></expr></argument>)</argument_list></call></expr></cpp:if>
struct fcntl_arg {

int fd;

int cmd;

long narg;

};

static VALUE

nogvl_fcntl(void *ptr)

{

struct fcntl_arg *arg = ptr;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_DUPFD</name></expr></argument>)</argument_list></call></expr></cpp:if>

if (arg-&gt;cmd == F_DUPFD)

return (VALUE)rb_cloexec_fcntl_dupfd(arg-&gt;fd, (int)arg-&gt;narg);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return (VALUE)fcntl(arg-&gt;fd, arg-&gt;cmd, arg-&gt;narg);

}

static int

do_fcntl(int fd, int cmd, long narg)

{

int retval;

struct fcntl_arg arg;

arg.fd = fd;

arg.cmd = cmd;

arg.narg = narg;

retval = (int)rb_thread_io_blocking_region(nogvl_fcntl, &amp;arg, fd);

if (retval != -<literal type="number">1</literal>) {

switch (cmd) {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_DUPFD</name></expr></argument>)</argument_list></call></expr></cpp:if>

case F_DUPFD:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>F_DUPFD_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

case F_DUPFD_CLOEXEC:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_update_max_fd(retval);

}

}

return retval;

}

static VALUE

rb_fcntl(VALUE io, VALUE req, VALUE arg)

{

int cmd = NUM2INT(req);

rb_io_t *fptr;

long narg;

int retval;

narg = setup_narg(cmd, &amp;arg, <literal type="number">0</literal>);

GetOpenFile(io, fptr);

retval = do_fcntl(fptr-&gt;fd, cmd, narg);

if (retval &lt; <literal type="number">0</literal>) rb_sys_fail_path(fptr-&gt;pathv);

if (RB_TYPE_P(arg, T_STRING)) {

char *ptr;

long slen;

RSTRING_GETMEM(arg, ptr, slen);

if (ptr[slen-<literal type="number">1</literal>] != <literal type="number">17</literal>)

rb_raise(rb_eArgError, <literal type="string">"return value overflowed string"</literal>);

ptr[slen-<literal type="number">1</literal>] = <literal type="char">'\0'</literal>;

}

return INT2NUM(retval);

}

static VALUE

rb_io_fcntl(int argc, VALUE *argv, VALUE io)

{

VALUE req</argument>, <argument>arg;

rb_scan_args(argc, argv, <literal type="string">"11"</literal>, &amp;req, &amp;arg);

return rb_fcntl(io, req, arg);

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_io_fcntl</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCALL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE___SYSCALL</name></expr></argument>)</argument_list></call></expr></cpp:if>

static VALUE

rb_f_syscall(int argc, VALUE *argv, VALUE _)

{

VALUE arg[<literal type="number">8</literal>];

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOIDP</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE___SYSCALL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SIZEOF_INT</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYSCALL</name></cpp:macro> <cpp:value>__syscall</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2SYSCALLID</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2LONG(x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETVAL2NUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LONG2NUM(x)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>

long num</argument>, <argument>retval = -<literal type="number">1</literal>;

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:elif>

long long num</argument>, <argument>retval = -<literal type="number">1</literal>;

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:error>#<cpp:directive>error</cpp:directive> ----&gt;&gt; it is asserted that __syscall takes the first argument and returns retval in 64bit signed integer. &lt;&lt;----</cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYSCALL</name></cpp:macro> <cpp:value>syscall</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2SYSCALLID</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2LONG(x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETVAL2NUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LONG2NUM(x)</cpp:value></cpp:define>

long num</argument>, <argument>retval = -<literal type="number">1</literal>;

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYSCALL</name></cpp:macro> <cpp:value>syscall</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2SYSCALLID</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2INT(x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETVAL2NUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>INT2NUM(x)</cpp:value></cpp:define>

int num</argument>, <argument>retval = -<literal type="number">1</literal>;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

int i;

if (RTEST(ruby_verbose)) {

rb_warning(<literal type="string">"We plan to remove a syscall function at future release. DL(Fiddle) provides safer alternative."</literal>);

}

if (argc == <literal type="number">0</literal>)

rb_raise(rb_eArgError, <literal type="string">"too few arguments for syscall"</literal>);

if (argc &gt; numberof(arg))

rb_raise(rb_eArgError, <literal type="string">"too many arguments for syscall"</literal>);

num = NUM2SYSCALLID(argv[<literal type="number">0</literal>]); ++argv;

for (i = argc - <literal type="number">1</literal>; i--; ) {

VALUE v = rb_check_string_type(argv[i]);

if (!NIL_P(v)) {

SafeStringValue(v);

rb_str_modify(v);

arg[i] = (VALUE)StringValueCStr(v);

}

else {

arg[i] = (VALUE)NUM2LONG(argv[i]);

}

}

switch (argc) {

case <literal type="number">1</literal>:

retval = SYSCALL(num);

break;

case <literal type="number">2</literal>:

retval = SYSCALL(num, arg[<literal type="number">0</literal>]);

break;

case <literal type="number">3</literal>:

retval = SYSCALL(num, arg[<literal type="number">0</literal>],arg[<literal type="number">1</literal>]);

break;

case <literal type="number">4</literal>:

retval = SYSCALL(num, arg[<literal type="number">0</literal>],arg[<literal type="number">1</literal>],arg[<literal type="number">2</literal>]);

break;

case <literal type="number">5</literal>:

retval = SYSCALL(num, arg[<literal type="number">0</literal>],arg[<literal type="number">1</literal>],arg[<literal type="number">2</literal>],arg[<literal type="number">3</literal>]);

break;

case <literal type="number">6</literal>:

retval = SYSCALL(num, arg[<literal type="number">0</literal>],arg[<literal type="number">1</literal>],arg[<literal type="number">2</literal>],arg[<literal type="number">3</literal>],arg[<literal type="number">4</literal>]);

break;

case <literal type="number">7</literal>:

retval = SYSCALL(num, arg[<literal type="number">0</literal>],arg[<literal type="number">1</literal>],arg[<literal type="number">2</literal>],arg[<literal type="number">3</literal>],arg[<literal type="number">4</literal>],arg[<literal type="number">5</literal>]);

break;

case <literal type="number">8</literal>:

retval = SYSCALL(num, arg[<literal type="number">0</literal>],arg[<literal type="number">1</literal>],arg[<literal type="number">2</literal>],arg[<literal type="number">3</literal>],arg[<literal type="number">4</literal>],arg[<literal type="number">5</literal>],arg[<literal type="number">6</literal>]);

break;

}

if (retval == -<literal type="number">1</literal>)

rb_sys_fail(<literal type="number">0</literal>);

return RETVAL2NUM(retval);

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SYSCALL</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM2SYSCALLID</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RETVAL2NUM</name></cpp:undef>

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_f_syscall</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static VALUE

io_new_instance(VALUE args)

{

return rb_class_new_instance(<literal type="number">2</literal>, (VALUE*)args+<literal type="number">1</literal>, *(VALUE*)args);

}

static rb_encoding *

find_encoding(VALUE v)

{

rb_encoding *enc = rb_find_encoding(v);

if (!enc) rb_warn(<literal type="string">"Unsupported encoding %"</literal>PRIsVALUE<literal type="string">" ignored"</literal>, v);

return enc;

}

static void

io_encoding_set(rb_io_t *fptr, VALUE v1, VALUE v2, VALUE opt)

{

rb_encoding *enc</argument>, <argument>*enc2;

int ecflags = fptr-&gt;encs.ecflags;

VALUE ecopts</argument>, <argument>tmp;

if (!NIL_P(v2)) {

enc2 = find_encoding(v1);

tmp = rb_check_string_type(v2);

if (!NIL_P(tmp)) {

if (RSTRING_LEN(tmp) == <literal type="number">1</literal> &amp;&amp; RSTRING_PTR(tmp)[<literal type="number">0</literal>] == <literal type="char">'-'</literal>) {

enc = enc2;

enc2 = NULL;

}

else

enc = find_encoding(v2);

if (enc == enc2) {

enc2 = NULL;

}

}

else {

enc = find_encoding(v2);

if (enc == enc2) {

enc2 = NULL;

}

}

SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(enc2, ecflags);

ecflags = rb_econv_prepare_options(opt, &amp;ecopts, ecflags);

}

else {

if (NIL_P(v1)) {

rb_io_ext_int_to_encs(NULL, NULL, &amp;enc, &amp;enc2, <literal type="number">0</literal>);

SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(enc2, ecflags);

ecopts = Qnil;

}

else {

tmp = rb_check_string_type(v1);

if (!NIL_P(tmp) &amp;&amp; rb_enc_asciicompat(enc = rb_enc_get(tmp))) {

parse_mode_enc(RSTRING_PTR(tmp), enc, &amp;enc, &amp;enc2, NULL);

SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(enc2, ecflags);

ecflags = rb_econv_prepare_options(opt, &amp;ecopts, ecflags);

}

else {

rb_io_ext_int_to_encs(find_encoding(v1), NULL, &amp;enc, &amp;enc2, <literal type="number">0</literal>);

SET_UNIVERSAL_NEWLINE_DECORATOR_IF_ENC2(enc2, ecflags);

ecopts = Qnil;

}

}

}

validate_enc_binmode(&amp;fptr-&gt;mode, ecflags, enc, enc2);

fptr-&gt;encs.enc = enc;

fptr-&gt;encs.enc2 = enc2;

fptr-&gt;encs.ecflags = ecflags;

fptr-&gt;encs.ecopts = ecopts;

clear_codeconv(fptr);

}

struct io_encoding_set_args {

rb_io_t *fptr;

VALUE v1;

VALUE v2;

VALUE opt;

};

static VALUE

io_encoding_set_v(VALUE v)

{

struct io_encoding_set_args *arg = (struct io_encoding_set_args *)v;

io_encoding_set(arg-&gt;fptr, arg-&gt;v1, arg-&gt;v2, arg-&gt;opt);

return Qnil;

}

static VALUE

pipe_pair_close(VALUE rw)

{

VALUE *rwp = (VALUE *)rw;

return rb_ensure(io_close, rwp[<literal type="number">0</literal>], io_close, rwp[<literal type="number">1</literal>]);

}

static VALUE

rb_io_s_pipe(int argc, VALUE *argv, VALUE klass)

{

int pipes[<literal type="number">2</literal>]</argument>, <argument>state;

VALUE r</argument>, <argument>w</argument>, <argument>args[<literal type="number">3</literal>]</argument>, <argument>v1</argument>, <argument>v2;

VALUE opt;

rb_io_t *fptr</argument>, <argument>*fptr2;

struct io_encoding_set_args ies_args;

int fmode = <literal type="number">0</literal>;

VALUE ret;

argc = rb_scan_args(argc, argv, <literal type="string">"02:"</literal>, &amp;v1, &amp;v2, &amp;opt);

if (rb_pipe(pipes) &lt; <literal type="number">0</literal>)

rb_sys_fail(<literal type="number">0</literal>);

args[<literal type="number">0</literal>] = klass;

args[<literal type="number">1</literal>] = INT2NUM(pipes[<literal type="number">0</literal>]);

args[<literal type="number">2</literal>] = INT2FIX(O_RDONLY);

r = rb_protect(io_new_instance, (VALUE)args, &amp;state);

if (state) {

close(pipes[<literal type="number">0</literal>]);

close(pipes[<literal type="number">1</literal>]);

rb_jump_tag(state);

}

GetOpenFile(r, fptr);

ies_args.fptr = fptr;

ies_args.v1 = v1;

ies_args.v2 = v2;

ies_args.opt = opt;

rb_protect(io_encoding_set_v, (VALUE)&amp;ies_args, &amp;state);

if (state) {

close(pipes[<literal type="number">1</literal>]);

io_close(r);

rb_jump_tag(state);

}

args[<literal type="number">1</literal>] = INT2NUM(pipes[<literal type="number">1</literal>]);

args[<literal type="number">2</literal>] = INT2FIX(O_WRONLY);

w = rb_protect(io_new_instance, (VALUE)args, &amp;state);

if (state) {

close(pipes[<literal type="number">1</literal>]);

if (!NIL_P(r)) rb_io_close(r);

rb_jump_tag(state);

}

GetOpenFile(w, fptr2);

rb_io_synchronized(fptr2);

extract_binmode(opt, &amp;fmode);

if ((fmode &amp; FMODE_BINMODE) &amp;&amp; v1 == Qnil) {

rb_io_ascii8bit_binmode(r);

rb_io_ascii8bit_binmode(w);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_TEXTMODE</name></expr></cpp:if>

if ((fptr-&gt;mode &amp; FMODE_TEXTMODE) &amp;&amp; (fmode &amp; FMODE_BINMODE)) {

fptr-&gt;mode &amp;= ~FMODE_TEXTMODE;

setmode(fptr-&gt;fd, O_BINARY);

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_TEST_CRLF_ENVIRONMENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

if (fptr-&gt;encs.ecflags &amp; ECONV_DEFAULT_NEWLINE_DECORATOR) {

fptr-&gt;encs.ecflags |= ECONV_UNIVERSAL_NEWLINE_DECORATOR;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

fptr-&gt;mode |= fmode;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEFAULT_TEXTMODE</name></expr></cpp:if>

if ((fptr2-&gt;mode &amp; FMODE_TEXTMODE) &amp;&amp; (fmode &amp; FMODE_BINMODE)) {

fptr2-&gt;mode &amp;= ~FMODE_TEXTMODE;

setmode(fptr2-&gt;fd, O_BINARY);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

fptr2-&gt;mode |= fmode;

ret = rb_assoc_new(r, w);

if (rb_block_given_p()) {

VALUE rw[<literal type="number">2</literal>];

rw[<literal type="number">0</literal>] = r;

rw[<literal type="number">1</literal>] = w;

return rb_ensure(rb_yield, ret, pipe_pair_close, (VALUE)rw);

}

return ret;

}

struct foreach_arg {

int argc;

VALUE *argv;

VALUE io;

};

static void

open_key_args(VALUE klass, int argc, VALUE *argv, VALUE opt, struct foreach_arg *arg)

{

VALUE path</argument>, <argument>v;

VALUE vmode = Qnil</argument>, <argument>vperm = Qnil;

path = *argv++;

argc--;

FilePathValue(path);

arg-&gt;io = <literal type="number">0</literal>;

arg-&gt;argc = argc;

arg-&gt;argv = argv;

if (NIL_P(opt)) {

vmode = INT2NUM(O_RDONLY);

vperm = INT2FIX(<literal type="number">0666</literal>);

}

else if (!NIL_P(v = rb_hash_aref(opt, sym_open_args))) {

int n;

v = rb_to_array_type(v);

n = RARRAY_LENINT(v);

rb_check_arity(n, <literal type="number">0</literal>, <literal type="number">3</literal>); 

rb_scan_args_kw(RB_SCAN_ARGS_LAST_HASH_KEYWORDS, n, RARRAY_CONST_PTR(v), <literal type="string">"02:"</literal>, &amp;vmode, &amp;vperm, &amp;opt);

}

arg-&gt;io = rb_io_open(klass, path, vmode, vperm, opt);

}

static VALUE

io_s_foreach(VALUE v)

{

struct getline_arg *arg = (void *)v;

VALUE str;

while (!NIL_P(str = rb_io_getline_1(arg-&gt;rs, arg-&gt;limit, arg-&gt;chomp, arg-&gt;io))) {

rb_lastline_set(str);

rb_yield(str);

}

rb_lastline_set(Qnil);

return Qnil;

}

static VALUE

rb_io_s_foreach(int argc, VALUE *argv, VALUE self)

{

VALUE opt;

int orig_argc = argc;

struct foreach_arg arg;

struct getline_arg garg;

argc = rb_scan_args(argc, argv, <literal type="string">"13:"</literal>, NULL, NULL, NULL, NULL, &amp;opt);

RETURN_ENUMERATOR(self, orig_argc, argv);

extract_getline_args(argc-<literal type="number">1</literal>, argv+<literal type="number">1</literal>, &amp;garg);

open_key_args(self, argc, argv, opt, &amp;arg);

if (NIL_P(arg.io)) return Qnil;

extract_getline_opts(opt, &amp;garg);

check_getline_args(&amp;garg.rs, &amp;garg.limit, garg.io = arg.io);

return rb_ensure(io_s_foreach, (VALUE)&amp;garg, rb_io_close, arg.io);

}

static VALUE

io_s_readlines(VALUE v)

{

struct getline_arg *arg = (void *)v;

return io_readlines(arg, arg-&gt;io);

}

static VALUE

rb_io_s_readlines(int argc, VALUE *argv, VALUE io)

{

VALUE opt;

struct foreach_arg arg;

struct getline_arg garg;

argc = rb_scan_args(argc, argv, <literal type="string">"13:"</literal>, NULL, NULL, NULL, NULL, &amp;opt);

extract_getline_args(argc-<literal type="number">1</literal>, argv+<literal type="number">1</literal>, &amp;garg);

open_key_args(io, argc, argv, opt, &amp;arg);

if (NIL_P(arg.io)) return Qnil;

extract_getline_opts(opt, &amp;garg);

check_getline_args(&amp;garg.rs, &amp;garg.limit, garg.io = arg.io);

return rb_ensure(io_s_readlines, (VALUE)&amp;garg, rb_io_close, arg.io);

}

static VALUE

io_s_read(VALUE v)

{

struct foreach_arg *arg = (void *)v;

return io_read(arg-&gt;argc, arg-&gt;argv, arg-&gt;io);

}

struct seek_arg {

VALUE io;

VALUE offset;

int mode;

};

static VALUE

seek_before_access(VALUE argp)

{

struct seek_arg *arg = (struct seek_arg *)argp;

rb_io_binmode(arg-&gt;io);

return rb_io_seek(arg-&gt;io, arg-&gt;offset, arg-&gt;mode);

}

static VALUE

rb_io_s_read(int argc, VALUE *argv, VALUE io)

{

VALUE opt</argument>, <argument>offset;

struct foreach_arg arg;

argc = rb_scan_args(argc, argv, <literal type="string">"13:"</literal>, NULL, NULL, &amp;offset, NULL, &amp;opt);

open_key_args(io, argc, argv, opt, &amp;arg);

if (NIL_P(arg.io)) return Qnil;

if (!NIL_P(offset)) {

struct seek_arg sarg;

int state = <literal type="number">0</literal>;

sarg.io = arg.io;

sarg.offset = offset;

sarg.mode = SEEK_SET;

rb_protect(seek_before_access, (VALUE)&amp;sarg, &amp;state);

if (state) {

rb_io_close(arg.io);

rb_jump_tag(state);

}

if (arg.argc == <literal type="number">2</literal>) arg.argc = <literal type="number">1</literal>;

}

return rb_ensure(io_s_read, (VALUE)&amp;arg, rb_io_close, arg.io);

}

static VALUE

rb_io_s_binread(int argc, VALUE *argv, VALUE io)

{

VALUE offset;

struct foreach_arg arg;

enum {

fmode = FMODE_READABLE|FMODE_BINMODE</argument>,

<argument>oflags = O_RDONLY

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
|O_BINARY

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

};

convconfig_t convconfig = {NULL</argument>, <argument>NULL</argument>, <argument><literal type="number">0</literal></argument>, <argument>Qnil};

rb_scan_args(argc, argv, <literal type="string">"12"</literal>, NULL, NULL, &amp;offset);

FilePathValue(argv[<literal type="number">0</literal>]);

convconfig.enc = rb_ascii8bit_encoding();

arg.io = rb_io_open_generic(io, argv[<literal type="number">0</literal>], oflags, fmode, &amp;convconfig, <literal type="number">0</literal>);

if (NIL_P(arg.io)) return Qnil;

arg.argv = argv+<literal type="number">1</literal>;

arg.argc = (argc &gt; <literal type="number">1</literal>) ? <literal type="number">1</literal> : <literal type="number">0</literal>;

if (!NIL_P(offset)) {

struct seek_arg sarg;

int state = <literal type="number">0</literal>;

sarg.io = arg.io;

sarg.offset = offset;

sarg.mode = SEEK_SET;

rb_protect(seek_before_access, (VALUE)&amp;sarg, &amp;state);

if (state) {

rb_io_close(arg.io);

rb_jump_tag(state);

}

}

return rb_ensure(io_s_read, (VALUE)&amp;arg, rb_io_close, arg.io);

}

static VALUE

io_s_write0(VALUE v)

{

struct write_arg *arg = (void * )v;

return io_write(arg-&gt;io,arg-&gt;str,arg-&gt;nosync);

}

static VALUE

io_s_write(int argc, VALUE *argv, VALUE klass, int binary)

{

VALUE string</argument>, <argument>offset</argument>, <argument>opt;

struct foreach_arg arg;

struct write_arg warg;

rb_scan_args(argc, argv, <literal type="string">"21:"</literal>, NULL, &amp;string, &amp;offset, &amp;opt);

if (NIL_P(opt)) opt = rb_hash_new();

else opt = rb_hash_dup(opt);

if (NIL_P(rb_hash_aref(opt,sym_mode))) {

int mode = O_WRONLY|O_CREAT;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (binary) mode |= O_BINARY;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (NIL_P(offset)) mode |= O_TRUNC;

rb_hash_aset(opt,sym_mode,INT2NUM(mode));

}

open_key_args(klass, argc, argv, opt, &amp;arg);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (binary) rb_io_binmode_m(arg.io);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (NIL_P(arg.io)) return Qnil;

if (!NIL_P(offset)) {

struct seek_arg sarg;

int state = <literal type="number">0</literal>;

sarg.io = arg.io;

sarg.offset = offset;

sarg.mode = SEEK_SET;

rb_protect(seek_before_access, (VALUE)&amp;sarg, &amp;state);

if (state) {

rb_io_close(arg.io);

rb_jump_tag(state);

}

}

warg.io = arg.io;

warg.str = string;

warg.nosync = <literal type="number">0</literal>;

return rb_ensure(io_s_write0, (VALUE)&amp;warg, rb_io_close, arg.io);

}

static VALUE

rb_io_s_write(int argc, VALUE *argv, VALUE io)

{

return io_s_write(argc, argv, io, <literal type="number">0</literal>);

}

static VALUE

rb_io_s_binwrite(int argc, VALUE *argv, VALUE io)

{

return io_s_write(argc, argv, io, <literal type="number">1</literal>);

}

struct copy_stream_struct {

VALUE src;

VALUE dst;

off_t copy_length; 

off_t src_offset; 

int src_fd;

int dst_fd;

unsigned close_src : <literal type="number">1</literal>;

unsigned close_dst : <literal type="number">1</literal>;

int error_no;

off_t total;

const char *syserr;

const char *notimp;

VALUE th;

struct stat src_stat;

struct stat dst_stat;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCOPYFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
copyfile_state_t copyfile_state;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

};

static void *

exec_interrupts(void *arg)

{

VALUE th = (VALUE)arg;

rb_thread_execute_interrupts(th);

return NULL;

}

static int

maygvl_copy_stream_continue_p(int has_gvl, struct copy_stream_struct *stp)

{

switch (errno) {

case EINTR:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ERESTART</name></expr></argument>)</argument_list></call></expr></cpp:if>

case ERESTART:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (rb_thread_interrupted(stp-&gt;th)) {

if (has_gvl)

rb_thread_execute_interrupts(stp-&gt;th);

else

rb_thread_call_with_gvl(exec_interrupts, (void *)stp-&gt;th);

}

return TRUE;

}

return FALSE;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_POLL</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOWAIT_SYSCALL</name></cpp:macro> <cpp:value>"poll"</cpp:value></cpp:define>

STATIC_ASSERT(pollin_expected, POLLIN == RB_WAITFD_IN);

STATIC_ASSERT(pollout_expected, POLLOUT == RB_WAITFD_OUT);

static int

nogvl_wait_for_single_fd(int fd, short events)

{

struct pollfd fds;

fds.fd = fd;

fds.events = events;

return poll(&amp;fds, <literal type="number">1</literal>, -<literal type="number">1</literal>);

}

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOWAIT_SYSCALL</name></cpp:macro> <cpp:value>"select"</cpp:value></cpp:define>

static int

nogvl_wait_for_single_fd(int fd, short events)

{

rb_fdset_t fds;

int ret;

rb_fd_init(&amp;fds);

rb_fd_set(fd, &amp;fds);

switch (events) {

case RB_WAITFD_IN:

ret = rb_fd_select(fd + <literal type="number">1</literal>, &amp;fds, <literal type="number">0</literal>, <literal type="number">0</literal>, <literal type="number">0</literal>);

break;

case RB_WAITFD_OUT:

ret = rb_fd_select(fd + <literal type="number">1</literal>, <literal type="number">0</literal>, &amp;fds, <literal type="number">0</literal>, <literal type="number">0</literal>);

break;

default:

VM_UNREACHABLE(nogvl_wait_for_single_fd);

}

rb_fd_term(&amp;fds);

return ret;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

static int

maygvl_copy_stream_wait_read(int has_gvl, struct copy_stream_struct *stp)

{

int ret;

do {

if (has_gvl) {

ret = rb_wait_for_single_fd(stp-&gt;src_fd, RB_WAITFD_IN, NULL);

}

else {

ret = nogvl_wait_for_single_fd(stp-&gt;src_fd, RB_WAITFD_IN);

}

} while (ret &lt; <literal type="number">0</literal> &amp;&amp; maygvl_copy_stream_continue_p(has_gvl, stp));

if (ret &lt; <literal type="number">0</literal>) {

stp-&gt;syserr = IOWAIT_SYSCALL;

stp-&gt;error_no = errno;

return ret;

}

return <literal type="number">0</literal>;

}

static int

nogvl_copy_stream_wait_write(struct copy_stream_struct *stp)

{

int ret;

do {

ret = nogvl_wait_for_single_fd(stp-&gt;dst_fd, RB_WAITFD_OUT);

} while (ret &lt; <literal type="number">0</literal> &amp;&amp; maygvl_copy_stream_continue_p(<literal type="number">0</literal>, stp));

if (ret &lt; <literal type="number">0</literal>) {

stp-&gt;syserr = IOWAIT_SYSCALL;

stp-&gt;error_no = errno;

return ret;

}

return <literal type="number">0</literal>;

}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_COPY_FILE_RANGE</name> <operator>||</operator> <operator>(</operator><name>defined</name> <name>__linux__</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>__NR_copy_file_range</name><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_COPY_FILE_RANGE</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COPY_FILE_RANGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
static ssize_t

simple_copy_file_range(int in_fd, off_t *in_offset, int out_fd, off_t *out_offset, size_t count, unsigned int flags)

{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_COPY_FILE_RANGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
return copy_file_range(in_fd, in_offset, out_fd, out_offset, count, flags);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

return syscall(__NR_copy_file_range, in_fd, in_offset, out_fd, out_offset, count, flags);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

static int

nogvl_copy_file_range(struct copy_stream_struct *stp)

{

ssize_t ss;

off_t src_size;

off_t copy_length</argument>, <argument>src_offset</argument>, <argument>*src_offset_ptr;

if (!S_ISREG(stp-&gt;src_stat.st_mode))

return <literal type="number">0</literal>;

src_size = stp-&gt;src_stat.st_size;

src_offset = stp-&gt;src_offset;

if (src_offset &gt;= (off_t)<literal type="number">0</literal>) {

src_offset_ptr = &amp;src_offset;

}

else {

src_offset_ptr = NULL; 

}

copy_length = stp-&gt;copy_length;

if (copy_length &lt; (off_t)<literal type="number">0</literal>) {

if (src_offset &lt; (off_t)<literal type="number">0</literal>) {

off_t current_offset;

errno = <literal type="number">0</literal>;

current_offset = lseek(stp-&gt;src_fd, <literal type="number">0</literal>, SEEK_CUR);

if (current_offset &lt; (off_t)<literal type="number">0</literal> &amp;&amp; errno) {

stp-&gt;syserr = <literal type="string">"lseek"</literal>;

stp-&gt;error_no = errno;

return (int)current_offset;

}

copy_length = src_size - current_offset;

}

else {

copy_length = src_size - src_offset;

}

}

retry_copy_file_range:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_OFF_T</name> <operator>&gt;</operator> <name>SIZEOF_SIZE_T</name></expr></cpp:if>

ss = (copy_length &gt; (off_t)SSIZE_MAX) ? SSIZE_MAX : (ssize_t)copy_length;

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

ss = (ssize_t)copy_length;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

ss = simple_copy_file_range(stp-&gt;src_fd, src_offset_ptr, stp-&gt;dst_fd, NULL, ss, <literal type="number">0</literal>);

if (<literal type="number">0</literal> &lt; ss) {

stp-&gt;total += ss;

copy_length -= ss;

if (<literal type="number">0</literal> &lt; copy_length) {

goto retry_copy_file_range;

}

}

if (ss &lt; <literal type="number">0</literal>) {

if (maygvl_copy_stream_continue_p(<literal type="number">0</literal>, stp)) {

goto retry_copy_file_range;

}

switch (errno) {

case EINVAL:

case EPERM: 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENOSYS</name></expr></argument>)</argument_list></call></expr></cpp:if>
case ENOSYS:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
case EXDEV: 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return <literal type="number">0</literal>;

case EAGAIN:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name></expr></cpp:if>

case EWOULDBLOCK:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

{

int ret = nogvl_copy_stream_wait_write(stp);

if (ret &lt; <literal type="number">0</literal>) return ret;

}

goto retry_copy_file_range;

case EBADF:

{

int e = errno;

int flags = fcntl(stp-&gt;dst_fd, F_GETFL);

if (flags != -<literal type="number">1</literal> &amp;&amp; flags &amp; O_APPEND) {

return <literal type="number">0</literal>;

}

errno = e;

}

}

stp-&gt;syserr = <literal type="string">"copy_file_range"</literal>;

stp-&gt;error_no = errno;

return (int)ss;

}

return <literal type="number">1</literal>;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCOPYFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
static int

nogvl_fcopyfile(struct copy_stream_struct *stp)

{

off_t cur</argument>, <argument>ss = <literal type="number">0</literal>;

const off_t src_offset = stp-&gt;src_offset;

int ret;

if (stp-&gt;copy_length &gt;= (off_t)<literal type="number">0</literal>) {

return <literal type="number">0</literal>;

}

if (!S_ISREG(stp-&gt;src_stat.st_mode))

return <literal type="number">0</literal>;

if (!S_ISREG(stp-&gt;dst_stat.st_mode))

return <literal type="number">0</literal>;

if (lseek(stp-&gt;dst_fd, <literal type="number">0</literal>, SEEK_CUR) &gt; (off_t)<literal type="number">0</literal>) 

return <literal type="number">0</literal>;

if (src_offset &gt; (off_t)<literal type="number">0</literal>) {

off_t r;

errno = <literal type="number">0</literal>;

cur = lseek(stp-&gt;src_fd, <literal type="number">0</literal>, SEEK_CUR);

if (cur &lt; (off_t)<literal type="number">0</literal> &amp;&amp; errno) {

stp-&gt;error_no = errno;

return <literal type="number">1</literal>;

}

errno = <literal type="number">0</literal>;

r = lseek(stp-&gt;src_fd, src_offset, SEEK_SET);

if (r &lt; (off_t)<literal type="number">0</literal> &amp;&amp; errno) {

stp-&gt;error_no = errno;

return <literal type="number">1</literal>;

}

}

stp-&gt;copyfile_state = copyfile_state_alloc(); 

ret = fcopyfile(stp-&gt;src_fd, stp-&gt;dst_fd, stp-&gt;copyfile_state, COPYFILE_DATA);

copyfile_state_get(stp-&gt;copyfile_state, COPYFILE_STATE_COPIED, &amp;ss); 

if (ret == <literal type="number">0</literal>) { 

stp-&gt;total = ss;

if (src_offset &gt; (off_t)<literal type="number">0</literal>) {

off_t r;

errno = <literal type="number">0</literal>;

r = lseek(stp-&gt;src_fd, cur, SEEK_SET);

if (r &lt; (off_t)<literal type="number">0</literal> &amp;&amp; errno) {

stp-&gt;error_no = errno;

return <literal type="number">1</literal>;

}

}

}

else {

switch (errno) {

case ENOTSUP:

case EPERM:

case EINVAL:

return <literal type="number">0</literal>;

}

stp-&gt;syserr = <literal type="string">"fcopyfile"</literal>;

stp-&gt;error_no = errno;

return (int)ret;

}

return <literal type="number">1</literal>;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SENDFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_SENDFILE</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_SENDFILE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sendfile.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static ssize_t

simple_sendfile(int out_fd, int in_fd, off_t *offset, off_t count)

{

return sendfile(out_fd, in_fd, offset, (size_t)count);

}

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><literal type="number">0</literal> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_SENDFILE</name></cpp:macro></cpp:define>

static ssize_t

simple_sendfile(int out_fd, int in_fd, off_t *offset, off_t count)

{

int r;

off_t pos = offset ? *offset : lseek(in_fd, <literal type="number">0</literal>, SEEK_CUR);

off_t sbytes;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
r = sendfile(in_fd, out_fd, pos, &amp;count, NULL, <literal type="number">0</literal>);

sbytes = count;

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

r = sendfile(in_fd, out_fd, pos, (size_t)count, NULL, &amp;sbytes, <literal type="number">0</literal>);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (r != <literal type="number">0</literal> &amp;&amp; sbytes == <literal type="number">0</literal>) return r;

if (offset) {

*offset += sbytes;

}

else {

lseek(in_fd, sbytes, SEEK_CUR);

}

return (ssize_t)sbytes;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SENDFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
static int

nogvl_copy_stream_sendfile(struct copy_stream_struct *stp)

{

ssize_t ss;

off_t src_size;

off_t copy_length;

off_t src_offset;

int use_pread;

if (!S_ISREG(stp-&gt;src_stat.st_mode))

return <literal type="number">0</literal>;

src_size = stp-&gt;src_stat.st_size;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
if ((stp-&gt;dst_stat.st_mode &amp; S_IFMT) != S_IFSOCK)

return <literal type="number">0</literal>;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

src_offset = stp-&gt;src_offset;

use_pread = src_offset &gt;= (off_t)<literal type="number">0</literal>;

copy_length = stp-&gt;copy_length;

if (copy_length &lt; (off_t)<literal type="number">0</literal>) {

if (use_pread)

copy_length = src_size - src_offset;

else {

off_t cur;

errno = <literal type="number">0</literal>;

cur = lseek(stp-&gt;src_fd, <literal type="number">0</literal>, SEEK_CUR);

if (cur &lt; (off_t)<literal type="number">0</literal> &amp;&amp; errno) {

stp-&gt;syserr = <literal type="string">"lseek"</literal>;

stp-&gt;error_no = errno;

return (int)cur;

}

copy_length = src_size - cur;

}

}

retry_sendfile:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_OFF_T</name> <operator>&gt;</operator> <name>SIZEOF_SIZE_T</name></expr></cpp:if>

ss = (copy_length &gt; (off_t)SSIZE_MAX) ? SSIZE_MAX : (ssize_t)copy_length;

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

ss = (ssize_t)copy_length;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (use_pread) {

ss = simple_sendfile(stp-&gt;dst_fd, stp-&gt;src_fd, &amp;src_offset, ss);

}

else {

ss = simple_sendfile(stp-&gt;dst_fd, stp-&gt;src_fd, NULL, ss);

}

if (<literal type="number">0</literal> &lt; ss) {

stp-&gt;total += ss;

copy_length -= ss;

if (<literal type="number">0</literal> &lt; copy_length) {

goto retry_sendfile;

}

}

if (ss &lt; <literal type="number">0</literal>) {

if (maygvl_copy_stream_continue_p(<literal type="number">0</literal>, stp))

goto retry_sendfile;

switch (errno) {

case EINVAL:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENOSYS</name></expr></argument>)</argument_list></call></expr></cpp:if>
case ENOSYS:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return <literal type="number">0</literal>;

case EAGAIN:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name></expr></cpp:if>

case EWOULDBLOCK:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

{

int ret;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
ret = maygvl_copy_stream_wait_read(<literal type="number">0</literal>, stp);

if (ret &lt; <literal type="number">0</literal>) return ret;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

ret = nogvl_copy_stream_wait_write(stp);

if (ret &lt; <literal type="number">0</literal>) return ret;

}

goto retry_sendfile;

}

stp-&gt;syserr = <literal type="string">"sendfile"</literal>;

stp-&gt;error_no = errno;

return (int)ss;

}

return <literal type="number">1</literal>;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

static ssize_t

maygvl_read(int has_gvl, int fd, void *buf, size_t count)

{

if (has_gvl)

return rb_read_internal(fd, buf, count);

else

return read(fd, buf, count);

}

static ssize_t

maygvl_copy_stream_read(int has_gvl, struct copy_stream_struct *stp, char *buf, size_t len, off_t offset)

{

ssize_t ss;

retry_read:

if (offset &lt; (off_t)<literal type="number">0</literal>) {

ss = maygvl_read(has_gvl, stp-&gt;src_fd, buf, len);

}

else {

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
ss = pread(stp-&gt;src_fd, buf, len, offset);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

stp-&gt;notimp = <literal type="string">"pread"</literal>;

return -<literal type="number">1</literal>;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

if (ss == <literal type="number">0</literal>) {

return <literal type="number">0</literal>;

}

if (ss &lt; <literal type="number">0</literal>) {

if (maygvl_copy_stream_continue_p(has_gvl, stp))

goto retry_read;

switch (errno) {

case EAGAIN:

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name></expr></cpp:if>

case EWOULDBLOCK:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

{

int ret = maygvl_copy_stream_wait_read(has_gvl, stp);

if (ret &lt; <literal type="number">0</literal>) return ret;

}

goto retry_read;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENOSYS</name></expr></argument>)</argument_list></call></expr></cpp:if>
case ENOSYS:

stp-&gt;notimp = <literal type="string">"pread"</literal>;

return ss;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}

stp-&gt;syserr = offset &lt; (off_t)<literal type="number">0</literal> ? <literal type="string">"read"</literal> : <literal type="string">"pread"</literal>;

stp-&gt;error_no = errno;

}

return ss;

}

static int

nogvl_copy_stream_write(struct copy_stream_struct *stp, char *buf, size_t len)

{

ssize_t ss;

int off = <literal type="number">0</literal>;

while (len) {

ss = write(stp-&gt;dst_fd, buf+off, len);

if (ss &lt; <literal type="number">0</literal>) {

if (maygvl_copy_stream_continue_p(<literal type="number">0</literal>, stp))

continue;

if (errno == EAGAIN || errno == EWOULDBLOCK) {

int ret = nogvl_copy_stream_wait_write(stp);

if (ret &lt; <literal type="number">0</literal>) return ret;

continue;

}

stp-&gt;syserr = <literal type="string">"write"</literal>;

stp-&gt;error_no = errno;

return (int)ss;

}

off += (int)ss;

len -= (int)ss;

stp-&gt;total += ss;

}

return <literal type="number">0</literal>;

}

static void

nogvl_copy_stream_read_write(struct copy_stream_struct *stp)

{

char buf[<literal type="number">1024</literal>*<literal type="number">16</literal>];

size_t len;

ssize_t ss;

int ret;

off_t copy_length;

int use_eof;

off_t src_offset;

int use_pread;

copy_length = stp-&gt;copy_length;

use_eof = copy_length &lt; (off_t)<literal type="number">0</literal>;

src_offset = stp-&gt;src_offset;

use_pread = src_offset &gt;= (off_t)<literal type="number">0</literal>;

if (use_pread &amp;&amp; stp-&gt;close_src) {

off_t r;

errno = <literal type="number">0</literal>;

r = lseek(stp-&gt;src_fd, src_offset, SEEK_SET);

if (r &lt; (off_t)<literal type="number">0</literal> &amp;&amp; errno) {

stp-&gt;syserr = <literal type="string">"lseek"</literal>;

stp-&gt;error_no = errno;

return;

}

src_offset = (off_t)-<literal type="number">1</literal>;

use_pread = <literal type="number">0</literal>;

}

while (use_eof || <literal type="number">0</literal> &lt; copy_length) {

if (!use_eof &amp;&amp; copy_length &lt; (off_t)sizeof(buf)) {

len = (size_t)copy_length;

}

else {

len = sizeof(buf);

}

if (use_pread) {

ss = maygvl_copy_stream_read(<literal type="number">0</literal>, stp, buf, len, src_offset);

if (<literal type="number">0</literal> &lt; ss)

src_offset += ss;

}

else {

ss = maygvl_copy_stream_read(<literal type="number">0</literal>, stp, buf, len, (off_t)-<literal type="number">1</literal>);

}

if (ss &lt;= <literal type="number">0</literal>) 

return;

ret = nogvl_copy_stream_write(stp, buf, ss);

if (ret &lt; <literal type="number">0</literal>)

return;

if (!use_eof)

copy_length -= ss;

}

}

static void *

nogvl_copy_stream_func(void *arg)

{

struct copy_stream_struct *stp = (struct copy_stream_struct *)arg;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SENDFILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>USE_COPY_FILE_RANGE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCOPYFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>

int ret;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COPY_FILE_RANGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
ret = nogvl_copy_file_range(stp);

if (ret != <literal type="number">0</literal>)

goto finish; 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCOPYFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
ret = nogvl_fcopyfile(stp);

if (ret != <literal type="number">0</literal>)

goto finish; 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SENDFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
ret = nogvl_copy_stream_sendfile(stp);

if (ret != <literal type="number">0</literal>)

goto finish; 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

nogvl_copy_stream_read_write(stp);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SENDFILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>USE_COPY_FILE_RANGE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCOPYFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>

finish:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

return <literal type="number">0</literal>;

}

static VALUE

copy_stream_fallback_body(VALUE arg)

{

struct copy_stream_struct *stp = (struct copy_stream_struct *)arg;

const int buflen = <literal type="number">16</literal>*<literal type="number">1024</literal>;

VALUE n;

VALUE buf = rb_str_buf_new(buflen);

off_t rest = stp-&gt;copy_length;

off_t off = stp-&gt;src_offset;

ID read_method = id_readpartial;

if (stp-&gt;src_fd &lt; <literal type="number">0</literal>) {

if (!rb_respond_to(stp-&gt;src, read_method)) {

read_method = id_read;

}

}

while (<literal type="number">1</literal>) {

long numwrote;

long l;

if (stp-&gt;copy_length &lt; (off_t)<literal type="number">0</literal>) {

l = buflen;

}

else {

if (rest == <literal type="number">0</literal>) {

rb_str_resize(buf, <literal type="number">0</literal>);

break;

}

l = buflen &lt; rest ? buflen : (long)rest;

}

if (stp-&gt;src_fd &lt; <literal type="number">0</literal>) {

VALUE rc = rb_funcall(stp-&gt;src, read_method, <literal type="number">2</literal>, INT2FIX(l), buf);

if (read_method == id_read &amp;&amp; NIL_P(rc))

break;

}

else {

ssize_t ss;

rb_str_resize(buf, buflen);

ss = maygvl_copy_stream_read(<literal type="number">1</literal>, stp, RSTRING_PTR(buf), l, off);

rb_str_resize(buf, ss &gt; <literal type="number">0</literal> ? ss : <literal type="number">0</literal>);

if (ss &lt; <literal type="number">0</literal>)

return Qnil;

if (ss == <literal type="number">0</literal>)

rb_eof_error();

if (off &gt;= (off_t)<literal type="number">0</literal>)

off += ss;

}

n = rb_io_write(stp-&gt;dst, buf);

numwrote = NUM2LONG(n);

stp-&gt;total += numwrote;

rest -= numwrote;

if (read_method == id_read &amp;&amp; RSTRING_LEN(buf) == <literal type="number">0</literal>) {

break;

}

}

return Qnil;

}

static VALUE

copy_stream_fallback(struct copy_stream_struct *stp)

{

if (stp-&gt;src_fd &lt; <literal type="number">0</literal> &amp;&amp; stp-&gt;src_offset &gt;= (off_t)<literal type="number">0</literal>) {

rb_raise(rb_eArgError, <literal type="string">"cannot specify src_offset for non-IO"</literal>);

}

rb_rescue2(copy_stream_fallback_body, (VALUE)stp,

(VALUE (*) (VALUE, VALUE))<literal type="number">0</literal>, (VALUE)<literal type="number">0</literal>,

rb_eEOFError, (VALUE)<literal type="number">0</literal>);

return Qnil;

}

static VALUE

copy_stream_body(VALUE arg)

{

struct copy_stream_struct *stp = (struct copy_stream_struct *)arg;

VALUE src_io = stp-&gt;src</argument>, <argument>dst_io = stp-&gt;dst;

rb_io_t *src_fptr = <literal type="number">0</literal></argument>, <argument>*dst_fptr = <literal type="number">0</literal>;

int src_fd</argument>, <argument>dst_fd;

const int common_oflags = <literal type="number">0</literal>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
| O_NOCTTY

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

;

stp-&gt;th = rb_thread_current();

stp-&gt;total = <literal type="number">0</literal>;

if (src_io == argf ||

!(RB_TYPE_P(src_io, T_FILE) ||

RB_TYPE_P(src_io, T_STRING) ||

rb_respond_to(src_io, rb_intern(<literal type="string">"to_path"</literal>)))) {

src_fd = -<literal type="number">1</literal>;

}

else {

int stat_ret;

VALUE tmp_io = rb_io_check_io(src_io);

if (!NIL_P(tmp_io)) {

src_io = tmp_io;

}

else if (!RB_TYPE_P(src_io, T_FILE)) {

VALUE args[<literal type="number">2</literal>];

FilePathValue(src_io);

args[<literal type="number">0</literal>] = src_io;

args[<literal type="number">1</literal>] = INT2NUM(O_RDONLY|common_oflags);

src_io = rb_class_new_instance(<literal type="number">2</literal>, args, rb_cFile);

stp-&gt;src = src_io;

stp-&gt;close_src = <literal type="number">1</literal>;

}

GetOpenFile(src_io, src_fptr);

rb_io_check_byte_readable(src_fptr);

src_fd = src_fptr-&gt;fd;

stat_ret = fstat(src_fd, &amp;stp-&gt;src_stat);

if (stat_ret &lt; <literal type="number">0</literal>) {

stp-&gt;syserr = <literal type="string">"fstat"</literal>;

stp-&gt;error_no = errno;

return Qnil;

}

}

stp-&gt;src_fd = src_fd;

if (dst_io == argf ||

!(RB_TYPE_P(dst_io, T_FILE) ||

RB_TYPE_P(dst_io, T_STRING) ||

rb_respond_to(dst_io, rb_intern(<literal type="string">"to_path"</literal>)))) {

dst_fd = -<literal type="number">1</literal>;

}

else {

int stat_ret;

VALUE tmp_io = rb_io_check_io(dst_io);

if (!NIL_P(tmp_io)) {

dst_io = GetWriteIO(tmp_io);

}

else if (!RB_TYPE_P(dst_io, T_FILE)) {

VALUE args[<literal type="number">3</literal>];

FilePathValue(dst_io);

args[<literal type="number">0</literal>] = dst_io;

args[<literal type="number">1</literal>] = INT2NUM(O_WRONLY|O_CREAT|O_TRUNC|common_oflags);

args[<literal type="number">2</literal>] = INT2FIX(<literal type="number">0666</literal>);

dst_io = rb_class_new_instance(<literal type="number">3</literal>, args, rb_cFile);

stp-&gt;dst = dst_io;

stp-&gt;close_dst = <literal type="number">1</literal>;

}

else {

dst_io = GetWriteIO(dst_io);

stp-&gt;dst = dst_io;

}

GetOpenFile(dst_io, dst_fptr);

rb_io_check_writable(dst_fptr);

dst_fd = dst_fptr-&gt;fd;

stat_ret = fstat(dst_fd, &amp;stp-&gt;dst_stat);

if (stat_ret &lt; <literal type="number">0</literal>) {

stp-&gt;syserr = <literal type="string">"fstat"</literal>;

stp-&gt;error_no = errno;

return Qnil;

}

}

stp-&gt;dst_fd = dst_fd;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (src_fptr)

SET_BINARY_MODE_WITH_SEEK_CUR(src_fptr);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (dst_fptr)

io_ascii8bit_binmode(dst_fptr);

if (stp-&gt;src_offset &lt; (off_t)<literal type="number">0</literal> &amp;&amp; src_fptr &amp;&amp; src_fptr-&gt;rbuf.len) {

size_t len = src_fptr-&gt;rbuf.len;

VALUE str;

if (stp-&gt;copy_length &gt;= (off_t)<literal type="number">0</literal> &amp;&amp; stp-&gt;copy_length &lt; (off_t)len) {

len = (size_t)stp-&gt;copy_length;

}

str = rb_str_buf_new(len);

rb_str_resize(str,len);

read_buffered_data(RSTRING_PTR(str), len, src_fptr);

if (dst_fptr) { 

if (io_binwrite(str, RSTRING_PTR(str), RSTRING_LEN(str), dst_fptr, <literal type="number">0</literal>) &lt; <literal type="number">0</literal>)

rb_sys_fail(<literal type="number">0</literal>);

}

else 

rb_io_write(dst_io, str);

rb_str_resize(str, <literal type="number">0</literal>);

stp-&gt;total += len;

if (stp-&gt;copy_length &gt;= (off_t)<literal type="number">0</literal>)

stp-&gt;copy_length -= len;

}

if (dst_fptr &amp;&amp; io_fflush(dst_fptr) &lt; <literal type="number">0</literal>) {

rb_raise(rb_eIOError, <literal type="string">"flush failed"</literal>);

}

if (stp-&gt;copy_length == <literal type="number">0</literal>)

return Qnil;

if (src_fd &lt; <literal type="number">0</literal> || dst_fd &lt; <literal type="number">0</literal>) {

return copy_stream_fallback(stp);

}

rb_thread_call_without_gvl(nogvl_copy_stream_func, (void*)stp, RUBY_UBF_IO, <literal type="number">0</literal>);

return Qnil;

}

static VALUE

copy_stream_finalize(VALUE arg)

{

struct copy_stream_struct *stp = (struct copy_stream_struct *)arg;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCOPYFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
if (stp-&gt;copyfile_state) {

copyfile_state_free(stp-&gt;copyfile_state);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if (stp-&gt;close_src) {

rb_io_close_m(stp-&gt;src);

}

if (stp-&gt;close_dst) {

rb_io_close_m(stp-&gt;dst);

}

if (stp-&gt;syserr) {

rb_syserr_fail(stp-&gt;error_no, stp-&gt;syserr);

}

if (stp-&gt;notimp) {

rb_raise(rb_eNotImpError, <literal type="string">"%s() not implemented"</literal>, stp-&gt;notimp);

}

return Qnil;

}

static VALUE

rb_io_s_copy_stream(int argc, VALUE *argv, VALUE io)

{

VALUE src</argument>, <argument>dst</argument>, <argument>length</argument>, <argument>src_offset;

struct copy_stream_struct st;

MEMZERO(&amp;st, struct copy_stream_struct, <literal type="number">1</literal>);

rb_scan_args(argc, argv, <literal type="string">"22"</literal>, &amp;src, &amp;dst, &amp;length, &amp;src_offset);

st.src = src;

st.dst = dst;

if (NIL_P(length))

st.copy_length = (off_t)-<literal type="number">1</literal>;

else

st.copy_length = NUM2OFFT(length);

if (NIL_P(src_offset))

st.src_offset = (off_t)-<literal type="number">1</literal>;

else

st.src_offset = NUM2OFFT(src_offset);

rb_ensure(copy_stream_body, (VALUE)&amp;st, copy_stream_finalize, (VALUE)&amp;st);

return OFFT2NUM(st.total);

}

static VALUE

rb_io_external_encoding(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

if (fptr-&gt;encs.enc2) {

return rb_enc_from_encoding(fptr-&gt;encs.enc2);

}

if (fptr-&gt;mode &amp; FMODE_WRITABLE) {

if (fptr-&gt;encs.enc)

return rb_enc_from_encoding(fptr-&gt;encs.enc);

return Qnil;

}

return rb_enc_from_encoding(io_read_encoding(fptr));

}

static VALUE

rb_io_internal_encoding(VALUE io)

{

rb_io_t *fptr;

GetOpenFile(io, fptr);

if (!fptr-&gt;encs.enc2) return Qnil;

return rb_enc_from_encoding(io_read_encoding(fptr));

}

static VALUE

rb_io_set_encoding(int argc, VALUE *argv, VALUE io)

{

rb_io_t *fptr;

VALUE v1</argument>, <argument>v2</argument>, <argument>opt;

if (!RB_TYPE_P(io, T_FILE)) {

return rb_funcallv(io, id_set_encoding, argc, argv);

}

argc = rb_scan_args(argc, argv, <literal type="string">"11:"</literal>, &amp;v1, &amp;v2, &amp;opt);

GetOpenFile(io, fptr);

io_encoding_set(fptr, v1, v2, opt);

return io;

}

void

rb_stdio_set_default_encoding(void)

{

VALUE val = Qnil;

rb_io_set_encoding(<literal type="number">1</literal>, &amp;val, rb_stdin);

rb_io_set_encoding(<literal type="number">1</literal>, &amp;val, rb_stdout);

rb_io_set_encoding(<literal type="number">1</literal>, &amp;val, rb_stderr);

}

static inline int

global_argf_p(VALUE arg)

{

return arg == argf;

}

static VALUE

argf_external_encoding(VALUE argf)

{

if (!RTEST(ARGF.current_file)) {

return rb_enc_from_encoding(rb_default_external_encoding());

}

return rb_io_external_encoding(rb_io_check_io(ARGF.current_file));

}

static VALUE

argf_internal_encoding(VALUE argf)

{

if (!RTEST(ARGF.current_file)) {

return rb_enc_from_encoding(rb_default_external_encoding());

}

return rb_io_internal_encoding(rb_io_check_io(ARGF.current_file));

}

static VALUE

argf_set_encoding(int argc, VALUE *argv, VALUE argf)

{

rb_io_t *fptr;

if (!next_argv()) {

rb_raise(rb_eArgError, <literal type="string">"no stream to set encoding"</literal>);

}

rb_io_set_encoding(argc, argv, ARGF.current_file);

GetOpenFile(ARGF.current_file, fptr);

ARGF.encs = fptr-&gt;encs;

return argf;

}

static VALUE

argf_tell(VALUE argf)

{

if (!next_argv()) {

rb_raise(rb_eArgError, <literal type="string">"no stream to tell"</literal>);

}

ARGF_FORWARD(<literal type="number">0</literal>, <literal type="number">0</literal>);

return rb_io_tell(ARGF.current_file);

}

static VALUE

argf_seek_m(int argc, VALUE *argv, VALUE argf)

{

if (!next_argv()) {

rb_raise(rb_eArgError, <literal type="string">"no stream to seek"</literal>);

}

ARGF_FORWARD(argc, argv);

return rb_io_seek_m(argc, argv, ARGF.current_file);

}

static VALUE

argf_set_pos(VALUE argf, VALUE offset)

{

if (!next_argv()) {

rb_raise(rb_eArgError, <literal type="string">"no stream to set position"</literal>);

}

ARGF_FORWARD(<literal type="number">1</literal>, &amp;offset);

return rb_io_set_pos(ARGF.current_file, offset);

}

static VALUE

argf_rewind(VALUE argf)

{

VALUE ret;

int old_lineno;

if (!next_argv()) {

rb_raise(rb_eArgError, <literal type="string">"no stream to rewind"</literal>);

}

ARGF_FORWARD(<literal type="number">0</literal>, <literal type="number">0</literal>);

old_lineno = RFILE(ARGF.current_file)-&gt;fptr-&gt;lineno;

ret = rb_io_rewind(ARGF.current_file);

if (!global_argf_p(argf)) {

ARGF.last_lineno = ARGF.lineno -= old_lineno;

}

return ret;

}

static VALUE

argf_fileno(VALUE argf)

{

if (!next_argv()) {

rb_raise(rb_eArgError, <literal type="string">"no stream"</literal>);

}

ARGF_FORWARD(<literal type="number">0</literal>, <literal type="number">0</literal>);

return rb_io_fileno(ARGF.current_file);

}

static VALUE

argf_to_io(VALUE argf)

{

next_argv();

ARGF_FORWARD(<literal type="number">0</literal>, <literal type="number">0</literal>);

return ARGF.current_file;

}

static VALUE

argf_eof(VALUE argf)

{

next_argv();

if (RTEST(ARGF.current_file)) {

if (ARGF.init_p == <literal type="number">0</literal>) return Qtrue;

next_argv();

ARGF_FORWARD(<literal type="number">0</literal>, <literal type="number">0</literal>);

if (rb_io_eof(ARGF.current_file)) {

return Qtrue;

}

}

return Qfalse;

}

static VALUE

argf_read(int argc, VALUE *argv, VALUE argf)

{

VALUE tmp</argument>, <argument>str</argument>, <argument>length;

long len = <literal type="number">0</literal>;

rb_scan_args(argc, argv, <literal type="string">"02"</literal>, &amp;length, &amp;str);

if (!NIL_P(length)) {

len = NUM2LONG(argv[<literal type="number">0</literal>]);

}

if (!NIL_P(str)) {

StringValue(str);

rb_str_resize(str,<literal type="number">0</literal>);

argv[<literal type="number">1</literal>] = Qnil;

}

retry:

if (!next_argv()) {

return str;

}

if (ARGF_GENERIC_INPUT_P()) {

tmp = argf_forward(argc, argv, argf);

}

else {

tmp = io_read(argc, argv, ARGF.current_file);

}

if (NIL_P(str)) str = tmp;

else if (!NIL_P(tmp)) rb_str_append(str, tmp);

if (NIL_P(tmp) || NIL_P(length)) {

if (ARGF.next_p != -<literal type="number">1</literal>) {

argf_close(argf);

ARGF.next_p = <literal type="number">1</literal>;

goto retry;

}

}

else if (argc &gt;= <literal type="number">1</literal>) {

long slen = RSTRING_LEN(str);

if (slen &lt; len) {

len -= slen;

argv[<literal type="number">0</literal>] = INT2NUM(len);

goto retry;

}

}

return str;

}

struct argf_call_arg {

int argc;

VALUE *argv;

VALUE argf;

};

static VALUE

argf_forward_call(VALUE arg)

{

struct argf_call_arg *p = (struct argf_call_arg *)arg;

argf_forward(p-&gt;argc, p-&gt;argv, p-&gt;argf);

return Qnil;

}

static VALUE argf_getpartial(int argc, VALUE *argv, VALUE argf, VALUE opts,

int nonblock);

static VALUE

argf_readpartial(int argc, VALUE *argv, VALUE argf)

{

return argf_getpartial(argc, argv, argf, Qnil, <literal type="number">0</literal>);

}

static VALUE

argf_read_nonblock(int argc, VALUE *argv, VALUE argf)

{

VALUE opts;

rb_scan_args(argc, argv, <literal type="string">"11:"</literal>, NULL, NULL, &amp;opts);

if (!NIL_P(opts))

argc--;

return argf_getpartial(argc, argv, argf, opts, <literal type="number">1</literal>);

}

static VALUE

argf_getpartial(int argc, VALUE *argv, VALUE argf, VALUE opts, int nonblock)

{

VALUE tmp</argument>, <argument>str</argument>, <argument>length;

int no_exception;

rb_scan_args(argc, argv, <literal type="string">"11"</literal>, &amp;length, &amp;str);

if (!NIL_P(str)) {

StringValue(str);

argv[<literal type="number">1</literal>] = str;

}

no_exception = no_exception_p(opts);

if (!next_argv()) {

if (!NIL_P(str)) {

rb_str_resize(str, <literal type="number">0</literal>);

}

rb_eof_error();

}

if (ARGF_GENERIC_INPUT_P()) {

VALUE (*const rescue_does_nothing)(VALUE, VALUE) = <literal type="number">0</literal>;

struct argf_call_arg arg;

arg.argc = argc;

arg.argv = argv;

arg.argf = argf;

tmp = rb_rescue2(argf_forward_call, (VALUE)&amp;arg,

rescue_does_nothing, Qnil, rb_eEOFError, (VALUE)<literal type="number">0</literal>);

}

else {

tmp = io_getpartial(argc, argv, ARGF.current_file, no_exception, nonblock);

}

if (NIL_P(tmp)) {

if (ARGF.next_p == -<literal type="number">1</literal>) {

return io_nonblock_eof(no_exception);

}

argf_close(argf);

ARGF.next_p = <literal type="number">1</literal>;

if (RARRAY_LEN(ARGF.argv) == <literal type="number">0</literal>) {

return io_nonblock_eof(no_exception);

}

if (NIL_P(str))

str = rb_str_new(NULL, <literal type="number">0</literal>);

return str;

}

return tmp;

}

static VALUE

argf_getc(VALUE argf)

{

VALUE ch;

retry:

if (!next_argv()) return Qnil;

if (ARGF_GENERIC_INPUT_P()) {

ch = rb_funcall3(ARGF.current_file, rb_intern(<literal type="string">"getc"</literal>), <literal type="number">0</literal>, <literal type="number">0</literal>);

}

else {

ch = rb_io_getc(ARGF.current_file);

}

if (NIL_P(ch) &amp;&amp; ARGF.next_p != -<literal type="number">1</literal>) {

argf_close(argf);

ARGF.next_p = <literal type="number">1</literal>;

goto retry;

}

return ch;

}

static VALUE

argf_getbyte(VALUE argf)

{

VALUE ch;

retry:

if (!next_argv()) return Qnil;

if (!RB_TYPE_P(ARGF.current_file, T_FILE)) {

ch = rb_funcall3(ARGF.current_file, rb_intern(<literal type="string">"getbyte"</literal>), <literal type="number">0</literal>, <literal type="number">0</literal>);

}

else {

ch = rb_io_getbyte(ARGF.current_file);

}

if (NIL_P(ch) &amp;&amp; ARGF.next_p != -<literal type="number">1</literal>) {

argf_close(argf);

ARGF.next_p = <literal type="number">1</literal>;

goto retry;

}

return ch;

}

static VALUE

argf_readchar(VALUE argf)

{

VALUE ch;

retry:

if (!next_argv()) rb_eof_error();

if (!RB_TYPE_P(ARGF.current_file, T_FILE)) {

ch = rb_funcall3(ARGF.current_file, rb_intern(<literal type="string">"getc"</literal>), <literal type="number">0</literal>, <literal type="number">0</literal>);

}

else {

ch = rb_io_getc(ARGF.current_file);

}

if (NIL_P(ch) &amp;&amp; ARGF.next_p != -<literal type="number">1</literal>) {

argf_close(argf);

ARGF.next_p = <literal type="number">1</literal>;

goto retry;

}

return ch;

}

static VALUE

argf_readbyte(VALUE argf)

{

VALUE c;

NEXT_ARGF_FORWARD(<literal type="number">0</literal>, <literal type="number">0</literal>);

c = argf_getbyte(argf);

if (NIL_P(c)) {

rb_eof_error();

}

return c;

}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOREACH_ARGF</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>while (next_argv())</cpp:value></cpp:define>

static VALUE

argf_block_call_i(RB_BLOCK_CALL_FUNC_ARGLIST(i, argf))

{

const VALUE current = ARGF.current_file;

rb_yield_values2(argc, argv);

if (ARGF.init_p == -<literal type="number">1</literal> || current != ARGF.current_file) {

rb_iter_break_value(Qundef);

}

return Qnil;

}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGF_block_call</name><parameter_list>(<parameter><type><name>mid</name></type></parameter>, <parameter><type><name>argc</name></type></parameter>, <parameter><type><name>argv</name></type></parameter>, <parameter><type><name>func</name></type></parameter>, <parameter><type><name>argf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_block_call_kw(ARGF.current_file, mid, argc, argv, func, argf, rb_keyword_given_p())</cpp:value></cpp:define>

static void

argf_block_call(ID mid, int argc, VALUE *argv, VALUE argf)

{

VALUE ret = ARGF_block_call(mid, argc, argv, argf_block_call_i, argf);

if (ret != Qundef) ARGF.next_p = <literal type="number">1</literal>;

}

static VALUE

argf_block_call_line_i(RB_BLOCK_CALL_FUNC_ARGLIST(i, argf))

{

if (!global_argf_p(argf)) {

ARGF.last_lineno = ++ARGF.lineno;

}

return argf_block_call_i(i, argf, argc, argv, blockarg);

}

static void

argf_block_call_line(ID mid, int argc, VALUE *argv, VALUE argf)

{

VALUE ret = ARGF_block_call(mid, argc, argv, argf_block_call_line_i, argf);

if (ret != Qundef) ARGF.next_p = <literal type="number">1</literal>;

}

static VALUE

argf_each_line(int argc, VALUE *argv, VALUE argf)

{

RETURN_ENUMERATOR(argf, argc, argv);

FOREACH_ARGF() {

argf_block_call_line(rb_intern(<literal type="string">"each_line"</literal>), argc, argv, argf);

}

return argf;

}

static VALUE

argf_lines(int argc, VALUE *argv, VALUE argf)

{

rb_warn_deprecated(<literal type="string">"ARGF#lines"</literal>, <literal type="string">"#each_line"</literal>);

if (!rb_block_given_p())

return rb_enumeratorize(argf, ID2SYM(rb_intern(<literal type="string">"each_line"</literal>)), argc, argv);

return argf_each_line(argc, argv, argf);

}

static VALUE

argf_each_byte(VALUE argf)

{

RETURN_ENUMERATOR(argf, <literal type="number">0</literal>, <literal type="number">0</literal>);

FOREACH_ARGF() {

argf_block_call(rb_intern(<literal type="string">"each_byte"</literal>), <literal type="number">0</literal>, <literal type="number">0</literal>, argf);

}

return argf;

}

static VALUE

argf_bytes(VALUE argf)

{

rb_warn_deprecated(<literal type="string">"ARGF#bytes"</literal>, <literal type="string">"#each_byte"</literal>);

if (!rb_block_given_p())

return rb_enumeratorize(argf, ID2SYM(rb_intern(<literal type="string">"each_byte"</literal>)), <literal type="number">0</literal>, <literal type="number">0</literal>);

return argf_each_byte(argf);

}

static VALUE

argf_each_char(VALUE argf)

{

RETURN_ENUMERATOR(argf, <literal type="number">0</literal>, <literal type="number">0</literal>);

FOREACH_ARGF() {

argf_block_call(rb_intern(<literal type="string">"each_char"</literal>), <literal type="number">0</literal>, <literal type="number">0</literal>, argf);

}

return argf;

}

static VALUE

argf_chars(VALUE argf)

{

rb_warn_deprecated(<literal type="string">"ARGF#chars"</literal>, <literal type="string">"#each_char"</literal>);

if (!rb_block_given_p())

return rb_enumeratorize(argf, ID2SYM(rb_intern(<literal type="string">"each_char"</literal>)), <literal type="number">0</literal>, <literal type="number">0</literal>);

return argf_each_char(argf);

}

static VALUE

argf_each_codepoint(VALUE argf)

{

RETURN_ENUMERATOR(argf, <literal type="number">0</literal>, <literal type="number">0</literal>);

FOREACH_ARGF() {

argf_block_call(rb_intern(<literal type="string">"each_codepoint"</literal>), <literal type="number">0</literal>, <literal type="number">0</literal>, argf);

}

return argf;

}

static VALUE

argf_codepoints(VALUE argf)

{

rb_warn_deprecated(<literal type="string">"ARGF#codepoints"</literal>, <literal type="string">"#each_codepoint"</literal>);

if (!rb_block_given_p())

return rb_enumeratorize(argf, ID2SYM(rb_intern(<literal type="string">"each_codepoint"</literal>)), <literal type="number">0</literal>, <literal type="number">0</literal>);

return argf_each_codepoint(argf);

}

static VALUE

argf_filename(VALUE argf)

{

next_argv();

return ARGF.filename;

}

static VALUE

argf_filename_getter(ID id, VALUE *var)

{

return argf_filename(*var);

}

static VALUE

argf_file(VALUE argf)

{

next_argv();

return ARGF.current_file;

}

static VALUE

argf_binmode_m(VALUE argf)

{

ARGF.binmode = <literal type="number">1</literal>;

next_argv();

ARGF_FORWARD(<literal type="number">0</literal>, <literal type="number">0</literal>);

rb_io_ascii8bit_binmode(ARGF.current_file);

return argf;

}

static VALUE

argf_binmode_p(VALUE argf)

{

return ARGF.binmode ? Qtrue : Qfalse;

}

static VALUE

argf_skip(VALUE argf)

{

if (ARGF.init_p &amp;&amp; ARGF.next_p == <literal type="number">0</literal>) {

argf_close(argf);

ARGF.next_p = <literal type="number">1</literal>;

}

return argf;

}

static VALUE

argf_close_m(VALUE argf)

{

next_argv();

argf_close(argf);

if (ARGF.next_p != -<literal type="number">1</literal>) {

ARGF.next_p = <literal type="number">1</literal>;

}

ARGF.lineno = <literal type="number">0</literal>;

return argf;

}

static VALUE

argf_closed(VALUE argf)

{

next_argv();

ARGF_FORWARD(<literal type="number">0</literal>, <literal type="number">0</literal>);

return rb_io_closed(ARGF.current_file);

}

static VALUE

argf_to_s(VALUE argf)

{

return rb_str_new2(<literal type="string">"ARGF"</literal>);

}

static VALUE

argf_inplace_mode_get(VALUE argf)

{

if (!ARGF.inplace) return Qnil;

if (NIL_P(ARGF.inplace)) return rb_str_new(<literal type="number">0</literal>, <literal type="number">0</literal>);

return rb_str_dup(ARGF.inplace);

}

static VALUE

opt_i_get(ID id, VALUE *var)

{

return argf_inplace_mode_get(*var);

}

static VALUE

argf_inplace_mode_set(VALUE argf, VALUE val)

{

if (!RTEST(val)) {

ARGF.inplace = Qfalse;

}

else if (StringValueCStr(val), !RSTRING_LEN(val)) {

ARGF.inplace = Qnil;

}

else {

ARGF.inplace = rb_str_new_frozen(val);

}

return argf;

}

static void

opt_i_set(VALUE val, ID id, VALUE *var)

{

argf_inplace_mode_set(*var, val);

}

void

ruby_set_inplace_mode(const char *suffix)

{

ARGF.inplace = !suffix ? Qfalse : !*suffix ? Qnil : rb_fstring_cstr(suffix);

}

static VALUE

argf_argv(VALUE argf)

{

return ARGF.argv;

}

static VALUE

argf_argv_getter(ID id, VALUE *var)

{

return argf_argv(*var);

}

VALUE

rb_get_argv(void)

{

return ARGF.argv;

}

static VALUE

argf_write_io(VALUE argf)

{

if (!RTEST(ARGF.current_file)) {

rb_raise(rb_eIOError, <literal type="string">"not opened for writing"</literal>);

}

return GetWriteIO(ARGF.current_file);

}

static VALUE

argf_write(VALUE argf, VALUE str)

{

return rb_io_write(argf_write_io(argf), str);

}

void

rb_readwrite_sys_fail(enum rb_io_wait_readwrite writable, const char *mesg)

{

rb_readwrite_syserr_fail(writable, errno, mesg);

}

void

rb_readwrite_syserr_fail(enum rb_io_wait_readwrite writable, int n, const char *mesg)

{

VALUE arg;

arg = mesg ? rb_str_new2(mesg) : Qnil;

if (writable == RB_IO_WAIT_WRITABLE) {

switch (n) {

case EAGAIN:

rb_exc_raise(rb_class_new_instance(<literal type="number">1</literal>, &amp;arg, rb_eEAGAINWaitWritable));

break;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EAGAIN</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr></cpp:if>

case EWOULDBLOCK:

rb_exc_raise(rb_class_new_instance(<literal type="number">1</literal>, &amp;arg, rb_eEWOULDBLOCKWaitWritable));

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

case EINPROGRESS:

rb_exc_raise(rb_class_new_instance(<literal type="number">1</literal>, &amp;arg, rb_eEINPROGRESSWaitWritable));

break;

default:

rb_mod_sys_fail_str(rb_mWaitWritable, arg);

}

}

else if (writable == RB_IO_WAIT_READABLE) {

switch (n) {

case EAGAIN:

rb_exc_raise(rb_class_new_instance(<literal type="number">1</literal>, &amp;arg, rb_eEAGAINWaitReadable));

break;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EAGAIN</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr></cpp:if>

case EWOULDBLOCK:

rb_exc_raise(rb_class_new_instance(<literal type="number">1</literal>, &amp;arg, rb_eEWOULDBLOCKWaitReadable));

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

case EINPROGRESS:

rb_exc_raise(rb_class_new_instance(<literal type="number">1</literal>, &amp;arg, rb_eEINPROGRESSWaitReadable));

break;

default:

rb_mod_sys_fail_str(rb_mWaitReadable, arg);

}

}

else {

rb_bug(<literal type="string">"invalid read/write type passed to rb_readwrite_sys_fail: %d"</literal>, writable);

}

}

static VALUE

get_LAST_READ_LINE(ID _x, VALUE *_y)

{

return rb_lastline_get();

}

static void

set_LAST_READ_LINE(VALUE val, ID _x, VALUE *_y)

{

rb_lastline_set(val);

}

void

Init_IO(void)

{

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_intern</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_intern_const(str)</cpp:value></cpp:define>

VALUE rb_cARGF;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/cygwin.h&gt;</cpp:file></cpp:include>

static struct __cygwin_perfile pf[] =

{

{<literal type="string">""</literal></argument>, <argument>O_RDONLY | O_BINARY}</argument>,

<argument>{<literal type="string">""</literal></argument>, <argument>O_WRONLY | O_BINARY}</argument>,

<argument>{<literal type="string">""</literal></argument>, <argument>O_RDWR | O_BINARY}</argument>,

<argument>{<literal type="string">""</literal></argument>, <argument>O_APPEND | O_BINARY}</argument>,

<argument>{NULL</argument>, <argument><literal type="number">0</literal>}

};

cygwin_internal(CW_PERFILE, pf);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_eIOError = rb_define_class(<literal type="string">"IOError"</literal>, rb_eStandardError);

rb_eEOFError = rb_define_class(<literal type="string">"EOFError"</literal>, rb_eIOError);

id_write = rb_intern(<literal type="string">"write"</literal>);

id_read = rb_intern(<literal type="string">"read"</literal>);

id_getc = rb_intern(<literal type="string">"getc"</literal>);

id_flush = rb_intern(<literal type="string">"flush"</literal>);

id_readpartial = rb_intern(<literal type="string">"readpartial"</literal>);

id_set_encoding = rb_intern(<literal type="string">"set_encoding"</literal>);

rb_define_global_function(<literal type="string">"syscall"</literal>, rb_f_syscall, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"open"</literal>, rb_f_open, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"printf"</literal>, rb_f_printf, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"print"</literal>, rb_f_print, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"putc"</literal>, rb_f_putc, <literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"puts"</literal>, rb_f_puts, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"gets"</literal>, rb_f_gets, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"readline"</literal>, rb_f_readline, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"select"</literal>, rb_f_select, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"readlines"</literal>, rb_f_readlines, -<literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"`"</literal>, rb_f_backquote, <literal type="number">1</literal>);

rb_define_global_function(<literal type="string">"p"</literal>, rb_f_p, -<literal type="number">1</literal>);

rb_define_method(rb_mKernel, <literal type="string">"display"</literal>, rb_obj_display, -<literal type="number">1</literal>);

rb_cIO = rb_define_class(<literal type="string">"IO"</literal>, rb_cObject);

rb_include_module(rb_cIO, rb_mEnumerable);

rb_mWaitReadable = rb_define_module_under(rb_cIO, <literal type="string">"WaitReadable"</literal>);

rb_mWaitWritable = rb_define_module_under(rb_cIO, <literal type="string">"WaitWritable"</literal>);

rb_eEAGAINWaitReadable = rb_define_class_under(rb_cIO, <literal type="string">"EAGAINWaitReadable"</literal>, rb_eEAGAIN);

rb_include_module(rb_eEAGAINWaitReadable, rb_mWaitReadable);

rb_eEAGAINWaitWritable = rb_define_class_under(rb_cIO, <literal type="string">"EAGAINWaitWritable"</literal>, rb_eEAGAIN);

rb_include_module(rb_eEAGAINWaitWritable, rb_mWaitWritable);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EAGAIN</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr></cpp:if>

rb_eEWOULDBLOCKWaitReadable = rb_eEAGAINWaitReadable;

rb_define_const(rb_cIO, <literal type="string">"EWOULDBLOCKWaitReadable"</literal>, rb_eEAGAINWaitReadable);

rb_eEWOULDBLOCKWaitWritable = rb_eEAGAINWaitWritable;

rb_define_const(rb_cIO, <literal type="string">"EWOULDBLOCKWaitWritable"</literal>, rb_eEAGAINWaitWritable);

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

rb_eEWOULDBLOCKWaitReadable = rb_define_class_under(rb_cIO, <literal type="string">"EWOULDBLOCKWaitReadable"</literal>, rb_eEWOULDBLOCK);

rb_include_module(rb_eEWOULDBLOCKWaitReadable, rb_mWaitReadable);

rb_eEWOULDBLOCKWaitWritable = rb_define_class_under(rb_cIO, <literal type="string">"EWOULDBLOCKWaitWritable"</literal>, rb_eEWOULDBLOCK);

rb_include_module(rb_eEWOULDBLOCKWaitWritable, rb_mWaitWritable);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_eEINPROGRESSWaitReadable = rb_define_class_under(rb_cIO, <literal type="string">"EINPROGRESSWaitReadable"</literal>, rb_eEINPROGRESS);

rb_include_module(rb_eEINPROGRESSWaitReadable, rb_mWaitReadable);

rb_eEINPROGRESSWaitWritable = rb_define_class_under(rb_cIO, <literal type="string">"EINPROGRESSWaitWritable"</literal>, rb_eEINPROGRESS);

rb_include_module(rb_eEINPROGRESSWaitWritable, rb_mWaitWritable);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

rb_define_singleton_method(rb_cFile, "open", rb_io_s_open, -1);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_define_alloc_func(rb_cIO, io_alloc);

rb_define_singleton_method(rb_cIO, <literal type="string">"new"</literal>, rb_io_s_new, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"open"</literal>, rb_io_s_open, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"sysopen"</literal>, rb_io_s_sysopen, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"for_fd"</literal>, rb_io_s_for_fd, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"popen"</literal>, rb_io_s_popen, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"foreach"</literal>, rb_io_s_foreach, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"readlines"</literal>, rb_io_s_readlines, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"read"</literal>, rb_io_s_read, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"binread"</literal>, rb_io_s_binread, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"write"</literal>, rb_io_s_write, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"binwrite"</literal>, rb_io_s_binwrite, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"select"</literal>, rb_f_select, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"pipe"</literal>, rb_io_s_pipe, -<literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"try_convert"</literal>, rb_io_s_try_convert, <literal type="number">1</literal>);

rb_define_singleton_method(rb_cIO, <literal type="string">"copy_stream"</literal>, rb_io_s_copy_stream, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"initialize"</literal>, rb_io_initialize, -<literal type="number">1</literal>);

rb_output_fs = Qnil;

rb_define_hooked_variable(<literal type="string">"$,"</literal>, &amp;rb_output_fs, <literal type="number">0</literal>, deprecated_str_setter);

rb_default_rs = rb_fstring_lit(<literal type="string">"\n"</literal>); 

rb_gc_register_mark_object(rb_default_rs);

rb_rs = rb_default_rs;

rb_output_rs = Qnil;

rb_define_hooked_variable(<literal type="string">"$/"</literal>, &amp;rb_rs, <literal type="number">0</literal>, deprecated_str_setter);

rb_define_hooked_variable(<literal type="string">"$-0"</literal>, &amp;rb_rs, <literal type="number">0</literal>, deprecated_str_setter);

rb_define_hooked_variable(<literal type="string">"$\\"</literal>, &amp;rb_output_rs, <literal type="number">0</literal>, deprecated_str_setter);

rb_define_virtual_variable(<literal type="string">"$_"</literal>, get_LAST_READ_LINE, set_LAST_READ_LINE);

rb_define_method(rb_cIO, <literal type="string">"initialize_copy"</literal>, rb_io_init_copy, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"reopen"</literal>, rb_io_reopen, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"print"</literal>, rb_io_print, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"putc"</literal>, rb_io_putc, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"puts"</literal>, rb_io_puts, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"printf"</literal>, rb_io_printf, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"each"</literal>, rb_io_each_line, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"each_line"</literal>, rb_io_each_line, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"each_byte"</literal>, rb_io_each_byte, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"each_char"</literal>, rb_io_each_char, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"each_codepoint"</literal>, rb_io_each_codepoint, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"lines"</literal>, rb_io_lines, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"bytes"</literal>, rb_io_bytes, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"chars"</literal>, rb_io_chars, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"codepoints"</literal>, rb_io_codepoints, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"syswrite"</literal>, rb_io_syswrite, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"sysread"</literal>, rb_io_sysread, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"pread"</literal>, rb_io_pread, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"pwrite"</literal>, rb_io_pwrite, <literal type="number">2</literal>);

rb_define_method(rb_cIO, <literal type="string">"fileno"</literal>, rb_io_fileno, <literal type="number">0</literal>);

rb_define_alias(rb_cIO, <literal type="string">"to_i"</literal>, <literal type="string">"fileno"</literal>);

rb_define_method(rb_cIO, <literal type="string">"to_io"</literal>, rb_io_to_io, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"fsync"</literal>, rb_io_fsync, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"fdatasync"</literal>, rb_io_fdatasync, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"sync"</literal>, rb_io_sync, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"sync="</literal>, rb_io_set_sync, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"lineno"</literal>, rb_io_lineno, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"lineno="</literal>, rb_io_set_lineno, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"readlines"</literal>, rb_io_readlines, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"readpartial"</literal>, io_readpartial, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"read"</literal>, io_read, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"write"</literal>, io_write_m, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"gets"</literal>, rb_io_gets_m, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"readline"</literal>, rb_io_readline, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"getc"</literal>, rb_io_getc, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"getbyte"</literal>, rb_io_getbyte, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"readchar"</literal>, rb_io_readchar, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"readbyte"</literal>, rb_io_readbyte, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"ungetbyte"</literal>,rb_io_ungetbyte, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"ungetc"</literal>,rb_io_ungetc, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"&lt;&lt;"</literal>, rb_io_addstr, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"flush"</literal>, rb_io_flush, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"tell"</literal>, rb_io_tell, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"seek"</literal>, rb_io_seek_m, -<literal type="number">1</literal>);

rb_define_const(rb_cIO, <literal type="string">"SEEK_SET"</literal>, INT2FIX(SEEK_SET));

rb_define_const(rb_cIO, <literal type="string">"SEEK_CUR"</literal>, INT2FIX(SEEK_CUR));

rb_define_const(rb_cIO, <literal type="string">"SEEK_END"</literal>, INT2FIX(SEEK_END));

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SEEK_DATA</name></expr></argument>)</argument_list></call></expr></cpp:if>
rb_define_const(rb_cIO, <literal type="string">"SEEK_DATA"</literal>, INT2FIX(SEEK_DATA));

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SEEK_HOLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
rb_define_const(rb_cIO, <literal type="string">"SEEK_HOLE"</literal>, INT2FIX(SEEK_HOLE));

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_define_method(rb_cIO, <literal type="string">"rewind"</literal>, rb_io_rewind, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"pos"</literal>, rb_io_tell, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"pos="</literal>, rb_io_set_pos, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"eof"</literal>, rb_io_eof, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"eof?"</literal>, rb_io_eof, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"close_on_exec?"</literal>, rb_io_close_on_exec_p, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"close_on_exec="</literal>, rb_io_set_close_on_exec, <literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"close"</literal>, rb_io_close_m, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"closed?"</literal>, rb_io_closed, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"close_read"</literal>, rb_io_close_read, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"close_write"</literal>, rb_io_close_write, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"isatty"</literal>, rb_io_isatty, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"tty?"</literal>, rb_io_isatty, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"binmode"</literal>, rb_io_binmode_m, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"binmode?"</literal>, rb_io_binmode_p, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"sysseek"</literal>, rb_io_sysseek, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"advise"</literal>, rb_io_advise, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"ioctl"</literal>, rb_io_ioctl, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"fcntl"</literal>, rb_io_fcntl, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"pid"</literal>, rb_io_pid, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"inspect"</literal>, rb_io_inspect, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"external_encoding"</literal>, rb_io_external_encoding, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"internal_encoding"</literal>, rb_io_internal_encoding, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"set_encoding"</literal>, rb_io_set_encoding, -<literal type="number">1</literal>);

rb_define_method(rb_cIO, <literal type="string">"set_encoding_by_bom"</literal>, rb_io_set_encoding_by_bom, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"autoclose?"</literal>, rb_io_autoclose_p, <literal type="number">0</literal>);

rb_define_method(rb_cIO, <literal type="string">"autoclose="</literal>, rb_io_set_autoclose, <literal type="number">1</literal>);

rb_define_variable(<literal type="string">"$stdin"</literal>, &amp;rb_stdin);

rb_stdin = prep_stdio(stdin, FMODE_READABLE, rb_cIO, <literal type="string">"&lt;STDIN&gt;"</literal>);

rb_define_hooked_variable(<literal type="string">"$stdout"</literal>, &amp;rb_stdout, <literal type="number">0</literal>, stdout_setter);

rb_stdout = prep_stdio(stdout, FMODE_WRITABLE, rb_cIO, <literal type="string">"&lt;STDOUT&gt;"</literal>);

rb_define_hooked_variable(<literal type="string">"$stderr"</literal>, &amp;rb_stderr, <literal type="number">0</literal>, stdout_setter);

rb_stderr = prep_stdio(stderr, FMODE_WRITABLE|FMODE_SYNC, rb_cIO, <literal type="string">"&lt;STDERR&gt;"</literal>);

rb_define_hooked_variable(<literal type="string">"$&gt;"</literal>, &amp;rb_stdout, <literal type="number">0</literal>, stdout_setter);

orig_stdout = rb_stdout;

orig_stderr = rb_stderr;

rb_define_global_const(<literal type="string">"STDIN"</literal>, rb_stdin);

rb_define_global_const(<literal type="string">"STDOUT"</literal>, rb_stdout);

rb_define_global_const(<literal type="string">"STDERR"</literal>, rb_stderr);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

rb_cARGF = rb_define_class("ARGF", rb_cObject);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

rb_cARGF = rb_class_new(rb_cObject);

rb_set_class_path(rb_cARGF, rb_cObject, <literal type="string">"ARGF.class"</literal>);

rb_define_alloc_func(rb_cARGF, argf_alloc);

rb_include_module(rb_cARGF, rb_mEnumerable);

rb_define_method(rb_cARGF, <literal type="string">"initialize"</literal>, argf_initialize, -<literal type="number">2</literal>);

rb_define_method(rb_cARGF, <literal type="string">"initialize_copy"</literal>, argf_initialize_copy, <literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"to_s"</literal>, argf_to_s, <literal type="number">0</literal>);

rb_define_alias(rb_cARGF, <literal type="string">"inspect"</literal>, <literal type="string">"to_s"</literal>);

rb_define_method(rb_cARGF, <literal type="string">"argv"</literal>, argf_argv, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"fileno"</literal>, argf_fileno, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"to_i"</literal>, argf_fileno, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"to_io"</literal>, argf_to_io, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"to_write_io"</literal>, argf_write_io, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"each"</literal>, argf_each_line, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"each_line"</literal>, argf_each_line, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"each_byte"</literal>, argf_each_byte, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"each_char"</literal>, argf_each_char, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"each_codepoint"</literal>, argf_each_codepoint, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"lines"</literal>, argf_lines, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"bytes"</literal>, argf_bytes, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"chars"</literal>, argf_chars, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"codepoints"</literal>, argf_codepoints, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"read"</literal>, argf_read, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"readpartial"</literal>, argf_readpartial, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"read_nonblock"</literal>, argf_read_nonblock, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"readlines"</literal>, argf_readlines, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"to_a"</literal>, argf_readlines, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"gets"</literal>, argf_gets, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"readline"</literal>, argf_readline, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"getc"</literal>, argf_getc, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"getbyte"</literal>, argf_getbyte, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"readchar"</literal>, argf_readchar, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"readbyte"</literal>, argf_readbyte, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"tell"</literal>, argf_tell, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"seek"</literal>, argf_seek_m, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"rewind"</literal>, argf_rewind, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"pos"</literal>, argf_tell, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"pos="</literal>, argf_set_pos, <literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"eof"</literal>, argf_eof, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"eof?"</literal>, argf_eof, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"binmode"</literal>, argf_binmode_m, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"binmode?"</literal>, argf_binmode_p, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"write"</literal>, argf_write, <literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"print"</literal>, rb_io_print, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"putc"</literal>, rb_io_putc, <literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"puts"</literal>, rb_io_puts, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"printf"</literal>, rb_io_printf, -<literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"filename"</literal>, argf_filename, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"path"</literal>, argf_filename, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"file"</literal>, argf_file, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"skip"</literal>, argf_skip, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"close"</literal>, argf_close_m, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"closed?"</literal>, argf_closed, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"lineno"</literal>, argf_lineno, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"lineno="</literal>, argf_set_lineno, <literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"inplace_mode"</literal>, argf_inplace_mode_get, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"inplace_mode="</literal>, argf_inplace_mode_set, <literal type="number">1</literal>);

rb_define_method(rb_cARGF, <literal type="string">"external_encoding"</literal>, argf_external_encoding, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"internal_encoding"</literal>, argf_internal_encoding, <literal type="number">0</literal>);

rb_define_method(rb_cARGF, <literal type="string">"set_encoding"</literal>, argf_set_encoding, -<literal type="number">1</literal>);

argf = rb_class_new_instance(<literal type="number">0</literal>, <literal type="number">0</literal>, rb_cARGF);

rb_define_readonly_variable(<literal type="string">"$&lt;"</literal>, &amp;argf);

rb_define_global_const(<literal type="string">"ARGF"</literal>, argf);

rb_define_hooked_variable(<literal type="string">"$."</literal>, &amp;argf, argf_lineno_getter, argf_lineno_setter);

rb_define_hooked_variable(<literal type="string">"$FILENAME"</literal>, &amp;argf, argf_filename_getter, rb_gvar_readonly_setter);

ARGF.filename = rb_str_new2(<literal type="string">"-"</literal>);

rb_define_hooked_variable(<literal type="string">"$-i"</literal>, &amp;argf, opt_i_get, opt_i_set);

rb_define_hooked_variable(<literal type="string">"$*"</literal>, &amp;argf, argf_argv_getter, rb_gvar_readonly_setter);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

atexit(pipe_atexit);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

Init_File();

rb_define_method(rb_cFile, <literal type="string">"initialize"</literal>, rb_file_initialize, -<literal type="number">1</literal>);

sym_mode = ID2SYM(rb_intern(<literal type="string">"mode"</literal>));

sym_perm = ID2SYM(rb_intern(<literal type="string">"perm"</literal>));

sym_flags = ID2SYM(rb_intern(<literal type="string">"flags"</literal>));

sym_extenc = ID2SYM(rb_intern(<literal type="string">"external_encoding"</literal>));

sym_intenc = ID2SYM(rb_intern(<literal type="string">"internal_encoding"</literal>));

sym_encoding = ID2SYM(rb_id_encoding());

sym_open_args = ID2SYM(rb_intern(<literal type="string">"open_args"</literal>));

sym_textmode = ID2SYM(rb_intern(<literal type="string">"textmode"</literal>));

sym_binmode = ID2SYM(rb_intern(<literal type="string">"binmode"</literal>));

sym_autoclose = ID2SYM(rb_intern(<literal type="string">"autoclose"</literal>));

sym_normal = ID2SYM(rb_intern(<literal type="string">"normal"</literal>));

sym_sequential = ID2SYM(rb_intern(<literal type="string">"sequential"</literal>));

sym_random = ID2SYM(rb_intern(<literal type="string">"random"</literal>));

sym_willneed = ID2SYM(rb_intern(<literal type="string">"willneed"</literal>));

sym_dontneed = ID2SYM(rb_intern(<literal type="string">"dontneed"</literal>));

sym_noreuse = ID2SYM(rb_intern(<literal type="string">"noreuse"</literal>));

sym_SET = ID2SYM(rb_intern(<literal type="string">"SET"</literal>));

sym_CUR = ID2SYM(rb_intern(<literal type="string">"CUR"</literal>));

sym_END = ID2SYM(rb_intern(<literal type="string">"END"</literal>));

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SEEK_DATA</name></expr></argument>)</argument_list></call></expr></cpp:if>
sym_DATA = ID2SYM(rb_intern(<literal type="string">"DATA"</literal>));

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SEEK_HOLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
sym_HOLE = ID2SYM(rb_intern(<literal type="string">"HOLE"</literal>));

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

sym_wait_readable = ID2SYM(rb_intern(<literal type="string">"wait_readable"</literal>));

sym_wait_writable = ID2SYM(rb_intern(<literal type="string">"wait_writable"</literal>));

}</argument></argument_list></macro></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"io.rbinc"</cpp:file></cpp:include>

</unit>
