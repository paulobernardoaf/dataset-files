<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\string.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_CRYPT_R</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_CRYPT_H</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crypt.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>HAVE_CRYPT</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"missing/crypt.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_CRYPT_R</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_counter.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"encindex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/array.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compar.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compilers.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/numeric.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/proc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/re.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/sanitizers.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/string.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/transcode.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"probes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/re.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_assert.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEG</name><parameter_list>(<parameter><type><name>no</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(regs-&gt;beg[(no)])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END</name><parameter_list>(<parameter><type><name>no</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(regs-&gt;end[(no)])</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_str_new</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_usascii_str_new</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_utf8_str_new</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_enc_str_new</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_str_new_cstr</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_tainted_str_new_cstr</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_usascii_str_new_cstr</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_utf8_str_new_cstr</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_enc_str_new_cstr</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_external_str_new_cstr</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_locale_str_new_cstr</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_str_dup_frozen</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_str_buf_new_cstr</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_str_buf_cat</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_str_buf_cat2</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_str_cat2</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_str_cat_cstr</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_fstring_cstr</name></cpp:undef>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_str_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cString</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cSymbol</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_MAX_CHAR_LEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_SHARED_ROOT</name></cpp:macro> <cpp:value>FL_USER5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_BORROWED</name></cpp:macro> <cpp:value>FL_USER6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_TMPLOCK</name></cpp:macro> <cpp:value>FL_USER7</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_NOFREE</name></cpp:macro> <cpp:value>FL_USER18</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_FAKESTR</name></cpp:macro> <cpp:value>FL_USER19</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_SET_NOEMBED</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {FL_SET((str), STR_NOEMBED);STR_SET_EMBED_LEN((str), 0);} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_SET_EMBED</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FL_UNSET((str), (STR_NOEMBED|STR_NOFREE))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_SET_EMBED_LEN</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { long tmp_n = (n);RBASIC(str)-&gt;flags &amp;= ~RSTRING_EMBED_LEN_MASK;RBASIC(str)-&gt;flags |= (tmp_n) &lt;&lt; RSTRING_EMBED_LEN_SHIFT;} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_SET_LEN</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (STR_EMBED_P(str)) {STR_SET_EMBED_LEN((str), (n));}else {RSTRING(str)-&gt;as.heap.len = (n);}} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_DEC_LEN</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (STR_EMBED_P(str)) {long n = RSTRING_LEN(str);n--;STR_SET_EMBED_LEN((str), n);}else {RSTRING(str)-&gt;as.heap.len--;}} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TERM_LEN</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_enc_mbminlen(rb_enc_get(str))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TERM_FILL</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>termlen</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {char *const term_fill_ptr = (ptr);const int term_fill_len = (termlen);*term_fill_ptr = '\0';if (UNLIKELY(term_fill_len &gt; 1))memset(term_fill_ptr, 0, term_fill_len);} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESIZE_CAPA</name><parameter_list>(<parameter><type><name>str</name></type></parameter>,<parameter><type><name>capacity</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {const int termlen = TERM_LEN(str);RESIZE_CAPA_TERM(str,capacity,termlen);} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESIZE_CAPA_TERM</name><parameter_list>(<parameter><type><name>str</name></type></parameter>,<parameter><type><name>capacity</name></type></parameter>,<parameter><type><name>termlen</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (STR_EMBED_P(str)) {if (!STR_EMBEDDABLE_P(capacity, termlen)) {char *const tmp = ALLOC_N(char, (size_t)(capacity) + (termlen));const long tlen = RSTRING_LEN(str);memcpy(tmp, RSTRING_PTR(str), tlen);RSTRING(str)-&gt;as.heap.ptr = tmp;RSTRING(str)-&gt;as.heap.len = tlen;STR_SET_NOEMBED(str);RSTRING(str)-&gt;as.heap.aux.capa = (capacity);}}else {assert(!FL_TEST((str), STR_SHARED)); SIZED_REALLOC_N(RSTRING(str)-&gt;as.heap.ptr, char, (size_t)(capacity) + (termlen), STR_HEAP_SIZE(str)); RSTRING(str)-&gt;as.heap.aux.capa = (capacity);}} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_SET_SHARED</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>shared_str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (!FL_TEST(str, STR_FAKESTR)) { RB_OBJ_WRITE((str), &amp;RSTRING(str)-&gt;as.heap.aux.shared, (shared_str)); FL_SET((str), STR_SHARED); FL_SET((shared_str), STR_SHARED_ROOT); if (RBASIC_CLASS((shared_str)) == 0) FL_SET_RAW((shared_str), STR_BORROWED); } } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_HEAP_PTR</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(RSTRING(str)-&gt;as.heap.ptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_HEAP_SIZE</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size_t)RSTRING(str)-&gt;as.heap.aux.capa + TERM_LEN(str))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_ENC_GET</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>get_encoding(str)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>SHARABLE_MIDDLE_SUBSTRING</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARABLE_MIDDLE_SUBSTRING</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SHARABLE_MIDDLE_SUBSTRING</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARABLE_SUBSTRING_P</name><parameter_list>(<parameter><type><name>beg</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((beg) + (len) == (end))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARABLE_SUBSTRING_P</name><parameter_list>(<parameter><type><name>beg</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_EMBEDDABLE_P</name><parameter_list>(<parameter><type><name>len</name></type></parameter>, <parameter><type><name>termlen</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((len) &lt;= RSTRING_EMBED_LEN_MAX + 1 - (termlen))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_replace_shared_without_enc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_new_shared</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_new_frozen</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_new_frozen_buffer</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>copy_encoding</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_new_static</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encindex</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>str_make_independent_expand</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>expand</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>termlen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>str_modifiable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_str_downcase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>str_make_independent</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>termlen</name> <init>= <expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_make_independent_expand</name><argument_list>(<argument><expr><operator>(</operator><name>str</name><operator>)</operator></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_ascii</name></decl>, <decl><type ref="prev"/><name>sym_turkic</name></decl>, <decl><type ref="prev"/><name>sym_lithuanian</name></decl>, <decl><type ref="prev"/><name>sym_fold</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>

<name>get_actual_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>encidx</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>encidx</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ENCINDEX_UTF_16</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>q</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xFE</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xFF</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_enc_get_from_index</name><argument_list>(<argument><expr><name>ENCINDEX_UTF_16BE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>q</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xFF</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xFE</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_enc_get_from_index</name><argument_list>(<argument><expr><name>ENCINDEX_UTF_16LE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr>;</return>

<case>case <expr><name>ENCINDEX_UTF_32</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>q</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xFE</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xFF</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_enc_get_from_index</name><argument_list>(<argument><expr><name>ENCINDEX_UTF_32BE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>q</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xFE</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xFF</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_enc_get_from_index</name><argument_list>(<argument><expr><name>ENCINDEX_UTF_32LE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>

<name>get_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>get_actual_encoding</name><argument_list>(<argument><expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mustnot_broken</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_broken_string</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid byte sequence in %s"</literal></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mustnot_wchar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"wide char encoding: %s"</literal></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fstring_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>register_fstring</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>rb_fstring_hash_type</name> <init>= <expr><block>{

<expr><name>fstring_cmp</name></expr>,

<expr><name>rb_str_hash</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BARE_STRING_P</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!FL_ANY_RAW(str, FL_EXIVAR) &amp;&amp; RBASIC_CLASS(str) == rb_cString)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fstr_update_callback</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>fstr</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>key</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_objspace_garbage_object_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>fstr</name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<return>return <expr><name>ST_DELETE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>fstr</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<return>return <expr><name>ST_STOP</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_FAKESTR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_new_static</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr></argument>,

<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name></expr></argument>,

<argument><expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_new_frozen</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_SHARED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>str_make_independent</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BARE_STRING_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_new_frozen</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <name>RSTRING_FSTR</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>key</name> <operator>=</operator> <operator>*</operator><name>value</name> <operator>=</operator> <operator>*</operator><name>fstr</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>RUBY_FUNC_EXPORTED</name>

<name>VALUE</name></type>

<name>rb_fstring</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>fstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bare</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>RSTRING_FSTR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bare</name> <operator>=</operator> <call><name>BARE_STRING_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bare</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>OBJ_FREEZE_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_NOEMBED</name><operator>|</operator><name>STR_SHARED_ROOT</name><operator>|</operator><name>STR_SHARED</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>STR_NOEMBED</name><operator>|</operator><name>STR_SHARED_ROOT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fstr</name> <operator>=</operator> <call><name>register_fstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bare</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>str_replace_shared_without_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>fstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>fstr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>register_fstring</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>frozen_strings</name> <init>= <expr><call><name>rb_vm_fstring_table</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_update</name><argument_list>(<argument><expr><name>frozen_strings</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>str</name></expr></argument>,

<argument><expr><name>fstr_update_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>ret</name> <operator>==</operator> <name>Qundef</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>STR_FAKESTR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>setup_fake_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>RString</name></name> <modifier>*</modifier></type><name>fake_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>fake_str</name><operator>-&gt;</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>T_STRING</name><operator>|</operator><name>RSTRING_NOEMBED</name><operator>|</operator><name>STR_NOFREE</name><operator>|</operator><name>STR_FAKESTR</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENCODING_SET_INLINED</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>fake_str</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS_RAW</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>fake_str</name></expr></argument>, <argument><expr><name>rb_cString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fake_str</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fake_str</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fake_str</name><operator>-&gt;</operator><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>fake_str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_setup_fake_str</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>RString</name></name> <modifier>*</modifier></type><name>fake_str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>setup_fake_str</name><argument_list>(<argument><expr><name>fake_str</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_fstring_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>RString</name></name></type> <name>fake_str</name></decl>;</decl_stmt>

<return>return <expr><call><name>register_fstring</name><argument_list>(<argument><expr><call><name>setup_fake_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fake_str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ENCINDEX_US_ASCII</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_fstring_enc_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>RString</name></name></type> <name>fake_str</name></decl>;</decl_stmt>

<return>return <expr><call><name>register_fstring</name><argument_list>(<argument><expr><call><name>rb_setup_fake_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fake_str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_fstring_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_fstring_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fstring_set_class_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fstring_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>alen</name></decl>, <decl><type ref="prev"/><name>blen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>aptr</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>bptr</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>alen</name> <operator>!=</operator> <name>blen</name> <operator>||</operator>

<call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>memcmp</name><argument_list>(<argument><expr><name>aptr</name></expr></argument>, <argument><expr><name>bptr</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>single_byte_optimizable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_fs</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>search_nonascii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal><operator>)</operator></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_UINTPTR_T</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NONASCII_MASK</name></cpp:macro> <cpp:value>UINT64_C(0x8080808080808080)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_UINTPTR_T</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NONASCII_MASK</name></cpp:macro> <cpp:value>UINT32_C(0x80808080)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"don't know what to do."</cpp:literal></cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_UINTPTR_T</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NONASCII_MASK</name></cpp:macro> <cpp:value>((uintptr_t)0x80808080UL &lt;&lt; 32 | (uintptr_t)0x80808080UL)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_UINTPTR_T</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NONASCII_MASK</name></cpp:macro> <cpp:value>0x80808080UL</cpp:value></cpp:define> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"don't know what to do."</cpp:literal></cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>UNALIGNED_WORD_ACCESS</name> <operator>||</operator> <name>e</name> <operator>-</operator> <name>p</name> <operator>&gt;=</operator> <name>SIZEOF_VOIDP</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>UNALIGNED_WORD_ACCESS</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>p</name> <operator>%</operator> <name>SIZEOF_VOIDP</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><name>SIZEOF_VOIDP</name> <operator>-</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>p</name> <operator>%</operator> <name>SIZEOF_VOIDP</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>l</name></expr>)</condition> <block>{<block_content>

<default>default:</default> <expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOIDP</name> <operator>&gt;</operator> <literal type="number">4</literal></expr></cpp:if>

<case>case <expr><literal type="number">7</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">7</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name><operator>-</operator><literal type="number">7</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">6</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">6</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name><operator>-</operator><literal type="number">6</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">5</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">5</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name><operator>-</operator><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">4</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name><operator>-</operator><literal type="number">4</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="number">3</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">3</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name><operator>-</operator><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">2</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">0</literal></expr>:</case> <break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BUILTIN___BUILTIN_ASSUME_ALIGNED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>!</operator> <name>UNALIGNED_WORD_ACCESS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>aligned_ptr</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_assume_aligned((value), sizeof(uintptr_t))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>aligned_ptr</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(uintptr_t *)(value)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>aligned_ptr</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <operator>(</operator><name>SIZEOF_VOIDP</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>aligned_ptr</name></cpp:undef>

<for>for <control>(<init>;</init><condition><expr><name>s</name> <operator>&lt;</operator> <name>t</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;</operator> <name>NONASCII_MASK</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>s</name> <operator>+</operator> <operator>(</operator><call><name>nlz_intptr</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>&amp;</operator><name>NONASCII_MASK</name></expr></argument>)</argument_list></call><operator>&gt;&gt;</operator><literal type="number">3</literal><operator>)</operator></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>s</name> <operator>+</operator> <operator>(</operator><call><name>ntz_intptr</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>&amp;</operator><name>NONASCII_MASK</name></expr></argument>)</argument_list></call><operator>&gt;&gt;</operator><literal type="number">3</literal><operator>)</operator></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>e</name> <operator>-</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<default>default:</default> <expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOIDP</name> <operator>&gt;</operator> <literal type="number">4</literal></expr></cpp:if>

<case>case <expr><literal type="number">7</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>e</name><index>[<expr><operator>-</operator><literal type="number">7</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>e</name><operator>-</operator><literal type="number">7</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">6</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>e</name><index>[<expr><operator>-</operator><literal type="number">6</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>e</name><operator>-</operator><literal type="number">6</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">5</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>e</name><index>[<expr><operator>-</operator><literal type="number">5</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>e</name><operator>-</operator><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">4</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>e</name><index>[<expr><operator>-</operator><literal type="number">4</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>e</name><operator>-</operator><literal type="number">4</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="number">3</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>e</name><index>[<expr><operator>-</operator><literal type="number">3</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>e</name><operator>-</operator><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">2</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>e</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>e</name><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>e</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>e</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>coderange_scan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>p</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>rb_ascii8bit_encindex</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name>ENC_CODERANGE_VALID</name></expr> </then><else>: <expr><name>ENC_CODERANGE_7BIT</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ENC_CODERANGE_7BIT</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ENC_CODERANGE_BROKEN</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ENC_CODERANGE_BROKEN</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ENC_CODERANGE_VALID</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>long</name></type>

<name>rb_str_coderange_scan_restartable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>e</name> <operator>-</operator> <name>s</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>rb_ascii8bit_encindex</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_VALID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>e</name> <operator>-</operator> <name>s</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><name>ENC_CODERANGE_VALID</name></expr> </then><else>: <expr><name>ENC_CODERANGE_7BIT</name></expr></else></ternary></expr>;</expr_stmt>

<return>return <expr><name>e</name> <operator>-</operator> <name>s</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cr</name> <operator>!=</operator> <name>ENC_CODERANGE_VALID</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_7BIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>e</name> <operator>-</operator> <name>s</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <ternary><condition><expr><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>ENC_CODERANGE_BROKEN</name></expr></then><else>: <expr><name>ENC_CODERANGE_UNKNOWN</name></expr></else></ternary></expr>;</expr_stmt>

<return>return <expr><name>p</name> <operator>-</operator> <name>s</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <ternary><condition><expr><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>ENC_CODERANGE_BROKEN</name></expr></then><else>: <expr><name>ENC_CODERANGE_UNKNOWN</name></expr></else></ternary></expr>;</expr_stmt>

<return>return <expr><name>p</name> <operator>-</operator> <name>s</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt>

<return>return <expr><name>e</name> <operator>-</operator> <name>s</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>str_enc_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_set_index</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_enc_cr_str_copy_for_substr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_enc_copy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ENC_CODERANGE_7BIT</name></expr>:</case>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ENC_CODERANGE_VALID</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>search_nonascii</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_enc_cr_str_exact_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_enc_copy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_enc_str_coderange</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>rb_enc_dummy_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name> <operator>=</operator> <call><name>get_actual_encoding</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_BROKEN</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>coderange_scan</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>cr</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_enc_str_asciionly_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>str_mod_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>p</name> <operator>||</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"string modified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>str_capacity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>termlen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>RSTRING_EMBED_LEN_MAX</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>termlen</name><operator>)</operator></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name><operator>|</operator><name>STR_NOFREE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>size_t</name></type>

<name>rb_str_capacity</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_capacity</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>must_not_null</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"NULL pointer given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>str_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>NEWOBJ_OF</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>struct <name>RString</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_STRING</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>RGENGC_WB_PROTECTED_STRING</name></expr> ?</condition><then> <expr><name>FL_WB_PROTECTED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>empty_str_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_DTRACE_CREATE_HOOK</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>str_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_new0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>termlen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative string size (or size too big)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_CREATE_HOOK</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name> <operator>+</operator> <name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_NOEMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_usascii_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ENCODING_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_usascii_encindex</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_utf8_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>str_new</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_utf8_encindex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_enc_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_new0</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>must_not_null</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>__msan_unpoison_string</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_usascii_str_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ENCODING_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_usascii_encindex</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_utf8_str_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_utf8_encindex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_enc_str_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>must_not_null</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"wchar encoding given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_new_static</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encindex</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative string size (or size too big)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get_from_index</name><argument_list>(<argument><expr><name>encindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_new0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RUBY_DTRACE_CREATE_HOOK</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_NOEMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <name>STR_NOFREE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_new_static</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new_static</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_usascii_str_new_static</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new_static</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ENCINDEX_US_ASCII</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_utf8_str_new_static</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new_static</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ENCINDEX_UTF_8</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_enc_str_new_static</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new_static</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_tainted_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn_deprecated_to_remove</name><argument_list>(<argument><expr><literal type="string">"rb_tainted_str_new"</literal></expr></argument>, <argument><expr><literal type="string">"3.2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_tainted_str_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn_deprecated_to_remove</name><argument_list>(<argument><expr><literal type="string">"rb_tainted_str_new_cstr"</literal></expr></argument>, <argument><expr><literal type="string">"3.2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_cat_conv_enc_opts</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>newstr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>ofs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>to</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ecopts</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>VALUE</name></type>

<name>rb_str_conv_enc_opts</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ecopts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>newstr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>to</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>to</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_ascii_string</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>

<name>to</name> <operator>==</operator> <call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>newstr</name> <operator>=</operator> <call><name>str_cat_conv_enc_opts</name><argument_list>(<argument><expr><call><name>rb_str_buf_new</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,

<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>newstr</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_cat_conv_enc_opts</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>newstr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>ofs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ecopts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ofs</name> <operator>&lt;</operator> <operator>-</operator><name>olen</name> <operator>||</operator> <name>olen</name> <operator>&lt;</operator> <name>ofs</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld out of string"</literal></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ofs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ofs</name> <operator>+=</operator> <name>olen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>from</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_modify</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>str_cat_conv_enc_opts</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>ofs</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>from</name></expr></argument>,

<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_initialize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_cat_conv_enc_opts</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>newstr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>ofs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>to</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>ecflags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ecopts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_econv_t</name> <modifier>*</modifier></type><name>ec</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_econv_result_t</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>econv_wrapper</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dest</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>converted_output</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>ofs</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>rb_str_capacity</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>econv_wrapper</name> <operator>=</operator> <call><name>rb_obj_alloc</name><argument_list>(<argument><expr><name>rb_cEncodingConverter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>econv_wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>rb_econv_open_opts</name><argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>to</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>ecopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ec</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>econv_wrapper</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>ec</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>dest</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr><operator>,</operator>

<expr><operator>(</operator><name>dp</name> <operator>=</operator> <name>dest</name> <operator>+</operator> <name>converted_output</name><operator>)</operator></expr><operator>,</operator>

<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>rb_econv_convert</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sp</name></expr></argument>, <argument><expr><name>start</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dp</name></expr></argument>, <argument><expr><name>dest</name> <operator>+</operator> <name>olen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr><operator>,</operator>

<expr><name>ret</name> <operator>==</operator> <name>econv_destination_buffer_full</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>converted_input</name> <init>= <expr><name>sp</name> <operator>-</operator> <name>start</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>rest</name> <init>= <expr><name>len</name> <operator>-</operator> <name>converted_input</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>converted_output</name> <operator>=</operator> <name>dp</name> <operator>-</operator> <name>dest</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>converted_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>converted_input</name> <operator>&amp;&amp;</operator> <name>converted_output</name> <operator>&amp;&amp;</operator>

<name>rest</name> <operator>&lt;</operator> <operator>(</operator><name>LONG_MAX</name> <operator>/</operator> <name>converted_output</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rest</name> <operator>=</operator> <operator>(</operator><name>rest</name> <operator>*</operator> <name>converted_output</name><operator>)</operator> <operator>/</operator> <name>converted_input</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>rest</name> <operator>=</operator> <name>olen</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>olen</name> <operator>+=</operator> <ternary><condition><expr><name>rest</name> <operator>&lt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><name>rest</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>econv_wrapper</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_econv_close</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_force_recycle</name><argument_list>(<argument><expr><name>econv_wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>econv_finished</name></expr>:</case>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>dp</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>newstr</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_conv_enc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_conv_enc_opts</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_external_str_new_with_enc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>eenc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>ienc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>eidx</name> <init>= <expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>eenc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>eenc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eidx</name> <operator>==</operator> <call><name>rb_ascii8bit_encindex</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>eidx</name> <operator>==</operator> <call><name>rb_usascii_encindex</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ienc</name> <operator>=</operator> <call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ienc</name> <operator>||</operator> <name>eenc</name> <operator>==</operator> <name>ienc</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>eenc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eidx</name> <operator>==</operator> <call><name>rb_ascii8bit_encindex</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>eidx</name> <operator>==</operator> <call><name>rb_usascii_encindex</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>

<operator>(</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>eenc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>search_nonascii</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ienc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ienc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>rb_str_cat_conv_enc_opts</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>eenc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_initialize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>eenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_external_str_with_enc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>eenc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>eidx</name> <init>= <expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>eenc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>eidx</name> <operator>==</operator> <call><name>rb_usascii_encindex</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_ascii8bit_encindex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>eidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>eenc</name></expr></argument>, <argument><expr><call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_external_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_external_str_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_locale_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_locale_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_locale_str_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_locale_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_filesystem_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_filesystem_str_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_export</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_export_locale</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_locale_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_export_to_enc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_replace_shared_without_enc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>termlen</name> <init>= <expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr2</name> <init>= <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr2</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><name>ptr2</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>root</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_SHARED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>STR_SHARED</name><operator>|</operator><name>STR_NOFREE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>STR_SHARED_ROOT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_fatal</name><argument_list>(<argument><expr><literal type="string">"about to free a possible shared root"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr2</name> <init>= <expr><call><name>STR_HEAP_PTR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr2</name> <operator>!=</operator> <name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><name>ptr2</name></expr></argument>, <argument><expr><call><name>STR_HEAP_SIZE</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>STR_NOEMBED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_SHARED</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>str2</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_replace_shared</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_replace_shared_without_enc</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_exact_copy</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str2</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_new_shared</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_replace_shared</name><argument_list>(<argument><expr><call><name>str_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_new_shared</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new_shared</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_new_frozen</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>orig</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>str_new_frozen</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_tmp_frozen_acquire</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>OBJ_FROZEN_RAW</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>orig</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>str_new_frozen_buffer</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>orig</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_str_tmp_frozen_release</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tmp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>OBJ_FROZEN_RAW</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_force_recycle</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>STR_SHARED</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>STR_TMPLOCK</name><operator>|</operator><name>RUBY_FL_FREEZE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>shared</name> <init>= <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>shared</name> <operator>==</operator> <name>tmp</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>STR_BORROWED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FL_UNSET_RAW</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>STR_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>==</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>STR_NOFREE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>OBJ_FROZEN_RAW</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_force_recycle</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_new_frozen</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new_frozen_buffer</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_new_frozen_buffer</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>copy_encoding</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>STR_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>shared</name> <init>= <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>ofs</name> <init>= <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>-</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>rest</name> <init>= <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>ofs</name> <operator>-</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ofs</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>rest</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>klass</name> <operator>!=</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name><operator>)</operator> <operator>||</operator>

<call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_new_shared</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>+=</operator> <name>ofs</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <name>ofs</name> <operator>+</operator> <name>rest</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>FL_SET_RAW</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr><name>STR_BORROWED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>shared</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_NOEMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>STR_NOFREE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>STR_NOFREE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_SHARED</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>FL_UNSET_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_BORROWED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>copy_encoding</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_enc_cr_str_exact_copy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_new_with_class</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new0</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_new_empty</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>v</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_BUF_MIN_SIZE</name></cpp:macro> <cpp:value>63</cpp:value></cpp:define>

<expr_stmt><expr><call><name>STATIC_ASSERT</name><argument_list>(<argument><expr><name>STR_BUF_MIN_SIZE</name></expr></argument>, <argument><expr><name>STR_BUF_MIN_SIZE</name> <operator>&gt;</operator> <name>RSTRING_EMBED_LEN_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>VALUE</name></type>

<name>rb_str_buf_new</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>capa</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>str_alloc</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>&lt;</operator> <name>STR_BUF_MIN_SIZE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>capa</name> <operator>=</operator> <name>STR_BUF_MIN_SIZE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_NOEMBED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>capa</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>capa</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_buf_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_tmp_new</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_str_free</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>RSTRING_FSTR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>fstr</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>str</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><call><name>rb_vm_fstring_table</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>fstr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_str_fstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_str_embed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name> <operator>|</operator> <name>STR_NOFREE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>obj_str_shared</name></expr></argument>, <argument><expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>RB_DEBUG_COUNTER_INC_IF</name><argument_list>(<argument><expr><name>obj_str_shared</name></expr></argument>, <argument><expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_NOFREE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_str_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><call><name>STR_HEAP_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR_HEAP_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>RUBY_FUNC_EXPORTED</name> <name>size_t</name></type>

<name>rb_str_memsize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_NOEMBED</name><operator>|</operator><name>STR_SHARED</name><operator>|</operator><name>STR_NOFREE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STR_NOEMBED</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>STR_HEAP_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_to_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_convert_type_with_id</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>, <argument><expr><literal type="string">"String"</literal></expr></argument>, <argument><expr><name>idTo_str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>str_discard</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>str_shared_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>

<name>rb_str_shared_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>str2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_shared_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>str_shared_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>termlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RUBY_ASSERT</name><argument_list>(<argument><expr><name>str2</name> <operator>!=</operator> <name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_discard</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>termlen</name> <operator>=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>STR_SET_EMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>STR_SET_NOEMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>STR_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>shared</name> <init>= <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>STR_SET_SHARED</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_obj_as_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>idTo_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_obj_as_string_result</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_obj_as_string_result</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_any_to_s</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_SHARED_P</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>shared</name> <init>= <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_NOEMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_SHARED</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_exact_copy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>str_replace_shared</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>str_duplicate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<enum>enum <block>{<decl><name>embed_size</name> <init>= <expr><name>RSTRING_EMBED_LEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>}</block>;</enum>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>flag_mask</name> <init>=

<expr><name>RSTRING_NOEMBED</name> <operator>|</operator> <name>RSTRING_EMBED_LEN_MASK</name> <operator>|</operator>

<name>ENC_CODERANGE_MASK</name> <operator>|</operator> <name>ENCODING_MASK</name> <operator>|</operator>

<name>FL_FREEZE</name></expr></init></decl>

;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name> <init>= <expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>flag_mask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dup</name> <init>= <expr><call><name>str_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>,

<argument><expr><name>char</name></expr></argument>, <argument><expr><name>embed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STR_NOEMBED</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>FL_FREEZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>str_new_frozen</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>flag_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STR_NOEMBED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RSTRING</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STR_SHARED</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>,

<argument><expr><name>char</name></expr></argument>, <argument><expr><name>embed_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ENCODING_MASK</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>ENCODING_INLINE_MAX</name><operator>&lt;&lt;</operator><name>ENCODING_SHIFT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>encidx</name> <operator>=</operator> <call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>ENCODING_MASK</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FL_SET_RAW</name><argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>FL_FREEZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>encidx</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>dup</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_dup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_duplicate</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_resurrect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_DTRACE_CREATE_HOOK</name><argument_list>(<argument><expr><name>STRING</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>str_duplicate</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name><name>keyword_ids</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>orig</name></decl>, <decl><type ref="prev"/><name>opt</name></decl>, <decl><type ref="prev"/><name>venc</name></decl>, <decl><type ref="prev"/><name>vcapa</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>kwargs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>keyword_ids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>keyword_ids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_id_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name><name>keyword_ids</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"capacity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"01:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>orig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>keyword_ids</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>kwargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>venc</name> <operator>=</operator> <name><name>kwargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>vcapa</name> <operator>=</operator> <name><name>kwargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>venc</name> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>venc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_to_encoding</name><argument_list>(<argument><expr><name>venc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vcapa</name> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>vcapa</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>capa</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>vcapa</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>termlen</name> <init>= <expr><ternary><condition><expr><name>enc</name></expr> ?</condition><then> <expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>&lt;</operator> <name>STR_BUF_MIN_SIZE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>capa</name> <operator>=</operator> <name>STR_BUF_MIN_SIZE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>capa</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>orig</name> <operator>==</operator> <name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_ptr</name> <init>= <expr><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>capa</name> <operator>+</operator> <name>termlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_ptr</name></expr></argument>, <argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><name>RSTRING_EMBED_LEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>new_ptr</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name><operator>|</operator><name>STR_NOFREE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><name>capa</name> <operator>+</operator> <name>termlen</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>old_ptr</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>osize</name> <init>= <expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>+</operator> <call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_ptr</name> <init>= <expr><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>capa</name> <operator>+</operator> <name>termlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_ptr</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>osize</name> <operator>&lt;</operator> <name>size</name></expr> ?</condition><then> <expr><name>osize</name></expr> </then><else>: <expr><name>size</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_UNSET_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>new_ptr</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STR_HEAP_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>capa</name> <operator>+</operator> <name>termlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SIZED_REALLOC_N</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>char</name></expr></argument>,

<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>capa</name> <operator>+</operator> <name>termlen</name></expr></argument>, <argument><expr><call><name>STR_HEAP_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_exact_copy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_NOEMBED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>capa</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NONASCII_MASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_utf8_lead_byte</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((c)&amp;0xC0) != 0x80)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uintptr_t</name></type>

<name>count_utf8_lead_bytes_with_word</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uintptr_t</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>uintptr_t</name></type> <name>d</name> <init>= <expr><operator>*</operator><name>s</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>d</name><operator>&gt;&gt;</operator><literal type="number">6</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>~</operator><name>d</name><operator>&gt;&gt;</operator><literal type="number">7</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>d</name> <operator>&amp;=</operator> <name>NONASCII_MASK</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BUILTIN___BUILTIN_POPCOUNT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__POPCNT__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<return>return <expr><call><name>rb_popcount_intptr</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>d</name> <operator>+=</operator> <operator>(</operator><name>d</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>d</name> <operator>+=</operator> <operator>(</operator><name>d</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOIDP</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>

<expr_stmt><expr><name>d</name> <operator>+=</operator> <operator>(</operator><name>d</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><name>d</name><operator>&amp;</operator><literal type="number">0xF</literal><operator>)</operator></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>

<name>enc_strlen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>diff</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<return>return <expr><name>diff</name> <operator>/</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name>diff</name> <operator>%</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NONASCII_MASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_VALID</name> <operator>&amp;&amp;</operator> <name>enc</name> <operator>==</operator> <call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uintptr_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>e</name> <operator>-</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>lowbits</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>uintptr_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>~</operator><name>lowbits</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>p</name> <operator>+</operator> <name>lowbits</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>uintptr_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>~</operator><name>lowbits</name> <operator>&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>e</name><operator>)</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_utf8_lead_byte</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>t</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>count_utf8_lead_bytes_with_word</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_utf8_lead_byte</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><operator>(</operator><name>long</name><operator>)</operator><name>len</name></expr>;</return>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE_CLEAN_P</name><argument_list>(<argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ISASCII</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>c</name> <operator>+</operator> <operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>+=</operator> <name>q</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>rb_enc_fast_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ISASCII</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>c</name> <operator>+</operator> <operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>+=</operator> <name>q</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>c</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>c</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name><operator>&lt;</operator><name>e</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>c</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>long</name></type>

<name>rb_enc_strlen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enc_strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>long</name></type>

<name>rb_enc_strlen_cr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>diff</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<return>return <expr><name>diff</name> <operator>/</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>!</operator><operator>!</operator><operator>(</operator><name>diff</name> <operator>%</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ISASCII</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_7BIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>c</name> <operator>+</operator> <operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>+=</operator> <name>q</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>cr</name> <operator>|=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_BROKEN</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_7BIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>c</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>c</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name><operator>&lt;</operator><name>e</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>cr</name> <operator>|=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_BROKEN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_7BIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>c</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>str_strlen</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>rb_enc_strlen_cr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>n</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>enc_strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>long</name></type>

<name>rb_str_strlen</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_bytesize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_empty</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_plus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str3</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr3</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>termlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check_str</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>termlen</name> <operator>=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;</operator> <name>LONG_MAX</name> <operator>-</operator> <name>len2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"string size too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str3</name> <operator>=</operator> <call><name>str_new0</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len1</name><operator>+</operator><name>len2</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr3</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr3</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr3</name><operator>+</operator><name>len1</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptr3</name><index>[<expr><name>len1</name><operator>+</operator><name>len2</name></expr>]</index></name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENCODING_CODERANGE_SET</name><argument_list>(<argument><expr><name>str3</name></expr></argument>, <argument><expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ENC_CODERANGE_AND</name><argument_list>(<argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str3</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_str_opt_plus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MAYBE_UNUSED</name><argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></call> <operator>*</operator><name>ptr1</name></expr><operator>,</operator> <expr><operator>*</operator><name>ptr2</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>enc1</name> <init>= <expr><call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>enc2</name> <init>= <expr><call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enc1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>enc2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>enc1</name> <operator>!=</operator> <name>enc2</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>len1</name> <operator>&gt;</operator> <name>LONG_MAX</name> <operator>-</operator> <name>len2</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qundef</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_str_plus</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_times</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>times</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>termlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>times</name> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>times</name> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>str_alloc</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str2</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>str_alloc</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <call><name>ZALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_NOEMBED</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str2</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <name>LONG_MAX</name><operator>/</operator><name>len</name> <operator>&lt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"argument too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>*=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>termlen</name> <operator>=</operator> <call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>str_new0</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr2</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>n</name> <operator>&lt;=</operator> <name>len</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr2</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr2</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>len</name><operator>-</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptr2</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_copy_for_substr</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str2</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_format_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_format</name><argument_list>(<argument><expr><call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_str_format</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>rb_check_lockedtmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_TMPLOCK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"can't modify string; temporarily locked"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>str_modifiable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_check_lockedtmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>str_dependent_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name><operator>|</operator><name>STR_NOFREE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>str_independent</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>!</operator><call><name>str_dependent_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>str_make_independent_expand</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>expand</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>termlen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>capa</name> <init>= <expr><name>len</name> <operator>+</operator> <name>expand</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>capa</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name>capa</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>capa</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>capa</name> <operator>+</operator> <name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>oldptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oldptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>oldptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_NOEMBED</name><operator>|</operator><name>STR_NOFREE</name><operator>|</operator><name>STR_SHARED</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STR_NOEMBED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>oldptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STR_SET_NOEMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name><operator>|</operator><name>STR_NOFREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>capa</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_str_modify</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str_independent</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>str_make_independent</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_str_modify_expand</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>expand</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>termlen</name> <init>= <expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>expand</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative expanding string size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>expand</name> <operator>&gt;=</operator> <name>LONG_MAX</name> <operator>-</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"string size too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str_independent</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>str_make_independent_expand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>expand</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RESIZE_CAPA_TERM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>expand</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>str_modify_keep_cr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str_independent</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>str_make_independent</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>str_discard</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_SHARED</name><operator>|</operator><name>STR_NOFREE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><call><name>STR_HEAP_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR_HEAP_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_must_asciicompat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncCompatError</name></expr></argument>, <argument><expr><literal type="string">"ASCII incompatible encoding: %s"</literal></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_string_value</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>rb_str_to_str</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>rb_string_value_ptr</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_string_value</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>zero_filled</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>n</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>str_null_char</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>s</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>+</operator> <name>minlen</name> <operator>&lt;=</operator> <name>e</name></expr>;</condition> <incr><expr><name>s</name> <operator>+=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>zero_filled</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>minlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>s</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>str_fill_term</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>termlen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>str_dependent_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zero_filled</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>str_make_independent_expand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_str_change_terminator_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>oldtermlen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>termlen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>capa</name> <init>= <expr><call><name>str_capacity</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>oldtermlen</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>oldtermlen</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>capa</name> <operator>&gt;=</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>-</operator> <name>len</name> <operator>&lt;</operator> <name>termlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_check_lockedtmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_make_independent_expand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>str_dependent_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>termlen</name> <operator>&gt;</operator> <name>oldtermlen</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>str_make_independent_expand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><operator>(</operator><name>str</name><operator>)</operator></expr></argument>, <argument><expr><name>STR_SHARED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>capa</name> <operator>-</operator> <name>termlen</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>termlen</name> <operator>&gt;</operator> <name>oldtermlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>str_null_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>minlen</name> <init>= <expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>minlen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>w</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>str_null_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>minlen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>str_fill_term</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>minlen</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>w</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>len</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>str_fill_term</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>minlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>rb_str_to_cstr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>

<return>return <expr><call><name>str_null_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>rb_string_value_cstr</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_string_value</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>str_null_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"string contains null char"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"string contains null byte"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>rb_str_fill_terminator</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newminlen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>str_fill_term</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>newminlen</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_check_string_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_check_convert_type_with_id</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>, <argument><expr><literal type="string">"String"</literal></expr></argument>, <argument><expr><name>idTo_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_s_try_convert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>

<name>str_nth_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>nthp</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>nth</name> <init>= <expr><operator>*</operator><name>nthp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nth</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nth</name> <operator>*</operator> <call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;</operator> <name>nth</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>e2</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>nth</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&lt;</operator> <name>e2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>nthp</name> <operator>=</operator> <name>nth</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>e</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISASCII</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nth</name> <operator>-=</operator> <name>e2</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>nthp</name> <operator>=</operator> <name>nth</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>e2</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nth</name> <operator>-=</operator> <name>p2</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nth</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>nthp</name> <operator>=</operator> <name>nth</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>e</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <name>nth</name><operator>--</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>nthp</name> <operator>=</operator> <name>nth</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type>

<name>rb_enc_nth</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nth</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_nth_len</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nth</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>

<name>str_nth</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nth</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>singlebyte</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>singlebyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>nth</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>str_nth_len</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nth</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>str_offset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nth</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>singlebyte</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><call><name>str_nth</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>singlebyte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>e</name> <operator>-</operator> <name>p</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>pp</name> <operator>-</operator> <name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>long</name></type>

<name>rb_str_offset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_offset</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pos</name></expr></argument>,

<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NONASCII_MASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>str_utf8_nth</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>nthp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>nth</name> <init>= <expr><operator>*</operator><name>nthp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>SIZEOF_VOIDP</name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>e</name> <operator>-</operator> <name>p</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>SIZEOF_VOIDP</name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>nth</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>lowbits</name> <init>= <expr><name>SIZEOF_VOIDP</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>uintptr_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>~</operator><name>lowbits</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>p</name> <operator>+</operator> <name>lowbits</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>uintptr_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>~</operator><name>lowbits</name> <operator>&amp;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><name>e</name><operator>)</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_utf8_lead_byte</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nth</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<do>do <block>{<block_content>

<expr_stmt><expr><name>nth</name> <operator>-=</operator> <call><name>count_utf8_lead_bytes_with_word</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>t</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>SIZEOF_VOIDP</name> <operator>&lt;=</operator> <name>nth</name></expr>)</condition>;</do>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_utf8_lead_byte</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nth</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>nthp</name> <operator>=</operator> <name>nth</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>str_utf8_offset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nth</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><call><name>str_utf8_nth</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>pp</name> <operator>-</operator> <name>p</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>long</name></type>

<name>rb_str_sublen</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>pos</name></expr>;</return></block_content></block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>enc_strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_subseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>SHARABLE_SUBSTRING_P</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>rb_str_new_shared</name><argument_list>(<argument><expr><call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>+=</operator> <name>beg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>olen</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>+</operator><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_copy_for_substr</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str2</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>rb_str_subpos</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>lenp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><operator>*</operator><name>lenp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name> <init>= <expr><operator>-</operator><literal type="number">1L</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>blen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name> <init>= <expr><name>s</name> <operator>+</operator> <name>blen</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>blen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;</operator> <name>blen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>+=</operator> <name>blen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>blen</name> <operator>-</operator> <name>beg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>blen</name> <operator>-</operator> <name>beg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>beg</name></expr>;</expr_stmt>

<goto>goto <name>end</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>-</operator><name>beg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>-</operator><name>beg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>-</operator><name>beg</name> <operator>*</operator> <call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <operator>-</operator><name>beg</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>beg</name><operator>--</operator> <operator>&gt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>e</name> <operator>=</operator> <call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>len</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>=</operator> <call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<goto>goto <name>end</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>beg</name> <operator>+=</operator> <name>slen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>beg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>beg</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>beg</name> <operator>&gt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;</operator> <call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>beg</name></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NONASCII_MASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_VALID</name> <operator>&amp;&amp;</operator>

<name>enc</name> <operator>==</operator> <call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>str_utf8_nth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>str_utf8_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>char_sz</name> <init>= <expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>beg</name> <operator>*</operator> <name>char_sz</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>len</name> <operator>*</operator> <name>char_sz</name> <operator>&gt;</operator> <name>e</name> <operator>-</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>*=</operator> <name>char_sz</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>str_nth_len</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>str_offset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<label><name>end</name>:</label>

<expr_stmt><expr><operator>*</operator><name>lenp</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_substr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>empty</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>VALUE</name></type>

<name>rb_str_substr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_substr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_substr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>empty</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>rb_str_subpos</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>SHARABLE_SUBSTRING_P</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>ofs</name> <init>= <expr><name>p</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>str_new_shared</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>+=</operator> <name>ofs</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>empty</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_copy_for_substr</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str2</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_freeze</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_uplus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_uminus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BARE_STRING_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_obj_frozen_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>RUBY_ALIAS_FUNCTION</name><argument_list>(<argument>rb_str_dup_frozen(VALUE str)</argument>, <argument>rb_str_new_frozen</argument>, <argument>(str)</argument>)</argument_list></macro>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_str_dup_frozen</name></cpp:macro> <cpp:value>rb_str_new_frozen</cpp:value></cpp:define>

<function><type><name>VALUE</name></type>

<name>rb_str_locktmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_TMPLOCK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"temporal locking already locked string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_TMPLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_unlocktmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_TMPLOCK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"temporal unlocking already unlocked string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>STR_TMPLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>RUBY_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_str_locktmp_ensure</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_str_locktmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>rb_str_unlocktmp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_str_set_len</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>capa</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>termlen</name> <init>= <expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_SHARED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"can't set length of shared string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>capa</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>str_capacity</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"probable buffer overflow: %ld for %ld"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><name>len</name></expr>]</index></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_resize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>independent</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative string size (or size too big)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>independent</name> <operator>=</operator> <call><name>str_independent</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>capa</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>termlen</name> <init>= <expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>STR_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>str_make_independent_expand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>slen</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>STR_HEAP_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>slen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>independent</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>independent</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>str_make_independent_expand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>slen</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>capa</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name><operator>)</operator> <operator>&lt;</operator> <name>len</name> <operator>||</operator>

<operator>(</operator><name>capa</name> <operator>-</operator> <name>len</name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><name>len</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><literal type="number">1024</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SIZED_REALLOC_N</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>char</name></expr></argument>,

<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name> <operator>+</operator> <name>termlen</name></expr></argument>, <argument><expr><call><name>STR_HEAP_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_buf_cat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>capa</name></decl>, <decl><type ref="prev"/><name>total</name></decl>, <decl><type ref="prev"/><name>olen</name></decl>, <decl><type ref="prev"/><name>off</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>termlen</name> <init>= <expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>termlen</name> <operator>&lt;</operator> <name>RSTRING_EMBED_LEN_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sptr</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>sptr</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;=</operator> <name>sptr</name> <operator>+</operator> <name>olen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>off</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>sptr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_modify</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>capa</name> <operator>=</operator> <name>RSTRING_EMBED_LEN_MAX</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>termlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>RSTRING_EMBED_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>capa</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>olen</name> <operator>&gt;</operator> <name>LONG_MAX</name> <operator>-</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"string sizes too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>total</name> <operator>=</operator> <name>olen</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>&lt;</operator> <name>total</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>total</name> <operator>&gt;=</operator> <name>LONG_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>capa</name> <operator>=</operator> <name>total</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>total</name> <operator>&gt;</operator> <name>capa</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>capa</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>capa</name> <operator>+</operator> <name>termlen</name></expr>;</expr_stmt> 

</block_content>}</block></while>

<expr_stmt><expr><call><name>RESIZE_CAPA_TERM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>sptr</name> <operator>+</operator> <name>off</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sptr</name> <operator>+</operator> <name>olen</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><name>sptr</name> <operator>+</operator> <name>total</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str_buf_cat2</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>str_buf_cat((str), (ptr), strlen(ptr))</cpp:value></cpp:define>

<function><type><name>VALUE</name></type>

<name>rb_str_cat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative string size (or size too big)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_cat_cstr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>must_not_null</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>RUBY_ALIAS_FUNCTION</name><argument_list>(<argument>rb_str_buf_cat(VALUE str, const char *ptr, long len)</argument>, <argument>rb_str_cat</argument>, <argument>(str, ptr, len)</argument>)</argument_list></macro>

<macro><name>RUBY_ALIAS_FUNCTION</name><argument_list>(<argument>rb_str_buf_cat2(VALUE str, const char *ptr)</argument>, <argument>rb_str_cat_cstr</argument>, <argument>(str, ptr)</argument>)</argument_list></macro>

<macro><name>RUBY_ALIAS_FUNCTION</name><argument_list>(<argument>rb_str_cat2(VALUE str, const char *ptr)</argument>, <argument>rb_str_cat_cstr</argument>, <argument>(str, ptr)</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_enc_cr_str_buf_cat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>ptr_encindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ptr_cr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptr_cr_ret</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>str_encindex</name> <init>= <expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res_encindex</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>str_cr</name></decl>, <decl><type ref="prev"/><name>res_cr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>str_enc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr_enc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str_cr</name> <operator>=</operator> <ternary><condition><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>ENC_CODERANGE_7BIT</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str_encindex</name> <operator>==</operator> <name>ptr_encindex</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>str_cr</name> <operator>!=</operator> <name>ENC_CODERANGE_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>ptr_cr</name> <operator>==</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr_cr</name> <operator>=</operator> <call><name>coderange_scan</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>ptr_encindex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>str_enc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>str_encindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr_enc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>ptr_encindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>str_enc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>ptr_enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENCODING_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr_encindex</name></expr></argument>, <argument><expr><name>ptr_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<goto>goto <name>incompatible</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr_cr</name> <operator>==</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr_cr</name> <operator>=</operator> <call><name>coderange_scan</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ptr_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str_cr</name> <operator>==</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ENCODING_IS_ASCII8BIT</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>ptr_cr</name> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str_cr</name> <operator>=</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr_cr_ret</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr_cr_ret</name> <operator>=</operator> <name>ptr_cr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str_encindex</name> <operator>!=</operator> <name>ptr_encindex</name> <operator>&amp;&amp;</operator>

<name>str_cr</name> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name> <operator>&amp;&amp;</operator>

<name>ptr_cr</name> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str_enc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>str_encindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr_enc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>ptr_encindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>incompatible</name>:</label>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncCompatError</name></expr></argument>, <argument><expr><literal type="string">"incompatible character encodings: %s and %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>ptr_enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str_cr</name> <operator>==</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res_encindex</name> <operator>=</operator> <name>str_encindex</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res_cr</name> <operator>=</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>str_cr</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ptr_cr</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res_encindex</name> <operator>=</operator> <name>str_encindex</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res_cr</name> <operator>=</operator> <name>ENC_CODERANGE_7BIT</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>res_encindex</name> <operator>=</operator> <name>ptr_encindex</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res_cr</name> <operator>=</operator> <name>ptr_cr</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>str_cr</name> <operator>==</operator> <name>ENC_CODERANGE_VALID</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res_encindex</name> <operator>=</operator> <name>str_encindex</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE_CLEAN_P</name><argument_list>(<argument><expr><name>ptr_cr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res_cr</name> <operator>=</operator> <name>str_cr</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>res_cr</name> <operator>=</operator> <name>ptr_cr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><name>res_encindex</name> <operator>=</operator> <name>str_encindex</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res_cr</name> <operator>=</operator> <name>str_cr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>res_cr</name> <operator>=</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative string size (or size too big)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENCODING_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>res_encindex</name></expr></argument>, <argument><expr><name>res_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_enc_str_buf_cat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>ptr_enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_enc_cr_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,

<argument><expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>ptr_enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ENC_CODERANGE_UNKNOWN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_buf_cat_ascii</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>encindex</name> <init>= <expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_enc_cr_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>encindex</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>rb_enc_codelen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,

<argument><expr><name>encindex</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_VALID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_buf_append</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>str2_cr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str2_cr</name> <operator>=</operator> <call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str2_cr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str2_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str2_cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_append</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_PRE_ALLOC_SIZE</name></cpp:macro> <cpp:value>48</cpp:value></cpp:define>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_str_concat_literals</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>strary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>num</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_resurrect</name><argument_list>(<argument><expr><name><name>strary</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content> <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name><name>strary</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;</operator> <name>MIN_PRE_ALLOC_SIZE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_resurrect</name><argument_list>(<argument><expr><name><name>strary</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>strary</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>v</name> <init>= <expr><name><name>strary</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>encidx</name></expr></argument>, <argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>!=</operator> <name>ENCINDEX_US_ASCII</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ENCODING_GET_INLINED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENCINDEX_US_ASCII</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_enc_set_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_concat_multi</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg_str</name> <init>= <expr><call><name>rb_str_tmp_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_concat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_num_to_uint</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>code</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"%ld out of char range"</literal></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"bignum out of char range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>encidx</name> <operator>=</operator> <call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>==</operator> <name>ENCINDEX_ASCII</name> <operator>||</operator> <name>encidx</name> <operator>==</operator> <name>ENCINDEX_US_ASCII</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>code</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>&gt;</operator> <literal type="number">0xFF</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"%u out of char range"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>==</operator> <name>ENCINDEX_US_ASCII</name> <operator>&amp;&amp;</operator> <name>code</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>ENCINDEX_ASCII</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>len</name> <operator>=</operator> <call><name>rb_enc_codelen</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ONIGERR_INVALID_CODE_POINT_VALUE</name></expr>:</case>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"invalid codepoint 0x%X in %s"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ONIGERR_TOO_BIG_WIDE_CHAR_VALUE</name></expr>:</case>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"%u out of char range"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"invalid codepoint 0x%X in %s"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>pos</name><operator>+</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name> <operator>&amp;&amp;</operator> <name>code</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>str1</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_prepend_multi</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_update</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg_str</name> <init>= <expr><call><name>rb_str_tmp_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>arg_str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_update</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>arg_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>st_index_t</name></type>

<name>rb_str_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_memhash</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>^</operator> <name>e</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_str_hash_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>len1</name> <operator>!=</operator> <name>len2</name> <operator>||</operator>

<operator>!</operator><call><name>rb_str_comparable</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>memcmp</name><argument_list>(<argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_hash_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>hval</name> <init>= <expr><call><name>rb_str_hash</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>hval</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lesser</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a)&gt;(b))?(b):(a))</cpp:value></cpp:define>

<function><type><name>int</name></type>

<name>rb_str_comparable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx1</name></decl>, <decl><type ref="prev"/><name>idx2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rc1</name></decl>, <decl><type ref="prev"/><name>rc2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>idx1</name> <operator>=</operator> <call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx2</name> <operator>=</operator> <call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx1</name> <operator>==</operator> <name>idx2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rc1</name> <operator>=</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rc2</name> <operator>=</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rc1</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rc2</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rc2</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_str_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str1</name> <operator>==</operator> <name>str2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr1</name> <operator>==</operator> <name>ptr2</name> <operator>||</operator> <operator>(</operator><name>retval</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>ptr1</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><call><name>lesser</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>==</operator> <name>len2</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_str_comparable</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&gt;</operator> <name>len2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>str1</name> <operator>==</operator> <name>str2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_respond_to</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>idTo_str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_str_eql_internal</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_str_eql</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>str1</name> <operator>==</operator> <name>str2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_eql_internal</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_cmp_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_invcmp</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_cmp</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_casecmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_casecmp_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_casecmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>str_casecmp</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_casecmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p1end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p2end</name></decl>;</decl_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_compatible</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>p1end</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>p2end</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>p1</name> <operator>&lt;</operator> <name>p1end</name> <operator>&amp;&amp;</operator> <name>p2</name> <operator>&lt;</operator> <name>p2end</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p1</name> <operator>!=</operator> <operator>*</operator><name>p2</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c1</name> <init>= <expr><call><name>TOLOWER</name><argument_list>(<argument><expr><operator>*</operator><name>p1</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c2</name> <init>= <expr><call><name>TOLOWER</name><argument_list>(<argument><expr><operator>*</operator><name>p2</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><ternary><condition><expr><name>c1</name> <operator>&lt;</operator> <name>c2</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>p1</name> <operator>&lt;</operator> <name>p1end</name> <operator>&amp;&amp;</operator> <name>p2</name> <operator>&lt;</operator> <name>p2end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>, <decl><type ref="prev"/><name>c1</name> <init>= <expr><call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p1end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l1</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l2</name></decl>, <decl><type ref="prev"/><name>c2</name> <init>= <expr><call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p2end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l2</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>c1</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>&lt;=</operator> <name>c2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>TOLOWER</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>TOLOWER</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><ternary><condition><expr><name>c1</name> <operator>&lt;</operator> <name>c2</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>l1</name> <operator>=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p1end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p2end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>l1</name> <operator>&lt;</operator> <name>l2</name></expr> ?</condition><then> <expr><name>l1</name></expr> </then><else>: <expr><name>l2</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><ternary><condition><expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>l1</name> <operator>!=</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><ternary><condition><expr><name>l1</name> <operator>&lt;</operator> <name>l2</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p1</name> <operator>+=</operator> <name>l1</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p2</name> <operator>+=</operator> <name>l2</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_casecmp_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>str_casecmp_p</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_casecmp_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>folded_str1</name></decl>, <decl><type ref="prev"/><name>folded_str2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>fold_opt</name> <init>= <expr><name>sym_fold</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_compatible</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>folded_str1</name> <operator>=</operator> <call><name>rb_str_downcase</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fold_opt</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>folded_str2</name> <operator>=</operator> <call><name>rb_str_downcase</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fold_opt</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_eql</name><argument_list>(<argument><expr><name>folded_str1</name></expr></argument>, <argument><expr><name>folded_str2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>strseq_core</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_ptr_end</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>str_len</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sub_ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>sub_len</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>search_start</name> <init>= <expr><name>str_ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>search_len</name> <init>= <expr><name>str_len</name> <operator>-</operator> <name>offset</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_memsearch</name><argument_list>(<argument><expr><name>sub_ptr</name></expr></argument>, <argument><expr><name>sub_len</name></expr></argument>, <argument><expr><name>search_start</name></expr></argument>, <argument><expr><name>search_len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>pos</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>rb_enc_right_char_head</name><argument_list>(<argument><expr><name>search_start</name></expr></argument>, <argument><expr><name>search_start</name><operator>+</operator><name>pos</name></expr></argument>, <argument><expr><name>str_ptr_end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>search_start</name> <operator>+</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>search_len</name> <operator>-=</operator> <name>t</name> <operator>-</operator> <name>search_start</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>search_len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>t</name> <operator>-</operator> <name>search_start</name></expr>;</expr_stmt>

<expr_stmt><expr><name>search_start</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>pos</name> <operator>+</operator> <name>offset</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_str_index</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>sub</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_strseq_index(str, sub, offset, 0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>rb_strseq_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sub</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_byte</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str_ptr_end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sub_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>str_len</name></decl>, <decl><type ref="prev"/><name>sub_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>single_byte</name> <init>= <expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_broken_string</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str_ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_ptr_end</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str_len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sub_ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sub_len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str_len</name> <operator>&lt;</operator> <name>sub_len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>str_len_char</name></decl>, <decl><type ref="prev"/><name>sub_len_char</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str_len_char</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>in_byte</name> <operator>||</operator> <name>single_byte</name><operator>)</operator></expr> ?</condition><then> <expr><name>str_len</name></expr> </then><else>: <expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>sub_len_char</name> <operator>=</operator> <ternary><condition><expr><name>in_byte</name></expr> ?</condition><then> <expr><name>sub_len</name></expr> </then><else>: <expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>str_len_char</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str_len_char</name> <operator>-</operator> <name>offset</name> <operator>&lt;</operator> <name>sub_len_char</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_byte</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>str_offset</name><argument_list>(<argument><expr><name>str_ptr</name></expr></argument>, <argument><expr><name>str_ptr_end</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>single_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str_ptr</name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sub_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>offset</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>strseq_core</name><argument_list>(<argument><expr><name>str_ptr</name></expr></argument>, <argument><expr><name>str_ptr_end</name></expr></argument>, <argument><expr><name>str_len</name></expr></argument>, <argument><expr><name>sub_ptr</name></expr></argument>, <argument><expr><name>sub_len</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_index_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>sub</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>initpos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>initpos</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>initpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>generic</name>;</goto></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>str_offset</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pos</name></expr></argument>,

<argument><expr><call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_reg_search</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_sublen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<label><name>generic</name>:</label>

<default>default:</default> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"type mismatch: %s given"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sub</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block>

<case>case <expr><name>T_STRING</name></expr>:</case>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_sublen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMRCHR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>long</name></type>

<name>str_rindex</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sub</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hit</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>adjusted</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name></decl>, <decl><type ref="prev"/><name>searchlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sbeg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>pos</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sbeg</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>t</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>searchlen</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>sbeg</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>memrchr</name><argument_list>(<argument><expr><name>sbeg</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>searchlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hit</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>adjusted</name> <operator>=</operator> <call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>sbeg</name></expr></argument>, <argument><expr><name>hit</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name> <operator>!=</operator> <name>adjusted</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>searchlen</name> <operator>=</operator> <name>adjusted</name> <operator>-</operator> <name>sbeg</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>hit</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_str_sublen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>hit</name> <operator>-</operator> <name>sbeg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>searchlen</name> <operator>=</operator> <name>adjusted</name> <operator>-</operator> <name>sbeg</name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>searchlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>str_rindex</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sub</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sbeg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sbeg</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>pos</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pos</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>sbeg</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>rb_str_rindex</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sub</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sbeg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>singlebyte</name></decl>;</decl_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_broken_string</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>singlebyte</name> <operator>=</operator> <call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>singlebyte</name></expr> ?</condition><then> <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt> 

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>str_strlen</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>-</operator> <name>pos</name> <operator>&lt;</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>slen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>pos</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sbeg</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>sbeg</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>str_nth</name><argument_list>(<argument><expr><name>sbeg</name></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>singlebyte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>str_rindex</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_rindex_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>sub</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vpos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vpos</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>vpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>generic</name>;</goto></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>str_offset</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pos</name></expr></argument>,

<argument><expr><name>enc</name></expr></argument>, <argument><expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_reg_search</name><argument_list>(<argument><expr><name>sub</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_sublen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

<label><name>generic</name>:</label>

<default>default:</default> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"type mismatch: %s given"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sub</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block>

<case>case <expr><name>T_STRING</name></expr>:</case>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_rindex</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_match</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>generic</name>;</goto></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_STRING</name></expr>:</case>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"type mismatch: String given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<return>return <expr><call><name>rb_reg_match</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>

<label><name>generic</name>:</label>

<default>default:</default>

<return>return <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>idEqTilde</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>get_pat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_match_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>re</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>re</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><call><name>get_pat</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"match"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_match_m_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>re</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>get_pat</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_reg_match_p</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><ternary><condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<enum>enum <name>neighbor_char</name> <block>{

<decl><name>NEIGHBOR_NOT_CHAR</name></decl>,

<decl><name>NEIGHBOR_FOUND</name></decl>,

<decl><name>NEIGHBOR_WRAPPED</name></decl>

}</block>;</enum>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>neighbor_char</name></name></type>

<name>enc_succ_char</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NEIGHBOR_NOT_CHAR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>rb_enc_code_to_mbclen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>l</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NEIGHBOR_NOT_CHAR</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NEIGHBOR_WRAPPED</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NEIGHBOR_NOT_CHAR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NEIGHBOR_FOUND</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0xff</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NEIGHBOR_WRAPPED</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NEIGHBOR_FOUND</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>len</name><operator>-</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>len</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l2</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>len2</name> <operator>=</operator> <name>len</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;</operator> <name>len2</name></expr>;</condition> <incr><expr><name>len2</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>len2</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>len2</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>len</name><operator>-</operator><operator>(</operator><name>len2</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>neighbor_char</name></name></type>

<name>enc_pred_char</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NEIGHBOR_NOT_CHAR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>c</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NEIGHBOR_NOT_CHAR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>rb_enc_code_to_mbclen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>l</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NEIGHBOR_NOT_CHAR</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NEIGHBOR_WRAPPED</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NEIGHBOR_NOT_CHAR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NEIGHBOR_FOUND</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\xff'</literal></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NEIGHBOR_WRAPPED</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NEIGHBOR_FOUND</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name><operator>-</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>len</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l2</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>len2</name> <operator>=</operator> <name>len</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;</operator> <name>len2</name></expr>;</condition> <incr><expr><name>len2</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>l2</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>len2</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>len2</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name><operator>-</operator><operator>(</operator><name>len2</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>neighbor_char</name></name></type>

<name>enc_succ_alnum_char</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>carry</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>neighbor_char</name></name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ctype</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>range</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>save</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>try</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_gaps</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_isctype</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_DIGIT</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ctype</name> <operator>=</operator> <name>ONIGENC_CTYPE_DIGIT</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_isctype</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ONIGENC_CTYPE_ALPHA</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ctype</name> <operator>=</operator> <name>ONIGENC_CTYPE_ALPHA</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>NEIGHBOR_NOT_CHAR</name></expr>;</return></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>save</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>try</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>try</name> <operator>&lt;=</operator> <name>max_gaps</name></expr>;</condition> <incr><expr><operator>++</operator><name>try</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>enc_succ_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NEIGHBOR_FOUND</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_isctype</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NEIGHBOR_FOUND</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>save</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>range</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>save</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>enc_pred_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NEIGHBOR_FOUND</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_isctype</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ctype</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>save</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>save</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>range</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>range</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NEIGHBOR_NOT_CHAR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>!=</operator> <name>ONIGENC_CTYPE_DIGIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>carry</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NEIGHBOR_WRAPPED</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>carry</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>enc_succ_char</name><argument_list>(<argument><expr><name>carry</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NEIGHBOR_WRAPPED</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>str_succ</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>VALUE</name></type>

<name>rb_str_succ</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_copy_for_substr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>str_succ</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_succ</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sbeg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last_alnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found_alnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>carry</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name></expr>]</index></name> <init>= <expr><literal type="string">"\1"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>carry_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>carry_len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>neighbor_char</name></name></type> <name>neighbor</name> <init>= <expr><name>NEIGHBOR_FOUND</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sbeg</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>e</name> <operator>=</operator> <name>sbeg</name> <operator>+</operator> <name>slen</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>sbeg</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>neighbor</name> <operator>==</operator> <name>NEIGHBOR_NOT_CHAR</name> <operator>&amp;&amp;</operator> <name>last_alnum</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name>ISALPHA</name><argument_list>(<argument><expr><operator>*</operator><name>last_alnum</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><ternary><condition><expr><call><name>ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>last_alnum</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>ISALPHA</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ONIGENC_MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>ONIGENC_MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>neighbor</name> <operator>=</operator> <call><name>enc_succ_alnum_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>neighbor</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NEIGHBOR_NOT_CHAR</name></expr>:</case>

<continue>continue;</continue>

<case>case <expr><name>NEIGHBOR_FOUND</name></expr>:</case>

<return>return <expr><name>str</name></expr>;</return>

<case>case <expr><name>NEIGHBOR_WRAPPED</name></expr>:</case>

<expr_stmt><expr><name>last_alnum</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>found_alnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>carry_pos</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>sbeg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>carry_len</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_alnum</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>sbeg</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>neighbor_char</name></name></type> <name>neighbor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><name>ONIGENC_CODE_TO_MBC_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ONIGENC_MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>ONIGENC_MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>neighbor</name> <operator>=</operator> <call><name>enc_succ_char</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>neighbor</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NEIGHBOR_FOUND</name></expr>:</case>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

<break>break;</break>

<case>case <expr><name>NEIGHBOR_WRAPPED</name></expr>:</case>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NEIGHBOR_NOT_CHAR</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name><operator>+</operator><name>l</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>l</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>enc_succ_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>carry</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>carry_len</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>carry_pos</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>sbeg</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RESIZE_CAPA</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name> <operator>+</operator> <name>carry_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sbeg</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>sbeg</name> <operator>+</operator> <name>carry_pos</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <name>carry_len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name> <operator>-</operator> <name>carry_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>carry</name></expr></argument>, <argument><expr><name>carry_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>slen</name> <operator>+=</operator> <name>carry_len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sbeg</name><index>[<expr><name>slen</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_succ_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_str_modify</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_succ</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>all_digits_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>len</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>str_upto_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_upto</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>beg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>end</name></decl>, <decl><type ref="prev"/><name>exclusive</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exclusive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_upto_each</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><call><name>RTEST</name><argument_list>(<argument><expr><name>exclusive</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str_upto_i</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_upto_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>excl</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>each</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>current</name></decl>, <decl><type ref="prev"/><name>after_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>succ</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>ascii</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>succ</name></expr></argument>, <argument><expr><literal type="string">"succ"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ascii</name> <operator>=</operator> <operator>(</operator><call><name>is_ascii_string</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_ascii_string</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>ascii</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>e</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>e</name> <operator>||</operator> <operator>(</operator><name>excl</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>e</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>beg</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>each</name>)<argument_list>(<argument><expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>excl</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>excl</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>beg</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ascii</name> <operator>&amp;&amp;</operator> <call><name>ISDIGIT</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISDIGIT</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>all_digits_p</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>all_digits_p</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>

<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>RSTRING_LENINT</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>rb_str_to_inum</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_str_to_inum</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>bi</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>ei</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>usascii</name> <init>= <expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>bi</name> <operator>&lt;=</operator> <name>ei</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>excl</name> <operator>&amp;&amp;</operator> <name>bi</name> <operator>==</operator> <name>ei</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>each</name>)<argument_list>(<argument><expr><call><name>rb_enc_sprintf</name><argument_list>(<argument><expr><name>usascii</name></expr></argument>, <argument><expr><literal type="string">"%.*ld"</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>bi</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bi</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>op</name> <init>= <expr><ternary><condition><expr><name>excl</name></expr> ?</condition><then> <expr><literal type="char">'&lt;'</literal></expr> </then><else>: <expr><name>idLE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>fmt</name> <init>= <expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"%.*d"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>each</name>)<argument_list>(<argument><expr><call><name>rb_str_format</name><argument_list>(<argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>succ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>beg</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_str_cmp</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>excl</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>beg</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>after_end</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><name>succ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>rb_str_equal</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>after_end</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>next</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>excl</name> <operator>||</operator> <operator>!</operator><call><name>rb_str_equal</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>succ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>each</name>)<argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>excl</name> <operator>&amp;&amp;</operator> <call><name>rb_str_equal</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>beg</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_upto_endless_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>beg</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>each</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>current</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>succ</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>succ</name></expr></argument>, <argument><expr><literal type="string">"succ"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_ascii_string</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISDIGIT</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>all_digits_p</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>fmt</name> <init>= <expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"%.*d"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><call><name>RSTRING_LENINT</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>rb_str_to_inum</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>bi</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>usascii</name> <init>= <expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>FIXABLE</name><argument_list>(<argument><expr><name>bi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>each</name>)<argument_list>(<argument><expr><call><name>rb_enc_sprintf</name><argument_list>(<argument><expr><name>usascii</name></expr></argument>, <argument><expr><literal type="string">"%.*ld"</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>bi</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bi</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>LONG2NUM</name><argument_list>(<argument><expr><name>bi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>each</name>)<argument_list>(<argument><expr><call><name>rb_str_format</name><argument_list>(<argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>succ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>next</name> <init>= <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>succ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>each</name>)<argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>current</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>beg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>include_range_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argp</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_equal</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>*</operator><name>argp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>argp</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_include_range_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exclusive</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ep</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vp</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>b</name> <init>= <expr><operator>*</operator><name>bp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>e</name> <init>= <expr><operator>*</operator><name>ep</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>v</name> <init>= <expr><operator>*</operator><name>vp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISASCII</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISASCII</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISASCII</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;=</operator> <name>v</name> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>exclusive</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>v</name> <operator>==</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (ISDIGIT(*bp) &amp;&amp; ISDIGIT(*ep) &amp;&amp;

all_digits_p(bp, RSTRING_LEN(beg)) &amp;&amp;

all_digits_p(ep, RSTRING_LEN(end))) {

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_upto_each</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><call><name>RTEST</name><argument_list>(<argument><expr><name>exclusive</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>include_range_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_subpat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>backref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_reg_search</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name> <init>= <expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><call><name>rb_reg_backref_number</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><name>nth</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_aref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>indx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_subpat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_str_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Qfalse</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>Qnil</name></expr>:</case>

<return>return <expr><name>Qnil</name></expr>;</return>

<default>default:</default>

<return>return <expr><call><name>rb_str_substr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>str_substr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_aref_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_subpat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_str_substr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_aref</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_drop_bytes</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>nlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>olen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name>olen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nlen</name> <operator>=</operator> <name>olen</name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>nlen</name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldptr</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fl</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>STR_NOEMBED</name><operator>|</operator><name>STR_SHARED</name><operator>|</operator><name>STR_NOFREE</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>oldptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fl</name> <operator>==</operator> <name>STR_NOEMBED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>oldptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_SHARED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>nlen</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>nlen</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_str_splice_0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name></decl>, <decl><type ref="prev"/><name>vlen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>vlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_drop_bytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sptr</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>vlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RESIZE_CAPA</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name> <operator>+</operator> <name>vlen</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>!=</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>sptr</name> <operator>+</operator> <name>beg</name> <operator>+</operator> <name>vlen</name></expr></argument>,

<argument><expr><name>sptr</name> <operator>+</operator> <name>beg</name> <operator>+</operator> <name>len</name></expr></argument>,

<argument><expr><name>slen</name> <operator>-</operator> <operator>(</operator><name>beg</name> <operator>+</operator> <name>len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&lt;</operator> <name>beg</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>sptr</name> <operator>+</operator> <name>slen</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><operator>-</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>sptr</name> <operator>+</operator> <name>beg</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>slen</name> <operator>+=</operator> <name>vlen</name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sptr</name><index>[<expr><name>slen</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_str_update</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>singlebyte</name> <init>= <expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"negative length %ld"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&lt;</operator> <name>beg</name></expr>)</condition> <block>{<block_content>

<label><name>out_of_range</name>:</label>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld out of string"</literal></expr></argument>, <argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>+</operator> <name>slen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>out_of_range</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>+=</operator> <name>slen</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>beg</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>beg</name> <operator>&lt;=</operator> <name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>slen</name> <operator>-</operator> <name>beg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>slen</name> <operator>-</operator> <name>beg</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>str_nth</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>singlebyte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>str_nth</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>singlebyte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>p</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_str_splice_0</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>ENC_CODERANGE_AND</name><argument_list>(<argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>!=</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_str_splice</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>beg</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_str_update(str, beg, len, val)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_str_subpat_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>backref</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nth</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_reg_search</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"regexp not matched"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nth</name> <operator>=</operator> <call><name>rb_reg_backref_number</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&gt;=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>)</condition> <block>{<block_content>

<label><name>out_of_range</name>:</label>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %d out of regexp"</literal></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>-</operator><name>nth</name> <operator>&gt;=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>out_of_range</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nth</name> <operator>+=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>BEG</name><argument_list>(<argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"regexp group %d not matched"</literal></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_splice_0</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_aset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>indx</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>beg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>num_index</name>:</label>

<expr_stmt><expr><call><name>rb_str_splice</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>generic</name>;</goto></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<expr_stmt><expr><call><name>rb_str_subpat_set</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

<case>case <expr><name>T_STRING</name></expr>:</case>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>rb_str_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"string not matched"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>rb_str_sublen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_splice</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

<label><name>generic</name>:</label>

<default>default:</default>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_splice</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>num_index</name>;</goto>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_aset_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_subpat_set</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_splice</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_aset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_insert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_splice</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_slice_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>indx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>indx</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_reg_search</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name> <init>= <expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>nth</name> <operator>=</operator> <call><name>rb_reg_backref_number</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nth</name> <operator>+=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>nth</name> <operator>&gt;=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>BEG</name><argument_list>(<argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><name>nth</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>beg</name></expr>;</expr_stmt>

<label><name>subseq</name>:</label>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>+</operator><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_cr_str_copy_for_substr</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>num_index</name>:</label>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>rb_str_subpos</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>p</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>subseq</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>rb_str_subpos</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>p</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>subseq</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>rb_str_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<switch>switch <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Qnil</name></expr>:</case>

<return>return <expr><name>Qnil</name></expr>;</return>

<case>case <expr><name>Qfalse</name></expr>:</case>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>num_index</name>;</goto>

<default>default:</default>

<goto>goto <name>num_index</name>;</goto>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_drop_bytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sptr</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>slen</name> <operator>-</operator> <name>beg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>sptr</name> <operator>+</operator> <name>beg</name></expr></argument>,

<argument><expr><name>sptr</name> <operator>+</operator> <name>beg</name> <operator>+</operator> <name>len</name></expr></argument>,

<argument><expr><name>slen</name> <operator>-</operator> <operator>(</operator><name>beg</name> <operator>+</operator> <name>len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>slen</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sptr</name><index>[<expr><name>slen</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>get_pat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>pat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>to_string</name>;</goto></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<return>return <expr><name>pat</name></expr>;</return>

<case>case <expr><name>T_STRING</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<label><name>to_string</name>:</label>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<return>return <expr><call><name>rb_reg_regcomp</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>get_pat_quoted</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>pat</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>to_string</name>;</goto></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_REGEXP</name></expr>:</case>

<return>return <expr><name>pat</name></expr>;</return>

<case>case <expr><name>T_STRING</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<label><name>to_string</name>:</label>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>check</name> <operator>&amp;&amp;</operator> <call><name>is_broken_string</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_reg_check_preprocess</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>pat</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>rb_pat_search</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>pat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>set_backref_str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_strseq_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>set_backref_str</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_backref_set_string</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>pos</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_reg_search0</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>set_backref_str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_sub_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pat</name></decl>, <decl><type ref="prev"/><name>repl</name></decl>, <decl><type ref="prev"/><name>hash</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>plen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min_arity</name> <init>= <expr><ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>min_arity</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iter</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_check_hash_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <call><name>get_pat_quoted</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>rb_pat_search</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>beg0</name></decl>, <decl><type ref="prev"/><name>end0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name></decl>, <decl><type ref="prev"/><name>match0</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>rlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg0</name> <operator>=</operator> <name>beg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end0</name> <operator>=</operator> <name>beg0</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>match0</name> <operator>=</operator> <name>pat</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>beg0</name> <operator>=</operator> <call><name>BEG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end0</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>iter</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>match0</name> <operator>=</operator> <call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>iter</name> <operator>||</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>iter</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>match0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg0</name></expr></argument>, <argument><expr><name>end0</name> <operator>-</operator> <name>beg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>rb_reg_regsub</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>regs</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><name>pat</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_compatible</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>str_enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>coderange_scan</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>beg0</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name> <operator>||</operator>

<call><name>coderange_scan</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>end0</name></expr></argument>, <argument><expr><name>len</name><operator>-</operator><name>end0</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncCompatError</name></expr></argument>, <argument><expr><literal type="string">"incompatible character encodings: %s and %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_modify</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ENC_CODERANGE_UNKNOWN</name> <operator>&lt;</operator> <name>cr</name> <operator>&amp;&amp;</operator> <name>cr</name> <operator>&lt;</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cr2</name> <init>= <expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cr2</name> <operator>==</operator> <name>ENC_CODERANGE_BROKEN</name> <operator>||</operator>

<operator>(</operator><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_VALID</name> <operator>&amp;&amp;</operator> <name>cr2</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>cr2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>plen</name> <operator>=</operator> <name>end0</name> <operator>-</operator> <name>beg0</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>&gt;</operator> <name>plen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RESIZE_CAPA</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>rlen</name> <operator>-</operator> <name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>!=</operator> <name>plen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>beg0</name> <operator>+</operator> <name>rlen</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>beg0</name> <operator>+</operator> <name>plen</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>beg0</name> <operator>-</operator> <name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rp</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>beg0</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>rlen</name> <operator>-</operator> <name>plen</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><name>len</name></expr>]</index></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_sub</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_sub_bang</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_gsub</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bang</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pat</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>repl</name></decl>, <decl><type ref="prev"/><name>match</name></decl>, <decl><type ref="prev"/><name>match0</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>dest</name></decl>, <decl><type ref="prev"/><name>hash</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>beg0</name></decl>, <decl><type ref="prev"/><name>end0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>blen</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>

<enum>enum <block>{<decl><name>STR</name></decl>, <decl><name>ITER</name></decl>, <decl><name>MAP</name></decl>}</block> <decl><name>mode</name> <init>= <expr><name>STR</name></expr></init></decl>;</enum>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>need_backref</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>str_enc</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <name>ITER</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_check_hash_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <name>MAP</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_error_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <call><name>get_pat_quoted</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>rb_pat_search</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>need_backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bang</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt> 

<return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>blen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">30</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str_enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>ENC_CODERANGE_7BIT</name></expr> </then><else>: <expr><name>ENC_CODERANGE_VALID</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg0</name> <operator>=</operator> <name>beg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end0</name> <operator>=</operator> <name>beg0</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>match0</name> <operator>=</operator> <name>pat</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>beg0</name> <operator>=</operator> <call><name>BEG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end0</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ITER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>match0</name> <operator>=</operator> <call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>ITER</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>match0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg0</name></expr></argument>, <argument><expr><name>end0</name> <operator>-</operator> <name>beg0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>dest</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"block should not cheat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>need_backref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_reg_regsub</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>regs</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><name>pat</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>need_backref</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>need_backref</name> <operator>=</operator> <name>val</name> <operator>!=</operator> <name>repl</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name>repl</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>beg0</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>end0</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg0</name> <operator>==</operator> <name>end0</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>end0</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>rb_enc_fast_mbclen</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>+</operator><name>end0</name></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>+</operator><name>end0</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>end0</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>rb_pat_search</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>need_backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>beg</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>offset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_pat_search</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bang</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>str_shared_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_gsub_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>str_gsub</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_gsub</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_gsub</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>str2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_discard</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>str_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_discard</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_chr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_substr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_getbyte</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><name>pos</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_setbyte</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>head</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><name>ENC_CODERANGE_UNKNOWN</name></expr></init></decl>, <decl><type ref="prev"/><name>width</name></decl>, <decl><type ref="prev"/><name>nlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <operator>-</operator><name>len</name> <operator>||</operator> <name>len</name> <operator>&lt;=</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld out of string"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>rb_to_int</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>w</name> <init>= <expr><call><name>rb_int_and</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>byte</name> <init>= <expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str_independent</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>str_make_independent</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>head</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>cr</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ENC_CODERANGE_7BIT</name></expr>:</case>

<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISASCII</name><argument_list>(<argument><expr><name>byte</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nlen</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>head</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_BROKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<goto>goto <name>end</name>;</goto>

<case>case <expr><name>ENC_CODERANGE_VALID</name></expr>:</case>

<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>head</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>head</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nlen</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>head</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_BROKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>nlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>width</name> <operator>||</operator> <call><name>ISASCII</name><argument_list>(<argument><expr><name>byte</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>end</name>;</goto>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>

<label><name>end</name>:</label>

<return>return <expr><name>value</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_byte_substr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>empty</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;</operator> <name>n</name> <operator>||</operator> <name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>n</name> <operator>-</operator> <name>beg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>n</name> <operator>-</operator> <name>beg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>empty</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>beg</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBEDDABLE_P</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SHARABLE_SUBSTRING_P</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>str_new_shared</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>+=</operator> <name>beg</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>str_enc_copy</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<switch>switch <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ENC_CODERANGE_7BIT</name></expr>:</case>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>str2</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_byte_aref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>indx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name>indx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Qfalse</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>Qnil</name></expr>:</case>

<return>return <expr><name>Qnil</name></expr>;</return>

<default>default:</default>

<return>return <expr><call><name>str_byte_substr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>str_byte_substr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_byteslice</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>end</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>str_byte_substr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>str_byte_aref</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_reverse</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rev</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>--</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_VALID</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name> <init>= <expr><call><name>rb_enc_fast_mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>-=</operator> <name>clen</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <ternary><condition><expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr> ?</condition><then>

<expr><name>ENC_CODERANGE_7BIT</name></expr> </then><else>: <expr><name>ENC_CODERANGE_VALID</name></expr></else></ternary></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name> <init>= <expr><call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>-=</operator> <name>clen</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_enc_copy</name><argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>rev</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_reverse_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>e</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>e</name><operator>--</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>str_shared_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_str_reverse</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_include</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>rb_str_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_to_i</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>base</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid radix %d"</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_str_to_inum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_to_f</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><call><name>rb_str_to_dbl</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rb_cString</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>str_duplicate</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static void

str_cat_char(VALUE str, unsigned int c, rb_encoding *enc)

{

char s[RUBY_MAX_CHAR_LEN];

int n = rb_enc_codelen(c, enc);

rb_enc_mbcput(c, s, enc);

rb_enc_str_buf_cat(str, s, n, enc);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_ESC_LEN</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define> 

<function><type><name>int</name></type>

<name>rb_str_buf_cat_escaped_char</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unicode_p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>CHAR_ESC_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> <operator>&gt;</operator> <literal type="number">4</literal></expr></cpp:if>

<expr_stmt><expr><name>c</name> <operator>&amp;=</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>unicode_p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x7F</literal> <operator>&amp;&amp;</operator> <call><name>ISPRINT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>CHAR_ESC_LEN</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x10000</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>CHAR_ESC_LEN</name></expr></argument>, <argument><expr><literal type="string">"\\u%04X"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>CHAR_ESC_LEN</name></expr></argument>, <argument><expr><literal type="string">"\\u{%X}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x100</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>CHAR_ESC_LEN</name></expr></argument>, <argument><expr><literal type="string">"\\x%02X"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>CHAR_ESC_LEN</name></expr></argument>, <argument><expr><literal type="string">"\\x{%X}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>l</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>ruby_escaped_char</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> <return>return <expr><literal type="string">"\\0"</literal></expr>;</return>

<case>case <expr><literal type="char">'\n'</literal></expr>:</case> <return>return <expr><literal type="string">"\\n"</literal></expr>;</return>

<case>case <expr><literal type="char">'\r'</literal></expr>:</case> <return>return <expr><literal type="string">"\\r"</literal></expr>;</return>

<case>case <expr><literal type="char">'\t'</literal></expr>:</case> <return>return <expr><literal type="string">"\\t"</literal></expr>;</return>

<case>case <expr><literal type="char">'\f'</literal></expr>:</case> <return>return <expr><literal type="string">"\\f"</literal></expr>;</return>

<case>case <expr><literal type="char">'\013'</literal></expr>:</case> <return>return <expr><literal type="string">"\\v"</literal></expr>;</return>

<case>case <expr><literal type="char">'\010'</literal></expr>:</case> <return>return <expr><literal type="string">"\\b"</literal></expr>;</return>

<case>case <expr><literal type="char">'\007'</literal></expr>:</case> <return>return <expr><literal type="string">"\\a"</literal></expr>;</return>

<case>case <expr><literal type="char">'\033'</literal></expr>:</case> <return>return <expr><literal type="string">"\\e"</literal></expr>;</return>

<case>case <expr><literal type="char">'\x7f'</literal></expr>:</case> <return>return <expr><literal type="string">"\\c?"</literal></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_escape</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pend</name> <init>= <expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>CHAR_ESC_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_str_buf_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>unicode_p</name> <init>= <expr><call><name>rb_enc_unicode_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>asciicompat</name> <init>= <expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pend</name> <operator>&lt;</operator> <name>p</name> <operator>+</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pend</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>n</name><operator>--</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>CHAR_ESC_LEN</name></expr></argument>, <argument><expr><literal type="string">"\\x%02X"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0377</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></while>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>ruby_escaped_char</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>n</name> <operator>&gt;</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>n</name> <operator>-</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>asciicompat</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_isascii</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISPRINT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>n</name> <operator>&gt;</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>n</name> <operator>-</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat_escaped_char</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>unicode_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ENCODING_CODERANGE_SET</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_usascii_encindex</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>actenc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>CHAR_ESC_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_str_buf_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>resenc</name> <init>= <expr><call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>unicode_p</name> <init>= <expr><call><name>rb_enc_unicode_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>asciicompat</name> <init>= <expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>resenc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>resenc</name> <operator>=</operator> <call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>resenc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>resenc</name> <operator>=</operator> <call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>resenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_buf_cat2</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pend</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>actenc</name> <operator>=</operator> <call><name>get_actual_encoding</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>actenc</name> <operator>!=</operator> <name>enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <name>actenc</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>unicode_p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>unicode_p</name> <operator>=</operator> <call><name>rb_enc_unicode_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pend</name> <operator>&lt;</operator> <name>p</name> <operator>+</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pend</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>n</name><operator>--</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>CHAR_ESC_LEN</name></expr></argument>, <argument><expr><literal type="string">"\\x%02X"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0377</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></while>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>asciicompat</name> <operator>||</operator> <name>unicode_p</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'"'</literal><operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator>

<operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator>

<name>p</name> <operator>&lt;</operator> <name>pend</name> <operator>&amp;&amp;</operator>

<call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>pend</name></expr></argument>,<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name>cc</name> <operator>=</operator> <call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>pend</name></expr></argument>,<argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>,</operator>

<operator>(</operator><name>cc</name> <operator>==</operator> <literal type="char">'$'</literal> <operator>||</operator> <name>cc</name> <operator>==</operator> <literal type="char">'@'</literal> <operator>||</operator> <name>cc</name> <operator>==</operator> <literal type="char">'{'</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>n</name> <operator>&gt;</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>n</name> <operator>-</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>str_buf_cat2</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>asciicompat</name> <operator>||</operator> <name>enc</name> <operator>==</operator> <name>resenc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>n</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\n'</literal></expr>:</case> <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'\r'</literal></expr>:</case> <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'\t'</literal></expr>:</case> <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'\f'</literal></expr>:</case> <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'\013'</literal></expr>:</case> <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'\010'</literal></expr>:</case> <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'\007'</literal></expr>:</case> <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">033</literal></expr>:</case> <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default> <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>cc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>n</name> <operator>&gt;</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>n</name> <operator>-</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>cc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>enc</name> <operator>==</operator> <name>resenc</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>asciicompat</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_isascii</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ISPRINT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>n</name> <operator>&gt;</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>n</name> <operator>-</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat_escaped_char</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>unicode_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>prev</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>str_buf_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>str_buf_cat2</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_EVSTR</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p) &lt; (e) &amp;&amp; (*(p) == '$' || *(p) == '@' || *(p) == '{'))</cpp:value></cpp:define>

<function><type><name>VALUE</name></type>

<name>rb_str_dump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>qend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>u8</name> <init>= <expr><operator>(</operator><name>encidx</name> <operator>==</operator> <call><name>rb_utf8_encindex</name><argument_list>()</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>nonascii_suffix</name><index>[]</index></name> <init>= <expr><literal type="string">".dup.force_encoding(\"%s\")"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nonascii_suffix</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>rb_strlen_lit</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>enc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pend</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'"'</literal></expr>:</case> <case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case>

<case>case <expr><literal type="char">'\t'</literal></expr>:</case> <case>case <expr><literal type="char">'\f'</literal></expr>:</case>

<case>case <expr><literal type="char">'\013'</literal></expr>:</case> <case>case <expr><literal type="char">'\010'</literal></expr>:</case> <case>case <expr><literal type="char">'\007'</literal></expr>:</case> <case>case <expr><literal type="char">'\033'</literal></expr>:</case>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'#'</literal></expr>:</case>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <ternary><condition><expr><call><name>IS_EVSTR</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><call><name>ISPRINT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>u8</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">0x7F</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cc</name> <init>= <expr><call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;=</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if> 

<if type="elseif">else if <condition>(<expr><name>cc</name> <operator>&lt;=</operator> <literal type="number">0xFFFFF</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if> 

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></else></if_stmt> 

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <name>LONG_MAX</name> <operator>-</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"string size too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pend</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>qend</name> <operator>=</operator> <name>q</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_EVSTR</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'#'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\f'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\013'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\010'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\007'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\033'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ISPRINT</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>u8</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cc</name> <init>= <expr><call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&lt;=</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qend</name><operator>-</operator><name>q</name></expr></argument>, <argument><expr><literal type="string">"u%04X"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> 

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qend</name><operator>-</operator><name>q</name></expr></argument>, <argument><expr><literal type="string">"u{%X}"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt> 

<expr_stmt><expr><name>q</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qend</name><operator>-</operator><name>q</name></expr></argument>, <argument><expr><literal type="string">"x%02X"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>q</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>qend</name><operator>-</operator><name>q</name></expr></argument>, <argument><expr><name>nonascii_suffix</name></expr></argument>, <argument><expr><name><name>enc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>encidx</name> <operator>=</operator> <call><name>rb_ascii8bit_encindex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_7BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>unescape_ascii</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<return>return <expr><literal type="char">'\n'</literal></expr>;</return>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<return>return <expr><literal type="char">'\r'</literal></expr>;</return>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<return>return <expr><literal type="char">'\t'</literal></expr>;</return>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<return>return <expr><literal type="char">'\f'</literal></expr>;</return>

<case>case <expr><literal type="char">'v'</literal></expr>:</case>

<return>return <expr><literal type="char">'\13'</literal></expr>;</return>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<return>return <expr><literal type="char">'\010'</literal></expr>;</return>

<case>case <expr><literal type="char">'a'</literal></expr>:</case>

<return>return <expr><literal type="char">'\007'</literal></expr>;</return>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>

<return>return <expr><literal type="number">033</literal></expr>;</return>

<default>default:</default>

<expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>undump_after_backslash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>undumped</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ss</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s_end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>penc</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>utf8</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>binary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>*</operator><name>ss</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>codelen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>hexlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type><name>enc_utf8</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<case>case <expr><literal type="char">'"'</literal></expr>:</case>

<case>case <expr><literal type="char">'#'</literal></expr>:</case>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<case>case <expr><literal type="char">'v'</literal></expr>:</case>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<case>case <expr><literal type="char">'a'</literal></expr>:</case>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>unescape_ascii</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>binary</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"hex escape and Unicode escape are mixed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>utf8</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name>s</name> <operator>&gt;=</operator> <name>s_end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_utf8</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>enc_utf8</name> <operator>=</operator> <call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>penc</name> <operator>!=</operator> <name>enc_utf8</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>penc</name> <operator>=</operator> <name>enc_utf8</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><name>enc_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;=</operator> <name>s_end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"unterminated Unicode escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISSPACE</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>scan_hex</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s_end</name><operator>-</operator><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hexlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hexlen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>hexlen</name> <operator>&gt;</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0x10ffff</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode codepoint (too large)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0xd800</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode codepoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>codelen</name> <operator>=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>penc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>codelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>hexlen</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>scan_hex</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hexlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hexlen</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0xd800</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode codepoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>codelen</name> <operator>=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>penc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>codelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>hexlen</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>utf8</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"hex escape and Unicode escape are mixed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>binary</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name>s</name> <operator>&gt;=</operator> <name>s_end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid hex escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>scan_hex</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hexlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hexlen</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid hex escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>hexlen</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>ss</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_str_is_ascii_only_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_undump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s_end</name> <init>= <expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>undumped</name> <init>= <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>utf8</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>binary</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_str_is_ascii_only_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"non-ASCII character detected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>str_null_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>w</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"string contains null byte"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_format</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_format</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;=</operator> <name>s_end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"unterminated dumped string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>s_end</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>force_encoding_suffix</name><index>[]</index></name> <init>= <expr><literal type="string">".force_encoding(\""</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>dup_suffix</name><index>[]</index></name> <init>= <expr><literal type="string">".dup"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>dup_suffix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s_end</name> <operator>-</operator> <name>s</name> <operator>&gt;</operator> <name>size</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dup_suffix</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>force_encoding_suffix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s_end</name> <operator>-</operator> <name>s</name> <operator>&lt;=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_format</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>force_encoding_suffix</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_format</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>utf8</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"dumped string contained Unicode escape but used force_encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>encname</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>, <argument><expr><name>s_end</name><operator>-</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>encname</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_format</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>s_end</name> <operator>-</operator> <name>s</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_format</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>||</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid_format</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>encidx</name> <operator>=</operator> <call><name>rb_enc_find_index2</name><argument_list>(<argument><expr><name>encname</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"dumped string has unknown encoding name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;=</operator> <name>s_end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>undump_after_backslash</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>s_end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>utf8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>binary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>undumped</name></expr></argument>, <argument><expr><name>s</name><operator>++</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>undumped</name></expr>;</return>

<label><name>invalid_format</name>:</label>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid dumped string; not wrapped with '\"' nor '\"...\".force_encoding(\"...\")' form"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_str_check_dummy_enc</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_dummy_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncCompatError</name></expr></argument>, <argument><expr><literal type="string">"incompatible encoding with this operation: %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>

<name>str_true_enc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_check_dummy_enc</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>enc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OnigCaseFoldType</name></type>

<name>check_case_options</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>flags</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name><operator>&gt;</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too many options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>sym_turkic</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ONIGENC_CASE_FOLD_TURKISH_AZERI</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>sym_lithuanian</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ONIGENC_CASE_FOLD_LITHUANIAN</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid second option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>sym_lithuanian</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ONIGENC_CASE_FOLD_LITHUANIAN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name><operator>==</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><name>sym_turkic</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ONIGENC_CASE_FOLD_TURKISH_AZERI</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid second option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>argc</name><operator>&gt;</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too many options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>sym_ascii</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ONIGENC_CASE_ASCII_ONLY</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>==</operator><name>sym_fold</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>ONIGENC_CASE_UPCASE</name><operator>|</operator><name>ONIGENC_CASE_DOWNCASE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>ONIGENC_CASE_DOWNCASE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>^=</operator> <name>ONIGENC_CASE_FOLD</name><operator>|</operator><name>ONIGENC_CASE_DOWNCASE</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"option :fold only allowed for downcasing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>flags</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>

<name>case_option_single_p</name><parameter_list>(<parameter><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ONIGENC_CASE_ASCII_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>enc</name><operator>==</operator><call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ONIGENC_CASE_FOLD_TURKISH_AZERI</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_MAPPING_ADDITIONAL_LENGTH</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CASEMAP_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASEMAP_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct_decl>struct <name>mapping_buffer</name>;</struct_decl>

<typedef>typedef <type><struct>struct <name>mapping_buffer</name> <block>{

<decl_stmt><decl><type><name>size_t</name></type> <name>capa</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>used</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>mapping_buffer</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigUChar</name></type> <name><name>space</name><index>[<expr><name>FLEX_ARY_LEN</name></expr>]</index></name></decl>;</decl_stmt>

}</block></struct></type> <name>mapping_buffer</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mapping_buffer_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mapping_buffer</name> <modifier>*</modifier></type><name>previous_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mapping_buffer</name> <modifier>*</modifier></type><name>current_buffer</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>current_buffer</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>previous_buffer</name> <operator>=</operator> <name>current_buffer</name></expr>;</expr_stmt>

<expr_stmt><expr><name>current_buffer</name> <operator>=</operator> <name><name>current_buffer</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><name>previous_buffer</name></expr></argument>, <argument><expr><name><name>previous_buffer</name><operator>-&gt;</operator><name>capa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>mapping_buffer_type</name> <init>= <expr><block>{

<expr><literal type="string">"mapping_buffer"</literal></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>mapping_buffer_free</name></expr>,}</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_casemap</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>OnigCaseFoldType</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>target</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>source_current</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>source_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>target_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>buffer_anchor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mapping_buffer</name> <modifier>*</modifier></type><name>current_buffer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mapping_buffer</name> <modifier>*</modifier><modifier>*</modifier></type><name>pre_buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>buffer_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>buffer_length_or_invalid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>source_current</name> <operator>=</operator> <operator>(</operator><name>OnigUChar</name><operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>source_end</name> <operator>=</operator> <operator>(</operator><name>OnigUChar</name><operator>*</operator><operator>)</operator><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer_anchor</name> <operator>=</operator> <call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mapping_buffer_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pre_buffer</name> <operator>=</operator> <operator>(</operator><name>mapping_buffer</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>buffer_anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>source_current</name> <operator>&lt;</operator> <name>source_end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>capa</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>source_end</name><operator>-</operator><name>source_current</name><operator>)</operator><operator>*</operator><operator>++</operator><name>buffer_count</name> <operator>+</operator> <name>CASE_MAPPING_ADDITIONAL_LENGTH</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>CASEMAP_DEBUG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Buffer allocation, capa is %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>current_buffer</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>mapping_buffer</name></expr></argument>, <argument><expr><name>space</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>pre_buffer</name> <operator>=</operator> <name>current_buffer</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pre_buffer</name> <operator>=</operator> <operator>&amp;</operator><name><name>current_buffer</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>current_buffer</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>current_buffer</name><operator>-&gt;</operator><name>capa</name></name> <operator>=</operator> <name>capa</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer_length_or_invalid</name> <operator>=</operator> <call><name><name>enc</name><operator>-&gt;</operator><name>case_map</name></name><argument_list>(<argument><expr><name>flags</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>OnigUChar</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>source_current</name></expr></argument>, <argument><expr><name>source_end</name></expr></argument>,

<argument><expr><name><name>current_buffer</name><operator>-&gt;</operator><name>space</name></name></expr></argument>,

<argument><expr><name><name>current_buffer</name><operator>-&gt;</operator><name>space</name></name><operator>+</operator><name><name>current_buffer</name><operator>-&gt;</operator><name>capa</name></name></expr></argument>,

<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buffer_length_or_invalid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>current_buffer</name> <operator>=</operator> <call><name>DATA_PTR</name><argument_list>(<argument><expr><name>buffer_anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>buffer_anchor</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mapping_buffer_free</name><argument_list>(<argument><expr><name>current_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"input string invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>target_length</name> <operator>+=</operator> <name><name>current_buffer</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>buffer_length_or_invalid</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>CASEMAP_DEBUG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Buffer count is %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>buffer_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>buffer_count</name><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>current_buffer</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name>target_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>target_current</name></decl>;</decl_stmt>

<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>target_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>target_current</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>current_buffer</name> <operator>=</operator> <call><name>DATA_PTR</name><argument_list>(<argument><expr><name>buffer_anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>current_buffer</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target_current</name></expr></argument>, <argument><expr><name><name>current_buffer</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name><name>current_buffer</name><operator>-&gt;</operator><name>used</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>target_current</name> <operator>+=</operator> <name><name>current_buffer</name><operator>-&gt;</operator><name>used</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>current_buffer</name> <operator>=</operator> <name><name>current_buffer</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>current_buffer</name> <operator>=</operator> <call><name>DATA_PTR</name><argument_list>(<argument><expr><name>buffer_anchor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>buffer_anchor</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mapping_buffer_free</name><argument_list>(<argument><expr><name>current_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_enc_copy</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>target</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_ascii_casemap</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>OnigCaseFoldType</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>source_current</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>source_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigUChar</name> <modifier>*</modifier></type><name>target_current</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>target_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>old_length</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>length_or_invalid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>old_length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>source_current</name> <operator>=</operator> <operator>(</operator><name>OnigUChar</name><operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>source_end</name> <operator>=</operator> <operator>(</operator><name>OnigUChar</name><operator>*</operator><operator>)</operator><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>target</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>target_current</name> <operator>=</operator> <operator>(</operator><name>OnigUChar</name><operator>*</operator><operator>)</operator><name>source_current</name></expr>;</expr_stmt>

<expr_stmt><expr><name>target_end</name> <operator>=</operator> <operator>(</operator><name>OnigUChar</name><operator>*</operator><operator>)</operator><name>source_end</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>target_current</name> <operator>=</operator> <operator>(</operator><name>OnigUChar</name><operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>target_end</name> <operator>=</operator> <operator>(</operator><name>OnigUChar</name><operator>*</operator><operator>)</operator><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>length_or_invalid</name> <operator>=</operator> <call><name>onigenc_ascii_only_case_map</name><argument_list>(<argument><expr><name>flags</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>source_current</name></expr></argument>, <argument><expr><name>source_end</name></expr></argument>,

<argument><expr><name>target_current</name></expr></argument>, <argument><expr><name>target_end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>length_or_invalid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"input string invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>CASEMAP_DEBUG</name> <operator>&amp;&amp;</operator> <name>length_or_invalid</name> <operator>!=</operator> <name>old_length</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"problem with rb_str_ascii_casemap"</literal>

<literal type="string">"; old_length=%ld, new_length=%d\n"</literal></expr></argument>, <argument><expr><name>old_length</name></expr></argument>, <argument><expr><name>length_or_invalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"internal problem with rb_str_ascii_casemap"</literal>

<literal type="string">"; old_length=%ld, new_length=%d\n"</literal></expr></argument>, <argument><expr><name>old_length</name></expr></argument>, <argument><expr><name>length_or_invalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>str_enc_copy</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>target</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>

<name>upcase_single</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>send</name> <init>= <expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>modified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_isascii</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="char">'a'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'z'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'A'</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'a'</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>modified</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_upcase_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name> <init>= <expr><name>ONIGENC_CASE_UPCASE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>check_case_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>str_true_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>case_option_single_p</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>upcase_single</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ONIGENC_CASE_MODIFIED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name><operator>&amp;</operator><name>ONIGENC_CASE_ASCII_ONLY</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_ascii_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>str_shared_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_str_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ONIGENC_CASE_MODIFIED</name><operator>&amp;</operator><name>flags</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_upcase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name> <init>= <expr><name>ONIGENC_CASE_UPCASE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>check_case_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>str_true_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>case_option_single_p</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_enc_copy</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>upcase_single</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name><operator>&amp;</operator><name>ONIGENC_CASE_ASCII_ONLY</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_ascii_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>

<name>downcase_single</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>send</name> <init>= <expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>modified</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_isascii</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="char">'A'</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'a'</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'A'</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>modified</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>modified</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_downcase_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name> <init>= <expr><name>ONIGENC_CASE_DOWNCASE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>check_case_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>str_true_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>case_option_single_p</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>downcase_single</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ONIGENC_CASE_MODIFIED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name><operator>&amp;</operator><name>ONIGENC_CASE_ASCII_ONLY</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_ascii_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>str_shared_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_str_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ONIGENC_CASE_MODIFIED</name><operator>&amp;</operator><name>flags</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_downcase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name> <init>= <expr><name>ONIGENC_CASE_DOWNCASE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>check_case_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>str_true_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>case_option_single_p</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_enc_copy</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>downcase_single</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name><operator>&amp;</operator><name>ONIGENC_CASE_ASCII_ONLY</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_ascii_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_capitalize_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name> <init>= <expr><name>ONIGENC_CASE_UPCASE</name> <operator>|</operator> <name>ONIGENC_CASE_TITLECASE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>check_case_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>str_true_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name><operator>&amp;</operator><name>ONIGENC_CASE_ASCII_ONLY</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_ascii_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>str_shared_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_str_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ONIGENC_CASE_MODIFIED</name><operator>&amp;</operator><name>flags</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_capitalize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name> <init>= <expr><name>ONIGENC_CASE_UPCASE</name> <operator>|</operator> <name>ONIGENC_CASE_TITLECASE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>check_case_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>str_true_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name><operator>&amp;</operator><name>ONIGENC_CASE_ASCII_ONLY</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_ascii_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_swapcase_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name> <init>= <expr><name>ONIGENC_CASE_UPCASE</name> <operator>|</operator> <name>ONIGENC_CASE_DOWNCASE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>check_case_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>str_true_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name><operator>&amp;</operator><name>ONIGENC_CASE_ASCII_ONLY</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_ascii_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>str_shared_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_str_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ONIGENC_CASE_MODIFIED</name><operator>&amp;</operator><name>flags</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_swapcase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>flags</name> <init>= <expr><name>ONIGENC_CASE_UPCASE</name> <operator>|</operator> <name>ONIGENC_CASE_DOWNCASE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>check_case_options</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>str_true_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name><operator>&amp;</operator><name>ONIGENC_CASE_ASCII_ONLY</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_ascii_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_casemap</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>USTR</name>;</typedef>

<struct>struct <name>tr</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>gen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>now</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>

<name>trnext</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tr</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>t</name><operator>-&gt;</operator><name>gen</name></name></expr>)</condition> <block>{<block_content>

<label><name>nextpart</name>:</label>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>pend</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>pend</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <name>n</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>pend</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>now</name></name> <operator>=</operator> <call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>pend</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>pend</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <name>n</name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>pend</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>pend</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>pend</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>now</name></name> <operator>&gt;</operator> <name>c</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>now</name></name> <operator>&lt;</operator> <literal type="number">0x80</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>,

<argument><expr><literal type="string">"invalid range \"%c-%c\" in string transliteration"</literal></expr></argument>,

<argument><expr><name><name>t</name><operator>-&gt;</operator><name>now</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid range in string transliteration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<continue>continue;</continue> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>gen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>t</name><operator>-&gt;</operator><name>now</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><call><name>ONIGENC_CODE_TO_MBCLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>++</operator><name><name>t</name><operator>-&gt;</operator><name>now</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>now</name></name> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>gen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<goto>goto <name>nextpart</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>now</name></name> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>t</name><operator>-&gt;</operator><name>now</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>gen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name><name>t</name><operator>-&gt;</operator><name>max</name></name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_str_delete_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>,<parameter><decl><type><name>VALUE</name><modifier>*</modifier></type></decl></parameter>,<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>tr_trans</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>repl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sflag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>errc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>trans</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>tr</name></name></type> <name>trsrc</name></decl>, <decl><type ref="prev"/><name>trrepl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c0</name></decl>, <decl><type ref="prev"/><name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>modify</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>send</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>singlebyte</name> <init>= <expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>termlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_IF_ASCII</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)((cr == ENC_CODERANGE_7BIT &amp;&amp; !rb_isascii(c)) ? (cr = ENC_CODERANGE_VALID) : 0)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_delete_bang</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e1</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e2</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e1</name> <operator>==</operator> <name>e2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <name>e1</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>trsrc</name><operator>.</operator><name>p</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>trsrc</name><operator>.</operator><name>pend</name></name> <operator>=</operator> <name><name>trsrc</name><operator>.</operator><name>p</name></name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>

<call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name><name>trsrc</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>trsrc</name><operator>.</operator><name>pend</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'^'</literal> <operator>&amp;&amp;</operator>

<name><name>trsrc</name><operator>.</operator><name>p</name></name> <operator>+</operator> <name>l</name> <operator>&lt;</operator> <name><name>trsrc</name><operator>.</operator><name>pend</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trsrc</name><operator>.</operator><name>p</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>trrepl</name><operator>.</operator><name>p</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trrepl</name><operator>.</operator><name>pend</name></name> <operator>=</operator> <name><name>trrepl</name><operator>.</operator><name>p</name></name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trsrc</name><operator>.</operator><name>gen</name></name> <operator>=</operator> <name><name>trrepl</name><operator>.</operator><name>gen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trsrc</name><operator>.</operator><name>now</name></name> <operator>=</operator> <name><name>trrepl</name><operator>.</operator><name>now</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>trsrc</name><operator>.</operator><name>max</name></name> <operator>=</operator> <name><name>trrepl</name><operator>.</operator><name>max</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cflag</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>trnext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trsrc</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>errc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>trans</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>errc</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hash</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>trnext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trrepl</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>errc</name></expr>)</condition><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></while>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>trrepl</name><operator>.</operator><name>now</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>errc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>last</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>r</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>trans</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>errc</name></expr>;</expr_stmt>

</block_content>}</block></for>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>trnext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trsrc</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>errc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>trnext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>trrepl</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>errc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>trrepl</name><operator>.</operator><name>now</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>trans</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_codelen</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>singlebyte</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hash</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_VALID</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_7BIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>send</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>termlen</name> <operator>=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sflag</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>, <decl><type ref="prev"/><name>tlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>save</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <macro><name>ALLOC_N</name><argument_list>(<argument>unsigned char</argument>, <argument>max + termlen</argument>)</argument_list></macro></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>may_modify</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>c0</name> <operator>=</operator> <name>c</name> <operator>=</operator> <call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>send</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tlen</name> <operator>=</operator> <ternary><condition><expr><name>enc</name> <operator>==</operator> <name>e1</name></expr> ?</condition><then> <expr><name>clen</name></expr> </then><else>: <expr><call><name>rb_enc_codelen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>trans</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>hash</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cflag</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>last</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>errc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>cflag</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>errc</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>errc</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>save</name> <operator>==</operator> <name>c</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK_IF_ASCII</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>save</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tlen</name> <operator>=</operator> <call><name>rb_enc_codelen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>save</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>c0</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <name>e1</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>may_modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>buf</name><operator>)</operator> <operator>+</operator> <name>tlen</name> <operator>&gt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>

<function_decl><type><name>size_t</name></type> <name>MAYBE_UNUSED</name><parameter_list>(<parameter><decl><type><name>old</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>max</name> <operator>+</operator> <name>termlen</name></expr></init>;</function_decl>

<expr_stmt><expr><name>max</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>tlen</name> <operator>+</operator> <operator>(</operator><name>send</name> <operator>-</operator> <name>s</name><operator>)</operator></expr>;</expr_stmt>

<macro><name>SIZED_REALLOC_N</name><argument_list>(<argument>buf</argument>, <argument>unsigned char</argument>, <argument>max + termlen</argument>, <argument>old</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>may_modify</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CHECK_IF_ASCII</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <name>tlen</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><call><name>STR_HEAP_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR_HEAP_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>t</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_NOEMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>singlebyte</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hash</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>s</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>trans</name><index>[<expr><name>c</name></expr>]</index></name> <operator>!=</operator> <name>errc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cflag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>trans</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>last</name></expr>;</expr_stmt>

<expr_stmt><expr><name>modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CHECK_IF_ASCII</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>, <decl><type ref="prev"/><name>tlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><operator>(</operator><name>send</name> <operator>-</operator> <name>s</name><operator>)</operator> <operator>*</operator> <literal type="number">1.2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <macro><name>ALLOC_N</name><argument_list>(<argument>unsigned char</argument>, <argument>max + termlen</argument>)</argument_list></macro></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>may_modify</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>c0</name> <operator>=</operator> <name>c</name> <operator>=</operator> <call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>send</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tlen</name> <operator>=</operator> <ternary><condition><expr><name>enc</name> <operator>==</operator> <name>e1</name></expr> ?</condition><then> <expr><name>clen</name></expr> </then><else>: <expr><call><name>rb_enc_codelen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>trans</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>hash</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cflag</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>last</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>errc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>cflag</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>errc</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <ternary><condition><expr><name>cflag</name></expr> ?</condition><then> <expr><name>last</name></expr> </then><else>: <expr><name>errc</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>errc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tlen</name> <operator>=</operator> <call><name>rb_enc_codelen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>c0</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <name>e1</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>may_modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>offset</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>buf</name><operator>)</operator> <operator>+</operator> <name>tlen</name> <operator>&gt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>

<function_decl><type><name>size_t</name></type> <name>MAYBE_UNUSED</name><parameter_list>(<parameter><decl><type><name>old</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>max</name> <operator>+</operator> <name>termlen</name></expr></init>;</function_decl>

<expr_stmt><expr><name>max</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>tlen</name> <operator>+</operator> <operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><operator>(</operator><name>send</name> <operator>-</operator> <name>s</name><operator>)</operator> <operator>*</operator> <literal type="number">1.2</literal><operator>)</operator></expr>;</expr_stmt>

<macro><name>SIZED_REALLOC_N</name><argument_list>(<argument>buf</argument>, <argument>unsigned char</argument>, <argument>max + termlen</argument>, <argument>old</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>t</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>may_modify</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CHECK_IF_ASCII</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <name>tlen</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STR_EMBED_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><call><name>STR_HEAP_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR_HEAP_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>t</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_NOEMBED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>capa</name></name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>modify</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>!=</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_tr_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>repl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>tr_trans</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_tr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>repl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tr_trans</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TR_TABLE_SIZE</name></cpp:macro> <cpp:value>257</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>tr_setup_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>stable</name><index>[<expr><name>TR_TABLE_SIZE</name></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>tablep</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ctablep</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>errc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>tr</name></name></type> <name>tr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>table</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ptable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>l</name></decl>, <decl><type ref="prev"/><name>cflag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tr</name><operator>.</operator><name>p</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>tr</name><operator>.</operator><name>pend</name></name> <operator>=</operator> <name><name>tr</name><operator>.</operator><name>p</name></name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tr</name><operator>.</operator><name>gen</name></name> <operator>=</operator> <name><name>tr</name><operator>.</operator><name>now</name></name> <operator>=</operator> <name><name>tr</name><operator>.</operator><name>max</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name><name>tr</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>tr</name><operator>.</operator><name>pend</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tr</name><operator>.</operator><name>p</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>stable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>stable</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <operator>=</operator> <name>cflag</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>stable</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cflag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>stable</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cflag</name></expr>;</expr_stmt>

</block_content>}</block></for>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>trnext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tr</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>errc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></name> <operator>=</operator> <operator>!</operator><name>cflag</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>table</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>first</name> <operator>||</operator> <operator>*</operator><name>tablep</name> <operator>||</operator> <name><name>stable</name><index>[<expr><literal type="number">256</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cflag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptable</name> <operator>=</operator> <operator>*</operator><name>ctablep</name></expr>;</expr_stmt>

<expr_stmt><expr><name>table</name> <operator>=</operator> <ternary><condition><expr><name>ptable</name></expr> ?</condition><then> <expr><name>ptable</name></expr> </then><else>: <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ctablep</name> <operator>=</operator> <name>table</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptable</name> <operator>=</operator> <operator>*</operator><name>tablep</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>tablep</name> <operator>=</operator> <name>table</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>table</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>ptable</name> <operator>||</operator> <operator>(</operator><name>cflag</name> <operator>^</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>ptable</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>stable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>stable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>table</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cflag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>tablep</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>tr_find</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>table</name><index>[<expr><name>TR_TABLE_SIZE</name></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>del</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>nodel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>table</name><index>[<expr><name>c</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>del</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>del</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><operator>!</operator><name>nodel</name> <operator>||</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>nodel</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>nodel</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>nodel</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name><name>table</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_delete_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>squeez</name><index>[<expr><name>TR_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>send</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>del</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nodel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>modify</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ascompat</name></decl>, <decl><type ref="prev"/><name>cr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tr_setup_table</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>squeez</name></expr></argument>, <argument><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>del</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodel</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ascompat</name> <operator>=</operator> <call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>t</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>send</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <ternary><condition><expr><name>ascompat</name></expr> ?</condition><then> <expr><name>ENC_CODERANGE_7BIT</name></expr> </then><else>: <expr><name>ENC_CODERANGE_VALID</name></expr></else></ternary></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ascompat</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>squeez</name><index>[<expr><name>c</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>t</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>tr_find</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>squeez</name></expr></argument>, <argument><expr><name>del</name></expr></argument>, <argument><expr><name>nodel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>t</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>modify</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_delete</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_delete_bang</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_squeeze_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>squeez</name><index>[<expr><name>TR_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>del</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nodel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>send</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>modify</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ascompat</name></decl>, <decl><type ref="prev"/><name>singlebyte</name> <init>= <expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>save</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>singlebyte</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>singlebyte</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>tr_setup_table</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>squeez</name></expr></argument>, <argument><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>del</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodel</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>t</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>send</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>save</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ascompat</name> <operator>=</operator> <call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>singlebyte</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>s</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>save</name> <operator>||</operator> <operator>(</operator><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>squeez</name><index>[<expr><name>c</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <name>save</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ascompat</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>save</name> <operator>||</operator> <operator>(</operator><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>squeez</name><index>[<expr><name>c</name></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <name>save</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>send</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>save</name> <operator>||</operator> <operator>(</operator><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>tr_find</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>squeez</name></expr></argument>, <argument><expr><name>del</name></expr></argument>, <argument><expr><name>nodel</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>save</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>t</name></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>t</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>t</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>modify</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>modify</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_squeeze</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_squeeze_bang</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_tr_s_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>repl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>tr_trans</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_tr_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>repl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tr_trans</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_count</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>table</name><index>[<expr><name>TR_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>del</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>nodel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>send</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ascompat</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tstr</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>tstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptstr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tstr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><name>ptstr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tstr</name></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>ONIGENC_IS_ALLOWED_REVERSE_MATCH</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>ptstr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>ptstr</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>is_broken_string</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr><call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name>ptstr</name></expr></argument>, <argument><expr><name>ptstr</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>send</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name><operator>++</operator> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

<return>return <expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tr_setup_table</name><argument_list>(<argument><expr><name>tstr</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>del</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodel</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>tstr</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>tstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tr_setup_table</name><argument_list>(<argument><expr><name>tstr</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>del</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodel</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>send</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ascompat</name> <operator>=</operator> <call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ascompat</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>table</name><index>[<expr><name>c</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>tr_find</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>del</name></expr></argument>, <argument><expr><name>nodel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_fs_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>isspacetable</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ascii_isspace</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>isspacetable[(unsigned char)(c)]</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>split_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>empty_count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>empty_count</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>empty_count</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>empty_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>str_new_empty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name>empty_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

</block_content>}</block></if>

<else>else <block>{<block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>str_new_empty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name>empty_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>empty_count</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_split_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>spat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>limit</name></decl>;</decl_stmt>

<enum>enum <block>{<decl><name>awk</name></decl>, <decl><name>string</name></decl>, <decl><name>regexp</name></decl>, <decl><name>chars</name></decl>}</block> <decl><name>split_type</name></decl>;</enum>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>empty_count</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"02"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>spat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lim</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lim</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>limit</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>lim</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name>result</name></expr> ?</condition><then> <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>str</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>lim</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>empty_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>split_type</name> <operator>=</operator> <name>regexp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>spat</name> <operator>=</operator> <call><name>get_pat_quoted</name><argument_list>(<argument><expr><name>spat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>spat</name> <operator>=</operator> <name>rb_fs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>split_type</name> <operator>=</operator> <name>awk</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>spat</name> <operator>=</operator> <call><name>rb_fs_check</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"value of $; must be String or Regexp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"$; is set to non-nil value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>split_type</name> <operator>!=</operator> <name>awk</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc2</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mustnot_broken</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>split_type</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>split_type</name> <operator>=</operator> <name>chars</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>split_type</name> <operator>=</operator> <name>awk</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_ascget</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>enc2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator>

<call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>l</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>split_type</name> <operator>=</operator> <name>awk</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_STR</name><parameter_list>(<parameter><type><name>beg</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(empty_count = split_string(result, str, beg, len, empty_count))</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>split_type</name> <operator>==</operator> <name>awk</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bptr</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>skip</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>beg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_ascii_string</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>eptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>skip</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ascii_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>bptr</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>bptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lim</name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ascii_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SPLIT_STR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name><operator>-</operator><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>bptr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>bptr</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>eptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>skip</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>bptr</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>bptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lim</name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SPLIT_STR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name><operator>-</operator><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>bptr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>bptr</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>split_type</name> <operator>==</operator> <name>string</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_start</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>substr_start</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sptr</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>spat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mustnot_broken</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>spat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>eptr</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>end</name> <operator>=</operator> <call><name>rb_memsearch</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>eptr</name> <operator>-</operator> <name>ptr</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>rb_enc_right_char_head</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>end</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>ptr</name> <operator>+</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SPLIT_STR</name><argument_list>(<argument><expr><name>substr_start</name> <operator>-</operator> <name>str_start</name></expr></argument>, <argument><expr><operator>(</operator><name>ptr</name><operator>+</operator><name>end</name><operator>)</operator> <operator>-</operator> <name>substr_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>end</name> <operator>+</operator> <name>slen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>substr_start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lim</name> <operator>&lt;=</operator> <operator>++</operator><name>i</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>str_start</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>split_type</name> <operator>==</operator> <name>chars</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_start</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mustnot_broken</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>ptr</name> <argument_list type="generic">&lt; <argument><expr><name>eptr</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>n</name> <operator>=</operator> <name>rb_enc_precise_mbclen</name><operator>(</operator><name>ptr</name>, <name>eptr</name>, <name>enc</name><operator>)</operator><operator>)</operator></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SPLIT_STR</name><argument_list>(<argument><expr><name>ptr</name> <operator>-</operator> <name>str_start</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lim</name> <operator>&lt;=</operator> <operator>++</operator><name>i</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>str_start</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><name>beg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_null</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>end</name> <operator>=</operator> <call><name>rb_reg_search</name><argument_list>(<argument><expr><name>spat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition>

<incr><expr><operator>(</operator><ternary><condition><expr><name>match</name></expr> ?</condition><then> <expr><operator>(</operator><call><name>rb_match_unbusy</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>rb_backref_set</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_match_busy</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>BEG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>END</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SPLIT_STR</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>last_null</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SPLIT_STR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><call><name>rb_enc_fast_mbclen</name><argument_list>(<argument><expr><name>ptr</name><operator>+</operator><name>beg</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>start</name> <operator>+=</operator> <call><name>rb_enc_fast_mbclen</name><argument_list>(<argument><expr><name>ptr</name><operator>+</operator><name>start</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>last_null</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>SPLIT_STR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name><operator>-</operator><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <name>start</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>last_null</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>idx</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>SPLIT_STR</name><argument_list>(<argument><expr><call><name>BEG</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>END</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>-</operator><call><name>BEG</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lim</name> <operator>&lt;=</operator> <operator>++</operator><name>i</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_match_unbusy</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>beg</name> <operator>||</operator> <name>lim</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SPLIT_STR</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-</operator><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>result</name></expr> ?</condition><then> <expr><name>result</name></expr> </then><else>: <expr><name>str</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_split</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep0</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>sep</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>sep0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_split_m</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sep</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WANTARRAY</name><parameter_list>(<parameter><type><name>m</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!rb_block_given_p() ? rb_ary_new_capa(size) : 0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>enumerator_element</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>e</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ary</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENUM_ELEM</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>enumerator_element(ary, e)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>chomp_newline</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_is_newline</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>e</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>get_rs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rs</name> <init>= <expr><name>rb_rs</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>(</operator><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>

<call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"$/ is set to non-default value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>rs</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_rs</name></cpp:macro> <cpp:value>get_rs()</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_enumerate_lines</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>line</name></decl>, <decl><type ref="prev"/><name>rs</name></decl>, <decl><type ref="prev"/><name>orig</name> <init>= <expr><name>str</name></expr></init></decl>, <decl><type ref="prev"/><name>opts</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>chomp</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>subptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>subend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rsptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>hit</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>adjusted</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>rslen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rsnewline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"01:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>rs</name> <operator>=</operator> <name>rb_rs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"chomp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>chomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>chomp</name> <operator>=</operator> <operator>(</operator><name>chomp</name> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>chomp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ENUM_ELEM</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>orig</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>subptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pend</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rslen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rs</name> <operator>==</operator> <name>rb_default_rs</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rslen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>subend</name> <operator>=</operator> <name>subptr</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>subend</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>subend</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rslen</name> <operator>=</operator> <name>n</name> <operator>+</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>subend</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_is_newline</name><argument_list>(<argument><expr><name>subend</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>eol</name> <operator>==</operator> <name>subend</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>subend</name> <operator>+=</operator> <name>rslen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>subptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eol</name> <operator>=</operator> <name>subend</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>subptr</name> <operator>=</operator> <name>subend</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>subend</name> <operator>+=</operator> <name>rslen</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>rslen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>subend</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>subptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>subptr</name> <operator>-</operator> <name>ptr</name></expr></argument>,

<argument><expr><name>subend</name> <operator>-</operator> <name>subptr</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>chomp</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>rslen</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENUM_ELEM</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>subptr</name> <operator>=</operator> <name>eol</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></while>

<goto>goto <name>end</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>rsptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>rb_enc_is_newline</name><argument_list>(<argument><expr><name>rsptr</name></expr></argument>, <argument><expr><name>rsptr</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rsnewline</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rs</name> <operator>==</operator> <name>rb_default_rs</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rs</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name>rsptr</name></expr></argument>, <argument><expr><name>rslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rs</name> <operator>=</operator> <call><name>rb_str_encode</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rsptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rslen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>subptr</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_memsearch</name><argument_list>(<argument><expr><name>rsptr</name></expr></argument>, <argument><expr><name>rslen</name></expr></argument>, <argument><expr><name>subptr</name></expr></argument>, <argument><expr><name>pend</name> <operator>-</operator> <name>subptr</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <name>subptr</name> <operator>+</operator> <name>pos</name></expr>;</expr_stmt>

<expr_stmt><expr><name>adjusted</name> <operator>=</operator> <call><name>rb_enc_right_char_head</name><argument_list>(<argument><expr><name>subptr</name></expr></argument>, <argument><expr><name>hit</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name> <operator>!=</operator> <name>adjusted</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>subptr</name> <operator>=</operator> <name>adjusted</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>subend</name> <operator>=</operator> <name>hit</name> <operator>+=</operator> <name>rslen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>chomp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rsnewline</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>subend</name> <operator>=</operator> <call><name>chomp_newline</name><argument_list>(<argument><expr><name>subptr</name></expr></argument>, <argument><expr><name>subend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>subend</name> <operator>-=</operator> <name>rslen</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>subptr</name> <operator>-</operator> <name>ptr</name></expr></argument>, <argument><expr><name>subend</name> <operator>-</operator> <name>subptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENUM_ELEM</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>subptr</name> <operator>=</operator> <name>hit</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>subptr</name> <operator>!=</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>chomp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rsnewline</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pend</name> <operator>=</operator> <call><name>chomp_newline</name><argument_list>(<argument><expr><name>subptr</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>pend</name> <operator>-</operator> <name>subptr</name> <operator>&gt;=</operator> <name>rslen</name> <operator>&amp;&amp;</operator>

<call><name>memcmp</name><argument_list>(<argument><expr><name>pend</name> <operator>-</operator> <name>rslen</name></expr></argument>, <argument><expr><name>rsptr</name></expr></argument>, <argument><expr><name>rslen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pend</name> <operator>-=</operator> <name>rslen</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>subptr</name> <operator>-</operator> <name>ptr</name></expr></argument>, <argument><expr><name>pend</name> <operator>-</operator> <name>subptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENUM_ELEM</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>end</name>:</label>

<if_stmt><if>if <condition>(<expr><name>ary</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ary</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>orig</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_each_line</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_enumerate_lines</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_lines</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>WANTARRAY</name><argument_list>(<argument><expr><literal type="string">"lines"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_str_enumerate_lines</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_each_byte_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_enumerate_bytes</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>ENUM_ELEM</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>ary</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ary</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>str</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_each_byte</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_str_each_byte_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_enumerate_bytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_bytes</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>WANTARRAY</name><argument_list>(<argument><expr><literal type="string">"bytes"</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_str_enumerate_bytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_each_char_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_enumerate_chars</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>orig</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE_CLEAN_P</name><argument_list>(<argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>n</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_enc_fast_mbclen</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENUM_ELEM</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>n</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_enc_mbclen</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENUM_ELEM</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ary</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ary</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>orig</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_each_char</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_str_each_char_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_enumerate_chars</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_chars</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>WANTARRAY</name><argument_list>(<argument><expr><literal type="string">"chars"</literal></expr></argument>, <argument><expr><call><name>rb_str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_str_enumerate_chars</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_enumerate_codepoints</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>orig</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_str_enumerate_bytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENUM_ELEM</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ary</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ary</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>orig</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_each_codepoint</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_str_each_char_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_enumerate_codepoints</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_codepoints</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>WANTARRAY</name><argument_list>(<argument><expr><literal type="string">"codepoints"</literal></expr></argument>, <argument><expr><call><name>rb_str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_str_enumerate_codepoints</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>regex_t</name> <modifier>*</modifier></type>

<name>get_reg_grapheme_cluster</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>reg_grapheme_cluster</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>regex_t</name> <modifier>*</modifier></type><name>reg_grapheme_cluster_utf8</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>==</operator> <call><name>rb_utf8_encindex</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>reg_grapheme_cluster_utf8</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reg_grapheme_cluster</name> <operator>=</operator> <name>reg_grapheme_cluster_utf8</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reg_grapheme_cluster</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>OnigUChar</name></type> <name><name>source_ascii</name><index>[]</index></name> <init>= <expr><literal type="string">"\\X"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigErrorInfo</name></type> <name>einfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>source</name> <init>= <expr><name>source_ascii</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>source_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>source_ascii</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>encidx</name></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARS_16BE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(OnigUChar)((x)&gt;&gt;8), (OnigUChar)(x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARS_16LE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(OnigUChar)(x), (OnigUChar)((x)&gt;&gt;8)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARS_32BE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CHARS_16BE((x)&gt;&gt;16), CHARS_16BE(x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHARS_32LE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CHARS_16LE(x), CHARS_16LE((x)&gt;&gt;16)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CASE_UTF</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case ENCINDEX_UTF_##e: { static const OnigUChar source_UTF_##e[] = {CHARS_##e('\\'), CHARS_##e('X')}; source = source_UTF_##e; source_len = sizeof(source_UTF_##e); break; }</cpp:value></cpp:define>

<expr_stmt><expr><call><name>CASE_UTF</name><argument_list>(<argument><expr><literal type="number">16BE</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>CASE_UTF</name><argument_list>(<argument><expr><literal type="number">16LE</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>CASE_UTF</name><argument_list>(<argument><expr><literal type="number">32BE</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>CASE_UTF</name><argument_list>(<argument><expr><literal type="number">32LE</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CASE_UTF</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHARS_16BE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHARS_16LE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHARS_32BE</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHARS_32LE</name></cpp:undef>

</block_content>}</block></switch>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>onig_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reg_grapheme_cluster</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>source</name> <operator>+</operator> <name>source_len</name></expr></argument>,

<argument><expr><name>ONIG_OPTION_DEFAULT</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>OnigDefaultSyntax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>einfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>UChar</name></type> <name><name>message</name><index>[<expr><name>ONIG_MAX_ERROR_MESSAGE_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>onig_error_code_to_str</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>einfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_fatal</name><argument_list>(<argument><expr><literal type="string">"cannot compile grapheme cluster regexp: %s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>==</operator> <call><name>rb_utf8_encindex</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reg_grapheme_cluster_utf8</name> <operator>=</operator> <name>reg_grapheme_cluster</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>reg_grapheme_cluster</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_each_grapheme_cluster_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>grapheme_cluster_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>reg_grapheme_cluster</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_unicode_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>reg_grapheme_cluster</name> <operator>=</operator> <call><name>get_reg_grapheme_cluster</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>OnigPosition</name></type> <name>len</name> <init>= <expr><call><name>onig_match</name><argument_list>(<argument><expr><name>reg_grapheme_cluster</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>OnigUChar</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>OnigUChar</name> <operator>*</operator><operator>)</operator><name>end</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>OnigUChar</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>grapheme_cluster_count</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><call><name>SIZET2NUM</name><argument_list>(<argument><expr><name>grapheme_cluster_count</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_enumerate_grapheme_clusters</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>orig</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>reg_grapheme_cluster</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_unicode_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_enumerate_chars</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ary</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>reg_grapheme_cluster</name> <operator>=</operator> <call><name>get_reg_grapheme_cluster</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr0</name> <operator>=</operator> <name>ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>OnigPosition</name></type> <name>len</name> <init>= <expr><call><name>onig_match</name><argument_list>(<argument><expr><name>reg_grapheme_cluster</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>OnigUChar</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>OnigUChar</name> <operator>*</operator><operator>)</operator><name>end</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>OnigUChar</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ENUM_ELEM</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name><operator>-</operator><name>ptr0</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ary</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ary</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>orig</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_each_grapheme_cluster</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_str_each_grapheme_cluster_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_enumerate_grapheme_clusters</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_grapheme_clusters</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>WANTARRAY</name><argument_list>(<argument><expr><literal type="string">"grapheme_clusters"</literal></expr></argument>, <argument><expr><call><name>rb_str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_str_enumerate_grapheme_clusters</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>chopped_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>beg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>beg</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>beg</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p2</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>p</name> <operator>-</operator> <name>beg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_chop_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>chopped_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><name>len</name></expr>]</index></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_chop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>chopped_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>chompped_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>rs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newline</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rsptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>rslen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>p</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rs</name> <operator>==</operator> <name>rb_default_rs</name></expr>)</condition> <block>{<block_content>

<label><name>smart_chomp</name>:</label>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name><operator>-</operator><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_is_newline</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <name>e</name> <operator>-</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pp</name> <operator>&gt;=</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><operator>(</operator><name>e</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content> 

<case>case <expr><literal type="char">'\n'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>e</name> <operator>&gt;</operator> <name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>e</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>e</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\r'</literal></expr>:</case>

<expr_stmt><expr><operator>--</operator><name>e</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>e</name> <operator>-</operator> <name>p</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><name>rsptr</name></expr></argument>, <argument><expr><name>rslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rslen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>e</name> <operator>&gt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name><operator>-</operator><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_is_newline</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pp</name> <operator>-=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pp</name> <operator>&gt;=</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>e</name> <operator>&gt;</operator> <name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>e</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>e</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&gt;</operator> <name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>e</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name>e</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>e</name> <operator>-</operator> <name>p</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rslen</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>newline</name> <operator>=</operator> <name><name>rsptr</name><index>[<expr><name>rslen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rslen</name> <operator>==</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rslen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>newline</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>smart_chomp</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_is_newline</name><argument_list>(<argument><expr><name>rsptr</name></expr></argument>, <argument><expr><name>rsptr</name><operator>+</operator><name>rslen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>smart_chomp</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_broken_string</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>rslen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>newline</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>rslen</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator>

<call><name>memcmp</name><argument_list>(<argument><expr><name>rsptr</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>rslen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>pp</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>len</name> <operator>-</operator> <name>rslen</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>chomp_rs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rs</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>rs</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>rb_rs</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_chomp_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>rs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>chompped_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>olen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><name>len</name></expr>]</index></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_chomp_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rs</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rs</name> <operator>=</operator> <call><name>chomp_rs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_chomp_string</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_chomp</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rs</name> <init>= <expr><call><name>chomp_rs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>chompped_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>lstrip_offset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>start</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <name>s</name> <operator>&gt;=</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <call><name>ascii_isspace</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cc</name> <init>= <expr><call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_isspace</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>s</name> <operator>-</operator> <name>start</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_lstrip_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>, <decl><type ref="prev"/><name>loffset</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>loffset</name> <operator>=</operator> <call><name>lstrip_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>olen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>loffset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><name>olen</name><operator>-</operator><name>loffset</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>start</name> <operator>+</operator> <name>loffset</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SHARABLE_MIDDLE_SUBSTRING</name></expr></cpp:if>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><name>start</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_lstrip</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>loffset</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>loffset</name> <operator>=</operator> <call><name>lstrip_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>loffset</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>loffset</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>loffset</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>rstrip_offset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_check_dummy_enc</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <name>s</name> <operator>&gt;=</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>t</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>t</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>ascii_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>tp</name> <operator>=</operator> <call><name>rb_enc_prev_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>e</name> <operator>-</operator> <name>t</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_rstrip_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>, <decl><type ref="prev"/><name>roffset</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>roffset</name> <operator>=</operator> <call><name>rstrip_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>olen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>roffset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><name>olen</name> <operator>-</operator> <name>roffset</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SHARABLE_MIDDLE_SUBSTRING</name></expr></cpp:if>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><name>start</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_rstrip</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>, <decl><type ref="prev"/><name>roffset</name></decl>;</decl_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>roffset</name> <operator>=</operator> <call><name>rstrip_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>olen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>roffset</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>olen</name><operator>-</operator><name>roffset</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_strip_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>, <decl><type ref="prev"/><name>loffset</name></decl>, <decl><type ref="prev"/><name>roffset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>loffset</name> <operator>=</operator> <call><name>lstrip_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>olen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>roffset</name> <operator>=</operator> <call><name>rstrip_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>loffset</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>olen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>loffset</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>roffset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><name>olen</name><operator>-</operator><name>roffset</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>loffset</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>loffset</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name> <operator>+</operator> <name>loffset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SHARABLE_MIDDLE_SUBSTRING</name></expr></cpp:if>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><name>start</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_strip</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>, <decl><type ref="prev"/><name>loffset</name></decl>, <decl><type ref="prev"/><name>roffset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>loffset</name> <operator>=</operator> <call><name>lstrip_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>olen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>roffset</name> <operator>=</operator> <call><name>rstrip_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>loffset</name></expr></argument>, <argument><expr><name>start</name><operator>+</operator><name>olen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>loffset</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>roffset</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>loffset</name></expr></argument>, <argument><expr><name>olen</name><operator>-</operator><name>loffset</name><operator>-</operator><name>roffset</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>scan_once</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pat</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>set_backref_str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>match</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>end</name></decl>, <decl><type ref="prev"/><name>pos</name> <init>= <expr><call><name>rb_pat_search</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>*</operator><name>start</name></expr></argument>, <argument><expr><name>set_backref_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>BEG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name>end</name> <operator>+</operator> <call><name>rb_enc_fast_mbclen</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>end</name></expr></argument>,

<argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>regs</name> <operator>||</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>END</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-</operator><call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_scan</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>last</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <call><name>get_pat_quoted</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mustnot_broken</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name> <operator>=</operator> <call><name>scan_once</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>last</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_pat_search</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name> <operator>=</operator> <call><name>scan_once</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>last</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_pat_search</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_hex</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_to_inum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_oct</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_to_inum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_crypt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>salt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CRYPT_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>VALUE</name></type> <name>databuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>crypt_data</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_END</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>ALLOCV_END(databuf)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>crypt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_END</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(void)0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>saltp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BROKEN_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>salt_8bit_clean</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>salt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mustnot_wchar</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mustnot_wchar</name><argument_list>(<argument><expr><name>salt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>salt</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<label><name>short_salt</name>:</label>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"salt too short (need &gt;=2 bytes)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>saltp</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>salt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>saltp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name><name>saltp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>short_salt</name>;</goto></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BROKEN_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISASCII</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>saltp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ISASCII</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>saltp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>salt_8bit_clean</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>saltp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>salt_8bit_clean</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>saltp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>salt_8bit_clean</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>saltp</name> <operator>=</operator> <name>salt_8bit_clean</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CRYPT_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>ALLOCV</name><argument_list>(<argument><expr><name>databuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>crypt_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_CRYPT_DATA_INITIALIZED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>initialized</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>crypt_r</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>saltp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>crypt</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>saltp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CRYPT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"crypt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CRYPT_END</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_ord</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_codepoint</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_sum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>sum</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>sum0</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>bits</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>FIXNUM_MAX</name> <operator>-</operator> <name>UCHAR_MAX</name> <operator>&lt;</operator> <name>sum0</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>sum</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>sum0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sum0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sum0</name> <operator>+=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sum0</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>sum</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>sum0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sum</name> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>CHAR_BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sum0</name> <operator>&amp;=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><literal type="number">1</literal><operator>)</operator><operator>&lt;&lt;</operator><name>bits</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>LONG2FIX</name><argument_list>(<argument><expr><name>sum0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mod</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sum0</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>sum</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>sum0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mod</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idLTLT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mod</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>sum</name></expr></argument>, <argument><expr><literal type="char">'&amp;'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>sum</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_justify</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>jflag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>w</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>width</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>flen</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>fclen</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>llen</name></decl>, <decl><type ref="prev"/><name>rlen</name></decl>, <decl><type ref="prev"/><name>llen2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rlen2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pad</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>singlebyte</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>cr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>termlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>w</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>termlen</name> <operator>=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fclen</name> <operator>=</operator> <call><name>str_strlen</name><argument_list>(<argument><expr><name>pad</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>singlebyte</name> <operator>=</operator> <call><name>single_byte_optimizable</name><argument_list>(<argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>fclen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"zero width padding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>str_strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>width</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name> <operator>&gt;=</operator> <name>width</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>width</name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llen</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>jflag</name> <operator>==</operator> <literal type="char">'l'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>jflag</name> <operator>==</operator> <literal type="char">'r'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>n</name><operator>/</operator><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>rlen</name> <operator>=</operator> <name>n</name> <operator>-</operator> <name>llen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>llen2</name> <operator>=</operator> <call><name>str_offset</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>f</name> <operator>+</operator> <name>flen</name></expr></argument>, <argument><expr><name>llen</name> <operator>%</operator> <name>fclen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>singlebyte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rlen2</name> <operator>=</operator> <call><name>str_offset</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>f</name> <operator>+</operator> <name>flen</name></expr></argument>, <argument><expr><name>rlen</name> <operator>%</operator> <name>fclen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>singlebyte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <name>llen</name> <operator>/</operator> <name>fclen</name> <operator>+</operator> <name>rlen</name> <operator>/</operator> <name>fclen</name><operator>)</operator> <operator>&gt;=</operator> <name>LONG_MAX</name> <operator>/</operator> <name>flen</name> <operator>||</operator>

<operator>(</operator><name>len</name> <operator>*=</operator> <name>flen</name><operator>)</operator> <operator>&gt;=</operator> <name>LONG_MAX</name> <operator>-</operator> <name>llen2</name> <operator>-</operator> <name>rlen2</name> <operator>||</operator>

<operator>(</operator><name>len</name> <operator>+=</operator> <name>llen2</name> <operator>+</operator> <name>rlen2</name><operator>)</operator> <operator>&gt;=</operator> <name>LONG_MAX</name> <operator>-</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"argument too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>str_new0</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>f</name></expr></argument>, <argument><expr><name>llen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>llen</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>llen</name> <operator>&gt;=</operator> <name>fclen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name>flen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>flen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llen</name> <operator>-=</operator> <name>fclen</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>llen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>llen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>llen2</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>f</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>rlen</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><name>rlen</name> <operator>&gt;=</operator> <name>fclen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>f</name></expr></argument>,<argument><expr><name>flen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>flen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rlen</name> <operator>-=</operator> <name>fclen</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>rlen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>rlen2</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>ENC_CODERANGE_AND</name><argument_list>(<argument><expr><name>cr</name></expr></argument>, <argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>!=</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_ljust</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_justify</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'l'</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_rjust</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_justify</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_center</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_justify</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_partition</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>get_pat_quoted</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_reg_search</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<label><name>failed</name>:</label>

<return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>str_new_empty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>str_new_empty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>rb_str_subpat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_index</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>sep</name></expr></argument>,

<argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name><operator>+</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-</operator><name>pos</name><operator>-</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_rpartition</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>regex</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_reg_search</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regex</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"type mismatch: %s given"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sep</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_sublen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_rindex</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>str_new_empty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>str_new_empty</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>regex</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>sep</name></expr></argument>,

<argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name><operator>+</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-</operator><name>pos</name><operator>-</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_start_with</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_reg_start_with_p</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_end_with</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>e</name> <operator>-</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>deleted_prefix_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>prefix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prefixptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>, <decl><type ref="prev"/><name>prefixlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_broken_string</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prefixlen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>olen</name> <operator>&lt;</operator> <name>prefixlen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>strptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prefixptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>strptr</name></expr></argument>, <argument><expr><name>prefixptr</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>prefixlen</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_delete_prefix_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>prefix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>prefixlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prefixlen</name> <operator>=</operator> <call><name>deleted_prefix_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_drop_bytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_delete_prefix</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>prefix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>prefixlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prefixlen</name> <operator>=</operator> <call><name>deleted_prefix_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prefixlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>prefixlen</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>deleted_suffix_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>suffix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>suffixptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>, <decl><type ref="prev"/><name>suffixlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_broken_string</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>suffixlen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>suffixlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>olen</name> <operator>&lt;</operator> <name>suffixlen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>strptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>suffixptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>strptr</name> <operator>+</operator> <name>olen</name> <operator>-</operator> <name>suffixlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>suffixptr</name></expr></argument>, <argument><expr><name>suffixlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>strptr</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>strptr</name> <operator>+</operator> <name>olen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>suffixlen</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_delete_suffix_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>suffix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>, <decl><type ref="prev"/><name>suffixlen</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>suffixlen</name> <operator>=</operator> <call><name>deleted_suffix_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>suffixlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_modify_keep_cr</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>olen</name> <operator>-</operator> <name>suffixlen</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STR_SET_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TERM_FILL</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><index>[<expr><name>len</name></expr>]</index></expr></argument>, <argument><expr><call><name>TERM_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_delete_suffix</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>suffix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>suffixlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>suffixlen</name> <operator>=</operator> <call><name>deleted_suffix_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>suffixlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>suffixlen</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_str_setter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"value of %"</literal><name>PRIsVALUE</name><literal type="string">" must be String"</literal></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>var</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_fs_setter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_fs_check</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,

<argument><expr><literal type="string">"value of %"</literal><name>PRIsVALUE</name><literal type="string">" must be String or Regexp"</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn_deprecated</name><argument_list>(<argument><expr><literal type="string">"`$;'"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>var</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_force_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_modifiable</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_to_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_b</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str2</name> <init>= <expr><call><name>str_alloc</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>str_replace_shared_without_enc</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str2</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_valid_encoding_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_BROKEN</name></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>Qtrue</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_is_ascii_only_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_ellipsize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ellipsis</name><index>[]</index></name> <init>= <expr><literal type="string">"..."</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>ellipsislen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ellipsis</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier><specifier>const</specifier></type> <name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>blen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>p</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name> <init>= <expr><name>p</name> <operator>+</operator> <name>blen</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>estr</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"negative length %ld"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>*</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>blen</name> <operator>||</operator>

<operator>(</operator><name>e</name> <operator>=</operator> <call><name>rb_enc_nth</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>-</operator> <name>p</name> <operator>==</operator> <name>blen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>ellipsislen</name> <operator>||</operator>

<operator>!</operator><operator>(</operator><name>e</name> <operator>=</operator> <call><name>rb_enc_step_back</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>len</name> <operator>=</operator> <name>ellipsislen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new_with_class</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ellipsis</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>estr</name> <operator>=</operator> <call><name>rb_usascii_str_new</name><argument_list>(<argument><expr><name>ellipsis</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_encode</name><argument_list>(<argument><expr><name>estr</name></expr></argument>, <argument><expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>ellipsis</name></expr></argument>, <argument><expr><name>ellipsislen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>estr</name> <operator>=</operator> <call><name>rb_str_encode</name><argument_list>(<argument><expr><call><name>rb_usascii_str_new</name><argument_list>(<argument><expr><name>ellipsis</name></expr></argument>, <argument><expr><name>ellipsislen</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>estr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_compat_and_valid</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>StringValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"replacement must be valid byte sequence '%+"</literal><name>PRIsVALUE</name><literal type="string">"'"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr> ?</condition><then> <expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>enc</name> <operator>!=</operator> <name>e</name></expr></else></ternary></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncCompatError</name></expr></argument>, <argument><expr><literal type="string">"incompatible character encodings: %s and %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>enc_str_scrub</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>repl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>VALUE</name></type>

<name>rb_str_scrub</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>repl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>enc_str_scrub</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>, <argument><expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_enc_str_scrub</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>repl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><name>ENC_CODERANGE_UNKNOWN</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>enc_str_scrub</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enc_str_scrub</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>repl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>buf</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rep</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>replen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"both of block and replacement given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>replen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE_CLEAN_P</name><argument_list>(<argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>str_compat_and_valid</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_dummy_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>encidx</name> <operator>=</operator> <call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_REPLACE_CHAR</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { static const char replace[sizeof(str)-1] = str; rep = replace; replen = (int)sizeof(replace); } while (0)</cpp:value></cpp:define>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rep7bit_p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rep7bit_p</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rep</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>replen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rep7bit_p</name> <operator>=</operator> <operator>(</operator><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>encidx</name> <operator>==</operator> <call><name>rb_utf8_encindex</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DEFAULT_REPLACE_CHAR</name><argument_list>(<argument><expr><literal type="string">"\xEF\xBF\xBD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rep7bit_p</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>DEFAULT_REPLACE_CHAR</name><argument_list>(<argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rep7bit_p</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_7BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_NEEDMORE_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>clen</name> <init>= <expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>p1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>-</operator> <name>p</name> <operator>&lt;</operator> <name>clen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>clen</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>clen</name><operator>--</operator></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>clen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>clen</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>q</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_NEEDMORE_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>replen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rep7bit_p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>str_compat_and_valid</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_VALID</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>search_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p1</name> <operator>&lt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>replen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rep7bit_p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name><operator>-</operator><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>str_compat_and_valid</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_VALID</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>mbminlen</name> <init>= <expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rep</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>replen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>encidx</name> <operator>==</operator> <name>ENCINDEX_UTF_16BE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DEFAULT_REPLACE_CHAR</name><argument_list>(<argument><expr><literal type="string">"\xFF\xFD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>encidx</name> <operator>==</operator> <name>ENCINDEX_UTF_16LE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DEFAULT_REPLACE_CHAR</name><argument_list>(<argument><expr><literal type="string">"\xFD\xFF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>encidx</name> <operator>==</operator> <name>ENCINDEX_UTF_32BE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DEFAULT_REPLACE_CHAR</name><argument_list>(<argument><expr><literal type="string">"\x00\x00\xFF\xFD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>encidx</name> <operator>==</operator> <name>ENCINDEX_UTF_32LE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>DEFAULT_REPLACE_CHAR</name><argument_list>(<argument><expr><literal type="string">"\xFD\xFF\x00\x00"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>DEFAULT_REPLACE_CHAR</name><argument_list>(<argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_NEEDMORE_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>clen</name> <init>= <expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>p1</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>-</operator> <name>p</name> <operator>&lt;</operator> <name>clen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>clen</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&lt;=</operator> <name>mbminlen</name> <operator>*</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <name>mbminlen</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>clen</name> <operator>-=</operator> <name>mbminlen</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>clen</name> <operator>&gt;</operator> <name>mbminlen</name></expr>;</condition> <incr><expr><name>clen</name><operator>-=</operator><name>mbminlen</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>q</name> <operator>+</operator> <name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_NEEDMORE_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>replen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>str_compat_and_valid</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>UNREACHABLE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ENC_CODERANGE_SET</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ENC_CODERANGE_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p1</name> <operator>&lt;</operator> <name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>replen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name><operator>-</operator><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>str_mod_check</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>repl</name> <operator>=</operator> <call><name>str_compat_and_valid</name><argument_list>(<argument><expr><name>repl</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <name>ENC_CODERANGE_VALID</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ENCODING_CODERANGE_SET</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_scrub</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>repl</name> <init>= <expr><ternary><condition><expr><name>argc</name></expr> ?</condition><then> <expr><operator>(</operator><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call>, <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>new</name> <init>= <expr><call><name>rb_str_scrub</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>new</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_scrub_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>repl</name> <init>= <expr><ternary><condition><expr><name>argc</name></expr> ?</condition><then> <expr><operator>(</operator><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call>, <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>new</name> <init>= <expr><call><name>rb_str_scrub</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_normalize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_normalized_p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>mUnicodeNormalize</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>unicode_normalize_common</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>UnicodeNormalizeRequired</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>argv2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>UnicodeNormalizeRequired</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_require</name><argument_list>(<argument><expr><literal type="string">"unicode_normalize/normalize.rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>UnicodeNormalizeRequired</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>argv2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>argv2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>mUnicodeNormalize</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>argc</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_unicode_normalize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>unicode_normalize_common</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>id_normalize</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_unicode_normalize_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>unicode_normalize_common</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>id_normalize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_unicode_normalized_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>unicode_normalize_common</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>id_normalized_p</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sym_equal</name></cpp:macro> <cpp:value>rb_obj_equal</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>sym_printable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>send</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_str_symname_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>resenc</name> <init>= <expr><call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>resenc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>resenc</name> <operator>=</operator> <call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>resenc</name> <operator>!=</operator> <name>enc</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_str_is_ascii_only_p</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name>len</name> <operator>!=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>rb_enc_symname2_p</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>sym_printable</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_quote_unprintable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>resenc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>resenc</name> <operator>=</operator> <call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>resenc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>resenc</name> <operator>=</operator> <call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>resenc</name> <operator>!=</operator> <name>enc</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_str_is_ascii_only_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>

<operator>!</operator><call><name>sym_printable</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_inspect</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_id_quote_unprintable</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_str_symname_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_str_inspect</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_str_symname_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_inspect</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dest</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>STR_ENC_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_enc_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>dest</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_sym_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>str_new_shared</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_to_sym</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>sym</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_sym_proc_call</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>passed_proc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no receiver given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><call><name>rb_funcall_with_block_kw</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>passed_proc</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

VALUE

rb_sym_to_proc(VALUE sym)

{

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_succ</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_intern</name><argument_list>(<argument><expr><call><name>rb_str_succ</name><argument_list>(<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_str_cmp_m</name><argument_list>(<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_casecmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>str_casecmp</name><argument_list>(<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_casecmp_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>str_casecmp_p</name><argument_list>(<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_match</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_match</name><argument_list>(<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_match_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_match_m</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_match_m_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_match_m_p</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_aref</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_aref_m</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_length</name><argument_list>(<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_empty</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_empty</name><argument_list>(<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_upcase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_intern</name><argument_list>(<argument><expr><call><name>rb_str_upcase</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_downcase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_intern</name><argument_list>(<argument><expr><call><name>rb_str_downcase</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_capitalize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_intern</name><argument_list>(<argument><expr><call><name>rb_str_capitalize</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_swapcase</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_intern</name><argument_list>(<argument><expr><call><name>rb_str_swapcase</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_start_with</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_start_with</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_end_with</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_str_end_with</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>sym</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_obj_encoding</name><argument_list>(<argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>string_for_symbol</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"%+"</literal><name>PRIsVALUE</name><literal type="string">" is not a symbol"</literal></expr></argument>,

<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ID</name></type>

<name>rb_to_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>SYM2ID</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>string_for_symbol</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_intern_str</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_to_symbol</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>string_for_symbol</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_intern</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>sym_all_symbols</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_sym_all_symbols</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_String</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_intern</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_intern_const(str)</cpp:value></cpp:define>

<expr_stmt><expr><name>rb_cString</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"String"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>rb_vm_fstring_table</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><call><name>rb_vm_fstring_table</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>fstring_set_class_i</name></expr></argument>, <argument><expr><name>rb_cString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>rb_mComparable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><name>empty_str_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"try_convert"</literal></expr></argument>, <argument><expr><name>rb_str_s_try_convert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>rb_str_init</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>, <argument><expr><name>rb_str_replace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"&lt;=&gt;"</literal></expr></argument>, <argument><expr><name>rb_str_cmp_m</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>rb_str_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"==="</literal></expr></argument>, <argument><expr><name>rb_str_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"eql?"</literal></expr></argument>, <argument><expr><name>rb_str_eql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>rb_str_hash_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"casecmp"</literal></expr></argument>, <argument><expr><name>rb_str_casecmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"casecmp?"</literal></expr></argument>, <argument><expr><name>rb_str_casecmp_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><name>rb_str_plus</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>rb_str_times</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"%"</literal></expr></argument>, <argument><expr><name>rb_str_format_m</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>rb_str_aref_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"[]="</literal></expr></argument>, <argument><expr><name>rb_str_aset_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"insert"</literal></expr></argument>, <argument><expr><name>rb_str_insert</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><name>rb_str_length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>rb_str_length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"bytesize"</literal></expr></argument>, <argument><expr><name>rb_str_bytesize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"empty?"</literal></expr></argument>, <argument><expr><name>rb_str_empty</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"=~"</literal></expr></argument>, <argument><expr><name>rb_str_match</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"match"</literal></expr></argument>, <argument><expr><name>rb_str_match_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"match?"</literal></expr></argument>, <argument><expr><name>rb_str_match_m_p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"succ"</literal></expr></argument>, <argument><expr><name>rb_str_succ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"succ!"</literal></expr></argument>, <argument><expr><name>rb_str_succ_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"next"</literal></expr></argument>, <argument><expr><name>rb_str_succ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"next!"</literal></expr></argument>, <argument><expr><name>rb_str_succ_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"upto"</literal></expr></argument>, <argument><expr><name>rb_str_upto</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><name>rb_str_index_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"rindex"</literal></expr></argument>, <argument><expr><name>rb_str_rindex_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"replace"</literal></expr></argument>, <argument><expr><name>rb_str_replace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"clear"</literal></expr></argument>, <argument><expr><name>rb_str_clear</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"chr"</literal></expr></argument>, <argument><expr><name>rb_str_chr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"getbyte"</literal></expr></argument>, <argument><expr><name>rb_str_getbyte</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"setbyte"</literal></expr></argument>, <argument><expr><name>rb_str_setbyte</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"byteslice"</literal></expr></argument>, <argument><expr><name>rb_str_byteslice</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"scrub"</literal></expr></argument>, <argument><expr><name>str_scrub</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"scrub!"</literal></expr></argument>, <argument><expr><name>str_scrub_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"freeze"</literal></expr></argument>, <argument><expr><name>rb_str_freeze</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"+@"</literal></expr></argument>, <argument><expr><name>str_uplus</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"-@"</literal></expr></argument>, <argument><expr><name>str_uminus</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"to_i"</literal></expr></argument>, <argument><expr><name>rb_str_to_i</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"to_f"</literal></expr></argument>, <argument><expr><name>rb_str_to_f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>rb_str_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"to_str"</literal></expr></argument>, <argument><expr><name>rb_str_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>rb_str_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"dump"</literal></expr></argument>, <argument><expr><name>rb_str_dump</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"undump"</literal></expr></argument>, <argument><expr><name>str_undump</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_ascii</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"ascii"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_turkic</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"turkic"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_lithuanian</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"lithuanian"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_fold</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"fold"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"upcase"</literal></expr></argument>, <argument><expr><name>rb_str_upcase</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"downcase"</literal></expr></argument>, <argument><expr><name>rb_str_downcase</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"capitalize"</literal></expr></argument>, <argument><expr><name>rb_str_capitalize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"swapcase"</literal></expr></argument>, <argument><expr><name>rb_str_swapcase</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"upcase!"</literal></expr></argument>, <argument><expr><name>rb_str_upcase_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"downcase!"</literal></expr></argument>, <argument><expr><name>rb_str_downcase_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"capitalize!"</literal></expr></argument>, <argument><expr><name>rb_str_capitalize_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"swapcase!"</literal></expr></argument>, <argument><expr><name>rb_str_swapcase_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"hex"</literal></expr></argument>, <argument><expr><name>rb_str_hex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"oct"</literal></expr></argument>, <argument><expr><name>rb_str_oct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"split"</literal></expr></argument>, <argument><expr><name>rb_str_split_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"lines"</literal></expr></argument>, <argument><expr><name>rb_str_lines</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"bytes"</literal></expr></argument>, <argument><expr><name>rb_str_bytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"chars"</literal></expr></argument>, <argument><expr><name>rb_str_chars</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"codepoints"</literal></expr></argument>, <argument><expr><name>rb_str_codepoints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"grapheme_clusters"</literal></expr></argument>, <argument><expr><name>rb_str_grapheme_clusters</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"reverse"</literal></expr></argument>, <argument><expr><name>rb_str_reverse</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"reverse!"</literal></expr></argument>, <argument><expr><name>rb_str_reverse_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"concat"</literal></expr></argument>, <argument><expr><name>rb_str_concat_multi</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>, <argument><expr><name>rb_str_concat</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"prepend"</literal></expr></argument>, <argument><expr><name>rb_str_prepend_multi</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"crypt"</literal></expr></argument>, <argument><expr><name>rb_str_crypt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"intern"</literal></expr></argument>, <argument><expr><name>rb_str_intern</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"to_sym"</literal></expr></argument>, <argument><expr><name>rb_str_intern</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"ord"</literal></expr></argument>, <argument><expr><name>rb_str_ord</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"include?"</literal></expr></argument>, <argument><expr><name>rb_str_include</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"start_with?"</literal></expr></argument>, <argument><expr><name>rb_str_start_with</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"end_with?"</literal></expr></argument>, <argument><expr><name>rb_str_end_with</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"scan"</literal></expr></argument>, <argument><expr><name>rb_str_scan</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"ljust"</literal></expr></argument>, <argument><expr><name>rb_str_ljust</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"rjust"</literal></expr></argument>, <argument><expr><name>rb_str_rjust</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"center"</literal></expr></argument>, <argument><expr><name>rb_str_center</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"sub"</literal></expr></argument>, <argument><expr><name>rb_str_sub</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"gsub"</literal></expr></argument>, <argument><expr><name>rb_str_gsub</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"chop"</literal></expr></argument>, <argument><expr><name>rb_str_chop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"chomp"</literal></expr></argument>, <argument><expr><name>rb_str_chomp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"strip"</literal></expr></argument>, <argument><expr><name>rb_str_strip</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"lstrip"</literal></expr></argument>, <argument><expr><name>rb_str_lstrip</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"rstrip"</literal></expr></argument>, <argument><expr><name>rb_str_rstrip</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"delete_prefix"</literal></expr></argument>, <argument><expr><name>rb_str_delete_prefix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"delete_suffix"</literal></expr></argument>, <argument><expr><name>rb_str_delete_suffix</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"sub!"</literal></expr></argument>, <argument><expr><name>rb_str_sub_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"gsub!"</literal></expr></argument>, <argument><expr><name>rb_str_gsub_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"chop!"</literal></expr></argument>, <argument><expr><name>rb_str_chop_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"chomp!"</literal></expr></argument>, <argument><expr><name>rb_str_chomp_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"strip!"</literal></expr></argument>, <argument><expr><name>rb_str_strip_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"lstrip!"</literal></expr></argument>, <argument><expr><name>rb_str_lstrip_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"rstrip!"</literal></expr></argument>, <argument><expr><name>rb_str_rstrip_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"delete_prefix!"</literal></expr></argument>, <argument><expr><name>rb_str_delete_prefix_bang</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"delete_suffix!"</literal></expr></argument>, <argument><expr><name>rb_str_delete_suffix_bang</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"tr"</literal></expr></argument>, <argument><expr><name>rb_str_tr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"tr_s"</literal></expr></argument>, <argument><expr><name>rb_str_tr_s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>, <argument><expr><name>rb_str_delete</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"squeeze"</literal></expr></argument>, <argument><expr><name>rb_str_squeeze</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>, <argument><expr><name>rb_str_count</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"tr!"</literal></expr></argument>, <argument><expr><name>rb_str_tr_bang</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"tr_s!"</literal></expr></argument>, <argument><expr><name>rb_str_tr_s_bang</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"delete!"</literal></expr></argument>, <argument><expr><name>rb_str_delete_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"squeeze!"</literal></expr></argument>, <argument><expr><name>rb_str_squeeze_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"each_line"</literal></expr></argument>, <argument><expr><name>rb_str_each_line</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"each_byte"</literal></expr></argument>, <argument><expr><name>rb_str_each_byte</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"each_char"</literal></expr></argument>, <argument><expr><name>rb_str_each_char</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"each_codepoint"</literal></expr></argument>, <argument><expr><name>rb_str_each_codepoint</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"each_grapheme_cluster"</literal></expr></argument>, <argument><expr><name>rb_str_each_grapheme_cluster</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"sum"</literal></expr></argument>, <argument><expr><name>rb_str_sum</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name>rb_str_aref_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"slice!"</literal></expr></argument>, <argument><expr><name>rb_str_slice_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"partition"</literal></expr></argument>, <argument><expr><name>rb_str_partition</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"rpartition"</literal></expr></argument>, <argument><expr><name>rb_str_rpartition</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>, <argument><expr><name>rb_obj_encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"force_encoding"</literal></expr></argument>, <argument><expr><name>rb_str_force_encoding</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"b"</literal></expr></argument>, <argument><expr><name>rb_str_b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"valid_encoding?"</literal></expr></argument>, <argument><expr><name>rb_str_valid_encoding_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"ascii_only?"</literal></expr></argument>, <argument><expr><name>rb_str_is_ascii_only_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mUnicodeNormalize</name> <operator>=</operator> <call><name>rb_define_module</name><argument_list>(<argument><expr><literal type="string">"UnicodeNormalize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_normalize</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"normalize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_normalized_p</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"normalized?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"unicode_normalize"</literal></expr></argument>, <argument><expr><name>rb_str_unicode_normalize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"unicode_normalize!"</literal></expr></argument>, <argument><expr><name>rb_str_unicode_normalize_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cString</name></expr></argument>, <argument><expr><literal type="string">"unicode_normalized?"</literal></expr></argument>, <argument><expr><name>rb_str_unicode_normalized_p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_fs</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_hooked_variable</name><argument_list>(<argument><expr><literal type="string">"$;"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rb_fs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_fs_setter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_hooked_variable</name><argument_list>(<argument><expr><literal type="string">"$-F"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rb_fs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_fs_setter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rb_fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cSymbol</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Symbol"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><name>rb_mComparable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"all_symbols"</literal></expr></argument>, <argument><expr><name>sym_all_symbols</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>sym_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"==="</literal></expr></argument>, <argument><expr><name>sym_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>sym_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>rb_sym_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"id2name"</literal></expr></argument>, <argument><expr><name>rb_sym_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"intern"</literal></expr></argument>, <argument><expr><name>sym_to_sym</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"to_sym"</literal></expr></argument>, <argument><expr><name>sym_to_sym</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"to_proc"</literal></expr></argument>, <argument><expr><name>rb_sym_to_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"succ"</literal></expr></argument>, <argument><expr><name>sym_succ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"next"</literal></expr></argument>, <argument><expr><name>sym_succ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"&lt;=&gt;"</literal></expr></argument>, <argument><expr><name>sym_cmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"casecmp"</literal></expr></argument>, <argument><expr><name>sym_casecmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"casecmp?"</literal></expr></argument>, <argument><expr><name>sym_casecmp_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"=~"</literal></expr></argument>, <argument><expr><name>sym_match</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>sym_aref</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name>sym_aref</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><name>sym_length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>sym_length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"empty?"</literal></expr></argument>, <argument><expr><name>sym_empty</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"match"</literal></expr></argument>, <argument><expr><name>sym_match_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"match?"</literal></expr></argument>, <argument><expr><name>sym_match_m_p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"upcase"</literal></expr></argument>, <argument><expr><name>sym_upcase</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"downcase"</literal></expr></argument>, <argument><expr><name>sym_downcase</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"capitalize"</literal></expr></argument>, <argument><expr><name>sym_capitalize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"swapcase"</literal></expr></argument>, <argument><expr><name>sym_swapcase</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"start_with?"</literal></expr></argument>, <argument><expr><name>sym_start_with</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"end_with?"</literal></expr></argument>, <argument><expr><name>sym_end_with</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cSymbol</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>, <argument><expr><name>sym_encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
