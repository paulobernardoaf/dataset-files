<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\thread_win32.c"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>THREAD_SYSTEM_DEPENDENT_IMPLEMENTATION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_QUANTUM_USEC</name></cpp:macro> <cpp:value>(10 * 1000)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB_CONDATTR_CLOCK_MONOTONIC</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Sleep</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>native_thread_yield</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>Sleep(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unregister_ubf_list</name><parameter_list>(<parameter><type><name>th</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ubf_wakeup_all_threads</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do {} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ubf_threads_empty</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ubf_timer_disarm</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do {} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ubf_list_atfork</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do {} while (0)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>DWORD</name></type> <name>ruby_native_thread_key</name> <init>= <expr><name>TLS_OUT_OF_INDEXES</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>w32_wait_events</name><parameter_list>(<parameter><decl><type><name>HANDLE</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>DWORD</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_mutex_lock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>rb_native_mutex_unlock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>w32_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>LPVOID</name></type> <name>lpMsgBuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DWORD</name></type> <name>err</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FormatMessage</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_ALLOCATE_BUFFER</name> <operator>|</operator>

<name>FORMAT_MESSAGE_FROM_SYSTEM</name> <operator>|</operator>

<name>FORMAT_MESSAGE_IGNORE_INSERTS</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>err</name></expr></argument>,

<argument><expr><call><name>MAKELANGID</name><argument_list>(<argument><expr><name>LANG_ENGLISH</name></expr></argument>, <argument><expr><name>SUBLANG_ENGLISH_US</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>LPTSTR</name><operator>)</operator> <operator>&amp;</operator> <name>lpMsgBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>FormatMessage</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_ALLOCATE_BUFFER</name> <operator>|</operator>

<name>FORMAT_MESSAGE_FROM_SYSTEM</name> <operator>|</operator>

<name>FORMAT_MESSAGE_IGNORE_INSERTS</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>err</name></expr></argument>,

<argument><expr><call><name>MAKELANGID</name><argument_list>(<argument><expr><name>LANG_NEUTRAL</name></expr></argument>, <argument><expr><name>SUBLANG_DEFAULT</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>LPTSTR</name><operator>)</operator> <operator>&amp;</operator> <name>lpMsgBuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>lpMsgBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>w32_mutex_lock</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>DWORD</name></type> <name>result</name></decl>;</decl_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"rb_native_mutex_lock: %p\n"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>w32_wait_events</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>WAIT_OBJECT_0</name></expr>:</case>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"acquire mutex: %p\n"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>WAIT_OBJECT_0</name> <operator>+</operator> <literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"acquire mutex interrupted: %p\n"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>WAIT_TIMEOUT</name></expr>:</case>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"timeout mutex: %p\n"</literal></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>WAIT_ABANDONED</name></expr>:</case>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"win32_mutex_lock: WAIT_ABANDONED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"win32_mutex_lock: unknown result (%ld)"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HANDLE</name></type>

<name>w32_mutex_create</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>HANDLE</name></type> <name>lock</name> <init>= <expr><call><name>CreateMutex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lock</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>w32_error</name><argument_list>(<argument><expr><literal type="string">"rb_native_mutex_initialize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>lock</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GVL_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_acquire</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>w32_mutex_lock</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>GVL_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"gvl acquire (%p): acquire\n"</literal></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_release</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ReleaseMutex</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_yield</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>gvl_release</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>vm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>native_thread_yield</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gvl_acquire</name><argument_list>(<argument><expr><name>vm</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_init</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>GVL_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"gvl init\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name> <operator>=</operator> <call><name>w32_mutex_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>gvl_destroy</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>GVL_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"gvl destroy\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>gvl</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type>

<name>ruby_thread_from_native</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>TlsGetValue</name><argument_list>(<argument><expr><name>ruby_native_thread_key</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ruby_thread_set_native</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>TlsSetValue</name><argument_list>(<argument><expr><name>ruby_native_thread_key</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_native_thread</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>ruby_native_thread_key</name> <operator>=</operator> <call><name>TlsAlloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_thread_set_native</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DuplicateHandle</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,

<argument><expr><call><name>GetCurrentThread</name><argument_list>()</argument_list></call></expr></argument>,

<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>interrupt_event</name></name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"initial thread (th: %p, thid: %p, event: %p)\n"</literal></expr></argument>,

<argument><expr><name>th</name></expr></argument>, <argument><expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>thread_id</name></expr></argument>,

<argument><expr><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>interrupt_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>w32_wait_events</name><parameter_list>(<parameter><decl><type><name>HANDLE</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>DWORD</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>HANDLE</name> <modifier>*</modifier></type><name>targets</name> <init>= <expr><name>events</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HANDLE</name></type> <name>intr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>initcount</name> <init>= <expr><name>count</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DWORD</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">" w32_wait_events events:%p, count:%d, timeout:%ld, th:%p\n"</literal></expr></argument>,

<argument><expr><name>events</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>th</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>intr</name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>interrupt_event</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ResetEvent</name><argument_list>(<argument><expr><name>intr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>RUBY_VM_INTERRUPTED</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SetEvent</name><argument_list>(<argument><expr><name>intr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>targets</name> <operator>=</operator> <call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>HANDLE</name></expr></argument>, <argument><expr><name>count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>events</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HANDLE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>targets</name><index>[<expr><name>count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>intr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">" * handle: %p (count: %d, intr)\n"</literal></expr></argument>, <argument><expr><name>intr</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>intr</name> <operator>==</operator> <name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>interrupt_event</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>w32_error</name><argument_list>(<argument><expr><literal type="string">"w32_wait_events"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">" WaitForMultipleObjects start (count: %d)\n"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">" WaitForMultipleObjects end (ret: %lu)\n"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>(</operator><name>WAIT_OBJECT_0</name> <operator>+</operator> <name>initcount</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>th</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>WAIT_FAILED</name> <operator>&amp;&amp;</operator> <name>THREAD_DEBUG</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DWORD</name></type> <name>dmy</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">" * error handle %d - %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,

<argument><expr><ternary><condition><expr><call><name>GetHandleInformation</name><argument_list>(<argument><expr><name><name>targets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dmy</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"OK"</literal></expr> </then><else>: <expr><literal type="string">"NG"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ubf_handle</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ubf_select</name></cpp:macro> <cpp:value>ubf_handle</cpp:value></cpp:define>

<function><type><name>int</name></type>

<name>rb_w32_wait_events_blocking</name><parameter_list>(<parameter><decl><type><name>HANDLE</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>DWORD</name></type> <name>timeout</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>w32_wait_events</name><argument_list>(<argument><expr><name>events</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><call><name>ruby_thread_from_native</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_w32_wait_events</name><parameter_list>(<parameter><decl><type><name>HANDLE</name> <modifier>*</modifier></type><name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>DWORD</name></type> <name>timeout</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BLOCKING_REGION</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>ret</name> <operator>=</operator> <call><name>rb_w32_wait_events_blocking</name><argument_list>(<argument><expr><name>events</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ubf_handle</name></expr></argument>, <argument><expr><call><name>ruby_thread_from_native</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>w32_close_handle</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>handle</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>w32_error</name><argument_list>(<argument><expr><literal type="string">"w32_close_handle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>w32_resume_thread</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>handle</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ResumeThread</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>w32_error</name><argument_list>(<argument><expr><literal type="string">"w32_resume_thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE__BEGINTHREADEX</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE__BEGINTHREADEX</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__BEGINTHREADEX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>start_thread</name></cpp:macro> <cpp:value>(HANDLE)_beginthreadex</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>thread_errno</name></cpp:macro> <cpp:value>errno</cpp:value></cpp:define>

<typedef>typedef <function_decl><type><name>unsigned</name> <name>long</name></type> (<name>__stdcall</name> <modifier>*</modifier><name>w32_thread_start_func</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>start_thread</name></cpp:macro> <cpp:value>CreateThread</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>thread_errno</name></cpp:macro> <cpp:value>rb_w32_map_errno(GetLastError())</cpp:value></cpp:define>

<typedef>typedef <type><name>LPTHREAD_START_ROUTINE</name></type> <name>w32_thread_start_func</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>HANDLE</name></type>

<name>w32_create_thread</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>stack_size</name></decl></parameter>, <parameter><decl><type><name>w32_thread_start_func</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>start_thread</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>CREATE_SUSPENDED</name> <operator>|</operator> <name>STACK_SIZE_PARAM_IS_A_RESERVATION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_w32_sleep</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>msec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>w32_wait_events</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>msec</name></expr></argument>, <argument><expr><call><name>ruby_thread_from_native</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>WINAPI</name></type>

<name>rb_w32_Sleep</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>msec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BLOCKING_REGION</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>ret</name> <operator>=</operator> <call><name>rb_w32_sleep</name><argument_list>(<argument><expr><name>msec</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ubf_handle</name></expr></argument>, <argument><expr><call><name>ruby_thread_from_native</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DWORD</name></type>

<name>hrtime2msec</name><parameter_list>(<parameter><decl><type><name>rb_hrtime_t</name></type> <name>hrt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>DWORD</name><operator>)</operator><name>hrt</name> <operator>/</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>RB_HRTIME_PER_MSEC</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_sleep</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>rb_hrtime_t</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <specifier>volatile</specifier> <name>DWORD</name></type> <name>msec</name> <init>= <expr><ternary><condition><expr><name>rel</name></expr> ?</condition><then> <expr><call><name>hrtime2msec</name><argument_list>(<argument><expr><operator>*</operator><name>rel</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>INFINITE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GVL_UNLOCK_BEGIN</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>DWORD</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>interrupt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>ubf_handle</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>th</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>interrupt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RUBY_VM_INTERRUPTED</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"native_sleep start (%lu)\n"</literal></expr></argument>, <argument><expr><name>msec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>w32_wait_events</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>msec</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"native_sleep done (%lu)\n"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>interrupt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>func</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>unblock</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>interrupt_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>GVL_UNLOCK_END</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_mutex_lock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_WIN32_MUTEX</name></expr></cpp:if>

<expr_stmt><expr><call><name>w32_mutex_lock</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>crit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_mutex_unlock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_WIN32_MUTEX</name></expr></cpp:if>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"release mutex: %p\n"</literal></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ReleaseMutex</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>crit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_mutex_trylock</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_WIN32_MUTEX</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"native_mutex_trylock: %p\n"</literal></expr></argument>, <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>w32_wait_events</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"native_mutex_trylock result: %d\n"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>WAIT_OBJECT_0</name></expr>:</case>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>WAIT_TIMEOUT</name></expr>:</case>

<return>return <expr><name>EBUSY</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>EINVAL</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>TryEnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>crit</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_mutex_initialize</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_WIN32_MUTEX</name></expr></cpp:if>

<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>mutex</name></name> <operator>=</operator> <call><name>w32_mutex_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>crit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_mutex_destroy</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_WIN32_MUTEX</name></expr></cpp:if>

<expr_stmt><expr><call><name>w32_close_handle</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>DeleteCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>crit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<struct>struct <name>cond_event_entry</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name><modifier>*</modifier></type> <name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name><modifier>*</modifier></type> <name>prev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HANDLE</name></type> <name>event</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><name>void</name></type>

<name>rb_native_cond_signal</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>cond</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name> <modifier>*</modifier></type><name>head</name> <init>= <expr><operator>(</operator>struct <name>cond_event_entry</name><operator>*</operator><operator>)</operator><name>cond</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>!=</operator> <name>head</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_cond_broadcast</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>cond</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name> <modifier>*</modifier></type><name>head</name> <init>= <expr><operator>(</operator>struct <name>cond_event_entry</name><operator>*</operator><operator>)</operator><name>cond</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>e</name> <operator>!=</operator> <name>head</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_cond_timedwait_ms</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>msec</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>DWORD</name></type> <name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name></type> <name>entry</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>cond_event_entry</name></name> <modifier>*</modifier></type><name>head</name> <init>= <expr><operator>(</operator>struct <name>cond_event_entry</name><operator>*</operator><operator>)</operator><name>cond</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>entry</name><operator>.</operator><name>event</name></name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>head</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>&amp;</operator><name>entry</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>&amp;</operator><name>entry</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_native_mutex_unlock</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>event</name></name></expr></argument>, <argument><expr><name>msec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>!=</operator> <name>WAIT_OBJECT_0</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>r</name> <operator>!=</operator> <name>WAIT_TIMEOUT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_native_cond_wait: WaitForSingleObject returns %lu"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>rb_native_mutex_lock</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>.</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>.</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>w32_close_handle</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>r</name> <operator>==</operator> <name>WAIT_OBJECT_0</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>ETIMEDOUT</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_cond_wait</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>rb_nativethread_lock_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>native_cond_timedwait_ms</name><argument_list>(<argument><expr><name>cond</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static unsigned long

abs_timespec_to_timeout_ms(const struct timespec *ts)

{

struct timeval tv;

struct timeval now;

gettimeofday(&amp;now, NULL);

tv.tv_sec = ts-&gt;tv_sec;

tv.tv_usec = ts-&gt;tv_nsec / 1000;

if (!rb_w32_time_subtract(&amp;tv, &amp;now))

return 0;

return (tv.tv_sec * 1000) + (tv.tv_usec / 1000);

}

static int

native_cond_timedwait(rb_nativethread_cond_t *cond, rb_nativethread_lock_t *mutex, const struct timespec *ts)

{

unsigned long timeout_ms;

timeout_ms = abs_timespec_to_timeout_ms(ts);

if (!timeout_ms)

return ETIMEDOUT;

return native_cond_timedwait_ms(cond, mutex, timeout_ms);

}

static struct timespec

native_cond_timeout(rb_nativethread_cond_t *cond, struct timespec timeout_rel)

{

int ret;

struct timeval tv;

struct timespec timeout;

struct timespec now;

ret = gettimeofday(&amp;tv, 0);

if (ret != 0)

rb_sys_fail(0);

now.tv_sec = tv.tv_sec;

now.tv_nsec = tv.tv_usec * 1000;

timeout.tv_sec = now.tv_sec;

timeout.tv_nsec = now.tv_nsec;

timeout.tv_sec += timeout_rel.tv_sec;

timeout.tv_nsec += timeout_rel.tv_nsec;

if (timeout.tv_nsec &gt;= 1000*1000*1000) {

timeout.tv_sec++;

timeout.tv_nsec -= 1000*1000*1000;

}

if (timeout.tv_sec &lt; now.tv_sec)

timeout.tv_sec = TIMET_MAX;

return timeout;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_native_cond_initialize</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>cond</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>(</operator>struct <name>cond_event_entry</name> <operator>*</operator><operator>)</operator><name>cond</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cond</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator>struct <name>cond_event_entry</name> <operator>*</operator><operator>)</operator><name>cond</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_native_cond_destroy</name><parameter_list>(<parameter><decl><type><name>rb_nativethread_cond_t</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ruby_init_stack</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ERR</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{if (!(expr)) {rb_bug("err: %lu - %s", GetLastError(), #expr);}}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_thread_init_stack</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>MEMORY_BASIC_INFORMATION</name></type> <name>mi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DWORD</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>space</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK_ERR</name><argument_list>(<argument><expr><call><name>VirtualQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>AllocationBase</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>BaseAddress</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>+=</operator> <name><name>mi</name><operator>.</operator><name>RegionSize</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>base</name></expr>;</expr_stmt>

<expr_stmt><expr><name>space</name> <operator>=</operator> <name>size</name> <operator>/</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>space</name> <operator>&gt;</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_start</name></name> <operator>=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>end</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_maxsize</name></name> <operator>=</operator> <name>size</name> <operator>-</operator> <name>space</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>InterlockedExchangePointer</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>InterlockedExchangePointer</name><parameter_list>(<parameter><type><name>t</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void *)InterlockedExchange((long *)(t), (long)(v))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_thread_destroy</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>HANDLE</name></type> <name>intr</name> <init>= <expr><call><name>InterlockedExchangePointer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>interrupt_event</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"close handle - intr: %p, thid: %p\n"</literal></expr></argument>, <argument><expr><name>intr</name></expr></argument>, <argument><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>w32_close_handle</name><argument_list>(<argument><expr><name>intr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>__stdcall</name></type>

<name>thread_start_func_1</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>th_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><name>th_ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>HANDLE</name></type> <name>thread_id</name> <init>= <expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>native_thread_init_stack</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>interrupt_event</name></name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"thread created (th: %p, thid: %p, event: %p)\n"</literal></expr></argument>, <argument><expr><name>th</name></expr></argument>,

<argument><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>, <argument><expr><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>interrupt_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_start_func_2</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name><operator>-&gt;</operator><name>machine</name><operator>.</operator><name>stack_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>w32_close_handle</name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"thread deleted (th: %p)\n"</literal></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_thread_create</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>stack_size</name> <init>= <expr><name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>thread_machine_stack_size</name></name> <operator>+</operator> <name><name>th</name><operator>-&gt;</operator><name>vm</name><operator>-&gt;</operator><name>default_params</name><operator>.</operator><name>thread_vm_stack_size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name> <operator>=</operator> <call><name>w32_create_thread</name><argument_list>(<argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>thread_start_func_1</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>thread_errno</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>w32_resume_thread</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>THREAD_DEBUG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"create: (th: %p, thid: %p, intr: %p), stack size: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>th</name></expr></argument>, <argument><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>,

<argument><expr><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>interrupt_event</name></name></expr></argument>, <argument><expr><name>stack_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_thread_join</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>w32_wait_events</name><argument_list>(<argument><expr><operator>&amp;</operator><name>th</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NATIVE_THREAD_PRIORITY</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_thread_apply_priority</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>priority</name> <init>= <expr><name><name>th</name><operator>-&gt;</operator><name>priority</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>priority</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>priority</name> <operator>=</operator> <name>THREAD_PRIORITY_ABOVE_NORMAL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>priority</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>priority</name> <operator>=</operator> <name>THREAD_PRIORITY_BELOW_NORMAL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>priority</name> <operator>=</operator> <name>THREAD_PRIORITY_NORMAL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>SetThreadPriority</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>thread_id</name></name></expr></argument>, <argument><expr><name>priority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function_decl><type><name>int</name></type> <name>rb_w32_select_with_thread</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> 

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_fd_select</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>rb_fdset_t</name> <modifier>*</modifier></type><name>readfds</name></decl></parameter>, <parameter><decl><type><name>rb_fdset_t</name> <modifier>*</modifier></type><name>writefds</name></decl></parameter>, <parameter><decl><type><name>rb_fdset_t</name> <modifier>*</modifier></type><name>exceptfds</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeout</name></decl></parameter>, <parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>w</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>readfds</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_fd_resize</name><argument_list>(<argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>readfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_fd_ptr</name><argument_list>(<argument><expr><name>readfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>writefds</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_fd_resize</name><argument_list>(<argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>writefds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>rb_fd_ptr</name><argument_list>(<argument><expr><name>writefds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exceptfds</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_fd_resize</name><argument_list>(<argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>exceptfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_fd_ptr</name><argument_list>(<argument><expr><name>exceptfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_w32_select_with_thread</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_w32_check_interrupt</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>w32_wait_events</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ubf_handle</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><operator>(</operator><name>rb_thread_t</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"ubf_handle: %p\n"</literal></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SetEvent</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>native_thread_data</name><operator>.</operator><name>interrupt_event</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>w32_error</name><argument_list>(<argument><expr><literal type="string">"ubf_handle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function_decl><type><name>int</name></type> <name>rb_w32_set_thread_description</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>th</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WCHAR</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_w32_set_thread_description_str</name><parameter_list>(<parameter><decl><type><name>HANDLE</name></type> <name>th</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>native_set_another_thread_name</name></cpp:macro> <cpp:value>rb_w32_set_thread_description_str</cpp:value></cpp:define>

<struct><specifier>static</specifier> struct <block>{

<decl_stmt><decl><type><name>HANDLE</name></type> <name>id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HANDLE</name></type> <name>lock</name></decl>;</decl_stmt>

}</block> <decl><name>timer_thread</name></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMER_THREAD_CREATED_P</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(timer_thread.id != 0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>__stdcall</name></type>

<name>timer_thread_func</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dummy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"timer_thread\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_w32_set_thread_description</name><argument_list>(<argument><expr><call><name>GetCurrentThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">L"ruby-timer-thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>timer_thread</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><name>TIME_QUANTUM_USEC</name><operator>/</operator><literal type="number">1000</literal></expr></argument>)</argument_list></call> <operator>==</operator>

<name>WAIT_TIMEOUT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>timer_thread_function</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_sigchld_handler</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_threadptr_check_signal</name><argument_list>(<argument><expr><name><name>vm</name><operator>-&gt;</operator><name>main_thread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>thread_debug</name><argument_list>(<argument><expr><literal type="string">"timer killed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_thread_wakeup_timer_thread</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_thread_start_unblock_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_thread_create_timer_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>timer_thread</name><operator>.</operator><name>id</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>timer_thread</name><operator>.</operator><name>lock</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>timer_thread</name><operator>.</operator><name>lock</name></name> <operator>=</operator> <call><name>CreateEvent</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>timer_thread</name><operator>.</operator><name>id</name></name> <operator>=</operator> <call><name>w32_create_thread</name><argument_list>(<argument><expr><literal type="number">1024</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>THREAD_DEBUG</name></expr> ?</condition><then> <expr><name>BUFSIZ</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,

<argument><expr><name>timer_thread_func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>w32_resume_thread</name><argument_list>(<argument><expr><name><name>timer_thread</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>native_stop_timer_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>stopped</name> <init>= <expr><operator>--</operator><name>system_working</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>stopped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name><name>timer_thread</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>native_thread_join</name><argument_list>(<argument><expr><name><name>timer_thread</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>timer_thread</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>timer_thread</name><operator>.</operator><name>lock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>stopped</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_reset_timer_thread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>timer_thread</name><operator>.</operator><name>id</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>timer_thread</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>timer_thread</name><operator>.</operator><name>id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>ruby_stack_overflowed_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_ec_raised_p</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>, <argument><expr><name>RAISED_STACKOVERFLOW</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>LONG</name> <name>WINAPI</name></type>

<name>rb_w32_stack_overflow_handler</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>_EXCEPTION_POINTERS</name></name> <modifier>*</modifier></type><name>exception</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>exception</name><operator>-&gt;</operator><name>ExceptionRecord</name><operator>-&gt;</operator><name>ExceptionCode</name></name> <operator>==</operator> <name>EXCEPTION_STACK_OVERFLOW</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ec_raised_set</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RAISED_STACKOVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>EXCEPTION_CONTINUE_SEARCH</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_ALLOCA_CHKSTK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>

<name>ruby_alloca_chkstk</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ruby_stack_length</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_ec_raised_p</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RAISED_STACKOVERFLOW</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ec_raised_set</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RAISED_STACKOVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>sysstack_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>rb_reserved_fd_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_sigwait_fd_get</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> 

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>void rb_sigwait_fd_put(rb_thread_t *, int)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><name>void</name></type>

<name>rb_sigwait_fd_put</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"not implemented, should not be called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>void rb_sigwait_sleep(const rb_thread_t *, int, const rb_hrtime_t *)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><name>void</name></type>

<name>rb_sigwait_sleep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_hrtime_t</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"not implemented, should not be called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>rb_nativethread_id_t</name></type>

<name>rb_nativethread_self</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>GetCurrentThread</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>native_set_thread_name</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>

<block>{<block_content>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_MJIT</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>__stdcall</name></type>

<name>mjit_worker</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>worker_func</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>arg</name></expr></init>;</function_decl>

<expr_stmt><expr><call><name>rb_w32_set_thread_description</name><argument_list>(<argument><expr><call><name>GetCurrentThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">L"ruby-mjitworker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>worker_func</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_thread_create_mjit_thread</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>worker_func</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>stack_size</name> <init>= <expr><literal type="number">4</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>HANDLE</name></type> <name>thread_id</name> <init>= <expr><call><name>w32_create_thread</name><argument_list>(<argument><expr><name>stack_size</name></expr></argument>, <argument><expr><name>mjit_worker</name></expr></argument>, <argument><expr><name>worker_func</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>thread_id</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>w32_resume_thread</name><argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
