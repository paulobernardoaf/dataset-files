<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\vm_callinfo.h"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_counter.h"</cpp:file></cpp:include>

<enum>enum <name>vm_call_flag_bits</name> <block>{

<decl><name>VM_CALL_ARGS_SPLAT_bit</name></decl>, 

<decl><name>VM_CALL_ARGS_BLOCKARG_bit</name></decl>, 

<decl><name>VM_CALL_FCALL_bit</name></decl>, 

<decl><name>VM_CALL_VCALL_bit</name></decl>, 

<decl><name>VM_CALL_ARGS_SIMPLE_bit</name></decl>, 

<decl><name>VM_CALL_BLOCKISEQ_bit</name></decl>, 

<decl><name>VM_CALL_KWARG_bit</name></decl>, 

<decl><name>VM_CALL_KW_SPLAT_bit</name></decl>, 

<decl><name>VM_CALL_TAILCALL_bit</name></decl>, 

<decl><name>VM_CALL_SUPER_bit</name></decl>, 

<decl><name>VM_CALL_ZSUPER_bit</name></decl>, 

<decl><name>VM_CALL_OPT_SEND_bit</name></decl>, 

<decl><name>VM_CALL_KW_SPLAT_MUT_bit</name></decl>, 

<decl><name>VM_CALL__END</name></decl>

}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_ARGS_SPLAT</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_ARGS_SPLAT_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_ARGS_BLOCKARG</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_ARGS_BLOCKARG_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_FCALL</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_FCALL_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_VCALL</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_VCALL_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_ARGS_SIMPLE</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_ARGS_SIMPLE_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_BLOCKISEQ</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_BLOCKISEQ_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_KWARG</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_KWARG_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_KW_SPLAT</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_KW_SPLAT_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_TAILCALL</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_TAILCALL_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_SUPER</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_SUPER_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_ZSUPER</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_ZSUPER_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_OPT_SEND</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_OPT_SEND_bit)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALL_KW_SPLAT_MUT</name></cpp:macro> <cpp:value>(0x01 &lt;&lt; VM_CALL_KW_SPLAT_MUT_bit)</cpp:value></cpp:define>

<struct>struct <name>rb_callinfo_kwarg</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>keyword_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type>

<name>rb_callinfo_kwarg_bytes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>keyword_len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_size_mul_add_or_raise</name><argument_list>(

<argument><expr><name>keyword_len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_callinfo_kwarg</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><name>rb_eRuntimeError</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>rb_callinfo</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kwarg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>argc</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VALUE</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_TAG_bits</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_ARGC_bits</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_FLAG_bits</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_ID_bits</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_VALUE</name> <operator>==</operator> <literal type="number">4</literal></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_TAG_bits</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_ARGC_bits</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_FLAG_bits</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_ID_bits</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>CI_EMBED_TAG_bits</name> <operator>+</operator> <name>CI_EMBED_ARGC_bits</name> <operator>+</operator> <name>CI_EMBED_FLAG_bits</name> <operator>+</operator> <name>CI_EMBED_ID_bits</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>SIZEOF_VALUE</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator></expr></cpp:if>

<cpp:error>#<cpp:directive>error</cpp:directive></cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_FLAG</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_ARGC_SHFT</name></cpp:macro> <cpp:value>(CI_EMBED_TAG_bits)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_ARGC_MASK</name></cpp:macro> <cpp:value>((((VALUE)1)&lt;&lt;CI_EMBED_ARGC_bits) - 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_FLAG_SHFT</name></cpp:macro> <cpp:value>(CI_EMBED_TAG_bits + CI_EMBED_ARGC_bits)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_FLAG_MASK</name></cpp:macro> <cpp:value>((((VALUE)1)&lt;&lt;CI_EMBED_FLAG_bits) - 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_ID_SHFT</name></cpp:macro> <cpp:value>(CI_EMBED_TAG_bits + CI_EMBED_ARGC_bits + CI_EMBED_FLAG_bits)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CI_EMBED_ID_MASK</name></cpp:macro> <cpp:value>((((VALUE)1)&lt;&lt;CI_EMBED_ID_bits) - 1)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>

<name>vm_ci_packed_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_EMBED_CI</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x01</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>imemo_callinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>

<name>vm_ci_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_packed_p</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>imemo_callinfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ID</name></type>

<name>vm_ci_mid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_packed_p</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CI_EMBED_ID_SHFT</name><operator>)</operator> <operator>&amp;</operator> <name>CI_EMBED_ID_MASK</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><operator>(</operator><name>ID</name><operator>)</operator><name><name>ci</name><operator>-&gt;</operator><name>mid</name></name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type>

<name>vm_ci_flag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_packed_p</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CI_EMBED_FLAG_SHFT</name><operator>)</operator> <operator>&amp;</operator> <name>CI_EMBED_FLAG_MASK</name><operator>)</operator></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>ci</name><operator>-&gt;</operator><name>flag</name></name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type>

<name>vm_ci_argc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_packed_p</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>ci</name><operator>)</operator> <operator>&gt;&gt;</operator> <name>CI_EMBED_ARGC_SHFT</name><operator>)</operator> <operator>&amp;</operator> <name>CI_EMBED_ARGC_MASK</name><operator>)</operator></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>ci</name><operator>-&gt;</operator><name>argc</name></name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type>

<name>vm_ci_kwarg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_packed_p</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name><name>ci</name><operator>-&gt;</operator><name>kwarg</name></name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_ci_dump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_packed_p</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"packed_ci ID:%s flag:%x argc:%u\n"</literal></expr></argument>,

<argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rp</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vm_ci_new</name><parameter_list>(<parameter><type><name>mid</name></type></parameter>, <parameter><type><name>flag</name></type></parameter>, <parameter><type><name>argc</name></type></parameter>, <parameter><type><name>kwarg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vm_ci_new_(mid, flag, argc, kwarg, __FILE__, __LINE__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vm_ci_new_runtime</name><parameter_list>(<parameter><type><name>mid</name></type></parameter>, <parameter><type><name>flag</name></type></parameter>, <parameter><type><name>argc</name></type></parameter>, <parameter><type><name>kwarg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vm_ci_new_runtime_(mid, flag, argc, kwarg, __FILE__, __LINE__)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type>

<name>vm_ci_new_</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kwarg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_EMBED_CI</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mid</name> <operator>&amp;</operator> <operator>~</operator><name>CI_EMBED_ID_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<operator>(</operator><name>argc</name> <operator>&amp;</operator> <operator>~</operator><name>CI_EMBED_ARGC_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<name>kwarg</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>embed_ci</name> <init>=

<expr><literal type="number">1L</literal> <operator>|</operator>

<operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>argc</name> <operator>&lt;&lt;</operator> <name>CI_EMBED_ARGC_SHFT</name><operator>)</operator> <operator>|</operator>

<operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>flag</name> <operator>&lt;&lt;</operator> <name>CI_EMBED_FLAG_SHFT</name><operator>)</operator> <operator>|</operator>

<operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>mid</name> <operator>&lt;&lt;</operator> <name>CI_EMBED_ID_SHFT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ci_packed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><specifier>const</specifier> struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><name>embed_ci</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>debug</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s:%d "</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator>

<call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>imemo_callinfo</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>mid</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>flag</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>argc</name></expr></argument>,

<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>kwarg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rp</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>kwarg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ci_kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ci_nokw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ci</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type>

<name>vm_ci_new_runtime_</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kwarg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ci_runtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vm_ci_new_</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>kwarg</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>vm_call_handler</name>)<parameter_list>(

<parameter><decl><type><name><name>struct</name> <name>rb_execution_context_struct</name></name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_control_frame_struct</name></name> <modifier>*</modifier></type><name>cfp</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_calling_info</name></name> <modifier>*</modifier></type><name>calling</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>rb_callcache</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callable_method_entry_struct</name></name> <modifier>*</modifier> <specifier>const</specifier></type> <name>cme_</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>vm_call_handler</name></type> <name>call_</name></decl>;</decl_stmt>

<union>union <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>attr_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>method_missing_reason</name></name></type> <name>method_missing_reason</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

}</block> <decl><name>aux_</name></decl>;</union>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VM_CALLCACHE_UNMARKABLE</name></cpp:macro> <cpp:value>IMEMO_FL_USER0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type>

<name>vm_cc_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callable_method_entry_struct</name></name> <modifier>*</modifier></type><name>cme</name></decl></parameter>,

<parameter><decl><type><name>vm_call_handler</name></type> <name>call</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>rb_callcache</name> <operator>*</operator><operator>)</operator><call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>imemo_callcache</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cme</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>call</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>cc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type>

<name>vm_cc_fill</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callable_method_entry_struct</name></name> <modifier>*</modifier></type><name>cme</name></decl></parameter>,

<parameter><decl><type><name>vm_call_handler</name></type> <name>call</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_callcache</name></name></type> <name>cc_body</name> <init>= <expr><block>{

<expr><operator>.</operator><name>flags</name> <operator>=</operator> <name>T_IMEMO</name> <operator>|</operator> <operator>(</operator><name>imemo_callcache</name> <operator>&lt;&lt;</operator> <name>FL_USHIFT</name><operator>)</operator> <operator>|</operator> <name>VM_CALLCACHE_UNMARKABLE</name></expr>,

<expr><operator>.</operator><name>klass</name> <operator>=</operator> <name>klass</name></expr>,

<expr><operator>.</operator><name>cme_</name> <operator>=</operator> <name>cme</name></expr>,

<expr><operator>.</operator><name>call_</name> <operator>=</operator> <name>call</name></expr>,

<expr><operator>.</operator><name><name>aux_</name><operator>.</operator><name>v</name></name> <operator>=</operator> <literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc_body</name></expr></argument>, <argument><expr>struct <name>rb_callcache</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>cc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>

<name>vm_cc_class_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>

<call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <name>klass</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callable_method_entry_struct</name></name> <modifier>*</modifier></type>

<name>vm_cc_cme</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>cc</name><operator>-&gt;</operator><name>cme_</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>vm_call_handler</name></type>

<name>vm_cc_call</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>cc</name><operator>-&gt;</operator><name>call_</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type>

<name>vm_cc_attr_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>cc</name><operator>-&gt;</operator><name>aux_</name><operator>.</operator><name>attr_index</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type>

<name>vm_cc_cmethod_missing_reason</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>cc</name><operator>-&gt;</operator><name>aux_</name><operator>.</operator><name>method_missing_reason</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>vm_cc_markable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>VM_CALLCACHE_UNMARKABLE</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>

<name>vm_cc_valid_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cc_cme</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <name>klass</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><name>cc_cme</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>vm_empty_cc</name></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>rb_vm_empty_cc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type>

<name>vm_cc_empty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MJIT_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>vm_empty_cc</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>rb_vm_empty_cc</name><argument_list>()</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_cc_cme_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callable_method_entry_struct</name></name> <modifier>*</modifier></type><name>cme</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_cc_cme</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>called_id</name> <operator>==</operator> <name><name>cme</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>vm_cc_markable</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>rb_callable_method_entry_struct</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>cme_</name></name><operator>)</operator> <operator>=</operator> <name>cme</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_cc_call_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>vm_call_handler</name></type> <name>call</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>vm_call_handler</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>call_</name></name> <operator>=</operator> <name>call</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_cc_attr_index_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>aux_</name><operator>.</operator><name>attr_index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_cc_method_missing_reason_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>method_missing_reason</name></name></type> <name>reason</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator>enum <name>method_missing_reason</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>aux_</name><operator>.</operator><name>method_missing_reason</name></name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_cc_invalidate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>imemo_callcache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cc</name> <operator>!=</operator> <call><name>vm_cc_empty</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>klass</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_ent_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>rb_call_data</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>rb_class_cc_entries</name> <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>debug_sig</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>capa</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callable_method_entry_struct</name></name> <modifier>*</modifier></type><name>cme</name></decl>;</decl_stmt>

<struct>struct <name>rb_class_cc_entries_entry</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>

}</block> <decl><modifier>*</modifier><name>entries</name></decl>;</struct>

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>

<name>vm_ccs_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>ccs</name><operator>-&gt;</operator><name>debug_sig</name></name> <operator>==</operator> <operator>~</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>ccs</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>void</name></type> <name>rb_vm_ccs_free</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl></parameter>)</parameter_list>;</function_decl>

</unit>
