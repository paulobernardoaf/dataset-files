<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\file.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"missing/file.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/cygwin.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__has_feature</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__has_attribute</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>API_AVAILABLE</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>API_DEPRECATED</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;CoreFoundation/CFString.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_FILE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function_decl><type><name>int</name></type> <name>flock</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_PARAM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATHLEN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_SYS_UTIME_H</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/utime.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PWD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_SYSMACROS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysmacros.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_MKDEV_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mkdev.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>HAVE_LSTAT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>lstat</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lstat</name></cpp:macro> <cpp:value>stat</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32/file.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_ustati128((p), (s))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>lstat</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lstat</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_ulstati128((p), (s))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>access</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>access</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_uaccess((p), (m))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>truncate</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>truncate</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_utruncate((p), (n))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>chmod</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chmod</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_uchmod((p), (m))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>chown</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chown</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>o</name></type></parameter>, <parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_uchown((p), (o), (g))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>lchown</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lchown</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>o</name></type></parameter>, <parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_ulchown((p), (o), (g))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>utimensat</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>utimensat</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>t</name></type></parameter>, <parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_uutimensat((s), (p), (t), (f))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>link</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>link</name><parameter_list>(<parameter><type><name>f</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_ulink((f), (t))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>unlink</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlink</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_uunlink(p)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rename</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rename</name><parameter_list>(<parameter><type><name>f</name></type></parameter>, <parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_urename((f), (t))</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>symlink</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>symlink</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_usymlink((s), (l))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_REALPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_REALPATH</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>stat((p), (s))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>||</operator> <name>defined</name> <name>__APPLE__</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_OSPATH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TO_OSPATH</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_str_encode_ospath(str)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_OSPATH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TO_OSPATH</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(str)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name> <operator>||</operator> <name>defined</name> <name>__CYGWIN__</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTIME_EINVAL</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_REALPATH</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>__sun</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>__SVR4</name></expr></cpp:if>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_REALPATH</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_REALPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dln.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"encindex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compilers.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/dir.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/file.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/load.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/process.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/vm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cFile</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_mFileTest</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cStat</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>file_path_convert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>fname_encidx</name> <init>= <expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fs_encidx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ENCINDEX_US_ASCII</name> <operator>!=</operator> <name>fname_encidx</name> <operator>&amp;&amp;</operator>

<name>ENCINDEX_ASCII</name> <operator>!=</operator> <name>fname_encidx</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name>fs_encidx</name> <operator>=</operator> <call><name>rb_filesystem_encindex</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>fname_encidx</name> <operator>&amp;&amp;</operator>

<call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>rb_enc_str_asciionly_p</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fname_encoding</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>fname_encidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fs_encoding</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>fs_encidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fname_encoding</name></expr></argument>, <argument><expr><name>fs_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>

<name>check_path_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncCompatError</name></expr></argument>, <argument><expr><literal type="string">"path name must be ASCII-compatible (%s): %"</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_str_inspect</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>enc</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_get_path_check_to_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>to_path</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><literal type="string">"to_path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_funcall_default</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>tmp</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_get_path_check_convert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>file_path_convert</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_path_encoding</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_str_to_cstr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"path name contains null byte"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_str_new4</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_get_path_no_checksafe</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_get_path</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_get_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_get_path_check_convert</name><argument_list>(<argument><expr><call><name>rb_get_path_check_to_string</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_encode_ospath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_OSPATH</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name> <init>= <expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>defined</name> <name>_WIN32</name></expr></cpp:if>

if (encidx == ENCINDEX_ASCII) {

encidx = rb_filesystem_encindex();

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>!=</operator> <name>ENCINDEX_ASCII</name> <operator>&amp;&amp;</operator> <name>encidx</name> <operator>!=</operator> <name>ENCINDEX_UTF_8</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>utf8</name> <init>= <expr><call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>path</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORMALIZE_UTF8PATH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_str_append_normalized_ospath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>CFIndex</name></type> <name>buflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CFRange</name></type> <name>all</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CFStringRef</name></type> <name>s</name> <init>= <expr><call><name>CFStringCreateWithBytesNoCopy</name><argument_list>(<argument><expr><name>kCFAllocatorDefault</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>UInt8</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,

<argument><expr><name>kCFStringEncodingUTF8</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,

<argument><expr><name>kCFAllocatorNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CFMutableStringRef</name></type> <name>m</name> <init>= <expr><call><name>CFStringCreateMutableCopy</name><argument_list>(<argument><expr><name>kCFAllocatorDefault</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>oldlen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CFStringNormalize</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>kCFStringNormalizationFormC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>all</name> <operator>=</operator> <call><name>CFRangeMake</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>CFStringGetLength</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CFStringGetBytes</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>all</name></expr></argument>, <argument><expr><name>kCFStringEncodingUTF8</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_modify_expand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CFStringGetBytes</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>all</name></expr></argument>, <argument><expr><name>kCFStringEncodingUTF8</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,

<argument><expr><operator>(</operator><name>UInt8</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>oldlen</name><operator>)</operator></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>oldlen</name> <operator>+</operator> <name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CFRelease</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CFRelease</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_str_normalize_ospath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_buf_new</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>invalid</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><literal type="string">"\xEF\xBF\xBD"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_append_normalized_ospath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>invalid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>invalid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0x2000</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0x2FFF</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><literal type="number">0xF900</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xFAFF</literal><operator>)</operator> <operator>||</operator>

<operator>(</operator><literal type="number">0x2F800</literal> <operator>&lt;=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0x2FAFF</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>p1</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_append_normalized_ospath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>p1</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_append_normalized_ospath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ignored_char_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name><operator>+</operator><literal type="number">3</literal> <operator>&gt;</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0xe2</literal></expr>:</case>

<switch>switch <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0x80</literal></expr>:</case>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x8c</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0x8f</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0xaa</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xae</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><literal type="number">0x81</literal></expr>:</case>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0xaa</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xaf</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="number">0xef</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xbb</literal> <operator>&amp;&amp;</operator>

<operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xbf</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORMALIZE_UTF8PATH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>apply2args</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(rb_check_arity(argc, n, UNLIMITED_ARGUMENTS), argc-=n)</cpp:value></cpp:define>

<struct>struct <name>apply_filename</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>apply_arg</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>errnum</name></decl>;</decl_stmt>

<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>apply_filename</name></name></type> <name><name>fn</name><index>[<expr><name>FLEX_ARY_LEN</name></expr>]</index></name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>no_gvl_apply2files</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>apply_arg</name></name> <modifier>*</modifier></type><name>aa</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name> <operator>&lt;</operator> <name><name>aa</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name><name>aa</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>fn</name><index>[<expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>.</operator><name>ptr</name></expr></argument>, <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>aa</name><operator>-&gt;</operator><name>errnum</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UTIME_EINVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>NORETURN</name><argument_list>(<argument>static void utime_failed(struct apply_arg *)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>utime_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>apply2files</name><parameter_list>(<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>apply_filename</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>apply_arg</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>size</name> <operator>*</operator> <name>argc</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>apply_arg</name></name> <modifier>*</modifier></type><name>aa</name> <init>= <expr><call><name>ALLOCV</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>aa</name><operator>-&gt;</operator><name>errnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aa</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aa</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aa</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_get_path</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aa</name><operator>-&gt;</operator><name>fn</name><index>[<expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>.</operator><name>ptr</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aa</name><operator>-&gt;</operator><name>fn</name><index>[<expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>.</operator><name>path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>no_gvl_apply2files</name></expr></argument>, <argument><expr><name>aa</name></expr></argument>, <argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>errnum</name></name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UTIME_EINVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>utime_internal</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>utime_failed</name><argument_list>(<argument><expr><name>aa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>errnum</name></name></expr></argument>, <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>fn</name><index>[<expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>.</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fptr</name> <operator>=</operator> <call><name>RFILE</name><argument_list>(<argument><expr><call><name>rb_io_taint_check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>fptr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_io_check_initialized</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><literal type="string">"File is unnamed (TMPFILE?)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>stat_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>stat</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>stat_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"stat"</literal></expr>,

<expr><block>{<expr><name>NULL</name></expr>, <expr><name>RUBY_TYPED_DEFAULT_FREE</name></expr>, <expr><name>stat_memsize</name></expr>,}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>stat_new_0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>nst</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_data_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>st</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nst</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>nst</name> <operator>=</operator> <operator>*</operator><name>st</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RTYPEDDATA_DATA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>nst</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_stat_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>stat_new_0</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>stat</name></name><modifier>*</modifier></type>

<name>get_stat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name><modifier>*</modifier></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>stat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_data_type</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>st</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized File::Stat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>st</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>timespec</name></name></type> <name>stat_mtimespec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts1</name> <init>= <expr><call><name>stat_mtimespec</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts2</name> <init>= <expr><call><name>stat_mtimespec</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ts1</name><operator>.</operator><name>tv_sec</name></name> <operator>==</operator> <name><name>ts2</name><operator>.</operator><name>tv_sec</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ts1</name><operator>.</operator><name>tv_nsec</name></name> <operator>==</operator> <name><name>ts2</name><operator>.</operator><name>tv_nsec</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ts1</name><operator>.</operator><name>tv_nsec</name></name> <operator>&lt;</operator> <name><name>ts2</name><operator>.</operator><name>tv_nsec</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ts1</name><operator>.</operator><name>tv_sec</name></name> <operator>&lt;</operator> <name><name>ts2</name><operator>.</operator><name>tv_sec</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST2UINT</name><parameter_list>(<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((val) &amp; ~(~1UL &lt;&lt; (sizeof(val) * CHAR_BIT - 1)))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NUM2DEVT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2DEVT</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2UINT(v)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>DEVT2NUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEVT2NUM</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>UINT2NUM(v)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PRI_DEVT_PREFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRI_DEVT_PREFIX</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_dev</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>DEVT2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_dev</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_dev_major</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>major</name></expr></argument>)</argument_list></call></expr></cpp:if>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><call><name>major</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_dev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qnil</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_dev_minor</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr></cpp:if>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><call><name>minor</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_dev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qnil</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_ino</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_INOHIGH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>rb_integer_unpack</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_ino</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,

<argument><expr><name>SIZEOF_STRUCT_STAT_ST_INO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>INTEGER_PACK_LSWORD_FIRST</name><operator>|</operator><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name><operator>|</operator>

<name>INTEGER_PACK_2COMP</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_STRUCT_STAT_ST_INO</name> <operator>&gt;</operator> <name>SIZEOF_LONG</name></expr></cpp:elif>

<return>return <expr><call><name>ULL2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_ino</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>ULONG2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_ino</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_mode</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><call><name>ST2UINT</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_nlink</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_nlink</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_uid</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>UIDT2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_uid</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_gid</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>GIDT2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_gid</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_rdev</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_RDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>DEVT2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_rdev</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qnil</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_rdev_major</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_RDEV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>major</name></expr></argument>)</argument_list></call></expr></cpp:if>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><call><name>major</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_rdev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qnil</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_rdev_minor</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_RDEV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr></cpp:if>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><call><name>minor</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_rdev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qnil</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>OFFT2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_blksize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BLKSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>ULONG2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_blksize</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qnil</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_blocks</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BLOCKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_STRUCT_STAT_ST_BLOCKS</name> <operator>&gt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>

<return>return <expr><call><name>ULL2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_blocks</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>ULONG2NUM</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_blocks</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qnil</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>timespec</name></name></type>

<name>stat_atimespec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_atime</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_ATIM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_atim</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_ATIMESPEC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_atimespec</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_ATIMENSEC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>st</name><operator>-&gt;</operator><name>st_atimensec</name></name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>ts</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>stat_atime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name> <init>= <expr><call><name>stat_atimespec</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_time_nano_new</name><argument_list>(<argument><expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>timespec</name></name></type>

<name>stat_mtimespec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_mtime</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_MTIM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_mtim</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_MTIMESPEC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_mtimespec</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_MTIMENSEC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>st</name><operator>-&gt;</operator><name>st_mtimensec</name></name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>ts</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>stat_mtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name> <init>= <expr><call><name>stat_mtimespec</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_time_nano_new</name><argument_list>(<argument><expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>timespec</name></name></type>

<name>stat_ctimespec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_ctime</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_CTIM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_ctim</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_CTIMESPEC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>st_ctimespec</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_CTIMENSEC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>st</name><operator>-&gt;</operator><name>st_ctimensec</name></name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>ts</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>stat_ctime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name> <init>= <expr><call><name>stat_ctimespec</name><argument_list>(<argument><expr><name>st</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_time_nano_new</name><argument_list>(<argument><expr><name><name>ts</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_STAT_BIRTHTIME</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<typedef>typedef <type><name><name>struct</name> <name>stat</name></name></type> <name>statx_data</name>;</typedef>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>stat_birthtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>ts</name> <init>= <expr><operator>&amp;</operator><name><name>st</name><operator>-&gt;</operator><name>st_birthtimespec</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_time_nano_new</name><argument_list>(<argument><expr><name><name>ts</name><operator>-&gt;</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><name><name>ts</name><operator>-&gt;</operator><name>tv_nsec</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<typedef>typedef <type><name><name>struct</name> <name>stat</name></name></type> <name>statx_data</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stat_birthtime</name></cpp:macro> <cpp:value>stat_ctime</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_STAT_BIRTHTIME</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_atime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>stat_atime</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_mtime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>stat_mtime</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_ctime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>stat_ctime</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_BIRTHTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_birthtime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>stat_birthtime</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_stat_birthtime</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>

}</block> <decl><name><name>member</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{<expr><literal type="string">"dev"</literal></expr>, <expr><name>rb_stat_dev</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"ino"</literal></expr>, <expr><name>rb_stat_ino</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"mode"</literal></expr>, <expr><name>rb_stat_mode</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"nlink"</literal></expr>, <expr><name>rb_stat_nlink</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"uid"</literal></expr>, <expr><name>rb_stat_uid</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"gid"</literal></expr>, <expr><name>rb_stat_gid</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"rdev"</literal></expr>, <expr><name>rb_stat_rdev</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"size"</literal></expr>, <expr><name>rb_stat_size</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"blksize"</literal></expr>, <expr><name>rb_stat_blksize</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"blocks"</literal></expr>, <expr><name>rb_stat_blocks</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"atime"</literal></expr>, <expr><name>rb_stat_atime</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"mtime"</literal></expr>, <expr><name>rb_stat_mtime</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"ctime"</literal></expr>, <expr><name>rb_stat_ctime</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr><block>{<expr><literal type="string">"birthtime"</literal></expr>, <expr><name>rb_stat_birthtime</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></expr></init></decl>;</struct>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name><modifier>*</modifier></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>stat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_data_type</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>st</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%s: uninitialized&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_buf_new2</name><argument_list>(<argument><expr><literal type="string">"#&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>member</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>member</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>member</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>member</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>func</name><operator>)</operator><operator>(</operator><name>self</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"0%lo"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><call><name>NUM2ULONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"0x%"</literal><name>PRI_DEVT_PREFIX</name><literal type="string">"x"</literal></expr></argument>, <argument><expr><call><name>NUM2DEVT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>no_gvl_stat_data</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl>;</decl_stmt>

<union>union <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

}</block> <decl><name>file</name></decl>;</union>

}</block></struct></type> <name>no_gvl_stat_data</name>;</typedef>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>no_gvl_fstat</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>no_gvl_stat_data</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>fstat</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>st</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fstat_without_gvl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>no_gvl_stat_data</name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>file</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>st</name></name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_io_blocking_region</name><argument_list>(<argument><expr><name>no_gvl_fstat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>no_gvl_stat</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type> <name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>no_gvl_stat_data</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>STAT</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>st</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>stat_without_gvl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>no_gvl_stat_data</name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>file</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>st</name></name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>no_gvl_stat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STATX_STX_BTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STATX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCALL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syscall.h&gt;</cpp:file></cpp:include>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_SYS_SYSCALL_H</name></expr></cpp:elif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/syscall.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__linux__</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/stat.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>statx</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dirfd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>statx</name></name> <modifier>*</modifier></type><name>statxbuf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>syscall</name><argument_list>(<argument><expr><name>__NR_statx</name></expr></argument>, <argument><expr><name>dirfd</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>statxbuf</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>no_gvl_statx_data</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>statx</name></name> <modifier>*</modifier></type><name>stx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl>;</decl_stmt>

}</block></struct></type> <name>no_gvl_statx_data</name>;</typedef>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>io_blocking_statx</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>no_gvl_statx_data</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>statx</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>mask</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>stx</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>no_gvl_statx</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>io_blocking_statx</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>statx_without_gvl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>statx</name></name> <modifier>*</modifier></type><name>stx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>no_gvl_statx_data</name></type> <name>data</name> <init>= <expr><block>{<expr><name>stx</name></expr>, <expr><name>AT_FDCWD</name></expr>, <expr><name>path</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>mask</name></expr>}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>no_gvl_statx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fstatx_without_gvl</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>statx</name></name> <modifier>*</modifier></type><name>stx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>no_gvl_statx_data</name></type> <name>data</name> <init>= <expr><block>{<expr><name>stx</name></expr>, <expr><name>fd</name></expr>, <expr><literal type="string">""</literal></expr>, <expr><name>AT_EMPTY_PATH</name></expr>, <expr><name>mask</name></expr>}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rb_thread_io_blocking_region</name><argument_list>(<argument><expr><name>io_blocking_statx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_statx</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>statx</name></name> <modifier>*</modifier></type><name>stx</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_convert_type_with_id</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>T_FILE</name></expr></argument>, <argument><expr><literal type="string">"IO"</literal></expr></argument>, <argument><expr><name>idTo_io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>fstatx_without_gvl</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>stx</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>statx_without_gvl</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stx</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>statx_has_birthtime</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((st)-&gt;stx_mask &amp; STATX_BTIME)</cpp:value></cpp:define>

<macro><name>NORETURN</name><argument_list>(<argument>static void statx_notimplement(const char *field_name)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>statx_notimplement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>field_name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eNotImpError</name></expr></argument>,

<argument><expr><literal type="string">"%s is unimplemented on this filesystem"</literal></expr></argument>,

<argument><expr><name>field_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>statx_birthtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>statx</name></name> <modifier>*</modifier></type><name>stx</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>statx_has_birthtime</name><argument_list>(<argument><expr><name>stx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>statx_notimplement</name><argument_list>(<argument><expr><literal type="string">"birthtime"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_time_nano_new</name><argument_list>(<argument><expr><name><name>stx</name><operator>-&gt;</operator><name>stx_btime</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><name><name>stx</name><operator>-&gt;</operator><name>stx_btime</name><operator>.</operator><name>tv_nsec</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>statx</name></name></type> <name>statx_data</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_STAT_BIRTHTIME</name></cpp:macro></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_BIRTHTIME</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>statx_without_gvl</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>st</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>stat_without_gvl(path, st)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fstatx_without_gvl</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>, <parameter><type><name>st</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fstat_without_gvl(fd, st)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>statx_birthtime</name><parameter_list>(<parameter><type><name>st</name></type></parameter>, <parameter><type><name>fname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>stat_birthtime(st)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>statx_has_birthtime</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_statx</name><parameter_list>(<parameter><type><name>file</name></type></parameter>, <parameter><type><name>st</name></type></parameter>, <parameter><type><name>mask</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_stat(file, st)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>statx_has_birthtime</name><parameter_list>(<parameter><type><name>st</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_stat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_convert_type_with_id</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>T_FILE</name></expr></argument>, <argument><expr><literal type="string">"IO"</literal></expr></argument>, <argument><expr><name>idTo_io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>fstat_without_gvl</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>stat_without_gvl</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_stat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat_without_gvl</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_stat_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_io_stat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_stat_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>no_gvl_lstat</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>no_gvl_stat_data</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>lstat</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>file</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>st</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>lstat_without_gvl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>no_gvl_stat_data</name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>file</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>st</name></name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>no_gvl_lstat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_lstat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lstat_without_gvl</name><argument_list>(<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_stat_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>rb_file_s_stat</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_lstat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lstat_without_gvl</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_stat_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>rb_io_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_group_member</name><parameter_list>(<parameter><decl><type><name>GETGROUPS_T</name></type> <name>gid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETGROUPS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<return>return <expr><name>FALSE</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>groups</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>GETGROUPS_T</name> <modifier>*</modifier></type><name>gary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>anum</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getgid</name><argument_list>()</argument_list></call> <operator>==</operator> <name>gid</name> <operator>||</operator> <call><name>getegid</name><argument_list>()</argument_list></call> <operator>==</operator> <name>gid</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>groups</name> <operator>&lt;=</operator> <name>RB_MAX_GROUPS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gary</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>GETGROUPS_T</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>anum</name> <operator>=</operator> <call><name>getgroups</name><argument_list>(<argument><expr><name>groups</name></expr></argument>, <argument><expr><name>gary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>anum</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>anum</name> <operator>!=</operator> <name>groups</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>groups</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>anum</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>--</operator><name>anum</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>gary</name><index>[<expr><name>anum</name></expr>]</index></name> <operator>==</operator> <name>gid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>v</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>rv</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_IXUGO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IXUGO</name></cpp:macro> <cpp:value>(S_IXUSR | S_IXGRP | S_IXOTH)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IXGRP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_GETEUID</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type>

<name>eaccess</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_uid_t</name></type> <name>euid</name></decl>;</decl_stmt>

<expr_stmt><expr><name>euid</name> <operator>=</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getuid</name><argument_list>()</argument_list></call> <operator>==</operator> <name>euid</name> <operator>&amp;&amp;</operator> <call><name>getgid</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>getegid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STAT</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>euid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <name>X_OK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXUGO</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_uid</name></name> <operator>==</operator> <name>euid</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>mode</name> <operator>&lt;&lt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_group_member</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_gid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>mode</name> <operator>&lt;&lt;=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>mode</name><operator>)</operator> <operator>==</operator> <name>mode</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>access_arg</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_eaccess</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>access_arg</name></name> <modifier>*</modifier></type><name>aa</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>eaccess</name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_eaccess</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>access_arg</name></name></type> <name>aa</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aa</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aa</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_eaccess</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aa</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_access</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>access_arg</name></name> <modifier>*</modifier></type><name>aa</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>access</name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_access</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>access_arg</name></name></type> <name>aa</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aa</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aa</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_access</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aa</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_file_directory_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISDIR</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFDIR)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_pipe_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IFIFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISFIFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISFIFO</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFIFO)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISFIFO</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_symlink_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISLNK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_S_ISLNK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISLNK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_S_ISLNK(m)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_S_IFLNK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISLNK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == _S_IFLNK)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IFLNK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISLNK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFLNK)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISLNK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lstat_without_gvl</name><argument_list>(<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_socket_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_S_ISSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISSOCK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_S_ISSOCK(m)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_S_IFSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISSOCK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == _S_IFSOCK)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IFSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISSOCK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFSOCK)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISSOCK</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_blockdev_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISBLK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IFBLK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISBLK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFBLK)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISBLK</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISBLK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISBLK</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_chardev_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISCHR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISCHR</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFCHR)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISCHR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_exist_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_exists_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><literal type="string">"FileTest#"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>rb_mFileTest</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <literal type="string">"FileTest."</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>obj</name> <operator>==</operator> <name>rb_cFile</name> <operator>||</operator>

<operator>(</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_class_inherited_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>rb_cFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <literal type="string">"File."</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"%sexists? is a deprecated name, use %sexist? instead"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_file_exist_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_readable_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_eaccess</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_readable_real_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_access</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_IRUGO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IRUGO</name></cpp:macro> <cpp:value>(S_IRUSR | S_IRGRP | S_IROTH)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_IWUGO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IWUGO</name></cpp:macro> <cpp:value>(S_IWUSR | S_IWGRP | S_IWOTH)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_world_readable_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IROTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IROTH</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>S_IROTH</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRUGO</name><operator>|</operator><name>S_IWUGO</name><operator>|</operator><name>S_IXUGO</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_writable_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_eaccess</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>W_OK</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_writable_real_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_access</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>W_OK</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_world_writable_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IWOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IWOTH</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>S_IWOTH</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRUGO</name><operator>|</operator><name>S_IWUGO</name><operator>|</operator><name>S_IXUGO</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_executable_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_eaccess</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>X_OK</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_executable_real_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_access</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>X_OK</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISREG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISREG</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFREG)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_file_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_zero_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_size_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>OFFT2NUM</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_owned_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_uid</name></name> <operator>==</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_rowned_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_uid</name></name> <operator>==</operator> <call><name>getuid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_grpowned_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_group_member</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_gid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISUID</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>S_ISGID</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>S_ISVTX</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>check3rdbyte</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>mode</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_suid_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>check3rdbyte</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>S_ISUID</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qfalse</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_sgid_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>check3rdbyte</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>S_ISGID</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qfalse</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_sticky_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISVTX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>check3rdbyte</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>S_ISVTX</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>Qnil</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_identical_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st1</name></decl>, <decl><type ref="prev"/><name>st2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st1</name><operator>.</operator><name>st_dev</name></name> <operator>!=</operator> <name><name>st2</name><operator>.</operator><name>st_dev</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>st1</name><operator>.</operator><name>st_ino</name></name> <operator>!=</operator> <name><name>st2</name><operator>.</operator><name>st_ino</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>extern</specifier> <name>VALUE</name></type> <name>rb_w32_file_identical_p</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<return>return <expr><call><name>rb_w32_file_identical_p</name><argument_list>(<argument><expr><name>fname1</name></expr></argument>, <argument><expr><name>fname2</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>OFFT2NUM</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_ftype</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="string">"file"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="string">"directory"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>S_ISCHR</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="string">"characterSpecial"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISBLK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><call><name>S_ISBLK</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="string">"blockSpecial"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISFIFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><call><name>S_ISFIFO</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="string">"fifo"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISLNK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="string">"link"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><call><name>S_ISSOCK</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="string">"socket"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<else>else <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="string">"unknown"</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>rb_usascii_str_new2</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_ftype</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lstat_without_gvl</name><argument_list>(<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_file_ftype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_atime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>stat_atime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_atime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>stat_atime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_mtime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>stat_mtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_mtime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>stat_mtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_ctime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>stat_ctime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_ctime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>stat_ctime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_BIRTHTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>RUBY_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_file_s_birthtime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>statx_data</name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_statx</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>STATX_BTIME</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>statx_birthtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_s_birthtime</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT_BIRTHTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_birthtime</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>statx_data</name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstatx_without_gvl</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name>STATX_BTIME</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>statx_birthtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_birthtime</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_WRITABLE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_io_flush_raw</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>OFFT2NUM</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>chmod_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>mode_t</name> <operator>*</operator><operator>)</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_chmod</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>apply2args</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>NUM2MODET</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>apply2files</name><argument_list>(<argument><expr><name>chmod_internal</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_chmod</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>vmode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>HAVE_FCHMOD</name> <operator>||</operator> <operator>!</operator><name>HAVE_FCHMOD</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>NUM2MODET</name><argument_list>(<argument><expr><name>vmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHMOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>fchmod</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>HAVE_FCHMOD</name> <operator>||</operator> <name>errno</name> <operator>!=</operator> <name>ENOSYS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HAVE_FCHMOD</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>HAVE_FCHMOD</name> <operator>||</operator> <operator>!</operator><name>HAVE_FCHMOD</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LCHMOD</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>lchmod_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>lchmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>mode_t</name> <operator>*</operator><operator>)</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_lchmod</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>apply2args</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>NUM2MODET</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>apply2files</name><argument_list>(<argument><expr><name>lchmod_internal</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_s_lchmod</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_uid_t</name></type>

<name>to_uid</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>u</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_uid_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>NUM2UIDT</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_gid_t</name></type>

<name>to_gid</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>g</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_gid_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>NUM2GIDT</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>chown_args</name> <block>{

<decl_stmt><decl><type><name>rb_uid_t</name></type> <name>owner</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_gid_t</name></type> <name>group</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>chown_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>chown_args</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>chown</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_chown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>chown_args</name></name></type> <name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>apply2args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <call><name>to_uid</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>group</name></name> <operator>=</operator> <call><name>to_gid</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>apply2files</name><argument_list>(<argument><expr><name>chown_internal</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_chown</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>group</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_uid_t</name></type> <name>o</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_gid_t</name></type> <name>g</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>to_uid</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>g</name> <operator>=</operator> <call><name>to_gid</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>chown</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><call><name>fchown</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LCHOWN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>lchown_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>chown_args</name></name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>lchown</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_lchown</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>chown_args</name></name></type> <name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>apply2args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <call><name>to_uid</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>group</name></name> <operator>=</operator> <call><name>to_gid</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>apply2files</name><argument_list>(<argument><expr><name>lchown_internal</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_s_lchown</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>utime_args</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timespec</name></name><modifier>*</modifier></type> <name>tsp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>atime</name></decl>, <decl><type ref="prev"/><name>mtime</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>follow</name></decl>;</decl_stmt> 

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UTIME_EINVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>NORETURN</name><argument_list>(<argument>static void utime_failed(struct apply_arg *)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>utime_failed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>apply_arg</name></name> <modifier>*</modifier></type><name>aa</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name><name>aa</name><operator>-&gt;</operator><name>errnum</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><name><name>aa</name><operator>-&gt;</operator><name>fn</name><index>[<expr><name><name>aa</name><operator>-&gt;</operator><name>i</name></name></expr>]</index></name><operator>.</operator><name>path</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>utime_args</name></name> <modifier>*</modifier></type><name>ua</name> <init>= <expr><name><name>aa</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ua</name><operator>-&gt;</operator><name>tsp</name></name> <operator>&amp;&amp;</operator> <name>e</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>a</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>m</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>atime</name> <init>= <expr><name><name>ua</name><operator>-&gt;</operator><name>atime</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mtime</name> <init>= <expr><name><name>ua</name><operator>-&gt;</operator><name>mtime</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>atime</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><name>atime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>mtime</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>mtime</name> <operator>!=</operator> <name>atime</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>rb_equal</name><argument_list>(<argument><expr><name>atime</name></expr></argument>, <argument><expr><name>mtime</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><name>mtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>rb_str_cmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_str_plus</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><literal type="string">" or "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>path</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>d</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">" for "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>rb_eSystemCallError</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIMES</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>utime_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>utime_args</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>tsp</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>tsp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name><name>tvbuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tvp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIMENSAT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>try_utimensat</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AT_SYMLINK_NOFOLLOW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>try_utimensat_follow</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>try_utimensat_follow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name><name>v</name><operator>-&gt;</operator><name>follow</name></name></expr> ?</condition><then> <expr><name>try_utimensat_follow</name></expr> </then><else>: <expr><name>try_utimensat</name></expr></else></ternary></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AT_SYMLINK_NOFOLLOW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>follow</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>AT_SYMLINK_NOFOLLOW</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>utimensat</name><argument_list>(<argument><expr><name>AT_FDCWD</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>tsp</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOSYS</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AT_SYMLINK_NOFOLLOW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>try_utimensat_follow</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>follow</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>try_utimensat</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>no_utimensat</name>;</goto>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> 

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<label><name>no_utimensat</name>:</label>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>tsp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tvbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name><name>tsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tvbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>tsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_nsec</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tvbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name><name>tsp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tvbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>tsp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_nsec</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>tvp</name> <operator>=</operator> <name>tvbuf</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LUTIMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>follow</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>lutimes</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tvp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>utimes</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tvp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>HAVE_UTIME_H</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>HAVE_SYS_UTIME_H</name></expr></cpp:if>

<struct>struct <name>utimbuf</name> <block>{

<decl_stmt><decl><type><name>long</name></type> <name>actime</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>modtime</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>utime_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>utime_args</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timespec</name></name> <modifier>*</modifier></type><name>tsp</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>tsp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>utimbuf</name></name></type> <name>utbuf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>utp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tsp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>utbuf</name><operator>.</operator><name>actime</name></name> <operator>=</operator> <name><name>tsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>utbuf</name><operator>.</operator><name>modtime</name></name> <operator>=</operator> <name><name>tsp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name></expr>;</expr_stmt>

<expr_stmt><expr><name>utp</name> <operator>=</operator> <operator>&amp;</operator><name>utbuf</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>utime</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>utp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>utime_internal_i</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>follow</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>utime_args</name></name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name><name>tss</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tsp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>apply2args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>atime</name></name> <operator>=</operator> <operator>*</operator><name>argv</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>mtime</name></name> <operator>=</operator> <operator>*</operator><name>argv</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>follow</name></name> <operator>=</operator> <name>follow</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>atime</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>mtime</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tsp</name> <operator>=</operator> <name>tss</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_time_timespec</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>atime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>.</operator><name>atime</name></name> <operator>==</operator> <name><name>args</name><operator>.</operator><name>mtime</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>tsp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>tsp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>tsp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_time_timespec</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>mtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>tsp</name></name> <operator>=</operator> <name>tsp</name></expr>;</expr_stmt>

<return>return <expr><call><name>apply2files</name><argument_list>(<argument><expr><name>utime_internal</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_utime</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>utime_internal_i</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIMES</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LUTIMES</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UTIMENSAT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>AT_SYMLINK_NOFOLLOW</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></cpp:if>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_lutime</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>utime_internal_i</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_s_lutime</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>syserr_fail2</name><parameter_list>(<parameter><type><name>e</name></type></parameter>, <parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>syserr_fail2_in(RUBY_FUNCTION_NAME_STRING, e, s1, s2)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>syserr_fail2_in</name><parameter_list>(<parameter><type><name>func</name></type></parameter>, <parameter><type><name>e</name></type></parameter>, <parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>syserr_fail2(e, s1, s2)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sys_fail2</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>syserr_fail2(errno, s1, s2)</cpp:value></cpp:define>

<macro><name>NORETURN</name><argument_list>(<argument>static void syserr_fail2_in(const char *,int,VALUE,VALUE)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>syserr_fail2_in</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>s1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>s2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MAX_PATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_pathlen</name> <init>= <expr><name>MAX_PATH</name></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_pathlen</name> <init>= <expr><name>MAXPATHLEN</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>EEXIST</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>rb_str_ellipsize</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>max_pathlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_str_ellipsize</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>max_pathlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_str_ellipsize</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>max_pathlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_syserr_fail_path_in</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_link</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>to</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>link</name><argument_list>(<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sys_fail2</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_s_link</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYMLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_symlink</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>to</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>symlink</name><argument_list>(<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sys_fail2</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_s_symlink</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_readlink</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_readlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>readlink_arg</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_readlink</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>readlink_arg</name></name> <modifier>*</modifier></type><name>ra</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>readlink</name><argument_list>(<argument><expr><name><name>ra</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ra</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>ra</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>

<name>readlink_without_gvl</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>readlink_arg</name></name></type> <name>ra</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ra</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ra</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ra</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_readlink</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ra</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_readlink</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>rv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_enc_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>readlink_without_gvl</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>size</name>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <operator>(</operator><name>rv</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name><operator>)</operator></expr> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_modify_expand</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>v</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_s_readlink</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>unlink_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>unlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_unlink</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>apply2files</name><argument_list>(<argument><expr><name>unlink_internal</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>rename_args</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>no_gvl_rename</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rename_args</name></name> <modifier>*</modifier></type><name>ra</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rename</name><argument_list>(<argument><expr><name><name>ra</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>ra</name><operator>-&gt;</operator><name>dst</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_rename</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>to</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rename_args</name></name></type> <name>ra</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>f</name></decl>, <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ra</name><operator>.</operator><name>src</name></name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ra</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__CYGWIN__</name></expr></cpp:if>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>no_gvl_rename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ra</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name></expr></cpp:if>

<switch>switch <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EEXIST</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name><name>ra</name><operator>.</operator><name>dst</name></name></expr></argument>, <argument><expr><literal type="number">0666</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>unlink</name><argument_list>(<argument><expr><name><name>ra</name><operator>.</operator><name>dst</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>

<call><name>rename</name><argument_list>(<argument><expr><name><name>ra</name><operator>.</operator><name>src</name></name></expr></argument>, <argument><expr><name><name>ra</name><operator>.</operator><name>dst</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></switch>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>syserr_fail2</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_umask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mode_t</name></type> <name>omask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>omask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>omask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>omask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><call><name>NUM2MODET</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_error_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<return>return <expr><call><name>MODET2NUM</name><argument_list>(<argument><expr><name>omask</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DOSISH</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__CYGWIN__</name> <operator>||</operator> <name>defined</name> <name>DOSISH</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOSISH_UNC</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOSISH_DRIVE_LETTER</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_ALT_SEPARATOR</name></cpp:macro> <cpp:value>'\\'</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILE_ALT_SEPARATOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isdirsep</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == '/' || (x) == FILE_ALT_SEPARATOR)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>file_alt_separator</name><index>[]</index></name> <init>= <expr><block>{<expr><name>FILE_ALT_SEPARATOR</name></expr>, <expr><literal type="char">'\0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isdirsep</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == '/')</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_NTFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NTFS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NTFS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_NTFS_ADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NTFS_ADS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_NTFS_ADS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>istrailinggarbage</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == '.' || (x) == ' ')</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>istrailinggarbage</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS_ADS</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isADS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == ':')</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isADS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Next</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>e</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p) + rb_enc_mbclen((p), (e), (enc)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Inc</name><parameter_list>(<parameter><type><name>p</name></type></parameter>, <parameter><type><name>e</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p) = Next((p), (e), (enc)))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_UNC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>has_unc</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(isdirsep((buf)[0]) &amp;&amp; isdirsep((buf)[1]))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>has_unc</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>has_drive_letter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ISALPHA</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>

<name>getcwdofdrv</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>drv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>drive</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>drvcwd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>oldcwd</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>drive</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>drv</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>drive</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>drive</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>oldcwd</name> <operator>=</operator> <call><name>ruby_getcwd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>drive</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>drvcwd</name> <operator>=</operator> <call><name>ruby_getcwd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>chdir</name><argument_list>(<argument><expr><name>oldcwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>oldcwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>drvcwd</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>drive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>drvcwd</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>not_same_drive</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>drive</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>has_drive_letter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>TOLOWER</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>TOLOWER</name><argument_list>(<argument><expr><name>drive</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>has_unc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type>

<name>skiproot</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>path</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>has_drive_letter</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nextdirsep</name></cpp:macro> <cpp:value>rb_enc_path_next</cpp:value></cpp:define>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>rb_enc_path_next</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_UNC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>skipprefix</name></cpp:macro> <cpp:value>rb_enc_path_skip_prefix</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>skipprefix</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>end</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(path)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>rb_enc_path_skip_prefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_UNC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_UNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>path</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>path</name> <operator>=</operator> <call><name>rb_enc_path_next</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdirsep</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_enc_path_next</name><argument_list>(<argument><expr><name>path</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>has_drive_letter</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>path</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>char</name> <modifier>*</modifier></type>

<name>skipprefixroot</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_UNC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>skipprefix</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><name>p</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>skiproot</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strrdirsep</name></cpp:macro> <cpp:value>rb_enc_path_last_separator</cpp:value></cpp:define>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>rb_enc_path_last_separator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>path</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>last</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>chompdirsep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>path</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>last</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>rb_enc_path_end</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>chompdirsep</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>ntfs_tail</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>path</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isADS</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>istrailinggarbage</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>path</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>istrailinggarbage</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>&gt;=</operator> <name>end</name> <operator>||</operator> <call><name>isADS</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>last</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>path</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>last</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isADS</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFCHECK</name><parameter_list>(<parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {bdiff = p - buf;if (cond) {do {buflen *= 2;} while (cond);rb_str_resize(result, buflen);buf = RSTRING_PTR(result);p = buf + bdiff;pend = buf + buflen;}} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFINIT</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(p = buf = RSTRING_PTR(result),buflen = RSTRING_LEN(result),pend = p + buflen)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIPPATHSEP</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((*(p)) ? 1 : 0)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIPPATHSEP</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFCOPY</name><parameter_list>(<parameter><type><name>srcptr</name></type></parameter>, <parameter><type><name>srclen</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const int skip = SKIPPATHSEP(p); rb_str_set_len(result, p-buf+skip); BUFCHECK(bdiff + ((srclen)+skip) &gt;= buflen); p += skip; memcpy(p, (srcptr), (srclen)); p += (srclen); } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WITH_ROOTDIFF</name><parameter_list>(<parameter><type><name>stmt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { long rootdiff = root - buf; stmt; root = buf + rootdiff; } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>copy_home_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name> <operator>||</operator> <name>defined</name> <name>__CYGWIN__</name></expr></cpp:if>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>long</name></type> <name>dirlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dirlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>encidx</name> <operator>=</operator> <call><name>rb_filesystem_encindex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name> <operator>||</operator> <name>defined</name> <name>__CYGWIN__</name></expr></cpp:if>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>encidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>bend</name> <operator>=</operator> <operator>(</operator><name>p</name> <operator>=</operator> <name>buf</name><operator>)</operator> <operator>+</operator> <name>dirlen</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>bend</name></expr>;</condition> <incr><expr><call><name>Inc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_home_dir_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>user</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PWD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pwPtr</name></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>getlogin</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pwPtr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>endpwent</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>username</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:if>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fsenc</name> <init>= <expr><call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fsenc</name> <init>= <expr><call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <name>fsenc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>username</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>fsenc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PWD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>pwPtr</name> <operator>=</operator> <call><name>getpwnam</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>username</name></expr></argument>, <argument><expr><call><name>getlogin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>pwPtr</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pwPtr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>endpwent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"user %"</literal><name>PRIsVALUE</name><literal type="string">" doesn't exist"</literal></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PWD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <name><name>pwPtr</name><operator>-&gt;</operator><name>pw_dir</name></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>copy_home_path</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>endpwent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>VALUE</name></type>

<name>rb_default_home_dir</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"HOME"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_PWD_H</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>login</name> <init>= <expr><call><name>getlogin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>login</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pw</name> <init>= <expr><call><name>getpwnam</name><argument_list>(<argument><expr><name>login</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>copy_home_path</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>pw</name><operator>-&gt;</operator><name>pw_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>endpwent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>endpwent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"couldn't find HOME for login `%s' -- expanding `~'"</literal></expr></argument>,

<argument><expr><name>login</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"couldn't find login name -- expanding `~'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"couldn't find HOME environment -- expanding `~'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>copy_home_path</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ospath_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fsenc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NORMALIZE_UTF8PATH</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_str_normalize_ospath</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>fsenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>path</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fsenc</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>append_fspath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fsenc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cwdp</name> <init>= <expr><name>dir</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dirname</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>dirlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>buflen</name> <init>= <expr><call><name>rb_str_capacity</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>NORMALIZE_UTF8PATH</name> <operator>||</operator> <operator>*</operator><name>enc</name> <operator>!=</operator> <name>fsenc</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>direnc</name> <init>= <expr><call><name>rb_enc_check</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>dirname</name> <operator>=</operator> <call><name>ospath_new</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>, <argument><expr><name>fsenc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>direnc</name> <operator>!=</operator> <name>fsenc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>fsenc</name></expr></argument>, <argument><expr><name>direnc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>cwdp</name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>NORMALIZE_UTF8PATH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>cwdp</name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>enc</name> <operator>=</operator> <name>direnc</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<do>do <block>{<block_content><expr_stmt><expr><name>buflen</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content>}</block> while <condition>(<expr><name>dirlen</name> <operator>&gt;</operator> <name>buflen</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>cwdp</name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>*</operator><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>buf</name> <operator>+</operator> <name>dirlen</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_file_expand_path_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>abs_mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>long_name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>buflen</name></decl>, <decl><type ref="prev"/><name>bdiff</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fsenc</name> <init>= <expr><call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>StringValuePtr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fend</name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUFINIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator> <name>abs_mode</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>long</name></type> <name>userlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_default_home_dir</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>nextdirsep</name><argument_list>(<argument><expr><name>b</name> <operator>=</operator> <name>s</name></expr></argument>, <argument><expr><name>fend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name><operator>++</operator></expr>;</expr_stmt> 

<expr_stmt><expr><name>userlen</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>b</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUFCHECK</name><argument_list>(<argument><expr><name>bdiff</name> <operator>+</operator> <name>userlen</name> <operator>&gt;=</operator> <name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>userlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>userlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_home_dir_of</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>userlen</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_absolute_path</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>userlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_raise</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"non-absolute home of %.*s%.0"</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>userlen</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"non-absolute home"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>BUFINIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>pend</name></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><call><name>has_drive_letter</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>BUFCHECK</name><argument_list>(<argument><expr><name>bdiff</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>same</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>dname</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>not_same_drive</name><argument_list>(<argument><expr><name>dname</name></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_file_expand_path_internal</name><argument_list>(<argument><expr><name>dname</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>abs_mode</name></expr></argument>, <argument><expr><name>long_name</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUFINIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>has_drive_letter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TOLOWER</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>TOLOWER</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>same</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>same</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>append_fspath</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>getcwdofdrv</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>enc</name></expr></argument>, <argument><expr><name>fsenc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUFINIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>pend</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>chompdirsep</name><argument_list>(<argument><expr><call><name>skiproot</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_is_absolute_path</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_file_expand_path_internal</name><argument_list>(<argument><expr><name>dname</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>abs_mode</name></expr></argument>, <argument><expr><name>long_name</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_enc_check</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUFINIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>pend</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>append_fspath</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>ruby_getcwd</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>enc</name></expr></argument>, <argument><expr><name>fsenc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BUFINIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name> <operator>||</operator> <name>defined</name> <name>__CYGWIN__</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipprefix</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>chompdirsep</name><argument_list>(<argument><expr><call><name>skiproot</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block> while <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>b</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUFCHECK</name><argument_list>(<argument><expr><name>bdiff</name> <operator>&gt;=</operator> <name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_enc_check</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>buf</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUFCHECK</name><argument_list>(<argument><expr><name>bdiff</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUFCHECK</name><argument_list>(<argument><expr><name>bdiff</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>skipprefix</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'.'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>s</name><operator>++</operator></expr>)</condition> <block>{<block_content> 

<switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><name>b</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>s</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>s</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>n</name> <operator>=</operator> <call><name>strrdirsep</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>++</operator><name>s</name></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<else>else <block>{<block_content>

<do>do<block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt></block_content></block> while <condition>(<expr><call><name>istrailinggarbage</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<case>case <expr><literal type="char">'/'</literal></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name> <operator>||</operator> <name>defined</name> <name>__CYGWIN__</name></expr></cpp:if>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>++</operator><name>s</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>s</name></expr>;</expr_stmt>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>fend</name> <operator>&amp;&amp;</operator> <call><name>istrailinggarbage</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;=</operator> <name>fend</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<goto>goto <name>endpath</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<case>case <expr><literal type="char">'/'</literal></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name> <operator>||</operator> <name>defined</name> <name>__CYGWIN__</name></expr></cpp:if>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <name>b</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>WITH_ROOTDIFF</name><argument_list>(<argument><expr><call><name>BUFCOPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>++</operator><name>s</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>ignored_char_p</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <name>b</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>WITH_ROOTDIFF</name><argument_list>(<argument><expr><call><name>BUFCOPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <name>s</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <name>b</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS_ADS</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>prime</name><index>[]</index></name> <init>= <expr><literal type="string">":$DATA"</literal></expr></init></decl>;</decl_stmt>

<enum>enum <block>{<decl><name>prime_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>prime</name></expr></argument>)</argument_list></sizeof> <operator>-</operator><literal type="number">1</literal></expr></init></decl>}</block>;</enum>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>endpath</name>:</label>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS_ADS</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <name>b</name> <operator>+</operator> <name>prime_len</name> <operator>&amp;&amp;</operator> <call><name>strncasecmp</name><argument_list>(<argument><expr><name>s</name> <operator>-</operator> <name>prime_len</name></expr></argument>, <argument><expr><name>prime</name></expr></argument>, <argument><expr><name>prime_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>isADS</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>s</name> <operator>-</operator> <operator>(</operator><name>prime_len</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>-=</operator> <name>prime_len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>, <argument><expr><name>s</name> <operator>-</operator> <name>prime_len</name> <operator>-</operator> <name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>-=</operator> <name>prime_len</name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>BUFCOPY</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <call><name>skiproot</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <operator>!</operator><operator>!</operator><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>strrdirsep</name><argument_list>(<argument><expr><name>b</name> <operator>=</operator> <name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strpbrk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"*?"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>encidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>wstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WIN32_FIND_DATAW</name></type> <name>wfd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CYGWIN_CONV_PATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>w32buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name> <init>= <expr><name>CCP_POSIX_TO_WIN_A</name> <operator>|</operator> <name>CCP_RELATIVE</name></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>char</name></type> <name><name>w32buf</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>bufsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lnk_added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_symlink</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lstat_without_gvl</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_symlink</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRCASECMP</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">".lnk"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lnk_added</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>buf</name></expr> ?</condition><then> <expr><name>buf</name></expr> </then><else>: <expr><literal type="string">"/"</literal></expr></else></ternary></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CYGWIN_CONV_PATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>bufsize</name> <operator>=</operator> <call><name>cygwin_conv_path</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bufsize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bufsize</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lnk_added</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bufsize</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>w32buf</name> <operator>=</operator> <call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>cygwin_conv_path</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>w32buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>b</name> <operator>=</operator> <name>w32buf</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>bufsize</name> <operator>=</operator> <name>MAXPATHLEN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>cygwin_conv_to_win32_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>w32buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>b</name> <operator>=</operator> <name>w32buf</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>is_symlink</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>==</operator> <name>w32buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strlcat</name><argument_list>(<argument><expr><name>w32buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lnk_added</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strlcat</name><argument_list>(<argument><expr><name>w32buf</name></expr></argument>, <argument><expr><literal type="string">".lnk"</literal></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>lnk_added</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>buf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>encidx</name> <operator>=</operator> <call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>encidx</name> <operator>!=</operator> <name>ENCINDEX_UTF_8</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wstr</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>WCHAR</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>wstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>FindFirstFileW</name><argument_list>(<argument><expr><name>wstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>wlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>lstrlenW</name><argument_list>(<argument><expr><name><name>wfd</name><operator>.</operator><name>cFileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>lnk_added</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>

<call><name>wcscasecmp</name><argument_list>(<argument><expr><name><name>wfd</name><operator>.</operator><name>cFileName</name></name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">L".lnk"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>wfd</name><operator>.</operator><name>cFileName</name><index>[<expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>L</name><literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>wlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>wfd</name><operator>.</operator><name>cFileName</name></name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>BUFCHECK</name><argument_list>(<argument><expr><name>bdiff</name> <operator>+</operator> <name>len</name> <operator>&gt;=</operator> <name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>wfd</name><operator>.</operator><name>cFileName</name></name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_modify_expand</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>wfd</name><operator>.</operator><name>cFileName</name></name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat_conv_enc_opts</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>bdiff</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>,

<argument><expr><call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUFINIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_check</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPAND_PATH_BUFFER</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>rb_usascii_str_new(0, MAXPATHLEN + 2)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>str_shrink</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expand_path</name><parameter_list>(<parameter><type><name>fname</name></type></parameter>, <parameter><type><name>dname</name></type></parameter>, <parameter><type><name>abs_mode</name></type></parameter>, <parameter><type><name>long_name</name></type></parameter>, <parameter><type><name>result</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>str_shrink(rb_file_expand_path_internal(fname, dname, abs_mode, long_name, result))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_expand_path_args</name><parameter_list>(<parameter><type><name>fname</name></type></parameter>, <parameter><type><name>dname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((fname) = rb_get_path(fname)), (void)(NIL_P(dname) ? (dname) : ((dname) = rb_get_path(dname))))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>file_expand_path_1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_file_expand_path_internal</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>EXPAND_PATH_BUFFER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_file_expand_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_expand_path_args</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>expand_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>EXPAND_PATH_BUFFER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_file_expand_path_fast</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>expand_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>EXPAND_PATH_BUFFER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_file_s_expand_path</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_file_expand_path</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>s_expand_path</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_file_s_expand_path</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_file_absolute_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_expand_path_args</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>expand_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>dname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>EXPAND_PATH_BUFFER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_file_s_absolute_path</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_file_absolute_path</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>s_absolute_path</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_file_s_absolute_path</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>s_absolute_path_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_get_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_absolute_path</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<enum>enum <name>rb_realpath_mode</name> <block>{

<decl><name>RB_REALPATH_CHECK</name></decl>,

<decl><name>RB_REALPATH_DIR</name></decl>,

<decl><name>RB_REALPATH_STRICT</name></decl>,

<decl><name>RB_REALPATH_MODE_MAX</name></decl>

}</block>;</enum>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>realpath_rec</name><parameter_list>(<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>prefixlenp</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>resolvedp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unresolved</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fallback</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>loopcheck</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>rb_realpath_mode</name></name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>last</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pend</name> <init>= <expr><name>unresolved</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>unresolved</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><operator>*</operator><name>resolvedp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>resolving</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>resolving</name></expr></argument>, <argument><expr><literal type="string">"resolving"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>unresolved</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>testname</name> <init>= <expr><name>unresolved</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unresolved_firstsep</name> <init>= <expr><call><name>rb_enc_path_next</name><argument_list>(<argument><expr><name>unresolved</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>testnamelen</name> <init>= <expr><name>unresolved_firstsep</name> <operator>-</operator> <name>unresolved</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unresolved_nextname</name> <init>= <expr><name>unresolved_firstsep</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>unresolved_nextname</name> <operator>&lt;</operator> <name>pend</name> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>unresolved_nextname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>unresolved_nextname</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>unresolved</name> <operator>=</operator> <name>unresolved_nextname</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>testnamelen</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>testname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>testnamelen</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>testname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>testname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>prefixlenp</name> <operator>&lt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><operator>*</operator><name>resolvedp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resolved_str</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><operator>*</operator><name>resolvedp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>resolved_names</name> <init>= <expr><name>resolved_str</name> <operator>+</operator> <operator>*</operator><name>prefixlenp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lastsep</name> <init>= <expr><call><name>strrdirsep</name><argument_list>(<argument><expr><name>resolved_names</name></expr></argument>, <argument><expr><name>resolved_str</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><operator>*</operator><name>resolvedp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name>lastsep</name></expr> ?</condition><then> <expr><name>lastsep</name> <operator>-</operator> <name>resolved_names</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><operator>*</operator><name>resolvedp</name></expr></argument>, <argument><expr><operator>*</operator><name>prefixlenp</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>checkval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>testpath</name> <init>= <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><operator>*</operator><name>resolvedp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>prefixlenp</name> <operator>&lt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>testpath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>testpath</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_UNC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>prefixlenp</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>prefixlenp</name> <operator>==</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>testpath</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>testpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefix</name> <operator>+</operator> <operator>*</operator><name>prefixlenp</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>prefix</name> <operator>+</operator> <operator>*</operator><name>prefixlenp</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>last</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>testpath</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>testpath</name></expr></argument>, <argument><expr><name>testname</name></expr></argument>, <argument><expr><name>testnamelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>checkval</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>loopcheck</name></expr></argument>, <argument><expr><name>testpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>checkval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>checkval</name> <operator>==</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><name>resolving</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RB_REALPATH_CHECK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ELOOP</name></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>ELOOP</name></expr></argument>, <argument><expr><name>testpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>resolvedp</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>checkval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sbuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>lstat_without_gvl</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>testpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>stat_without_gvl</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>sbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_replace</name><argument_list>(<argument><expr><operator>*</operator><name>resolvedp</name></expr></argument>, <argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RB_REALPATH_CHECK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RB_REALPATH_STRICT</name> <operator>||</operator> <operator>!</operator><name>last</name> <operator>||</operator> <operator>*</operator><name>unresolved_firstsep</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>testpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>resolvedp</name> <operator>=</operator> <name>testpath</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>testpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_READLINK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>sbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>link</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>link_orig</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>link_prefix</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>link_names</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>link_prefixlen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>loopcheck</name></expr></argument>, <argument><expr><name>testpath</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>resolving</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>link</name> <operator>=</operator> <call><name>rb_readlink</name><argument_list>(<argument><expr><name>testpath</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>link_prefix</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>link_names</name> <operator>=</operator> <call><name>skipprefixroot</name><argument_list>(<argument><expr><name>link_prefix</name></expr></argument>, <argument><expr><name>link_prefix</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>link_prefixlen</name> <operator>=</operator> <name>link_names</name> <operator>-</operator> <name>link_prefix</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>link_prefixlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>tmpenc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>linkenc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>link_orig</name> <operator>=</operator> <name>link</name></expr>;</expr_stmt>

<expr_stmt><expr><name>link</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>link</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>link_prefixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmpenc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><operator>*</operator><name>resolvedp</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmpenc</name> <operator>!=</operator> <name>linkenc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>link</name> <operator>=</operator> <call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>link</name></expr></argument>, <argument><expr><name>linkenc</name></expr></argument>, <argument><expr><name>tmpenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>resolvedp</name> <operator>=</operator> <name>link</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>prefixlenp</name> <operator>=</operator> <name>link_prefixlen</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>realpath_rec</name><argument_list>(<argument><expr><name>prefixlenp</name></expr></argument>, <argument><expr><name>resolvedp</name></expr></argument>, <argument><expr><name>link_names</name></expr></argument>, <argument><expr><name>testpath</name></expr></argument>,

<argument><expr><name>loopcheck</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><operator>!</operator><operator>*</operator><name>unresolved_firstsep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>link_orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>loopcheck</name></expr></argument>, <argument><expr><name>testpath</name></expr></argument>, <argument><expr><call><name>rb_str_dup_frozen</name><argument_list>(<argument><expr><operator>*</operator><name>resolvedp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><call><name>rb_str_dup_frozen</name><argument_list>(<argument><expr><name>testpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>loopcheck</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>resolvedp</name> <operator>=</operator> <name>testpath</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_check_realpath_emulate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>basedir</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>origenc</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>rb_realpath_mode</name></name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>prefixlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>resolved</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>unresolved_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>loopcheck</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>curdir</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path_names</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>basedir_names</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>curdir_names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prefixptr</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>unresolved_path</name> <operator>=</operator> <call><name>rb_str_dup_frozen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>basedir</name> <operator>=</operator> <call><name>TO_OSPATH</name><argument_list>(<argument><expr><call><name>rb_str_dup_frozen</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>unresolved_path</name> <operator>=</operator> <call><name>TO_OSPATH</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path_names</name> <operator>=</operator> <call><name>skipprefixroot</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>path_names</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>resolved</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>path_names</name> <operator>-</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>root_found</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>basedir_names</name> <operator>=</operator> <call><name>skipprefixroot</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>basedir_names</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>resolved</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>basedir_names</name> <operator>-</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>root_found</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>curdir</name> <operator>=</operator> <call><name>rb_dir_getwd_ospath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curdir_names</name> <operator>=</operator> <call><name>skipprefixroot</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>resolved</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>curdir_names</name> <operator>-</operator> <name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>root_found</name>:</label>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><name>prefixptr</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>prefixptr</name> <operator>+</operator> <name>prefixlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>chompdirsep</name><argument_list>(<argument><expr><name>prefixptr</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prefixlen</name> <operator>=</operator> <operator>++</operator><name>ptr</name> <operator>-</operator> <name>prefixptr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><name>prefixlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILE_ALT_SEPARATOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<while>while <condition>(<expr><name>prefixptr</name> <operator>&lt;</operator> <name>ptr</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>prefixptr</name> <operator>==</operator> <name>FILE_ALT_SEPARATOR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>prefixptr</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>prefixptr</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ENCINDEX_ASCII</name></expr>:</case>

<case>case <expr><name>ENCINDEX_US_ASCII</name></expr>:</case>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><call><name>rb_filesystem_encindex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name>loopcheck</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>curdir_names</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>realpath_rec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefixlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resolved</name></expr></argument>, <argument><expr><name>curdir_names</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>loopcheck</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>basedir_names</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>realpath_rec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefixlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resolved</name></expr></argument>, <argument><expr><name>basedir_names</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>loopcheck</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>realpath_rec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefixlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resolved</name></expr></argument>, <argument><expr><name>path_names</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>loopcheck</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>origenc</name> <operator>&amp;&amp;</operator> <name>origenc</name> <operator>!=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_str_asciionly_p</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>resolved</name> <operator>=</operator> <call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>resolved</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_file_join</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_check_realpath_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>basedir</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>origenc</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>rb_realpath_mode</name></name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_REALPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>VALUE</name></type> <name>unresolved_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resolved_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>resolved</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RB_REALPATH_DIR</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_check_realpath_emulate</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>unresolved_path</name> <operator>=</operator> <call><name>rb_str_dup_frozen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>unresolved_path</name> <operator>=</operator> <call><name>rb_file_join</name><argument_list>(<argument><expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>origenc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>unresolved_path</name> <operator>=</operator> <call><name>TO_OSPATH</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>resolved_ptr</name> <operator>=</operator> <call><name>realpath</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOTDIR</name> <operator>||</operator>

<operator>(</operator><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>&amp;&amp;</operator> <call><name>rb_file_exist_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_check_realpath_emulate</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RB_REALPATH_CHECK</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>resolved</name> <operator>=</operator> <call><name>ospath_new</name><argument_list>(<argument><expr><name>resolved_ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>resolved_ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>resolved_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat_without_gvl</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>RB_REALPATH_CHECK</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>origenc</name> <operator>&amp;&amp;</operator> <name>origenc</name> <operator>!=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_str_asciionly_p</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>resolved</name> <operator>=</operator> <call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>resolved</name></expr></argument>, <argument><expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>unresolved_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>resolved</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>rb_check_realpath_emulate</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_realpath_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>basedir</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>rb_realpath_mode</name></name></type> <name>mode</name> <init>=

<expr><ternary><condition><expr><name>strict</name></expr> ?</condition><then> <expr><name>RB_REALPATH_STRICT</name></expr> </then><else>: <expr><name>RB_REALPATH_DIR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_check_realpath_internal</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_check_realpath</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>basedir</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_realpath_internal</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>RB_REALPATH_CHECK</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_realpath</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>basedir</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_realpath_internal</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_realdirpath</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>basedir</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_realpath_internal</name><argument_list>(<argument><expr><name>basedir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>rmext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l0</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l2</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name> <operator>||</operator> <operator>!</operator><name>l2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>e</name> <operator>+</operator> <name>l2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len1</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>e</name> <operator>+</operator> <name>len1</name></expr></argument>, <argument><expr><name>e</name> <operator>+</operator> <name>l2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len2</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name>len1</name> <operator>+</operator> <name>len2</name> <operator>==</operator> <name>l2</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>l0</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>l1</name></expr>;</expr_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len1</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>last</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>len1</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>last</name> <operator>-</operator> <name>p</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>l1</name> <operator>&lt;</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>l1</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name><operator>+</operator><name>l1</name><operator>-</operator><name>l2</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>l1</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CASEFOLD_FILESYSTEM</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fncomp</name></cpp:macro> <cpp:value>strncasecmp</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fncomp</name></cpp:macro> <cpp:value>strncmp</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>fncomp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>l1</name><operator>-</operator><name>l2</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>ruby_enc_find_basename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>baselen</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>alllen</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH_DRIVE_LETTER</name> <operator>||</operator> <name>defined</name> <name>DOSISH_UNC</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>long</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>name</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>alllen</name></expr> ?</condition><then> <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>*</operator><name>alllen</name></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>skipprefix</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH_DRIVE_LETTER</name> <operator>||</operator> <name>defined</name> <name>DOSISH_UNC</name></expr></cpp:if>

<expr_stmt><expr><name>root</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>name</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH_DRIVE_LETTER</name> <operator>||</operator> <name>defined</name> <name>DOSISH_UNC</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>root</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_UNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="string">"/"</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strrdirsep</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while> 

</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ntfs_tail</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>chompdirsep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><name>q</name> <operator>-</operator> <name>p</name> <operator>&lt;</operator> <name>n</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'.'</literal></expr>;</condition> <incr><expr><name>q</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>q</name> <operator>-</operator> <name>p</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><call><name>Inc</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>f</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>f</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>baselen</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>baselen</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>alllen</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>alllen</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_basename</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>fname</name></decl>, <decl><type ref="prev"/><name>fext</name></decl>, <decl><type ref="prev"/><name>basename</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>f</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fext</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fext</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>fext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>check_path_encoding</name><argument_list>(<argument><expr><name>fext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FilePathStringValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>fext</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><operator>(</operator><name>enc</name> <operator>=</operator> <call><name>rb_enc_compatible</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>fext</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fext</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><operator>*</operator><operator>(</operator><name>name</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_str_new_shared</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ruby_enc_find_basename</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>fext</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>f</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>fext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>f</name> <operator>=</operator> <call><name>rmext</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>fext</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>f</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>fext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_new_shared</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>basename</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>basename</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>basename</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_dirname</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_file_dirname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_file_dirname</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>root</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dirname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathStringValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>name</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>skiproot</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_UNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>root</name> <operator>&gt;</operator> <name>name</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>skipprefix</name><argument_list>(<argument><expr><name>name</name> <operator>=</operator> <name>root</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><name>root</name> <operator>&gt;</operator> <name>name</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>root</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strrdirsep</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_usascii_str_new2</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>has_drive_letter</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>name</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>top</name> <init>= <expr><call><name>skiproot</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>top</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>dirname</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>has_drive_letter</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>root</name> <operator>==</operator> <name>name</name> <operator>+</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>-</operator> <name>name</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>dirname</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>ruby_enc_find_extname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>name</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>len</name></expr> ?</condition><then> <expr><operator>*</operator><name>len</name></expr> </then><else>: <expr><operator>(</operator><name>long</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strrdirsep</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>name</name> <operator>=</operator> <operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block> while <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>;</do></block_content></block></else></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <call><name>istrailinggarbage</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>p</name><operator>++</operator></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dot</name> <init>= <expr><name>last</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>istrailinggarbage</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dot</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name> <operator>||</operator> <call><name>isADS</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>last</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>last</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <name>dot</name> <operator>&gt;</operator> <name>last</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name> <operator>=</operator> <name>dot</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<continue>continue;</continue>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_NTFS</name></expr></cpp:if>

<if type="elseif">else if <condition>(<expr><call><name>isADS</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if type="elseif">else if <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Inc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name> <operator>||</operator> <name>e</name> <operator>==</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>e</name><operator>+</operator><literal type="number">1</literal> <operator>==</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>e</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>e</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_extname</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>extname</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathStringValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>ruby_enc_find_extname</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>extname</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>extname</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_get_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_split</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>FilePathStringValue</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>rb_file_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_file_s_basename</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>,<argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>file_inspect_join</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>recur</name> <operator>||</operator> <name>ary</name> <operator>==</operator> <name>arg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"recursive array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_file_join</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_join</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>checked</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_path_encoding</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>OBJ_BUILTIN_TYPE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_STRING</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>checked</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>check_path_encoding</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_ARRAY</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>ary</name> <operator>==</operator> <name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"recursive array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_exec_recursive</name><argument_list>(<argument><expr><name>file_inspect_join</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>FilePathStringValue</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>checked</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <call><name>chompdirsep</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>tail</name> <operator>-</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>*</operator><name>tail</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_check</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS_RAW</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rb_cString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_join</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_file_join</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TRUNCATE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CHSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<struct>struct <name>truncate_arg</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2POS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2OFFT(n)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>off_t</name></type> <name>pos</name></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2POS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2LONG(n)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_truncate</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>truncate_arg</name></name> <modifier>*</modifier></type><name>ta</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>truncate</name><argument_list>(<argument><expr><name><name>ta</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ta</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>tmpfd</name> <init>= <expr><call><name>rb_cloexec_open</name><argument_list>(<argument><expr><name><name>ta</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmpfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_update_max_fd</name><argument_list>(<argument><expr><name>tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>chsize</name><argument_list>(<argument><expr><name>tmpfd</name></expr></argument>, <argument><expr><name><name>ta</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_truncate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>truncate_arg</name></name></type> <name>ta</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ta</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <call><name>NUM2POS</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ta</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_truncate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ta</name></expr></argument>,

<argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM2POS</name></cpp:undef>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_s_truncate</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CHSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<struct>struct <name>ftruncate_arg</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2POS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2OFFT(n)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>off_t</name></type> <name>pos</name></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM2POS</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>NUM2LONG(n)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>nogvl_ftruncate</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ftruncate_arg</name></name> <modifier>*</modifier></type><name>fa</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>ftruncate</name><argument_list>(<argument><expr><name><name>fa</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>fa</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>chsize</name><argument_list>(<argument><expr><name><name>fa</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>fa</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_truncate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ftruncate_arg</name></name></type> <name>fa</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>fa</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <call><name>NUM2POS</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_WRITABLE</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIOError</name></expr></argument>, <argument><expr><literal type="string">"not opened for writing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_io_flush_raw</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fa</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rb_thread_io_blocking_region</name><argument_list>(<argument><expr><name>nogvl_ftruncate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fa</name></expr></argument>, <argument><expr><name><name>fa</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM2POS</name></cpp:undef>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_truncate</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LOCK_SH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_SH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LOCK_EX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_EX</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LOCK_NB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_NB</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LOCK_UN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOCK_UN</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winerror.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_thread_flock</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>old_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>data</name></expr></init></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><call><name>flock</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ERROR_NOT_LOCKED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>old_errno</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_flock</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>operation</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_io_t</name> <modifier>*</modifier></type><name>fptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>op</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>op1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>time</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>op1</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GetOpenFile</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fptr</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>FMODE_WRITABLE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_io_flush_raw</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rb_thread_io_blocking_region</name><argument_list>(<argument><expr><name>rb_thread_flock</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EAGAIN</name></expr>:</case>

<case>case <expr><name>EACCES</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name></expr></cpp:if>

<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>op1</name> <operator>&amp;</operator> <name>LOCK_NB</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>time</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_thread_wait_for</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_io_check_closed</name><argument_list>(<argument><expr><name>fptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><name>EINTR</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ERESTART</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>ERESTART</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>fptr</name><operator>-&gt;</operator><name>pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></while>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>test_check</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name><operator>+=</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>T_FILE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>test_check((n), argc, argv)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_f_test</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cmd</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>NUM2CHR</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<label><name>unknown</name>:</label>

<if_stmt><if>if <condition>(<expr><call><name>ISPRINT</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unknown command '%s%c'"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>cmd</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>||</operator> <name>cmd</name> <operator>==</operator> <literal type="char">'\\'</literal></expr> ?</condition><then> <expr><literal type="string">"\\"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unknown command \"\\x%02X\""</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"bcdefgGkloOprRsSuwWxXz"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_blockdev_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'c'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_chardev_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_directory_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_exist_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_file_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'g'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_sgid_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'G'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_grpowned_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_sticky_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'l'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_symlink_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'o'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_owned_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'O'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_rowned_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'p'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_pipe_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_readable_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'R'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_readable_real_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_size_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'S'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_socket_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'u'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_suid_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_writable_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'W'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_writable_real_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_executable_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'X'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_executable_real_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'z'</literal></expr>:</case>

<return>return <expr><call><name>rb_file_zero_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"MAC"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>fname</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'A'</literal></expr>:</case>

<return>return <expr><call><name>stat_atime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'M'</literal></expr>:</case>

<return>return <expr><call><name>stat_mtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'C'</literal></expr>:</case>

<return>return <expr><call><name>stat_ctime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_file_identical_p</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"=&lt;&gt;"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st1</name></decl>, <decl><type ref="prev"/><name>st2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>t1</name></decl>, <decl><type ref="prev"/><name>t2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st1</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_stat</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>stat_mtimespec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>stat_mtimespec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>st2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'='</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>t1</name><operator>.</operator><name>tv_sec</name></name> <operator>==</operator> <name><name>t2</name><operator>.</operator><name>tv_sec</name></name> <operator>&amp;&amp;</operator> <name><name>t1</name><operator>.</operator><name>tv_nsec</name></name> <operator>==</operator> <name><name>t2</name><operator>.</operator><name>tv_nsec</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>t1</name><operator>.</operator><name>tv_sec</name></name> <operator>&gt;</operator> <name><name>t2</name><operator>.</operator><name>tv_sec</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t1</name><operator>.</operator><name>tv_sec</name></name> <operator>==</operator> <name><name>t2</name><operator>.</operator><name>tv_sec</name></name> <operator>&amp;&amp;</operator> <name><name>t1</name><operator>.</operator><name>tv_nsec</name></name> <operator>&gt;</operator> <name><name>t2</name><operator>.</operator><name>tv_nsec</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>t1</name><operator>.</operator><name>tv_sec</name></name> <operator>&lt;</operator> <name><name>t2</name><operator>.</operator><name>tv_sec</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t1</name><operator>.</operator><name>tv_sec</name></name> <operator>==</operator> <name><name>t2</name><operator>.</operator><name>tv_sec</name></name> <operator>&amp;&amp;</operator> <name><name>t1</name><operator>.</operator><name>tv_nsec</name></name> <operator>&lt;</operator> <name><name>t2</name><operator>.</operator><name>tv_nsec</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<goto>goto <name>unknown</name>;</goto>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_s_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>stat_new_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nst</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STAT</name><argument_list>(<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nst</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>nst</name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>nst</name></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_init_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>copy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>nst</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OBJ_INIT_COPY</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>copy</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nst</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>nst</name> <operator>=</operator> <operator>*</operator><operator>(</operator>struct <name>stat</name><operator>*</operator><operator>)</operator><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>nst</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>copy</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_ftype</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_file_ftype</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_d</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IFIFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>S_ISFIFO</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_l</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISLNK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>S_ISLNK</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_S</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>S_ISSOCK</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_b</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISBLK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>S_ISBLK</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_c</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>S_ISCHR</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_owned</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_uid</name> <operator>==</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_rowned</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_uid</name> <operator>==</operator> <call><name>getuid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_grpowned</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_group_member</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_gid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_r</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>geteuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IRUSR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_stat_owned</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IRUSR</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IRGRP</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_stat_grpowned</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IRGRP</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IROTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IROTH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_R</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>getuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IRUSR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_stat_rowned</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IRUSR</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IRGRP</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_group_member</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_gid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IRGRP</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IROTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IROTH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_wr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IROTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IROTH</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>S_IROTH</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRUGO</name><operator>|</operator><name>S_IWUGO</name><operator>|</operator><name>S_IXUGO</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_w</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>geteuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IWUSR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_stat_owned</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IWUSR</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IWGRP</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_stat_grpowned</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IWGRP</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IWOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IWOTH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_W</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>getuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IWUSR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_stat_rowned</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IWUSR</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IWGRP</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_group_member</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_gid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IWGRP</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IWOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IWOTH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_ww</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IROTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IWOTH</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>S_IWOTH</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <operator>(</operator><name>S_IRUGO</name><operator>|</operator><name>S_IWUGO</name><operator>|</operator><name>S_IXUGO</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_x</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>geteuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXUGO</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IXUSR</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_stat_owned</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXUSR</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IXGRP</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_stat_grpowned</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXGRP</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IXOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXOTH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_X</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_GETEUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>getuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXUGO</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IXUSR</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_stat_rowned</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXUSR</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IXGRP</name></expr></argument>)</argument_list></call></expr></condition></ternary></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>rb_group_member</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_gid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXGRP</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_IXOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IXOTH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_f</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_z</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>off_t</name></type> <name>size</name> <init>= <expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_size</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>OFFT2NUM</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_suid</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISUID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name> <operator>&amp;</operator> <name>S_ISUID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_sgid</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISGID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name> <operator>&amp;</operator> <name>S_ISGID</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_stat_sticky</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISVTX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>get_stat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>st_mode</name> <operator>&amp;</operator> <name>S_ISVTX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>defined</name> <name>HAVE_MKFIFO</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>HAVE_MKNOD</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>S_IFIFO</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mkfifo</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>mode</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mknod(path, (mode)&amp;~S_IFMT|S_IFIFO, 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_MKFIFO</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKFIFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>mkfifo_arg</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>nogvl_mkfifo</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>mkfifo_arg</name></name> <modifier>*</modifier></type><name>ma</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>mkfifo</name><argument_list>(<argument><expr><name><name>ma</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>ma</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_file_s_mkfifo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>mkfifo_arg</name></name></type> <name>ma</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ma</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <literal type="number">0666</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ma</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <call><name>NUM2MODET</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_encode_ospath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ma</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_thread_call_without_gvl</name><argument_list>(<argument><expr><name>nogvl_mkfifo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ma</name></expr></argument>, <argument><expr><name>RUBY_UBF_IO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_sys_fail_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_file_s_mkfifo</name></cpp:macro> <cpp:value>rb_f_notimplement</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_mFConst</name></decl>;</decl_stmt>

<function><type><name>void</name></type>

<name>rb_file_const</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_is_absolute_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_DRIVE_LETTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>has_drive_letter</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH_UNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>isdirsep</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isdirsep</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_PATH_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name> <operator>||</operator> <name>defined</name> <name>__CYGWIN__</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_PATH_CHECK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENABLE_PATH_CHECK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ENABLE_PATH_CHECK</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>path_check_0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>execpath</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p0</name> <init>= <expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_absolute_path</name><argument_list>(<argument><expr><name>p0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>ruby_getcwd</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>newpath</name></decl>;</decl_stmt>

<expr_stmt><expr><name>newpath</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>p0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>e0</name> <operator>=</operator> <name>p0</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_IWOTH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IWOTH</name></cpp:macro> <cpp:value>002</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>STAT</name><argument_list>(<argument><expr><name>p0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IWOTH</name><operator>)</operator>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>S_ISVTX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>p</name> <operator>&amp;&amp;</operator> <name>execpath</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_ISVTX</name><operator>)</operator><operator>)</operator>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<operator>&amp;&amp;</operator> <operator>!</operator><call><name>access</name><argument_list>(<argument><expr><name>p0</name></expr></argument>, <argument><expr><name>W_OK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_warn</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><literal type="string">"Insecure world writable dir %s in %sPATH, mode 0%"</literal>

<name>PRI_MODET_PREFIX</name><literal type="string">"o"</literal></expr></argument>,

<argument><expr><name>p0</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>execpath</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"LOAD_"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strrdirsep</name><argument_list>(<argument><expr><name>p0</name></expr></argument>, <argument><expr><name>e0</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name> <operator>||</operator> <name>s</name> <operator>==</operator> <name>p0</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>e0</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ENABLE_PATH_CHECK</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fpath_check</name><parameter_list>(<parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>path_check_0((path), FALSE)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fpath_check</name><parameter_list>(<parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>rb_path_check</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ENABLE_PATH_CHECK</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>sep</name> <init>= <expr><name>PATH_SEP_CHAR</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>path</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>path</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pend</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>path_check_0</name><argument_list>(<argument><expr><call><name>rb_str_new</name><argument_list>(<argument><expr><name>p0</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>p0</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>&gt;</operator> <name>pend</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p0</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pend</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>ruby_is_fd_loadable</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><literal type="number">1</literal></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISFIFO</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>S_ISCHR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EISDIR</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENXIO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type>

<name>rb_file_load_ok</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><operator>(</operator><name>O_RDONLY</name> <operator>|</operator>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>O_NONBLOCK</name></expr></cpp:if>

<name>O_NONBLOCK</name> <operator>|</operator>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>O_NDELAY</name></expr></cpp:elif>

<name>O_NDELAY</name> <operator>|</operator>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>rb_cloexec_open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_update_max_fd</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ruby_is_fd_loadable</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>is_explicit_relative</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>path</name><operator>++</operator> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>path</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>isdirsep</name><argument_list>(<argument><expr><operator>*</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>copy_path_class</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>str_shrink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>path</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_find_file_ext_safe</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>filep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ext</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>_level</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"rb_find_file_ext_safe will be removed in Ruby 3.0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_find_file_ext</name><argument_list>(<argument><expr><name>filep</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_find_file_ext</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>filep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ext</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><operator>*</operator><name>filep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>fname</name> <init>= <expr><operator>*</operator><name>filep</name></expr></init></decl>, <decl><type ref="prev"/><name>load_path</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>fnlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>expanded</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>f</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>file_expand_path_1</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>filep</name> <operator>=</operator> <name>fname</name></expr>;</expr_stmt>

<expr_stmt><expr><name>expanded</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>expanded</name> <operator>||</operator> <call><name>rb_is_absolute_path</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_explicit_relative</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expanded</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>file_expand_path_1</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fnlen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ext</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>ext</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_file_load_ok</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>filep</name> <operator>=</operator> <call><name>copy_path_class</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><operator>*</operator><name>filep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>i</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>fnlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>load_path</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>rb_get_expanded_load_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>load_path</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><operator>*</operator><name>filep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fnlen</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_tmp_new</name><argument_list>(<argument><expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>rb_usascii_encindex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ext</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>ext</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>load_path</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>load_path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>rb_get_path</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_file_expand_path_internal</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_file_load_ok</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>filep</name> <operator>=</operator> <call><name>copy_path_class</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>*</operator><name>filep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>j</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>fnlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>load_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_find_file_safe</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>_level</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"rb_find_file_safe will be removed in Ruby 3.0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_find_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_find_file</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>load_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>expanded</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>f</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>file_expand_path_1</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>copy_path_class</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>expanded</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>expanded</name> <operator>||</operator> <call><name>rb_is_absolute_path</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_explicit_relative</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_file_load_ok</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expanded</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>copy_path_class</name><argument_list>(<argument><expr><call><name>file_expand_path_1</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>path</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>load_path</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>rb_get_expanded_load_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>load_path</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_tmp_new</name><argument_list>(<argument><expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>rb_usascii_encindex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>load_path</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>load_path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>rb_get_path</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_file_expand_path_internal</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_file_load_ok</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>found</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return> 

</block_content>}</block></else></if_stmt>

<label><name>found</name>:</label>

<return>return <expr><call><name>copy_path_class</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>define_filetest_function</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_define_module_function</name><argument_list>(<argument><expr><name>rb_mFileTest</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>ruby_null_device</name><index>[]</index></name> <init>=

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>DOSISH</name></expr></cpp:if>

<expr><literal type="string">"NUL"</literal>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>AMIGA</name> <operator>||</operator> <name>defined</name> <name>__amigaos__</name></expr></cpp:elif>

<literal type="string">"NIL"</literal>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__VMS</name></expr></cpp:elif>

<literal type="string">"NL:"</literal>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<literal type="string">"/dev/null"</literal></expr></init></decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

;</decl_stmt>

<function><type><name>void</name></type>

<name>Init_File</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>separator</name></decl>;</decl_stmt>

<expr_stmt><expr><name>rb_mFileTest</name> <operator>=</operator> <call><name>rb_define_module</name><argument_list>(<argument><expr><literal type="string">"FileTest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cFile</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"File"</literal></expr></argument>, <argument><expr><name>rb_cIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"directory?"</literal></expr></argument>, <argument><expr><name>rb_file_directory_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"exist?"</literal></expr></argument>, <argument><expr><name>rb_file_exist_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"exists?"</literal></expr></argument>, <argument><expr><name>rb_file_exists_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"readable?"</literal></expr></argument>, <argument><expr><name>rb_file_readable_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"readable_real?"</literal></expr></argument>, <argument><expr><name>rb_file_readable_real_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"world_readable?"</literal></expr></argument>, <argument><expr><name>rb_file_world_readable_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"writable?"</literal></expr></argument>, <argument><expr><name>rb_file_writable_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"writable_real?"</literal></expr></argument>, <argument><expr><name>rb_file_writable_real_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"world_writable?"</literal></expr></argument>, <argument><expr><name>rb_file_world_writable_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"executable?"</literal></expr></argument>, <argument><expr><name>rb_file_executable_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"executable_real?"</literal></expr></argument>, <argument><expr><name>rb_file_executable_real_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"file?"</literal></expr></argument>, <argument><expr><name>rb_file_file_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"zero?"</literal></expr></argument>, <argument><expr><name>rb_file_zero_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"empty?"</literal></expr></argument>, <argument><expr><name>rb_file_zero_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"size?"</literal></expr></argument>, <argument><expr><name>rb_file_size_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>rb_file_s_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"owned?"</literal></expr></argument>, <argument><expr><name>rb_file_owned_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"grpowned?"</literal></expr></argument>, <argument><expr><name>rb_file_grpowned_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"pipe?"</literal></expr></argument>, <argument><expr><name>rb_file_pipe_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"symlink?"</literal></expr></argument>, <argument><expr><name>rb_file_symlink_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"socket?"</literal></expr></argument>, <argument><expr><name>rb_file_socket_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"blockdev?"</literal></expr></argument>, <argument><expr><name>rb_file_blockdev_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"chardev?"</literal></expr></argument>, <argument><expr><name>rb_file_chardev_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"setuid?"</literal></expr></argument>, <argument><expr><name>rb_file_suid_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"setgid?"</literal></expr></argument>, <argument><expr><name>rb_file_sgid_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"sticky?"</literal></expr></argument>, <argument><expr><name>rb_file_sticky_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_filetest_function</name><argument_list>(<argument><expr><literal type="string">"identical?"</literal></expr></argument>, <argument><expr><name>rb_file_identical_p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"stat"</literal></expr></argument>, <argument><expr><name>rb_file_s_stat</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"lstat"</literal></expr></argument>, <argument><expr><name>rb_file_s_lstat</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"ftype"</literal></expr></argument>, <argument><expr><name>rb_file_s_ftype</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"atime"</literal></expr></argument>, <argument><expr><name>rb_file_s_atime</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"mtime"</literal></expr></argument>, <argument><expr><name>rb_file_s_mtime</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"ctime"</literal></expr></argument>, <argument><expr><name>rb_file_s_ctime</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"birthtime"</literal></expr></argument>, <argument><expr><name>rb_file_s_birthtime</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"utime"</literal></expr></argument>, <argument><expr><name>rb_file_s_utime</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"chmod"</literal></expr></argument>, <argument><expr><name>rb_file_s_chmod</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"chown"</literal></expr></argument>, <argument><expr><name>rb_file_s_chown</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"lchmod"</literal></expr></argument>, <argument><expr><name>rb_file_s_lchmod</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"lchown"</literal></expr></argument>, <argument><expr><name>rb_file_s_lchown</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"lutime"</literal></expr></argument>, <argument><expr><name>rb_file_s_lutime</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"link"</literal></expr></argument>, <argument><expr><name>rb_file_s_link</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"symlink"</literal></expr></argument>, <argument><expr><name>rb_file_s_symlink</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"readlink"</literal></expr></argument>, <argument><expr><name>rb_file_s_readlink</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"unlink"</literal></expr></argument>, <argument><expr><name>rb_file_s_unlink</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>, <argument><expr><name>rb_file_s_unlink</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"rename"</literal></expr></argument>, <argument><expr><name>rb_file_s_rename</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"umask"</literal></expr></argument>, <argument><expr><name>rb_file_s_umask</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"truncate"</literal></expr></argument>, <argument><expr><name>rb_file_s_truncate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"mkfifo"</literal></expr></argument>, <argument><expr><name>rb_file_s_mkfifo</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"expand_path"</literal></expr></argument>, <argument><expr><name>s_expand_path</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"absolute_path"</literal></expr></argument>, <argument><expr><name>s_absolute_path</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"absolute_path?"</literal></expr></argument>, <argument><expr><name>s_absolute_path_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"realpath"</literal></expr></argument>, <argument><expr><name>rb_file_s_realpath</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"realdirpath"</literal></expr></argument>, <argument><expr><name>rb_file_s_realdirpath</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"basename"</literal></expr></argument>, <argument><expr><name>rb_file_s_basename</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"dirname"</literal></expr></argument>, <argument><expr><name>rb_file_s_dirname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"extname"</literal></expr></argument>, <argument><expr><name>rb_file_s_extname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>rb_file_s_path</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>separator</name> <operator>=</operator> <call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"Separator"</literal></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"SEPARATOR"</literal></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"split"</literal></expr></argument>, <argument><expr><name>rb_file_s_split</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"join"</literal></expr></argument>, <argument><expr><name>rb_file_s_join</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DOSISH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"ALT_SEPARATOR"</literal></expr></argument>, <argument><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><call><name>rb_usascii_str_new2</name><argument_list>(<argument><expr><name>file_alt_separator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"ALT_SEPARATOR"</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"PATH_SEPARATOR"</literal></expr></argument>, <argument><expr><call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><name>PATH_SEP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cIO</name></expr></argument>, <argument><expr><literal type="string">"stat"</literal></expr></argument>, <argument><expr><name>rb_io_stat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"lstat"</literal></expr></argument>, <argument><expr><name>rb_file_lstat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"atime"</literal></expr></argument>, <argument><expr><name>rb_file_atime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"mtime"</literal></expr></argument>, <argument><expr><name>rb_file_mtime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"ctime"</literal></expr></argument>, <argument><expr><name>rb_file_ctime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"birthtime"</literal></expr></argument>, <argument><expr><name>rb_file_birthtime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>rb_file_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"chmod"</literal></expr></argument>, <argument><expr><name>rb_file_chmod</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"chown"</literal></expr></argument>, <argument><expr><name>rb_file_chown</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"truncate"</literal></expr></argument>, <argument><expr><name>rb_file_truncate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"flock"</literal></expr></argument>, <argument><expr><name>rb_file_flock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_mFConst</name> <operator>=</operator> <call><name>rb_define_module_under</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"Constants"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cIO</name></expr></argument>, <argument><expr><name>rb_mFConst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"RDONLY"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"WRONLY"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_WRONLY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"RDWR"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"APPEND"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_APPEND</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"CREAT"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_CREAT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"EXCL"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_EXCL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NDELAY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_NONBLOCK</name></cpp:macro> <cpp:value>O_NDELAY</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"NONBLOCK"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"TRUNC"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_TRUNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"NOCTTY"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_NOCTTY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_BINARY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"BINARY"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>O_SHARE_DELETE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_SHARE_DELETE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"SHARE_DELETE"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_SHARE_DELETE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_SYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"SYNC"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_SYNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_DSYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"DSYNC"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_DSYNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_RSYNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"RSYNC"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_RSYNC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NOFOLLOW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"NOFOLLOW"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_NOFOLLOW</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_NOATIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"NOATIME"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_NOATIME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_DIRECT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"DIRECT"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_DIRECT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_TMPFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"TMPFILE"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>O_TMPFILE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"LOCK_SH"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>LOCK_SH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"LOCK_EX"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>LOCK_EX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"LOCK_UN"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>LOCK_UN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"LOCK_NB"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>LOCK_NB</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mFConst</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>, <argument><expr><call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><name>ruby_null_device</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>rb_file_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"to_path"</literal></expr></argument>, <argument><expr><name>rb_file_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_global_function</name><argument_list>(<argument><expr><literal type="string">"test"</literal></expr></argument>, <argument><expr><name>rb_f_test</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cStat</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cFile</name></expr></argument>, <argument><expr><literal type="string">"Stat"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><name>rb_stat_s_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>rb_stat_init</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>, <argument><expr><name>rb_stat_init_copy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><name>rb_mComparable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"&lt;=&gt;"</literal></expr></argument>, <argument><expr><name>rb_stat_cmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"dev"</literal></expr></argument>, <argument><expr><name>rb_stat_dev</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"dev_major"</literal></expr></argument>, <argument><expr><name>rb_stat_dev_major</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"dev_minor"</literal></expr></argument>, <argument><expr><name>rb_stat_dev_minor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"ino"</literal></expr></argument>, <argument><expr><name>rb_stat_ino</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"mode"</literal></expr></argument>, <argument><expr><name>rb_stat_mode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"nlink"</literal></expr></argument>, <argument><expr><name>rb_stat_nlink</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"uid"</literal></expr></argument>, <argument><expr><name>rb_stat_uid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"gid"</literal></expr></argument>, <argument><expr><name>rb_stat_gid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"rdev"</literal></expr></argument>, <argument><expr><name>rb_stat_rdev</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"rdev_major"</literal></expr></argument>, <argument><expr><name>rb_stat_rdev_major</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"rdev_minor"</literal></expr></argument>, <argument><expr><name>rb_stat_rdev_minor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>rb_stat_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"blksize"</literal></expr></argument>, <argument><expr><name>rb_stat_blksize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"blocks"</literal></expr></argument>, <argument><expr><name>rb_stat_blocks</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"atime"</literal></expr></argument>, <argument><expr><name>rb_stat_atime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"mtime"</literal></expr></argument>, <argument><expr><name>rb_stat_mtime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"ctime"</literal></expr></argument>, <argument><expr><name>rb_stat_ctime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"birthtime"</literal></expr></argument>, <argument><expr><name>rb_stat_birthtime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>rb_stat_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"ftype"</literal></expr></argument>, <argument><expr><name>rb_stat_ftype</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"directory?"</literal></expr></argument>, <argument><expr><name>rb_stat_d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"readable?"</literal></expr></argument>, <argument><expr><name>rb_stat_r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"readable_real?"</literal></expr></argument>, <argument><expr><name>rb_stat_R</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"world_readable?"</literal></expr></argument>, <argument><expr><name>rb_stat_wr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"writable?"</literal></expr></argument>, <argument><expr><name>rb_stat_w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"writable_real?"</literal></expr></argument>, <argument><expr><name>rb_stat_W</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"world_writable?"</literal></expr></argument>, <argument><expr><name>rb_stat_ww</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"executable?"</literal></expr></argument>, <argument><expr><name>rb_stat_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"executable_real?"</literal></expr></argument>, <argument><expr><name>rb_stat_X</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"file?"</literal></expr></argument>, <argument><expr><name>rb_stat_f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"zero?"</literal></expr></argument>, <argument><expr><name>rb_stat_z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"size?"</literal></expr></argument>, <argument><expr><name>rb_stat_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"owned?"</literal></expr></argument>, <argument><expr><name>rb_stat_owned</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"grpowned?"</literal></expr></argument>, <argument><expr><name>rb_stat_grpowned</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"pipe?"</literal></expr></argument>, <argument><expr><name>rb_stat_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"symlink?"</literal></expr></argument>, <argument><expr><name>rb_stat_l</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"socket?"</literal></expr></argument>, <argument><expr><name>rb_stat_S</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"blockdev?"</literal></expr></argument>, <argument><expr><name>rb_stat_b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"chardev?"</literal></expr></argument>, <argument><expr><name>rb_stat_c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"setuid?"</literal></expr></argument>, <argument><expr><name>rb_stat_suid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"setgid?"</literal></expr></argument>, <argument><expr><name>rb_stat_sgid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cStat</name></expr></argument>, <argument><expr><literal type="string">"sticky?"</literal></expr></argument>, <argument><expr><name>rb_stat_sticky</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
