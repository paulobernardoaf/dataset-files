<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\iseq.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_VM_INSNS_INFO</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DLADDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval_intern.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id_table.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/bits.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compile.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/file.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/parse.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/sanitizers.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/symbol.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/variable.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iseq.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mjit.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_callinfo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"insns.inc"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"insns_info.inc"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cISeq</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>iseqw_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseqw_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>iseqw</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>succ_index_table</name></name> <modifier>*</modifier></type><name>succ_index_table_create</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max_pos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>succ_index_table_invert</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max_pos</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>succ_index_table</name></name> <modifier>*</modifier></type><name>sd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>succ_index_lookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>succ_index_table</name></name> <modifier>*</modifier></type><name>sd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hidden_obj_p</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!SPECIAL_CONST_P(obj) &amp;&amp; !RBASIC(obj)-&gt;klass)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>obj_resurrect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>hidden_obj_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_STRING</name></expr>:</case>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_str_resurrect</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_ARRAY</name></expr>:</case>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_ary_resurrect</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>T_HASH</name></expr>:</case>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_hash_resurrect</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>free_arena</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier></type><name>cur</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>cur</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>compile_data_free</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iseq_compile_data</name></name> <modifier>*</modifier></type><name>compile_data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>compile_data</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free_arena</name><argument_list>(<argument><expr><name><name>compile_data</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>storage_head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_arena</name><argument_list>(<argument><expr><name><name>compile_data</name><operator>-&gt;</operator><name>insn</name><operator>.</operator><name>storage_head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>compile_data</name><operator>-&gt;</operator><name>ivar_cache_table</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_id_table_free</name><argument_list>(<argument><expr><name><name>compile_data</name><operator>-&gt;</operator><name>ivar_cache_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>compile_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_free</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_FREE_ENTER</name><argument_list>(<argument><expr><literal type="string">"iseq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>iseq</name> <operator>&amp;&amp;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mjit_free_iseq</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>succ_index_table</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>succ_index_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>local_table</name></name> <operator>!=</operator> <name>rb_iseq_shared_exc_local_tbl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>local_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>is_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>call_data</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>call_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>default_values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>compile_data_free</name><argument_list>(<argument><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>iseq</name> <operator>&amp;&amp;</operator> <call><name>ISEQ_EXECUTABLE_P</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hook_list_free</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_FREE_LEAVE</name><argument_list>(<argument><expr><literal type="string">"iseq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DIRECT_THREADED_CODE</name> <operator>||</operator> <name>OPT_CALL_THREADED_CODE</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_vm_insn_addr2insn2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_vm_insn_addr2insn</name><argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_vm_insn_null_translator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>addr</name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>VALUE</name></type> <name>iseq_value_itr_t</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>VALUE</name></type> <name>rb_vm_insns_translator_t</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_extract_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>iseq_value_itr_t</name> <modifier>*</modifier></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>rb_vm_insns_translator_t</name> <modifier>*</modifier></type> <name>translator</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>insn</name> <init>= <expr><call><name>translator</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>code</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>op_no</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>op_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>types</name><index>[<expr><name>op_no</name></expr>]</index></name></expr>;</condition> <incr><expr><name>op_no</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>type</name> <init>= <expr><name><name>types</name><index>[<expr><name>op_no</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_CDHASH</name></expr>:</case>

<case>case <expr><name>TS_ISEQ</name></expr>:</case>

<case>case <expr><name>TS_VALUE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>op</name> <init>= <expr><name><name>code</name><index>[<expr><name>pos</name> <operator>+</operator> <name>op_no</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>newop</name> <init>= <expr><call><name>func</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>newop</name> <operator>!=</operator> <name>op</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>code</name><index>[<expr><name>pos</name> <operator>+</operator> <name>op_no</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newop</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_ISE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name><name>union</name> <name>iseq_inline_storage_entry</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>is</name> <init>= <expr><operator>(</operator>union <name>iseq_inline_storage_entry</name> <operator>*</operator><operator>)</operator><name><name>code</name><index>[<expr><name>pos</name> <operator>+</operator> <name>op_no</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>value</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>nv</name> <init>= <expr><call><name>func</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>value</name></name> <operator>!=</operator> <name>nv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>once</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>nv</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_iseq_each_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>iseq_value_itr_t</name> <modifier>*</modifier></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_vm_insns_translator_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>translator</name> <init>=

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>OPT_DIRECT_THREADED_CODE</name> <operator>||</operator> <name>OPT_CALL_THREADED_CODE</name></expr></condition></ternary></expr></cpp:if>

<expr><ternary><condition><expr><operator>(</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_TRANSLATED</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>rb_vm_insn_addr2insn2</name></expr> </then><else>:

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>rb_vm_insn_null_translator</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>size</name></expr>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>iseq_extract_values</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>translator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>update_each_insn_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_gc_location</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_update_references</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>variable</name><operator>.</operator><name>coverage</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>variable</name><operator>.</operator><name>coverage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>variable</name><operator>.</operator><name>pc2branchindex</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>variable</name><operator>.</operator><name>pc2branchindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>base_label</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>base_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>=</operator> <operator>(</operator>struct <name>rb_iseq_struct</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name> <operator>=</operator> <operator>(</operator>struct <name>rb_iseq_struct</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>call_data</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cds</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>call_data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name> <operator>=</operator> <operator>(</operator>struct <name>rb_callinfo</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name> <operator>=</operator> <operator>(</operator>struct <name>rb_callcache</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_MARKABLE_ISEQ</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_iseq_each_value</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>update_each_insn_value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>original_iseq</name> <init>= <expr><call><name>ISEQ_ORIGINAL_ISEQ</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>original_iseq</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>size</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>iseq_extract_values</name><argument_list>(<argument><expr><name>original_iseq</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>update_each_insn_value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rb_vm_insn_null_translator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>&amp;&amp;</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>required_num</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>default_values</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name><operator>-&gt;</operator><name>default_values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_catch_table_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name> <operator>=</operator> <operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><call><name>rb_gc_location</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_MJIT</name></expr></cpp:if>

<expr_stmt><expr><call><name>mjit_update_references</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>each_insn_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RUBY_MARK_ENTER</name><argument_list>(<argument><expr><literal type="string">"iseq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>wrapper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_MARKABLE_ISEQ</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_iseq_each_value</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>each_insn_value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>variable</name><operator>.</operator><name>coverage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>variable</name><operator>.</operator><name>pc2branchindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>base_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_MOVABLE_UNLESS_NULL</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>call_data</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cds</name> <init>= <expr><operator>(</operator>struct <name>rb_call_data</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>call_data</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callcache</name></name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&amp;&amp;</operator> <call><name>vm_cc_markable</name><argument_list>(<argument><expr><name><name>cds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>&amp;&amp;</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>keyword</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>keyword</name><operator>-&gt;</operator><name>required_num</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>keyword</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><name><name>keyword</name><operator>-&gt;</operator><name>default_values</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table</name></name> <modifier>*</modifier></type><name>table</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_MJIT</name></expr></cpp:if>

<expr_stmt><expr><call><name>mjit_mark_cc_entries</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_NOT_LOADED_YET</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>loader</name><operator>.</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ISEQ_USE_COMPILE_DATA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_compile_data</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>compile_data</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_iseq_mark_insn_storage</name><argument_list>(<argument><expr><name><name>compile_data</name><operator>-&gt;</operator><name>insn</name><operator>.</operator><name>storage_head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_UNLESS_NULL</name><argument_list>(<argument><expr><name><name>compile_data</name><operator>-&gt;</operator><name>err_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name><name>compile_data</name><operator>-&gt;</operator><name>catch_table_ary</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>compile_data</name><operator>-&gt;</operator><name>catch_table_ary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>compile_data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>ISEQ_EXECUTABLE_P</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hook_list_mark</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RUBY_MARK_LEAVE</name><argument_list>(<argument><expr><literal type="string">"iseq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>param_keyword_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier></type><name>pkw</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pkw</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>size</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_iseq_param_keyword</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>pkw</name><operator>-&gt;</operator><name>num</name></name> <operator>-</operator> <name><name>pkw</name><operator>-&gt;</operator><name>required_num</name></name><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type>

<name>rb_iseq_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_compile_data</name></name> <modifier>*</modifier></type><name>compile_data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISEQ_EXECUTABLE_P</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>body</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_iseq_constant_body</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name> <operator>*</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>iseq_insn_info_entry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>iseq_catch_table_bytes</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>param_keyword_size</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>body</name><operator>-&gt;</operator><name>is_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>union <name>iseq_inline_storage_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>body</name><operator>-&gt;</operator><name>ci_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>rb_call_data</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>compile_data</name> <operator>=</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>compile_data</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>iseq_compile_data</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>compile_data</name><operator>-&gt;</operator><name>node</name><operator>.</operator><name>storage_head</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>cur</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>cur</name><operator>-&gt;</operator><name>size</name></name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr>struct <name>iseq_compile_data_storage</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>uintptr_t</name></type> <name>fresh_iseq_unique_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<function><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type>

<name>rb_iseq_constant_body_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>iseq_body</name></decl>;</decl_stmt>

<expr_stmt><expr><name>iseq_body</name> <operator>=</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr>struct <name>rb_iseq_constant_body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>iseq_unique_id</name></name> <operator>=</operator> <name>fresh_iseq_unique_id</name><operator>++</operator></expr>;</expr_stmt> 

<return>return <expr><name>iseq_body</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>iseq_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>iseq_imemo_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name> <operator>=</operator> <call><name>rb_iseq_constant_body_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_pathobj_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pathobj</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>realpath</name> <operator>==</operator> <name>Qnil</name> <operator>||</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>realpath</name> <operator>||</operator>

<operator>(</operator><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rb_str_cmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pathobj</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>realpath</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pathobj</name> <operator>=</operator> <call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>pathobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>pathobj</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_pathobj_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>,

<argument><expr><call><name>rb_iseq_pathobj_new</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_iseq_location_t</name> <modifier>*</modifier></type>

<name>iseq_location_setup</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>first_lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_code_location_t</name> <modifier>*</modifier></type><name>code_location</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>node_id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_location_t</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><operator>&amp;</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_iseq_pathobj_set</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>loc</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>loc</name><operator>-&gt;</operator><name>base_label</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>loc</name><operator>-&gt;</operator><name>first_lineno</name></name> <operator>=</operator> <name>first_lineno</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>code_location</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>loc</name><operator>-&gt;</operator><name>node_id</name></name> <operator>=</operator> <name>node_id</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>loc</name><operator>-&gt;</operator><name>code_location</name></name> <operator>=</operator> <operator>*</operator><name>code_location</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>loc</name><operator>-&gt;</operator><name>code_location</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>loc</name><operator>-&gt;</operator><name>code_location</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>column</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>loc</name><operator>-&gt;</operator><name>code_location</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>loc</name><operator>-&gt;</operator><name>code_location</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>column</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>loc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>set_relation</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>piseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>type</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ISEQ_TYPE_TOP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>=</operator> <name>iseq</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>ISEQ_TYPE_METHOD</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>ISEQ_TYPE_CLASS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>=</operator> <name>iseq</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>piseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>=</operator> <name><name>piseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>piseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name> <operator>=</operator> <name>piseq</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ISEQ_TYPE_MAIN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>=</operator> <name>iseq</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier></type>

<name>new_arena</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data_storage</name></name> <modifier>*</modifier></type> <name>new_arena</name> <init>=

<expr><operator>(</operator>struct <name>iseq_compile_data_storage</name> <operator>*</operator><operator>)</operator>

<call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>INITIAL_ISEQ_COMPILE_DATA_STORAGE_BUFF_SIZE</name> <operator>+</operator>

<call><name>offsetof</name><argument_list>(<argument><expr>struct <name>iseq_compile_data_storage</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>new_arena</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_arena</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_arena</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>INITIAL_ISEQ_COMPILE_DATA_STORAGE_BUFF_SIZE</name></expr>;</expr_stmt>

<return>return <expr><name>new_arena</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>prepare_iseq_build</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>first_lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_code_location_t</name> <modifier>*</modifier></type><name>code_location</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>node_id</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>iseq_type</name></name></type> <name>type</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_compile_option_t</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>coverage</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>err_info</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>==</operator> <name>ISEQ_TYPE_MAIN</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>ISEQ_TYPE_TOP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>err_info</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_relation</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_location_setup</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>, <argument><expr><name>first_lineno</name></expr></argument>, <argument><expr><name>code_location</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>iseq</name> <operator>!=</operator> <name><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>base_label</name></name></expr></argument>, <argument><expr><name><name>body</name><operator>-&gt;</operator><name>local_iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ISEQ_COVERAGE_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_ORIGINAL_ISEQ_CLEAR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>variable</name><operator>.</operator><name>flip_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA_ALLOC</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>err_info</name></expr></argument>, <argument><expr><name>err_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>catch_table_ary</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>node</name><operator>.</operator><name>storage_head</name></name> <operator>=</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>node</name><operator>.</operator><name>storage_current</name></name> <operator>=</operator> <call><name>new_arena</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>insn</name><operator>.</operator><name>storage_head</name></name> <operator>=</operator> <call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>insn</name><operator>.</operator><name>storage_current</name></name> <operator>=</operator> <call><name>new_arena</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>option</name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ivar_cache_table</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>builtin_function_table</name> <operator>=</operator> <call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>builtin_function_table</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>option</name><operator>-&gt;</operator><name>coverage_enabled</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>coverages</name> <init>= <expr><call><name>rb_get_coverages</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>coverages</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>coverage</name> <operator>=</operator> <call><name>rb_hash_lookup</name><argument_list>(<argument><expr><name>coverages</name></expr></argument>, <argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>coverage</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>coverage</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ISEQ_COVERAGE_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>coverage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>coverage</name> <operator>&amp;&amp;</operator> <call><name>ISEQ_BRANCH_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ISEQ_PC2BRANCHINDEX_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>VM_INSN_INFO_TABLE_IMPL</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validate_get_insn_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_iseq_insns_info_encode_positions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_pos</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>succ_index_table</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>succ_index_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>succ_index_table</name></name> <operator>=</operator> <call><name>succ_index_table_create</name><argument_list>(<argument><expr><name>max_pos</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>==</operator> <literal type="number">0</literal></expr></cpp:if>

<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>

<function><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type>

<name>rb_iseq_insns_info_decode_positions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier></type><name>body</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_pos</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>succ_index_table</name></name> <modifier>*</modifier></type><name>sd</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>succ_index_table</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>succ_index_table_invert</name><argument_list>(<argument><expr><name>max_pos</name></expr></argument>, <argument><expr><name>sd</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_iseq_init_trace</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>global_trace_events</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ruby_vm_event_enabled_global_flags</name> <operator>&amp;</operator> <name>ISEQ_TRACE_EVENTS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_iseq_trace_set</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ruby_vm_event_enabled_global_flags</name> <operator>&amp;</operator> <name>ISEQ_TRACE_EVENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>finish_iseq_build</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_compile_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>ISEQ_COMPILE_DATA</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>err</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>err_info</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ISEQ_COMPILE_DATA_CLEAR</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_data_free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if> 

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>succ_index_table</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_iseq_insns_info_encode_positions</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>VM_INSN_INFO_TABLE_IMPL</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<expr_stmt><expr><call><name>validate_get_insn_info</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>pathobj_path</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>Qtrue</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>rb_exc_new_cstr</name><argument_list>(<argument><expr><name>rb_eSyntaxError</name></expr></argument>, <argument><expr><literal type="string">"compile error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"set_backtrace"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>iseq_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_ADD</name><argument_list>(<argument><expr><name>iseq_cd_num</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>ci_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_iseq_init_trace</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>rb_compile_option_t</name></type> <name>COMPILE_OPTION_DEFAULT</name> <init>= <expr><block>{

<expr><name>OPT_INLINE_CONST_CACHE</name></expr>, 

<expr><name>OPT_PEEPHOLE_OPTIMIZATION</name></expr>, 

<expr><name>OPT_TAILCALL_OPTIMIZATION</name></expr>, 

<expr><name>OPT_SPECIALISED_INSTRUCTION</name></expr>, 

<expr><name>OPT_OPERANDS_UNIFICATION</name></expr>, 

<expr><name>OPT_INSTRUCTIONS_UNIFICATION</name></expr>, 

<expr><name>OPT_STACK_CACHING</name></expr>, 

<expr><name>OPT_FROZEN_STRING_LITERAL</name></expr>,

<expr><name>OPT_DEBUG_FROZEN_STRING_LITERAL</name></expr>,

<expr><name>TRUE</name></expr>, 

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_compile_option_t</name></type> <name>COMPILE_OPTION_FALSE</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>set_compile_option_from_hash</name><parameter_list>(<parameter><decl><type><name>rb_compile_option_t</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_COMPILE_OPTION</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>h</name></type></parameter>, <parameter><type><name>mem</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ VALUE flag = rb_hash_aref((h), ID2SYM(rb_intern(#mem))); if (flag == Qtrue) { (o)-&gt;mem = 1; } else if (flag == Qfalse) { (o)-&gt;mem = 0; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_COMPILE_OPTION_NUM</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>h</name></type></parameter>, <parameter><type><name>mem</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ VALUE num = rb_hash_aref(opt, ID2SYM(rb_intern(#mem))); if (!NIL_P(num)) (o)-&gt;mem = NUM2INT(num); }</cpp:value></cpp:define>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>inline_const_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>peephole_optimization</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>tailcall_optimization</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>specialized_instruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>operands_unification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>instructions_unification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>stack_caching</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>frozen_string_literal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>debug_frozen_string_literal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>coverage_enabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION_NUM</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>debug_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_COMPILE_OPTION</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_COMPILE_OPTION_NUM</name></cpp:undef>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_iseq_make_compile_option</name><parameter_list>(<parameter><decl><type><name>rb_compile_option_t</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_compile_option_from_hash</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>make_compile_option</name><parameter_list>(<parameter><decl><type><name>rb_compile_option_t</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>option</name> <operator>=</operator> <name>COMPILE_OPTION_DEFAULT</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>opt</name> <operator>==</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>option</name> <operator>=</operator> <name>COMPILE_OPTION_FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>opt</name> <operator>==</operator> <name>Qtrue</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>rb_compile_option_t</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>option</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>option</name> <operator>=</operator> <name>COMPILE_OPTION_DEFAULT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_compile_option_from_hash</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"Compile option must be Hash/true/false/nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>make_compile_option_value</name><parameter_list>(<parameter><decl><type><name>rb_compile_option_t</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opt</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_COMPILE_OPTION</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>h</name></type></parameter>, <parameter><type><name>mem</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_hash_aset((h), ID2SYM(rb_intern(#mem)), (o)-&gt;mem ? Qtrue : Qfalse)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_COMPILE_OPTION_NUM</name><parameter_list>(<parameter><type><name>o</name></type></parameter>, <parameter><type><name>h</name></type></parameter>, <parameter><type><name>mem</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_hash_aset((h), ID2SYM(rb_intern(#mem)), INT2NUM((o)-&gt;mem))</cpp:value></cpp:define>

<block>{<block_content>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>inline_const_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>peephole_optimization</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>tailcall_optimization</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>specialized_instruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>operands_unification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>instructions_unification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>stack_caching</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>frozen_string_literal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>debug_frozen_string_literal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>coverage_enabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_COMPILE_OPTION_NUM</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><name>debug_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_COMPILE_OPTION</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_COMPILE_OPTION_NUM</name></cpp:undef>

<return>return <expr><name>opt</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_ast_body_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>iseq_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_new_with_opt</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>COMPILE_OPTION_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_new_top</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_ast_body_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>coverages</name> <init>= <expr><call><name>rb_get_coverages</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>coverages</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ast</name><operator>-&gt;</operator><name>line_count</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>rb_get_coverage_mode</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>COVERAGE_TARGET_ONESHOT_LINES</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>ast</name><operator>-&gt;</operator><name>line_count</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>coverage</name> <init>= <expr><call><name>rb_default_coverage</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>coverages</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>coverage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_iseq_new_with_opt</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>ISEQ_TYPE_TOP</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>COMPILE_OPTION_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_new_main</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_ast_body_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_new_with_opt</name><argument_list>(<argument><expr><name>ast</name></expr></argument>, <argument><expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"&lt;main&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>ISEQ_TYPE_MAIN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>COMPILE_OPTION_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>iseq_translate</name><parameter_list>(<parameter><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_respond_to</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"translate"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v1</name> <init>= <expr><call><name>iseqw_new</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v2</name> <init>= <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"translate"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>!=</operator> <name>v2</name> <operator>&amp;&amp;</operator> <call><name>CLASS_OF</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cISeq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><call><name>iseqw_check</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_new_with_opt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_ast_body_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>first_lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>iseq_type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_compile_option_t</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>NODE</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><ternary><condition><expr><name>ast</name></expr> ?</condition><then> <expr><name><name>ast</name><operator>-&gt;</operator><name>root</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>iseq_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_compile_option_t</name></type> <name>new_opt</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>option</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>new_opt</name> <operator>=</operator> <operator>*</operator><name>option</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>new_opt</name> <operator>=</operator> <name>COMPILE_OPTION_DEFAULT</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ast</name> <operator>&amp;&amp;</operator> <name><name>ast</name><operator>-&gt;</operator><name>compile_option</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_iseq_make_compile_option</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_opt</name></expr></argument>, <argument><expr><name><name>ast</name><operator>-&gt;</operator><name>compile_option</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>prepare_iseq_build</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>, <argument><expr><name>first_lineno</name></expr></argument>, <argument><expr><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>nd_loc</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>node</name></expr> ?</condition><then> <expr><call><name>nd_node_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_iseq_compile_node</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>finish_iseq_build</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>iseq_translate</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_new_with_callback</name><parameter_list>(

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_new_with_callback_callback_func</name></name> <modifier>*</modifier></type> <name>ifunc</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>first_lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>iseq_type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_compile_option_t</name> <modifier>*</modifier></type><name>option</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>iseq_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>option</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>option</name> <operator>=</operator> <operator>&amp;</operator><name>COMPILE_OPTION_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>prepare_iseq_build</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>, <argument><expr><name>first_lineno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_iseq_compile_callback</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>ifunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>finish_iseq_build</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>iseq_translate</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_load_iseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>iseqv</name> <init>= <expr><call><name>rb_check_funcall</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"load_iseq"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>iseqv</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>iseqv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cISeq</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>iseqv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ARRAY</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_to_array_type(v)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_HASH</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_to_hash_type(v)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STRING</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_str_to_str(v)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_SYMBOL</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_to_symbol_type(v)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type> <name>CHECK_INTEGER</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content><expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>v</name></expr>;</return></block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>iseq_type</name></name></type>

<name>iseq_type_from_sym</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_top</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"top"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_method</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"method"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_block</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"block"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_class</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"class"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_rescue</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"rescue"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_ensure</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"ensure"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_eval</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"eval"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_main</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id_plain</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"plain"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>typeid</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>id_top</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ISEQ_TYPE_TOP</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>id_method</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ISEQ_TYPE_METHOD</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>id_block</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ISEQ_TYPE_BLOCK</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>id_class</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ISEQ_TYPE_CLASS</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>id_rescue</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ISEQ_TYPE_RESCUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>id_ensure</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ISEQ_TYPE_ENSURE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>id_eval</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ISEQ_TYPE_EVAL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>id_main</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ISEQ_TYPE_MAIN</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>id_plain</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ISEQ_TYPE_PLAIN</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator>enum <name>iseq_type</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseq_load</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>iseq_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>magic</name></decl>, <decl><type ref="prev"/><name>version1</name></decl>, <decl><type ref="prev"/><name>version2</name></decl>, <decl><type ref="prev"/><name>format_type</name></decl>, <decl><type ref="prev"/><name>misc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name></decl>, <decl><type ref="prev"/><name>path</name></decl>, <decl><type ref="prev"/><name>realpath</name></decl>, <decl><type ref="prev"/><name>first_lineno</name></decl>, <decl><type ref="prev"/><name>code_location</name></decl>, <decl><type ref="prev"/><name>node_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>body</name></decl>, <decl><type ref="prev"/><name>locals</name></decl>, <decl><type ref="prev"/><name>params</name></decl>, <decl><type ref="prev"/><name>exception</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>iseq_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_compile_option_t</name></type> <name>option</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_code_location_t</name></type> <name>tmp_loc</name> <init>= <expr><block>{ <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>, <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>CHECK_ARRAY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>magic</name> <operator>=</operator> <call><name>CHECK_STRING</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>version1</name> <operator>=</operator> <call><name>CHECK_INTEGER</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>version2</name> <operator>=</operator> <call><name>CHECK_INTEGER</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>format_type</name> <operator>=</operator> <call><name>CHECK_INTEGER</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>misc</name> <operator>=</operator> <call><name>CHECK_HASH</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator><name>magic</name><operator>,</operator> <operator>(</operator><name>void</name><operator>)</operator><name>version1</name><operator>,</operator> <operator>(</operator><name>void</name><operator>)</operator><name>version2</name><operator>,</operator> <operator>(</operator><name>void</name><operator>)</operator><name>format_type</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>CHECK_STRING</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>CHECK_STRING</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>realpath</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>realpath</name> <operator>=</operator> <ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><call><name>CHECK_STRING</name><argument_list>(<argument><expr><name>realpath</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>first_lineno</name> <operator>=</operator> <call><name>CHECK_INTEGER</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>CHECK_SYMBOL</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>locals</name> <operator>=</operator> <call><name>CHECK_ARRAY</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>CHECK_HASH</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exception</name> <operator>=</operator> <call><name>CHECK_ARRAY</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>CHECK_ARRAY</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name></name> <operator>=</operator> <name>iseq</name></expr>;</expr_stmt>

<expr_stmt><expr><name>iseq_type</name> <operator>=</operator> <call><name>iseq_type_from_sym</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>iseq_type</name> <operator>==</operator> <operator>(</operator>enum <name>iseq_type</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"unsupported type: :%"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>node_id</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>misc</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"node_id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>code_location</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>misc</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"code_location"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>code_location</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>code_location</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tmp_loc</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>code_location</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp_loc</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>column</name></name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>code_location</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp_loc</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>lineno</name></name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>code_location</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp_loc</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>column</name></name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>code_location</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>make_compile_option</name><argument_list>(<argument><expr><operator>&amp;</operator><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>option</name><operator>.</operator><name>peephole_optimization</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>prepare_iseq_build</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>, <argument><expr><name>first_lineno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_loc</name></expr></argument>, <argument><expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>(</operator>enum <name>iseq_type</name><operator>)</operator><name>iseq_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_iseq_build_from_ary</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>misc</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>exception</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>finish_iseq_build</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>iseqw_new</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseq_s_load</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>data</name></decl>, <decl><type ref="prev"/><name>opt</name><init>=<expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>iseq_load</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_load</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>iseq_load</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>RTEST</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>parent</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseq_compile_with_option</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>realpath</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_compile_option_t</name></type> <name>option</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>__GNUC__</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>__GNUC_MINOR__</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIALIZED</name></cpp:macro> <cpp:value>volatile</cpp:value></cpp:define> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIALIZED</name></cpp:macro></cpp:define> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>rb_ast_t</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>parse</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>vparser</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>fname</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>int</name></type> <name>ln</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_ast_t</name> <modifier>*</modifier><name>INITIALIZED</name></type> <name>ast</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>make_compile_option</name><argument_list>(<argument><expr><operator>&amp;</operator><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>T_FILE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>parse</name> <operator>=</operator> <name>rb_parser_compile_file_path</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>parse</name> <operator>=</operator> <name>rb_parser_compile_string_path</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>parser</name> <init>= <expr><call><name>rb_parser_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"&lt;compiled&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>outer_scope</name> <init>= <expr><call><name>rb_iseq_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ISEQ_TYPE_TOP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>outer_scope_v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>outer_scope</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_parser_set_context</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>outer_scope</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>outer_scope_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ast</name> <operator>=</operator> <call>(<modifier>*</modifier><name>parse</name>)<argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ast</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>root</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ast_dispose</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>errinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>INITIALIZED</name> <name>VALUE</name></type> <name>label</name> <init>= <expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"&lt;compiled&gt;"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>rb_iseq_new_with_opt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ast</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>realpath</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ISEQ_TYPE_TOP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ast_dispose</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>pathobj_path</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_realpath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>pathobj_realpath</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>pathobj</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_absolute_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_realpath</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_label</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_base_label</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>base_label</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_first_lineno</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_method_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_METHOD</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>base_label</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_code_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>beg_pos_lineno</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>beg_pos_column</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>end_pos_lineno</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>end_pos_column</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_code_location_t</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><operator>&amp;</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>beg_pos_lineno</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>beg_pos_lineno</name> <operator>=</operator> <name><name>loc</name><operator>-&gt;</operator><name>beg_pos</name><operator>.</operator><name>lineno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>beg_pos_column</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>beg_pos_column</name> <operator>=</operator> <name><name>loc</name><operator>-&gt;</operator><name>beg_pos</name><operator>.</operator><name>column</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>end_pos_lineno</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>end_pos_lineno</name> <operator>=</operator> <name><name>loc</name><operator>-&gt;</operator><name>end_pos</name><operator>.</operator><name>lineno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>end_pos_column</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>end_pos_column</name> <operator>=</operator> <name><name>loc</name><operator>-&gt;</operator><name>end_pos</name><operator>.</operator><name>column</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_coverage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>ISEQ_COVERAGE</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>remove_coverage_i</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vstart</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vend</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>vstart</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>v</name> <operator>!=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>vend</name></expr>;</condition> <incr><expr><name>v</name> <operator>+=</operator> <name>stride</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_iseq</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ISEQ_COVERAGE_SET</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>asan_poison_object_if</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_remove_coverage_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_objspace_each_objects</name><argument_list>(<argument><expr><name>remove_coverage_i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>iseqw_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>iseqw_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_memsize</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>iseqw_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"T_IMEMO/iseq"</literal></expr>,

<expr><block>{<expr><name>iseqw_mark</name></expr>, <expr><name>NULL</name></expr>, <expr><name>iseqw_memsize</name></expr>,}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name><operator>|</operator><name>RUBY_TYPED_WB_PROTECTED</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>wrapper</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>iseq</name><operator>-&gt;</operator><name>wrapper</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<union>union <block>{ <decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt> }</block> <decl><name>deconst</name></decl>;</union>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>deconst</name><operator>.</operator><name>in</name></name> <operator>=</operator> <name>iseq</name></expr>;</expr_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iseqw_data_type</name></expr></argument>, <argument><expr><name><name>deconst</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iseq</name><operator>-&gt;</operator><name>wrapper</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_FREEZE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseqw_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>iseqw_new</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_s_compile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>src</name></decl>, <decl><type ref="prev"/><name>file</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>path</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>line</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>opt</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"1*:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">4</literal><operator>+</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_error_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>opt</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>path</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>file</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"&lt;compiled&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name> <operator>=</operator> <name>file</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>iseqw_new</name><argument_list>(<argument><expr><call><name>rb_iseq_compile_with_option</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_s_compile_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>file</name></decl>, <decl><type ref="prev"/><name>line</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>opt</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>parser</name></decl>, <decl><type ref="prev"/><name>f</name></decl>, <decl><type ref="prev"/><name>exc</name> <init>= <expr><name>Qnil</name></expr></init></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_ast_t</name> <modifier>*</modifier></type><name>ast</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_compile_option_t</name></type> <name>option</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"1*:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>file</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>+</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_error_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>opt</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>FilePathValue</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>rb_file_open_str</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>parser</name> <operator>=</operator> <call><name>rb_parser_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_parser_set_context</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ast</name> <operator>=</operator> <call><name>rb_parser_compile_file_path</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ast</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>root</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>errinfo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_io_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ast</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>root</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ast_dispose</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>make_compile_option</name><argument_list>(<argument><expr><operator>&amp;</operator><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>iseqw_new</name><argument_list>(<argument><expr><call><name>rb_iseq_new_with_opt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ast</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"&lt;main&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>file</name></expr></argument>,

<argument><expr><call><name>rb_realpath_internal</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>line</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ISEQ_TYPE_TOP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ast_dispose</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_s_compile_option_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_compile_option_t</name></type> <name>option</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>make_compile_option</name><argument_list>(<argument><expr><operator>&amp;</operator><name>option</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>COMPILE_OPTION_DEFAULT</name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>

<return>return <expr><name>opt</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_s_compile_option_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>make_compile_option_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>COMPILE_OPTION_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>iseqw_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>iseqw</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>iseqw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ibf_load_iseq_complete</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized InstructionSequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>iseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type>

<name>rb_iseqw_to_iseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>iseqw</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>iseqw</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_eval</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_eval</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>rb_class_name</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": uninitialized&gt;"</literal></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"&lt;%"</literal><name>PRIsVALUE</name><literal type="string">":%"</literal><name>PRIsVALUE</name><literal type="string">"@%"</literal><name>PRIsVALUE</name><literal type="string">":%d&gt;"</literal></expr></argument>,

<argument><expr><name>klass</name></expr></argument>,

<argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>, <argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>rb_iseq_first_lineno</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_absolute_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_realpath</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_label</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_label</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_base_label</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_base_label</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_first_lineno</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_first_lineno</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>iseq_data_to_ary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_to_a</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>iseq_data_to_ary</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if> 

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type>

<name>get_insn_info_binary_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>insns_info</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>debug</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"size: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"insns_info[%"</literal><name>PRIuSIZE</name><literal type="string">"]: position: %d, line: %d, pos: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>positions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>insns_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>line_no</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>l</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>r</name> <init>= <expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>l</name> <operator>&lt;=</operator> <name>r</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>m</name> <init>= <expr><name>l</name> <operator>+</operator> <operator>(</operator><name>r</name> <operator>-</operator> <name>l</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>positions</name><index>[<expr><name>m</name></expr>]</index></name> <operator>==</operator> <name>pos</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><name>m</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>positions</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&lt;</operator> <name>pos</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <name>m</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><name>size</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>positions</name><index>[<expr><name>l</name></expr>]</index></name> <operator>&gt;</operator> <name>pos</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><name>l</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><name>l</name></expr>]</index></name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type>

<name>get_insn_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>get_insn_info_binary_search</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if> 

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type>

<name>get_insn_info_succinct_bitvector</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>insns_info</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>debug</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"size: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"insns_info[%"</literal><name>PRIuSIZE</name><literal type="string">"]: position: %d, line: %d, pos: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>positions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>insns_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>line_no</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"size: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"insns_info[%"</literal><name>PRIuSIZE</name><literal type="string">"]: line: %d, pos: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>insns_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>line_no</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>succ_index_table</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>succ_index_lookup</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>succ_index_table</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><name>index</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type>

<name>get_insn_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>get_insn_info_succinct_bitvector</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type>

<name>get_insn_info_linear_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>insns_info</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>positions</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>debug</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"size: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"insns_info[%"</literal><name>PRIuSIZE</name><literal type="string">"]: position: %d, line: %d, pos: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>insns_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line_no</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>debug</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"insns_info[%"</literal><name>PRIuSIZE</name><literal type="string">"]: position: %d, line: %d, pos: %"</literal><name>PRIuSIZE</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>insns_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>line_no</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>pos</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>pos</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<return>return <expr><operator>&amp;</operator><name><name>insns_info</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">0</literal></expr></cpp:if> 

<function><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type>

<name>get_insn_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>get_insn_info_linear_search</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_CHECK_MODE</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>VM_INSN_INFO_TABLE_IMPL</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>validate_get_insn_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_insn_info_linear_search</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>get_insn_info</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"validate_get_insn_info: get_insn_info_linear_search(iseq, %"</literal><name>PRIuSIZE</name><literal type="string">") != get_insn_info(iseq, %"</literal><name>PRIuSIZE</name><literal type="string">")"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>unsigned</name> <name>int</name></type>

<name>rb_iseq_line_no</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>get_insn_info</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>line_no</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>rb_event_flag_t</name></type>

<name>rb_iseq_event_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>get_insn_info</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>events</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_clear_event_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>reset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator>struct <name>iseq_insn_info_entry</name> <operator>*</operator><operator>)</operator><call><name>get_insn_info</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;=</operator> <operator>~</operator><name>reset</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>events</name></name> <operator>&amp;</operator> <name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>global_trace_events</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>void</name></type> <name>rb_iseq_trace_flag_cleared</name><argument_list>(<argument><expr><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><name>iseq</name></expr></argument>, <argument><expr><name>size_t</name> <name>pos</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_iseq_trace_flag_cleared</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>local_var_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>diseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>lid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>diseq</name> <operator>=</operator> <name><name>diseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>parent_iseq</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>diseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>op</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>lid</name> <operator>=</operator> <name><name>diseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_id2str</name><argument_list>(<argument><expr><name>lid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_str_symname_p</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_str_inspect</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"@%d"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><name>int</name></type> <name>rb_insn_unified_local_var_level</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>VALUE</name></type>

<name>rb_insn_operand_intern</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>insn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op_no</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>op</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>pnop</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>child</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>type</name> <init>= <expr><name><name>types</name><index>[<expr><name>op_no</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><name>Qundef</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_OFFSET</name></expr>:</case> 

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%"</literal><name>PRIdVALUE</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>(</operator><name>pos</name> <operator>+</operator> <name>len</name> <operator>+</operator> <name>op</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_NUM</name></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name>insn</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>defined</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>op_no</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>enum</name> <name>defined_type</name></name></type> <name>deftype</name> <init>= <expr><operator>(</operator>enum <name>defined_type</name><operator>)</operator><name>op</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>deftype</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DEFINED_FUNC</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DEFINED_REF</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DEFINED_CONST_FROM</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"constant-from"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_iseq_defined_string</name><argument_list>(<argument><expr><name>deftype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>insn</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>checktype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>op_no</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_str</name> <init>= <expr><call><name>rb_type_str</name><argument_list>(<argument><expr><operator>(</operator>enum <name>ruby_value_type</name><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type_str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>type_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%"</literal><name>PRIuVALUE</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_LINDEX</name></expr>:</case><block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><name>op_no</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>TS_NUM</name> <operator>&amp;&amp;</operator> <name>pnop</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>local_var_name</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>*</operator><name>pnop</name></expr></argument>, <argument><expr><name>op</name> <operator>-</operator> <name>VM_ENV_DATA_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>level</name> <operator>=</operator> <call><name>rb_insn_unified_local_var_level</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>local_var_name</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>level</name></expr></argument>, <argument><expr><name>op</name> <operator>-</operator> <name>VM_ENV_DATA_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_ID</name></expr>:</case> 

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_VALUE</name></expr>:</case> 

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>obj_resurrect</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>insn</name> <operator>==</operator> <call><name>BIN</name><argument_list>(<argument><expr><name>defined</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>op_no</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">":$%c"</literal></expr></argument>, <argument><expr><operator>(</operator><name>type</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">":$%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>type</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cISeq</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>TS_ISEQ</name></expr>:</case> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_GENTRY</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator>struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator><name>op</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_IC</name></expr>:</case>

<case>case <expr><name>TS_IVC</name></expr>:</case>

<case>case <expr><name>TS_ISE</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"&lt;is:%"</literal><name>PRIdPTRDIFF</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator>union <name>iseq_inline_storage_entry</name> <operator>*</operator><operator>)</operator><name>op</name> <operator>-</operator> <name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>is_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_CALLDATA</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>(</operator>struct <name>rb_call_data</name> <operator>*</operator><operator>)</operator><name>op</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"mid:%"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"argc:%d"</literal></expr></argument>, <argument><expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_KWARG</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kw_args</name> <init>= <expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>kw_ary</name> <init>= <expr><call><name>rb_ary_new_from_values</name><argument_list>(<argument><expr><name><name>kw_args</name><operator>-&gt;</operator><name>keyword_len</name></name></expr></argument>, <argument><expr><name><name>kw_args</name><operator>-&gt;</operator><name>keywords</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"kw:[%"</literal><name>PRIsVALUE</name><literal type="string">"]"</literal></expr></argument>, <argument><expr><call><name>rb_ary_join</name><argument_list>(<argument><expr><name>kw_ary</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>flags</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_FLAG</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (vm_ci_flag(ci) &amp; VM_CALL_##n) rb_ary_push(flags, rb_str_new2(#n))</cpp:value></cpp:define>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>ARGS_SPLAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>ARGS_BLOCKARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>FCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>VCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>ARGS_SIMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>BLOCKISEQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>TAILCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>SUPER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>ZSUPER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>KWARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>KW_SPLAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>KW_SPLAT_MUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_FLAG</name><argument_list>(<argument><expr><name>OPT_SEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_ary_join</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"&lt;calldata!%"</literal><name>PRIsVALUE</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_ary_join</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_CDHASH</name></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"&lt;cdhash&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_FUNCPTR</name></expr>:</case>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DLADDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Dl_info</name></type> <name>info</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dladdr</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>info</name><operator>.</operator><name>dli_sname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>dli_sname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"&lt;funcptr&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_BUILTIN</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_builtin_function</name></name> <modifier>*</modifier></type><name>bf</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>rb_builtin_function</name> <operator>*</operator><operator>)</operator><name>op</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"&lt;builtin!%s/%d&gt;"</literal></expr></argument>,

<argument><expr><name><name>bf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>bf</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unknown operand type: %c"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>right_strip</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>beg</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>end</name><operator>--</operator> <operator>&gt;</operator> <name>beg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>end</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>beg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_iseq_disasm_insn</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ret</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>child</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>insn</name> <init>= <expr><name><name>code</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>insn_name_buff</name></decl>;</decl_stmt>

<expr_stmt><expr><name>insn_name_buff</name> <operator>=</operator> <call><name>insn_name</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>int</name></type> <name>rb_vm_max_insn_name_size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%04"</literal><name>PRIuSIZE</name><literal type="string">" %-*s "</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>rb_vm_max_insn_name_size</name></expr></argument>, <argument><expr><name>insn_name_buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%04"</literal><name>PRIuSIZE</name><literal type="string">" %-28.*s "</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strcspn</name><argument_list>(<argument><expr><name>insn_name_buff</name></expr></argument>, <argument><expr><literal type="string">"_"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>insn_name_buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opstr</name> <init>= <expr><call><name>rb_insn_operand_intern</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>insn</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><name>pos</name> <operator>+</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,

<argument><expr><name>len</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>code</name><index>[<expr><name>pos</name> <operator>+</operator> <name>j</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>,

<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>opstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>line_no</name> <init>= <expr><call><name>rb_iseq_line_no</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prev</name> <init>= <expr><ternary><condition><expr><name>pos</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>rb_iseq_line_no</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>line_no</name> <operator>&amp;&amp;</operator> <name>line_no</name> <operator>!=</operator> <name>prev</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>slen</name> <init>= <expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>slen</name> <operator>&gt;</operator> <literal type="number">70</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><literal type="number">70</literal> <operator>-</operator> <name>slen</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%*s(%4d)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>slen</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>line_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>events</name> <init>= <expr><call><name>rb_iseq_event_flags</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>events</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"[%s%s%s%s%s%s%s%s%s%s%s]"</literal></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_LINE</name></expr> ?</condition><then> <expr><literal type="string">"Li"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_CLASS</name></expr> ?</condition><then> <expr><literal type="string">"Cl"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_END</name></expr> ?</condition><then> <expr><literal type="string">"En"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_CALL</name></expr> ?</condition><then> <expr><literal type="string">"Ca"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_RETURN</name></expr> ?</condition><then> <expr><literal type="string">"Re"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_C_CALL</name></expr> ?</condition><then> <expr><literal type="string">"Cc"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_C_RETURN</name></expr> ?</condition><then> <expr><literal type="string">"Cr"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_B_CALL</name></expr> ?</condition><then> <expr><literal type="string">"Bc"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_B_RETURN</name></expr> ?</condition><then> <expr><literal type="string">"Br"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_COVERAGE_LINE</name></expr> ?</condition><then> <expr><literal type="string">"Cli"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>events</name> <operator>&amp;</operator> <name>RUBY_EVENT_COVERAGE_BRANCH</name></expr> ?</condition><then> <expr><literal type="string">"Cbr"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>right_strip</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%.*s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>catch_type</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>CATCH_TYPE_RESCUE</name></expr>:</case>

<return>return <expr><literal type="string">"rescue"</literal></expr>;</return>

<case>case <expr><name>CATCH_TYPE_ENSURE</name></expr>:</case>

<return>return <expr><literal type="string">"ensure"</literal></expr>;</return>

<case>case <expr><name>CATCH_TYPE_RETRY</name></expr>:</case>

<return>return <expr><literal type="string">"retry"</literal></expr>;</return>

<case>case <expr><name>CATCH_TYPE_BREAK</name></expr>:</case>

<return>return <expr><literal type="string">"break"</literal></expr>;</return>

<case>case <expr><name>CATCH_TYPE_REDO</name></expr>:</case>

<return>return <expr><literal type="string">"redo"</literal></expr>;</return>

<case>case <expr><name>CATCH_TYPE_NEXT</name></expr>:</case>

<return>return <expr><literal type="string">"next"</literal></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unknown catch type: %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseq_inspect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;ISeq: uninitialized&gt;"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_code_location_t</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><operator>&amp;</operator><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;ISeq:%"</literal><name>PRIsVALUE</name><literal type="string">"@%"</literal><name>PRIsVALUE</name><literal type="string">":%d (%d,%d)-(%d,%d)&gt;"</literal></expr></argument>,

<argument><expr><name><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>, <argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>loc</name><operator>-&gt;</operator><name>beg_pos</name><operator>.</operator><name>lineno</name></name></expr></argument>,

<argument><expr><name><name>loc</name><operator>-&gt;</operator><name>beg_pos</name><operator>.</operator><name>lineno</name></name></expr></argument>,

<argument><expr><name><name>loc</name><operator>-&gt;</operator><name>beg_pos</name><operator>.</operator><name>column</name></name></expr></argument>,

<argument><expr><name><name>loc</name><operator>-&gt;</operator><name>end_pos</name><operator>.</operator><name>lineno</name></name></expr></argument>,

<argument><expr><name><name>loc</name><operator>-&gt;</operator><name>end_pos</name><operator>.</operator><name>column</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>tmp_set</name> <init>= <expr><block>{

<expr><literal type="string">"tmpset"</literal></expr>,

<expr><block>{<expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>rb_mark_set</name></expr>, <expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>st_free_table</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_iseq_disasm_recursive</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>indent</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>child</name> <init>= <expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>

<enum>enum <block>{<decl><name>header_minlen</name> <init>= <expr><literal type="number">72</literal></expr></init></decl>}</block>;</enum>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>done_iseq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>done_iseq_wrapper</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indent_str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>indent_len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>indent_len</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>indent_str</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indent_str</name></expr></argument>, <argument><expr><name>indent_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"== disasm: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>iseq_inspect</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" (catch: %s)"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>body</name><operator>-&gt;</operator><name>catch_except_p</name></name></expr> ?</condition><then> <expr><literal type="string">"TRUE"</literal></expr> </then><else>: <expr><literal type="string">"FALSE"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>l</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>indent_len</name><operator>)</operator> <operator>&lt;</operator> <name>header_minlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_modify_expand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>header_minlen</name> <operator>-</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><name>header_minlen</name> <operator>-</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indent_str</name></expr></argument>, <argument><expr><name>indent_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"== catch table\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>indent</name></expr></argument>, <argument><expr><literal type="string">"| "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>indent_str</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>body</name><operator>-&gt;</operator><name>catch_table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>=

<expr><call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indent_str</name></expr></argument>, <argument><expr><name>indent_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>,

<argument><expr><literal type="string">"| catch type: %-6s st: %04d ed: %04d sp: %04d cont: %04d\n"</literal></expr></argument>,

<argument><expr><call><name>catch_type</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>start</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>cont</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>done_iseq</name> <operator>&amp;&amp;</operator> <call><name>st_is_member</name><argument_list>(<argument><expr><name>done_iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_iseq_disasm_recursive</name><argument_list>(<argument><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>done_iseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>done_iseq</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>done_iseq_wrapper</name> <operator>=</operator> <call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_set</name></expr></argument>, <argument><expr><name>done_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>done_iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>indent_str</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>indent</name></expr></argument>, <argument><expr><name>indent_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>indent_str</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indent_str</name></expr></argument>, <argument><expr><name>indent_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"|-------------------------------------"</literal>

<literal type="string">"-----------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>local_table</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>keyword</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indent_str</name></expr></argument>, <argument><expr><name>indent_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>,

<argument><expr><literal type="string">"local table (size: %d, argc: %d "</literal>

<literal type="string">"[opts: %d, rest: %d, post: %d, block: %d, kw: %d@%d, kwrest: %d])\n"</literal></expr></argument>,

<argument><expr><name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></argument>,

<argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>,

<argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name></expr> ?</condition><then> <expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name></expr> ?</condition><then> <expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name></expr> ?</condition><then> <expr><name><name>keyword</name><operator>-&gt;</operator><name>num</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name></expr> ?</condition><then> <expr><name><name>keyword</name><operator>-&gt;</operator><name>required_num</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr> ?</condition><then> <expr><name><name>keyword</name><operator>-&gt;</operator><name>rest_start</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>li</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>local_table_size</name></name> <operator>-</operator> <operator>--</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><call><name>local_var_name</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>argi</name><index>[<expr><literal type="number">0x100</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>opti</name><index>[<expr><literal type="number">0x100</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>opti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opts</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>li</name> <operator>&gt;=</operator> <name>argc</name> <operator>&amp;&amp;</operator> <name>li</name> <operator>&lt;</operator> <name>argc</name> <operator>+</operator> <name>opts</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>opti</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opti</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Opt=%"</literal><name>PRIdVALUE</name></expr></argument>,

<argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name><index>[<expr><name>li</name> <operator>-</operator> <name>argc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>argi</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>argi</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s%s%s"</literal></expr></argument>, 

<argument><expr><ternary><condition><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>&gt;</operator> <name>li</name></expr> ?</condition><then> <expr><literal type="string">"Arg"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><name>opti</name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>&amp;&amp;</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name> <operator>==</operator> <name>li</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"Rest"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name> <operator>&amp;&amp;</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name> <operator>&lt;=</operator> <name>li</name> <operator>&amp;&amp;</operator> <name>li</name> <operator>&lt;</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name> <operator>+</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"Post"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name> <operator>&amp;&amp;</operator> <name><name>keyword</name><operator>-&gt;</operator><name>rest_start</name></name> <operator>==</operator> <name>li</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"Kwrest"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name> <operator>&amp;&amp;</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name> <operator>==</operator> <name>li</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"Block"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indent_str</name></expr></argument>, <argument><expr><name>indent_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"[%2d] "</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">11</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>argi</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;%s&gt;"</literal></expr></argument>, <argument><expr><name>argi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>width</name> <operator>-=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>width</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><call><name>right_strip</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>rb_iseq_original_iseq</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>size</name></expr>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>indent_str</name></expr></argument>, <argument><expr><name>indent_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>rb_iseq_disasm_insn</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>l</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>l</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>isv</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>done_iseq</name> <operator>&amp;&amp;</operator> <call><name>st_is_member</name><argument_list>(<argument><expr><name>done_iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>isv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_concat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_iseq_disasm_recursive</name><argument_list>(<argument><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>isv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>indent_str</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>indent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>done_iseq_wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_disasm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_disasm_recursive</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_disasm</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_disasm</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_iterate_children</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>iter_func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>child_iseq</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>code</name> <init>= <expr><call><name>rb_iseq_original_iseq</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>all_children</name> <init>= <expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><call><name>rb_ident_hash_new</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>body</name><operator>-&gt;</operator><name>catch_table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>=

<expr><call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>catch_table</name></name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>child</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>all_children</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>child</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>all_children</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>child</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>iter_func</name>)<argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>insn</name> <init>= <expr><name><name>code</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>insn_op_types</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>types</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_ISEQ</name></expr>:</case>

<expr_stmt><expr><name>child</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name><name>code</name><index>[<expr><name>i</name><operator>+</operator><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>all_children</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>child</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>all_children</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>child</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>iter_func</name>)<argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>all_children</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>yield_each_children</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>child_iseq</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>iseqw_new</name><argument_list>(<argument><expr><name>child_iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_each_child</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>iseq_iterate_children</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>yield_each_children</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>push_event_info</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>events</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C</name><parameter_list>(<parameter><type><name>ev</name></type></parameter>, <parameter><type><name>cstr</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (events &amp; ev) rb_ary_push(ary, rb_ary_new_from_args(2, l, ID2SYM(rb_intern(cstr))));</cpp:value></cpp:define>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>RUBY_EVENT_CLASS</name></expr></argument>, <argument><expr><literal type="string">"class"</literal></expr></argument>, <argument><expr><call><name>rb_iseq_first_lineno</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>RUBY_EVENT_CALL</name></expr></argument>, <argument><expr><literal type="string">"call"</literal></expr></argument>, <argument><expr><call><name>rb_iseq_first_lineno</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>RUBY_EVENT_B_CALL</name></expr></argument>, <argument><expr><literal type="string">"b_call"</literal></expr></argument>, <argument><expr><call><name>rb_iseq_first_lineno</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>RUBY_EVENT_LINE</name></expr></argument>, <argument><expr><literal type="string">"line"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>RUBY_EVENT_END</name></expr></argument>, <argument><expr><literal type="string">"end"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>, <argument><expr><literal type="string">"return"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>C</name><argument_list>(<argument><expr><name>RUBY_EVENT_B_RETURN</name></expr></argument>, <argument><expr><literal type="string">"b_return"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>C</name></cpp:undef>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_trace_points</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>&amp;</operator><name><name>body</name><operator>-&gt;</operator><name>insns_info</name><operator>.</operator><name>body</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>events</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>push_event_info</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>events</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>line_no</name></name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_s_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>body</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>vm_proc_iseq</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_is_iseq</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_obj_is_method</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>rb_method_iseq</name><argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_typeddata_is_instance_of</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iseqw_data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>body</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>iseq</name></expr> ?</condition><then> <expr><call><name>iseqw_new</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_s_disasm</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>body</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>iseqw</name> <init>= <expr><call><name>iseqw_s_of</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>iseqw</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><call><name>rb_iseq_disasm</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>iseqw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>ruby_node_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>node</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node_name.inc"</cpp:file></cpp:include>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unknown node: %d"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECL_SYMBOL</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static ID sym_##name</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_SYMBOL</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sym_##name = rb_intern(#name)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>register_label</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>sym</name> <init>= <expr><call><name>rb_str_intern</name><argument_list>(<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"label_%lu"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>sym</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exception_type2symbol</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>CATCH_TYPE_RESCUE</name></expr>:</case> <expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"rescue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>CATCH_TYPE_ENSURE</name></expr>:</case> <expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"ensure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>CATCH_TYPE_RETRY</name></expr>:</case> <expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"retry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>CATCH_TYPE_BREAK</name></expr>:</case> <expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"break"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>CATCH_TYPE_REDO</name></expr>:</case> <expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"redo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>CATCH_TYPE_NEXT</name></expr>:</case> <expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"next"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unknown exception type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<return>return <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>cdhash_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>obj_resurrect</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>label_wrapper</name> <init>= <expr><block>{

<expr><literal type="string">"label_wrapper"</literal></expr>,

<expr><block>{<expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>rb_mark_tbl</name></expr>, <expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>st_free_table</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseq_data_to_ary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>iseq_body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>prev_insn_info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_line</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>seq</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iseq_original</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>type</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>locals</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>params</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>body</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>nbody</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exception</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>VALUE</name></type> <name>misc</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name><name>insn_syms</name><index>[<expr><name>VM_INSTRUCTION_SIZE</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>labels_table</name> <init>= <expr><call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>labels_wrapper</name> <init>= <expr><call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>label_wrapper</name></expr></argument>, <argument><expr><name>labels_table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DECL_SYMBOL</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_SYMBOL</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_SYMBOL</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_SYMBOL</name><argument_list>(<argument><expr><name>class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_SYMBOL</name><argument_list>(<argument><expr><name>rescue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_SYMBOL</name><argument_list>(<argument><expr><name>ensure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_SYMBOL</name><argument_list>(<argument><expr><name>eval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_SYMBOL</name><argument_list>(<argument><expr>main</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DECL_SYMBOL</name><argument_list>(<argument><expr><name>plain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sym_top</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>numberof</name><argument_list>(<argument><expr><name>insn_syms</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>insn_syms</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><call><name>insn_name</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>INIT_SYMBOL</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_SYMBOL</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_SYMBOL</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_SYMBOL</name><argument_list>(<argument><expr><name>class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_SYMBOL</name><argument_list>(<argument><expr><name>rescue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_SYMBOL</name><argument_list>(<argument><expr><name>ensure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_SYMBOL</name><argument_list>(<argument><expr><name>eval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_SYMBOL</name><argument_list>(<argument><expr>main</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_SYMBOL</name><argument_list>(<argument><expr><name>plain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ISEQ_TYPE_TOP</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <name>sym_top</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ISEQ_TYPE_METHOD</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <name>sym_method</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ISEQ_TYPE_BLOCK</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <name>sym_block</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ISEQ_TYPE_CLASS</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <name>sym_class</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ISEQ_TYPE_RESCUE</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <name>sym_rescue</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ISEQ_TYPE_ENSURE</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <name>sym_ensure</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ISEQ_TYPE_EVAL</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <name>sym_eval</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ISEQ_TYPE_MAIN</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <name>sym_main</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ISEQ_TYPE_PLAIN</name></expr>:</case> <expr_stmt><expr><name>type</name> <operator>=</operator> <name>sym_plain</name></expr>;</expr_stmt> <break>break;</break>

<default>default:</default> <expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unsupported iseq type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>iseq_body</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch><empty_stmt>;</empty_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>iseq_body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>lid</name> <init>= <expr><name><name>iseq_body</name><operator>-&gt;</operator><name>local_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lid</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>lid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>locals</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>lid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content> 

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>locals</name></expr></argument>, <argument><expr><call><name>ULONG2NUM</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>local_table_size</name></name><operator>-</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>locals</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"#arg_rest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>keyword</name> <init>= <expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_opt</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg_opt_labels</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>l</name> <init>= <expr><call><name>register_label</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_table</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>arg_opt_labels</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"opt"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg_opt_labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_lead</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"lead_num"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"post_num"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_post</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"post_start"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"rest_start"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"block_start"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>keywords</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>keyword</name><operator>-&gt;</operator><name>required_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>keyword</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>keyword</name><operator>-&gt;</operator><name>default_values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>default_values</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"kwbits"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>bits_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"keyword"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"kwrest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>rest_start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ambiguous_param0</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"ambiguous_param0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name>iseq_original</name> <operator>=</operator> <call><name>rb_iseq_original_iseq</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>seq</name> <operator>=</operator> <name>iseq_original</name></expr>;</init> <condition><expr><name>seq</name> <operator>&lt;</operator> <name>iseq_original</name> <operator>+</operator> <name><name>iseq_body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>insn</name> <init>= <expr><operator>*</operator><name>seq</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>nseq</name> <init>= <expr><name>seq</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>insn_syms</name><index>[<expr><name>insn</name><operator>%</operator><call><name>numberof</name><argument_list>(<argument><expr><name>insn_syms</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>len</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>seq</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>insn_op_type</name><argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>TS_OFFSET</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>idx</name> <init>= <expr><name>nseq</name> <operator>-</operator> <name>iseq_original</name> <operator>+</operator> <operator>*</operator><name>seq</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>register_label</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><name>TS_LINDEX</name></expr>:</case>

<case>case <expr><name>TS_NUM</name></expr>:</case>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>*</operator><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_VALUE</name></expr>:</case>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>obj_resurrect</name><argument_list>(<argument><expr><operator>*</operator><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_ISEQ</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>seq</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>iseq</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>iseq_data_to_ary</name><argument_list>(<argument><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_GENTRY</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator>struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>seq</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_IC</name></expr>:</case>

<case>case <expr><name>TS_IVC</name></expr>:</case>

<case>case <expr><name>TS_ISE</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name><name>union</name> <name>iseq_inline_storage_entry</name></name> <modifier>*</modifier></type><name>is</name> <init>= <expr><operator>(</operator>union <name>iseq_inline_storage_entry</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>seq</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>is</name> <operator>-</operator> <name><name>iseq_body</name><operator>-&gt;</operator><name>is_entries</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_CALLDATA</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_call_data</name></name> <modifier>*</modifier></type><name>cd</name> <init>= <expr><operator>(</operator>struct <name>rb_call_data</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>seq</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo</name></name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>cd</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><call><name>vm_ci_argc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><call><name>vm_ci_mid</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"mid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>mid</name></expr> ?</condition><then> <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"flag"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_ci_flag</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>VM_CALL_KWARG</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_callinfo_kwarg</name></name> <modifier>*</modifier></type><name>kwarg</name> <init>= <expr><call><name>vm_ci_kwarg</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>kw</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>kwarg</name><operator>-&gt;</operator><name>keyword_len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name><name>kwarg</name><operator>-&gt;</operator><name>keyword_len</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>kwarg</name><operator>-&gt;</operator><name>keyword_len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>kw</name></expr></argument>, <argument><expr><name><name>kwarg</name><operator>-&gt;</operator><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"kw_arg"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"orig_argc"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_ID</name></expr>:</case>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><operator>*</operator><name>seq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>TS_CDHASH</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><operator>*</operator><name>seq</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>cdhash_each</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>pos</name> <init>= <expr><call><name>FIX2INT</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>idx</name> <init>= <expr><name>nseq</name> <operator>-</operator> <name>iseq_original</name> <operator>+</operator> <name>pos</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>,

<argument><expr><call><name>register_label</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_FUNCPTR</name></expr>:</case>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VALUE</name> <operator>&lt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><operator>*</operator><name>seq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>LL2NUM</name><argument_list>(<argument><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><operator>*</operator><name>seq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>TS_BUILTIN</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VALUE</name> <operator>&lt;=</operator> <name>SIZEOF_LONG</name></expr></cpp:if>

<decl_stmt><decl><type><name>VALUE</name></type> <name>func_ptr</name> <init>= <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><operator>(</operator><operator>(</operator><name>RB_BUILTIN</name><operator>)</operator><operator>*</operator><name>seq</name><operator>)</operator><operator>-&gt;</operator><name>func_ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>VALUE</name></type> <name>func_ptr</name> <init>= <expr><call><name>LL2NUM</name><argument_list>(<argument><expr><operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><operator>(</operator><operator>(</operator><name>RB_BUILTIN</name><operator>)</operator><operator>*</operator><name>seq</name><operator>)</operator><operator>-&gt;</operator><name>func_ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"func_ptr"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>func_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"argc"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2NUM</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RB_BUILTIN</name><operator>)</operator><operator>*</operator><name>seq</name><operator>)</operator><operator>-&gt;</operator><name>argc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2NUM</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RB_BUILTIN</name><operator>)</operator><operator>*</operator><name>seq</name><operator>)</operator><operator>-&gt;</operator><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RB_BUILTIN</name><operator>)</operator><operator>*</operator><name>seq</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"unknown operand: %c"</literal></expr></argument>, <argument><expr><call><name>insn_op_type</name><argument_list>(<argument><expr><name>insn</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>nbody</name> <operator>=</operator> <name>body</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq_body</name><operator>-&gt;</operator><name>catch_table</name></name></expr>)</condition><block type="pseudo"><block_content> <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>iseq_body</name><operator>-&gt;</operator><name>catch_table</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_catch_table_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>=

<expr><call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>catch_table</name></name></expr></argument>, <argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>exception_type2symbol</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>iseq_data_to_ary</name><argument_list>(<argument><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>register_label</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>start</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>register_label</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>register_label</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>cont</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>UINT2NUM</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>sp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>exception</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_insn_info</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>l</name><operator>=</operator><literal type="number">0</literal></expr><operator>,</operator> <expr><name>pos</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>l</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>nbody</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>l</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>nbody</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>label</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>labels_table</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>label</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>get_insn_info</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prev_insn_info</name> <operator>!=</operator> <name>info</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>line_no</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>events</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>events</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>last_line</name> <operator>!=</operator> <name>line</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last_line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_EVENT</name><parameter_list>(<parameter><type><name>ev</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (events &amp; ev) rb_ary_push(body, ID2SYM(rb_intern(#ev)));</cpp:value></cpp:define>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_LINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_B_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_EVENT</name><argument_list>(<argument><expr><name>RUBY_EVENT_B_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_EVENT</name></cpp:undef>

<expr_stmt><expr><name>prev_insn_info</name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></for>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>nbody</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>labels_wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>misc</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"arg_size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>misc</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"local_size"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>local_table_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>misc</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"stack_max"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>stack_max</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>misc</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"node_id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>node_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>misc</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"code_location"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>beg_pos</name><operator>.</operator><name>column</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>code_location</name><operator>.</operator><name>end_pos</name><operator>.</operator><name>column</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"YARVInstructionSequence/SimpleDataFormat"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ISEQ_MAJOR_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ISEQ_MINOR_VERSION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>misc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>rb_iseq_realpath</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>exception</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_parameters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_proc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_param_keyword</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>keyword</name> <init>= <expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>keyword</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>args</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>req</name></decl>, <decl><type ref="prev"/><name>opt</name></decl>, <decl><type ref="prev"/><name>rest</name></decl>, <decl><type ref="prev"/><name>block</name></decl>, <decl><type ref="prev"/><name>key</name></decl>, <decl><type ref="prev"/><name>keyrest</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAM_TYPE</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_ary_push(a = rb_ary_new2(2), ID2SYM(type))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAM_ID</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>body-&gt;local_table[(i)]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARAM</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( PARAM_TYPE(type), rb_id2str(PARAM_ID(i)) ? rb_ary_push(a, ID2SYM(PARAM_ID(i))) : a)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><literal type="string">"req"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"opt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_proc</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>PARAM_TYPE</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><call><name>PARAM_ID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>PARAM_ID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>PARAM</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>lead_num</name></name> <operator>+</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>opt_num</name></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>r</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>PARAM_TYPE</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_id2str</name><argument_list>(<argument><expr><call><name>PARAM_ID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>PARAM_ID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>rest</name></expr></argument>, <argument><expr><literal type="string">"rest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>PARAM</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>rest_start</name></name></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name> <operator>+</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_num</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_proc</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>r</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>PARAM_TYPE</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><call><name>PARAM_ID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>PARAM_ID</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>post_start</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>r</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>PARAM</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>accepts_no_kwarg</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>nokey</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>nokey</name></expr></argument>, <argument><expr><literal type="string">"nokey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PARAM_TYPE</name><argument_list>(<argument><expr><name>nokey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>keyword</name><operator>-&gt;</operator><name>required_num</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>keyreq</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>keyreq</name></expr></argument>, <argument><expr><literal type="string">"keyreq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>keyword</name><operator>-&gt;</operator><name>required_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>PARAM_TYPE</name><argument_list>(<argument><expr><name>keyreq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>keyword</name><operator>-&gt;</operator><name>num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>PARAM_TYPE</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>keyrest</name></expr></argument>, <argument><expr><literal type="string">"keyrest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>PARAM</name><argument_list>(<argument><expr><name><name>keyword</name><operator>-&gt;</operator><name>rest_start</name></name></expr></argument>, <argument><expr><name>keyrest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_block</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><literal type="string">"block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>PARAM</name><argument_list>(<argument><expr><name><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>block_start</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>args</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseq_defined_string</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>defined_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>expr_names</name><index>[]</index><index>[<expr><literal type="number">18</literal></expr>]</index></name> <init>= <expr><block>{

<expr><literal type="string">"nil"</literal></expr>,

<expr><literal type="string">"instance-variable"</literal></expr>,

<expr><literal type="string">"local-variable"</literal></expr>,

<expr><literal type="string">"global-variable"</literal></expr>,

<expr><literal type="string">"class variable"</literal></expr>,

<expr><literal type="string">"constant"</literal></expr>,

<expr><literal type="string">"method"</literal></expr>,

<expr><literal type="string">"yield"</literal></expr>,

<expr><literal type="string">"super"</literal></expr>,

<expr><literal type="string">"self"</literal></expr>,

<expr><literal type="string">"true"</literal></expr>,

<expr><literal type="string">"false"</literal></expr>,

<expr><literal type="string">"assignment"</literal></expr>,

<expr><literal type="string">"expression"</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>estr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defs</name></decl>, <decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>type</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>numberof</name><argument_list>(<argument><expr><name>expr_names</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>estr</name> <operator>=</operator> <name><name>expr_names</name><index>[<expr><name>type</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>estr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>defs</name> <operator>=</operator> <call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>defined_strings</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>defs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>defs</name> <operator>=</operator> <call><name>ruby_xcalloc</name><argument_list>(<argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name>expr_names</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>defined_strings</name> <operator>=</operator> <name>defs</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>defs</name><index>[<expr><name>type</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>estr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>defs</name><index>[<expr><name>type</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>encoded_insn_data</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>insn_data_struct</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>insn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>insn_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>notrace_encoded_insn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>trace_encoded_insn</name></decl>;</decl_stmt>

}</block></struct></type> <name>insn_data_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>insn_data_t</name></type> <name><name>insn_data</name><index>[<expr><name>VM_INSTRUCTION_SIZE</name><operator>/</operator><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<function><type><name>void</name></type>

<name>rb_vm_encoded_insn_data_table_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPT_DIRECT_THREADED_CODE</name> <operator>||</operator> <name>OPT_CALL_THREADED_CODE</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>rb_vm_get_insns_address_table</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSN_CODE</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((VALUE)table[insn])</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSN_CODE</name><parameter_list>(<parameter><type><name>insn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(insn)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>insn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>encoded_insn_data</name> <operator>=</operator> <call><name>st_init_numtable_with_size</name><argument_list>(<argument><expr><name>VM_INSTRUCTION_SIZE</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>insn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>insn</name> <operator>&lt;</operator> <name>VM_INSTRUCTION_SIZE</name><operator>/</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>insn</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>key1</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><call><name>INSN_CODE</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>key2</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><call><name>INSN_CODE</name><argument_list>(<argument><expr><name>insn</name> <operator>+</operator> <name>VM_INSTRUCTION_SIZE</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>insn_data</name><index>[<expr><name>insn</name></expr>]</index></name><operator>.</operator><name>insn</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>insn</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>insn_data</name><index>[<expr><name>insn</name></expr>]</index></name><operator>.</operator><name>insn_len</name> <operator>=</operator> <call><name>insn_len</name><argument_list>(<argument><expr><name>insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>insn_data</name><index>[<expr><name>insn</name></expr>]</index></name><operator>.</operator><name>notrace_encoded_insn</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>insn_data</name><index>[<expr><name>insn</name></expr>]</index></name><operator>.</operator><name>trace_encoded_insn</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key2</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name>encoded_insn_data</name></expr></argument>, <argument><expr><name>key1</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name><name>insn_data</name><index>[<expr><name>insn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name>encoded_insn_data</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name><name>insn_data</name><index>[<expr><name>insn</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_vm_insn_addr2insn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>encoded_insn_data</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>insn_data_t</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>insn_data_t</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>insn</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_vm_insn_addr2insn: invalid insn address: %p"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>encoded_iseq_trace_instrument</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>iseq_encoded_insn</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>turnon</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>*</operator><name>iseq_encoded_insn</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>encoded_insn_data</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>insn_data_t</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>insn_data_t</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>iseq_encoded_insn</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><name>turnon</name></expr> ?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>trace_encoded_insn</name></name></expr> </then><else>: <expr><name><name>e</name><operator>-&gt;</operator><name>notrace_encoded_insn</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name><name>e</name><operator>-&gt;</operator><name>insn_len</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"trace_instrument: invalid insn address: %p"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>iseq_encoded_insn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_trace_flag_cleared</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>iseq_encoded</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>encoded_iseq_trace_instrument</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iseq_encoded</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_add_local_tracepoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>turnon_events</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tpval</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>target_line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>iseq_encoded</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>ISEQ_EXECUTABLE_P</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>pc</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>pc</name><operator>&lt;</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iseq_insn_info_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>get_insn_info</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>pc_events</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>events</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>target_events</name> <init>= <expr><name>turnon_events</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>line</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>line_no</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>target_line</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>target_line</name> <operator>==</operator> <name>line</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>target_events</name> <operator>&amp;=</operator> <operator>~</operator><name>RUBY_EVENT_LINE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pc_events</name> <operator>&amp;</operator> <name>target_events</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pc</name> <operator>+=</operator> <call><name>encoded_iseq_trace_instrument</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iseq_encoded</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>, <argument><expr><name>pc_events</name> <operator>&amp;</operator> <operator>(</operator><name>target_events</name> <operator>|</operator> <name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>global_trace_events</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseq</name><operator>)</operator><operator>-&gt;</operator><name><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name> <operator>=</operator> <call><name>RB_ZALLOC</name><argument_list>(<argument><expr><name>rb_hook_list_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_hook_list_connect_tracepoint</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>iseq</name></expr></argument>, <argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr></argument>, <argument><expr><name>tpval</name></expr></argument>, <argument><expr><name>target_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>n</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>trace_set_local_events_struct</name> <block>{

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>turnon_events</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tpval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>target_line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>iseq_add_local_tracepoint_i</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_set_local_events_struct</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>trace_set_local_events_struct</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>iseq_add_local_tracepoint</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>turnon_events</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>tpval</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>target_line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_iterate_children</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>iseq_add_local_tracepoint_i</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_iseq_add_local_tracepoint_recursively</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>turnon_events</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tpval</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>target_line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_set_local_events_struct</name></name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>turnon_events</name></name> <operator>=</operator> <name>turnon_events</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>tpval</name></name> <operator>=</operator> <name>tpval</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>target_line</name></name> <operator>=</operator> <name>target_line</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_add_local_tracepoint_i</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"puts"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>rb_iseq_disasm</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<return>return <expr><name><name>data</name><operator>.</operator><name>n</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>iseq_remove_local_tracepoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tpval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>iseq_encoded</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>local_events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hook_list_remove_tracepoint</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr></argument>, <argument><expr><name>tpval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>local_events</name> <operator>=</operator> <name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name><operator>-&gt;</operator><name>events</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>local_events</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name><operator>-&gt;</operator><name>running</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hook_list_free</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseq</name><operator>)</operator><operator>-&gt;</operator><name><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>pc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pc</name><operator>&lt;</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>pc_events</name> <init>= <expr><call><name>rb_iseq_event_flags</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>pc</name> <operator>+=</operator> <call><name>encoded_iseq_trace_instrument</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iseq_encoded</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>, <argument><expr><name>pc_events</name> <operator>&amp;</operator> <operator>(</operator><name>local_events</name> <operator>|</operator> <name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>global_trace_events</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>n</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>trace_clear_local_events_struct</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>tpval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>iseq_remove_local_tracepoint_i</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_clear_local_events_struct</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>trace_clear_local_events_struct</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>n</name></name> <operator>+=</operator> <call><name>iseq_remove_local_tracepoint</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>tpval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_iterate_children</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>iseq_remove_local_tracepoint_i</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_iseq_remove_local_tracepoint_recursively</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tpval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>trace_clear_local_events_struct</name></name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>tpval</name></name> <operator>=</operator> <name>tpval</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iseq_remove_local_tracepoint_i</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>data</name><operator>.</operator><name>n</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_trace_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>rb_event_flag_t</name></type> <name>turnon_events</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>global_trace_events</name></name> <operator>==</operator> <name>turnon_events</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISEQ_EXECUTABLE_P</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_iseq_constant_body</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>body</name> <init>= <expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>iseq_encoded</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_encoded</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>enabled_events</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>local_events</name> <init>= <expr><ternary><condition><expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name></name></expr> ?</condition><then> <expr><name><name>iseq</name><operator>-&gt;</operator><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>local_hooks</name><operator>-&gt;</operator><name>events</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>iseq</name><operator>)</operator><operator>-&gt;</operator><name><name>aux</name><operator>.</operator><name>exec</name><operator>.</operator><name>global_trace_events</name></name> <operator>=</operator> <name>turnon_events</name></expr>;</expr_stmt>

<expr_stmt><expr><name>enabled_events</name> <operator>=</operator> <name>turnon_events</name> <operator>|</operator> <name>local_events</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>pc</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>pc</name><operator>&lt;</operator><name><name>body</name><operator>-&gt;</operator><name>iseq_size</name></name></expr>;</condition><incr/>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>pc_events</name> <init>= <expr><call><name>rb_iseq_event_flags</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>pc</name> <operator>+=</operator> <call><name>encoded_iseq_trace_instrument</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iseq_encoded</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>, <argument><expr><name>pc_events</name> <operator>&amp;</operator> <name>enabled_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>trace_set_i</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vstart</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vend</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_event_flag_t</name></type> <name>turnon_events</name> <init>= <expr><operator>*</operator><operator>(</operator><name>rb_event_flag_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>vstart</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>v</name> <operator>!=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>vend</name></expr>;</condition> <incr><expr><name>v</name> <operator>+=</operator> <name>stride</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>asan_poisoned_object_p</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>asan_unpoison_object</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_iseq</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_iseq_trace_set</name><argument_list>(<argument><expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><operator>(</operator><name>rb_iseq_t</name> <operator>*</operator><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>turnon_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>asan_poison_object_if</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_iseq_trace_set_all</name><parameter_list>(<parameter><decl><type><name>rb_event_flag_t</name></type> <name>turnon_events</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_objspace_each_objects</name><argument_list>(<argument><expr><name>trace_set_i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>turnon_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_iseqw_local_variables</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>iseqval</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_local_variables</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>iseqval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_to_binary</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opt</name> <init>= <expr><ternary><condition><expr><operator>!</operator><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_iseq_ibf_dump</name><argument_list>(<argument><expr><call><name>iseqw_check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_s_load_from_binary</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>iseqw_new</name><argument_list>(<argument><expr><call><name>rb_iseq_ibf_load</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>iseqw_s_load_from_binary_extra_data</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_iseq_ibf_load_extra_data</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>VM_INSN_INFO_TABLE_IMPL</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IMMEDIATE_TABLE_SIZE</name></cpp:macro> <cpp:value>54</cpp:value></cpp:define> 

<struct>struct <name>succ_index_table</name> <block>{

<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>imm_part</name><index>[<expr><name>IMMEDIATE_TABLE_SIZE</name> <operator>/</operator> <literal type="number">9</literal></expr>]</index></name></decl>;</decl_stmt>

<struct>struct <name>succ_dict_block</name> <block>{

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>rank</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>small_block_ranks</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>bits</name><index>[<expr><literal type="number">512</literal><operator>/</operator><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

}</block> <decl><name><name>succ_part</name><index>[<expr><name>FLEX_ARY_LEN</name></expr>]</index></name></decl>;</struct>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>imm_block_rank_set</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(v) |= (uint64_t)(r) &lt;&lt; (7 * (i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>imm_block_rank_get</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((int)((v) &gt;&gt; ((i) * 7))) &amp; 0x7f)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>small_block_rank_set</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>i</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(v) |= (uint64_t)(r) &lt;&lt; (9 * ((i) - 1))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>small_block_rank_get</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((i) == 0 ? 0 : (((int)((v) &gt;&gt; (((i) - 1) * 9))) &amp; 0x1ff))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>succ_index_table</name></name> <modifier>*</modifier></type>

<name>succ_index_table_create</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max_pos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>imm_size</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>max_pos</name> <operator>&lt;</operator> <name>IMMEDIATE_TABLE_SIZE</name></expr> ?</condition><then> <expr><name>max_pos</name> <operator>+</operator> <literal type="number">8</literal></expr> </then><else>: <expr><name>IMMEDIATE_TABLE_SIZE</name></expr></else></ternary><operator>)</operator> <operator>/</operator> <literal type="number">9</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>succ_size</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>max_pos</name> <operator>&lt;</operator> <name>IMMEDIATE_TABLE_SIZE</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>max_pos</name> <operator>-</operator> <name>IMMEDIATE_TABLE_SIZE</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator></expr></else></ternary><operator>)</operator> <operator>/</operator> <literal type="number">512</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>succ_index_table</name></name> <modifier>*</modifier></type><name>sd</name> <init>=

<expr><call><name>rb_xcalloc_mul_add_mul</name><argument_list>(

<argument><expr><name>imm_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><name>succ_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>succ_dict_block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>imm_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name>size</name> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>r</name></expr>]</index></name> <operator>==</operator> <name>j</name> <operator>*</operator> <literal type="number">9</literal> <operator>+</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>imm_block_rank_set</name><argument_list>(<argument><expr><name><name>sd</name><operator>-&gt;</operator><name>imm_part</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>succ_size</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>succ_dict_block</name></name> <modifier>*</modifier></type><name>sd_block</name> <init>= <expr><operator>&amp;</operator><name><name>sd</name><operator>-&gt;</operator><name>succ_part</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>small_rank</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sd_block</name><operator>-&gt;</operator><name>rank</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>small_block_rank_set</name><argument_list>(<argument><expr><name><name>sd_block</name><operator>-&gt;</operator><name>small_block_ranks</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>small_rank</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name>size</name> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>r</name></expr>]</index></name> <operator>==</operator> <name>k</name> <operator>*</operator> <literal type="number">512</literal> <operator>+</operator> <name>j</name> <operator>*</operator> <literal type="number">64</literal> <operator>+</operator> <name>i</name> <operator>+</operator> <name>IMMEDIATE_TABLE_SIZE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bits</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>sd_block</name><operator>-&gt;</operator><name>bits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>bits</name></expr>;</expr_stmt>

<expr_stmt><expr><name>small_rank</name> <operator>+=</operator> <call><name>rb_popcount64</name><argument_list>(<argument><expr><name>bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<return>return <expr><name>sd</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name> <modifier>*</modifier></type>

<name>succ_index_table_invert</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>max_pos</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>succ_index_table</name></name> <modifier>*</modifier></type><name>sd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>imm_size</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>max_pos</name> <operator>&lt;</operator> <name>IMMEDIATE_TABLE_SIZE</name></expr> ?</condition><then> <expr><name>max_pos</name> <operator>+</operator> <literal type="number">8</literal></expr> </then><else>: <expr><name>IMMEDIATE_TABLE_SIZE</name></expr></else></ternary><operator>)</operator> <operator>/</operator> <literal type="number">9</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>succ_size</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>max_pos</name> <operator>&lt;</operator> <name>IMMEDIATE_TABLE_SIZE</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>max_pos</name> <operator>-</operator> <name>IMMEDIATE_TABLE_SIZE</name> <operator>+</operator> <literal type="number">511</literal><operator>)</operator></expr></else></ternary><operator>)</operator> <operator>/</operator> <literal type="number">512</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>positions</name> <init>= <macro><name>ALLOC_N</name><argument_list>(<argument>unsigned int</argument>, <argument>size</argument>)</argument_list></macro></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>r</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>positions</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>imm_size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nr</name> <init>= <expr><call><name>imm_block_rank_get</name><argument_list>(<argument><expr><name><name>sd</name><operator>-&gt;</operator><name>imm_part</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>nr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>j</name> <operator>*</operator> <literal type="number">9</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <name>nr</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>succ_size</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sd</name><operator>-&gt;</operator><name>succ_part</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>bits</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>i</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>k</name> <operator>*</operator> <literal type="number">512</literal> <operator>+</operator> <name>j</name> <operator>*</operator> <literal type="number">64</literal> <operator>+</operator> <name>i</name> <operator>+</operator> <name>IMMEDIATE_TABLE_SIZE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></for>

<return>return <expr><name>positions</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>succ_index_lookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>succ_index_table</name></name> <modifier>*</modifier></type><name>sd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <name>IMMEDIATE_TABLE_SIZE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>i</name> <init>= <expr><name>x</name> <operator>/</operator> <literal type="number">9</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>j</name> <init>= <expr><name>x</name> <operator>%</operator> <literal type="number">9</literal></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>imm_block_rank_get</name><argument_list>(<argument><expr><name><name>sd</name><operator>-&gt;</operator><name>imm_part</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>block_index</name> <init>= <expr><operator>(</operator><name>x</name> <operator>-</operator> <name>IMMEDIATE_TABLE_SIZE</name><operator>)</operator> <operator>/</operator> <literal type="number">512</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>succ_dict_block</name></name> <modifier>*</modifier></type><name>block</name> <init>= <expr><operator>&amp;</operator><name><name>sd</name><operator>-&gt;</operator><name>succ_part</name><index>[<expr><name>block_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>block_bit_index</name> <init>= <expr><operator>(</operator><name>x</name> <operator>-</operator> <name>IMMEDIATE_TABLE_SIZE</name><operator>)</operator> <operator>%</operator> <literal type="number">512</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>small_block_index</name> <init>= <expr><name>block_bit_index</name> <operator>/</operator> <literal type="number">64</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>small_block_popcount</name> <init>= <expr><call><name>small_block_rank_get</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>small_block_ranks</name></name></expr></argument>, <argument><expr><name>small_block_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>popcnt</name> <init>= <expr><call><name>rb_popcount64</name><argument_list>(<argument><expr><name><name>block</name><operator>-&gt;</operator><name>bits</name><index>[<expr><name>small_block_index</name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">63</literal> <operator>-</operator> <name>block_bit_index</name> <operator>%</operator> <literal type="number">64</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>block</name><operator>-&gt;</operator><name>rank</name></name> <operator>+</operator> <name>small_block_popcount</name> <operator>+</operator> <name>popcnt</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>Init_ISeq</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>rb_cISeq</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cRubyVM</name></expr></argument>, <argument><expr><literal type="string">"InstructionSequence"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>iseqw_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"disasm"</literal></expr></argument>, <argument><expr><name>iseqw_disasm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"disassemble"</literal></expr></argument>, <argument><expr><name>iseqw_disasm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"to_a"</literal></expr></argument>, <argument><expr><name>iseqw_to_a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"eval"</literal></expr></argument>, <argument><expr><name>iseqw_eval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"to_binary"</literal></expr></argument>, <argument><expr><name>iseqw_to_binary</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"load_from_binary"</literal></expr></argument>, <argument><expr><name>iseqw_s_load_from_binary</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"load_from_binary_extra_data"</literal></expr></argument>, <argument><expr><name>iseqw_s_load_from_binary_extra_data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>iseqw_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"absolute_path"</literal></expr></argument>, <argument><expr><name>iseqw_absolute_path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>, <argument><expr><name>iseqw_label</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"base_label"</literal></expr></argument>, <argument><expr><name>iseqw_base_label</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"first_lineno"</literal></expr></argument>, <argument><expr><name>iseqw_first_lineno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"trace_points"</literal></expr></argument>, <argument><expr><name>iseqw_trace_points</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"each_child"</literal></expr></argument>, <argument><expr><name>iseqw_each_child</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

rb_define_private_method(rb_cISeq, "marshal_dump", iseqw_marshal_dump, 0);

rb_define_private_method(rb_cISeq, "marshal_load", iseqw_marshal_load, 1);

rb_define_singleton_method(rb_cISeq, "load", iseq_s_load, -1);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>iseq_s_load</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"compile"</literal></expr></argument>, <argument><expr><name>iseqw_s_compile</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>iseqw_s_compile</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"compile_file"</literal></expr></argument>, <argument><expr><name>iseqw_s_compile_file</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"compile_option"</literal></expr></argument>, <argument><expr><name>iseqw_s_compile_option_get</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"compile_option="</literal></expr></argument>, <argument><expr><name>iseqw_s_compile_option_set</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"disasm"</literal></expr></argument>, <argument><expr><name>iseqw_s_disasm</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"disassemble"</literal></expr></argument>, <argument><expr><name>iseqw_s_disasm</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>, <argument><expr><literal type="string">"of"</literal></expr></argument>, <argument><expr><name>iseqw_s_of</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"translate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cISeq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"load_iseq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
