<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\vm_method.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id_table.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METHOD_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>vm_redefinition_check_flag</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rb_vm_check_redefinition_opt_method</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>object_id</name></cpp:macro> <cpp:value>idObject_id</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>added</name></cpp:macro> <cpp:value>idMethod_added</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>singleton_added</name></cpp:macro> <cpp:value>idSingleton_method_added</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>removed</name></cpp:macro> <cpp:value>idMethod_removed</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>singleton_removed</name></cpp:macro> <cpp:value>idSingleton_method_removed</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>undefined</name></cpp:macro> <cpp:value>idMethod_undefined</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>singleton_undefined</name></cpp:macro> <cpp:value>idSingleton_method_undefined</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>attached</name></cpp:macro> <cpp:value>id__attached__</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ruby_running</name></cpp:macro> <cpp:value>(GET_VM()-&gt;running)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>vm_ccs_dump_i</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><operator>(</operator>struct <name>rb_class_cc_entries</name> <operator>*</operator><operator>)</operator><name>val</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" | %s (%d) "</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rp</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>ccs</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" | [%d] "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>vm_ci_dump</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rp_m</name><argument_list>( <argument><expr><literal type="string">" | "</literal></expr></argument>, <argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_ccs_dump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>target_mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>cc_tbl</name> <init>= <expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc_tbl</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>target_mid</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>target_mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ccs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" [CCTB] %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>cc_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_ccs_dump_i</name><argument_list>(<argument><expr><name>target_mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ccs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" [CCTB] %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>cc_tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>vm_ccs_dump_i</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>target_mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>

<name>vm_cme_dump_i</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>target_mid</name> <init>= <expr><operator>(</operator><name>ID</name><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>target_mid</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>mid</name> <operator>==</operator> <name>target_mid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rp_m</name><argument_list>(<argument><expr><literal type="string">" &gt; "</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>vm_mtbl_dump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>target_mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"#vm_mtbl\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>klass</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rp_m</name><argument_list>(<argument><expr><literal type="string">" -&gt; "</literal></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>target_mid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target_mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rp_m</name><argument_list>(<argument><expr><literal type="string">" [MTBL] "</literal></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" ##RCLASS_M_TBL (%p)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vm_cme_dump_i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" MTBL: NULL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>target_mid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target_mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rp_m</name><argument_list>(<argument><expr><literal type="string">" [CM**] "</literal></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" ##RCLASS_CALLABLE_M_TBL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>vm_cme_dump_i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>vm_ccs_dump</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>target_mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vm_mtbl_dump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>target_mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[%s] "</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_mtbl_dump</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>target_mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>

<name>vm_me_invalidate_cache</name><parameter_list>(<parameter><decl><type><name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>IMEMO_TYPE_P</name><argument_list>(<argument><expr><name>cme</name></expr></argument>, <argument><expr><name>imemo_ment</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>callable_method_entry_p</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_INVALIDATED_SET</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_cme_invalidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_clear_constant_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>INC_GLOBAL_CONSTANT_STATE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>rb_method_entry_alloc</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>called_id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>defined_class</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type> <name>rb_method_entry_clone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>src_me</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>copmplemented_callable_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>clear_method_cache_by_id_in_class</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subclasses</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>cc_tbl</name> <init>= <expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc_tbl</name> <operator>&amp;&amp;</operator> <call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ccs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_ccs_free</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_delete</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_invalidate_leaf_ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>cm_tbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cm_tbl</name> <operator>=</operator> <call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_id_table_delete</name><argument_list>(<argument><expr><name>cm_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_invalidate_leaf_callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_invalidate_leaf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><call><name>copmplemented_callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cme</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>METHOD_ENTRY_CACHED</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>METHOD_ENTRY_COMPLEMENTED</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>owner</name> <init>= <expr><name><name>cme</name><operator>-&gt;</operator><name>owner</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>new_cme</name> <init>=

<expr><operator>(</operator><name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><call><name>rb_method_entry_clone</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name>cme</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>mtbl</name> <init>= <expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>mtbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>new_cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>owner</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>, <argument><expr><name>new_cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>vm_me_invalidate_cache</name><argument_list>(<argument><expr><operator>(</operator><name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_invalidate_tree_cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>METHOD_ENTRY_COMPLEMENTED</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name> <init>= <expr><name><name>cme</name><operator>-&gt;</operator><name>defined_class</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>cm_tbl</name> <init>= <expr><call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>defined_class</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>cm_tbl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>rb_id_table_delete</name><argument_list>(<argument><expr><name>cm_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>r</name> <operator>==</operator> <name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_invalidate_tree_callable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>cc_invalidate_tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>clear_iclass_method_cache_by_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>iclass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>d</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>iclass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>ID</name><operator>)</operator><name>d</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>clear_method_cache_by_id_in_class</name><argument_list>(<argument><expr><name>iclass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>clear_iclass_method_cache_by_id_for_refinements</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>d</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>ID</name><operator>)</operator><name>d</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>clear_method_cache_by_id_in_class</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_clear_method_cache</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass_or_module</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass_or_module</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>module</name> <init>= <expr><name>klass_or_module</name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>RMODULE_IS_REFINEMENT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>refined_class</name> <init>= <expr><call><name>rb_refinement_module_get_refined_class</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_clear_method_cache</name><argument_list>(<argument><expr><name>refined_class</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_class_foreach_subclass</name><argument_list>(<argument><expr><name>refined_class</name></expr></argument>, <argument><expr><name>clear_iclass_method_cache_by_id_for_refinements</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_class_foreach_subclass</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>clear_iclass_method_cache_by_id</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>clear_method_cache_by_id_in_class</name><argument_list>(<argument><expr><name>klass_or_module</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>rb_cc_table_free</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>invalidate_all_cc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vstart</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vend</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>stride</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>vstart</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>v</name> <operator>!=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>vend</name></expr>;</condition> <incr><expr><name>v</name> <operator>+=</operator> <name>stride</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_cc_table_free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return> 

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_clear_method_cache_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_objspace_each_objects</name><argument_list>(<argument><expr><name>invalidate_all_cc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_f_notimplement</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>marker</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_notimplement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_define_notimplement_method_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_add_method_cfunc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>ANYARGS</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">2</literal> <operator>||</operator> <literal type="number">15</literal> <operator>&lt;</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"arity out of range: %d for -2..15"</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>func</name> <operator>!=</operator> <name>rb_f_notimplement</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_method_cfunc_t</name></type> <name>opt</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opt</name><operator>.</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_CFUNC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_define_notimplement_method_id</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_method_definition_release</name><parameter_list>(<parameter><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>complemented</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>def</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>alias_count</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>alias_count</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>complemented_count</name> <init>= <expr><name><name>def</name><operator>-&gt;</operator><name>complemented_count</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>alias_count</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>complemented_count</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>alias_count</name> <operator>+</operator> <name>complemented_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>METHOD_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"-%p-%s:%d,%d (remove)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>def</name></expr></argument>,

<argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>alias_count</name></expr></argument>, <argument><expr><name>complemented_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_BMETHOD</name></expr> ?</condition><then> <expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>hooks</name></name> <operator>==</operator> <name>NULL</name></expr> </then><else>: <expr><name>TRUE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>complemented</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>complemented_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>complemented_count</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>alias_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>alias_count</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>METHOD_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"-%p-%s:%d-&gt;%d,%d-&gt;%d (dec)\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>def</name></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>alias_count</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>alias_count</name></name></expr></argument>, <argument><expr><name>complemented_count</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>complemented_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_free_method_entry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_method_definition_release</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><call><name>METHOD_ENTRY_COMPLEMENTED</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>search_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>rb_method_definition_eq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>d1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>d2</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>static</specifier> <macro><name>VALUE</name>

<argument_list>(<argument>*call_cfunc_invoker_func(int argc)</argument>)</argument_list></macro><operator>(</operator><name>VALUE</name> <name>recv</name><operator>,</operator> <name>int</name> <name>argc</name><operator>,</operator> <specifier>const</specifier> <name>VALUE</name> <operator>*</operator><operator>,</operator> <call><call><name>VALUE</name> <argument_list>(<argument><expr><operator>*</operator><name>func</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ANYARGS</name></expr></argument>)</argument_list></call><operator>)</operator>

<block>{

<switch>switch <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>

<case>case <expr><operator>-</operator><literal type="number">2</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_m2</name></expr>;</return>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_m1</name></expr>;</return>

<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_0</name></expr>;</return>

<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_1</name></expr>;</return>

<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_2</name></expr>;</return>

<case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_3</name></expr>;</return>

<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_4</name></expr>;</return>

<case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_5</name></expr>;</return>

<case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_6</name></expr>;</return>

<case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_7</name></expr>;</return>

<case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_8</name></expr>;</return>

<case>case <expr><literal type="number">9</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_9</name></expr>;</return>

<case>case <expr><literal type="number">10</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_10</name></expr>;</return>

<case>case <expr><literal type="number">11</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_11</name></expr>;</return>

<case>case <expr><literal type="number">12</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_12</name></expr>;</return>

<case>case <expr><literal type="number">13</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_13</name></expr>;</return>

<case>case <expr><literal type="number">14</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_14</name></expr>;</return>

<case>case <expr><literal type="number">15</literal></expr>:</case> <return>return <expr><operator>&amp;</operator><name>call_cfunc_15</name></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"call_cfunc_func: unsupported length: %d"</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt/></block_content></block></switch>}</block></expr></expr_stmt>

}

static <function><type><name>void</name></type>

<name>setup_method_cfunc_struct</name><parameter_list>(<parameter><decl><type><name>rb_method_cfunc_t</name> <modifier>*</modifier></type><name>cfunc</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>cfunc</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfunc</name><operator>-&gt;</operator><name>argc</name></name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cfunc</name><operator>-&gt;</operator><name>invoker</name></name> <operator>=</operator> <call><name>call_cfunc_invoker_func</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>

<name>rb_method_definition_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>rb_method_definition_t</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>me</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <name>def</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_iseq_t</name> <modifier>*</modifier></type><name>iseq_body</name> <init>= <expr><operator>(</operator><name>rb_method_iseq_t</name> <operator>*</operator><operator>)</operator><name>opts</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>method_cref</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cref</name> <init>= <expr><name><name>iseq_body</name><operator>-&gt;</operator><name>cref</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr></argument>, <argument><expr><name><name>iseq_body</name><operator>-&gt;</operator><name>iseqptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>vm_cref_dump</name><argument_list>(<argument><expr><literal type="string">"rb_method_definition_create"</literal></expr></argument>, <argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>method_cref</name> <operator>=</operator> <name>cref</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>method_cref</name> <operator>=</operator> <call><name>vm_cref_new_toplevel</name><argument_list>(<argument><expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>cref</name></name></expr></argument>, <argument><expr><name>method_cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_cfunc_t</name> <modifier>*</modifier></type><name>cfunc</name> <init>= <expr><operator>(</operator><name>rb_method_cfunc_t</name> <operator>*</operator><operator>)</operator><name>opts</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setup_method_cfunc_struct</name><argument_list>(<argument><expr><call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>def</name></expr></argument>, <argument><expr><name><name>body</name><operator>.</operator><name>cfunc</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>cfunc</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name><name>cfunc</name><operator>-&gt;</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>id</name></name> <operator>=</operator> <operator>(</operator><name>ID</name><operator>)</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>opts</name></expr>;</expr_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>line</name> <operator>=</operator> <call><name>rb_vm_get_sourceline</name><argument_list>(<argument><expr><name>cfp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>location</name> <init>= <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>location</name></name></expr></argument>, <argument><expr><call><name>rb_ary_freeze</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>location</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return;</return>

</block_content>}</block>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<expr_stmt><expr><call><name>setup_method_cfunc_struct</name><argument_list>(<argument><expr><call><name>UNALIGNED_MEMBER_PTR</name><argument_list>(<argument><expr><name>def</name></expr></argument>, <argument><expr><name><name>body</name><operator>.</operator><name>cfunc</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb_f_notimplement</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>optimize_type</name></name> <operator>=</operator> <operator>(</operator>enum <name>method_optimized_type</name><operator>)</operator><operator>(</operator><name>intptr_t</name><operator>)</operator><name>opts</name></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_refined_t</name> <modifier>*</modifier></type><name>refined</name> <init>= <expr><operator>(</operator><name>rb_method_refined_t</name> <operator>*</operator><operator>)</operator><name>opts</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr></argument>, <argument><expr><name><name>refined</name><operator>-&gt;</operator><name>orig_me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>refined</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name></name></expr></argument>, <argument><expr><operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<return>return;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>method_definition_reset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>cref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>hooks</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>rb_method_definition_t</name> <modifier>*</modifier></type>

<name>rb_method_definition_create</name><parameter_list>(<parameter><decl><type><name>rb_method_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>rb_method_definition_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uintptr_t</name></type> <name>method_serial</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>method_serial</name></name> <operator>=</operator> <name>method_serial</name><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><name>def</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type>

<name>method_definition_addref</name><parameter_list>(<parameter><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>alias_count</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>METHOD_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"+%p-%s:%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>def</name></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>alias_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>def</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type>

<name>method_definition_addref_complement</name><parameter_list>(<parameter><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>complemented_count</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>METHOD_DEBUG</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"+%p-%s:%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>def</name></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>complemented_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>def</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry_alloc</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>called_id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>defined_class</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><call><name>rb_imemo_new</name><argument_list>(<argument><expr><name>imemo_ment</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>def</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>called_id</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>me</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>filter_defined_class</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>T_CLASS</name></expr>:</case>

<return>return <expr><name>klass</name></expr>;</return>

<case>case <expr><name>T_MODULE</name></expr>:</case>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>T_ICLASS</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"filter_defined_class: %s"</literal></expr></argument>, <argument><expr><call><name>rb_obj_info</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry_create</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>called_id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_method_entry_alloc</name><argument_list>(<argument><expr><name>called_id</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>filter_defined_class</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_FLAGS_SET</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>, <argument><expr><ternary><condition><expr><name>ruby_running</name></expr> ?</condition><then> <expr><name>FALSE</name></expr> </then><else>: <expr><name>TRUE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>def</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>method_definition_reset</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>me</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry_clone</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>src_me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>rb_method_entry_alloc</name><argument_list>(<argument><expr><name><name>src_me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name><name>src_me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>src_me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>,

<argument><expr><call><name>method_definition_addref</name><argument_list>(<argument><expr><name><name>src_me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>METHOD_ENTRY_COMPLEMENTED</name><argument_list>(<argument><expr><name>src_me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>method_definition_addref_complement</name><argument_list>(<argument><expr><name><name>src_me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_FLAGS_COPY</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>src_me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>me</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry_complement_defined_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>src_me</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>called_id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>defined_class</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><name><name>src_me</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_method_entry_struct</name></name> <modifier>*</modifier></type><name>orig_me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>owner</name></decl>;</decl_stmt>

}</block> <decl><name>refined</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</struct>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>src_me</name><operator>-&gt;</operator><name>defined_class</name></name> <operator>&amp;&amp;</operator>

<name><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name> <operator>&amp;&amp;</operator>

<name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>orig_me</name> <init>=

<expr><call><name>rb_method_entry_clone</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>orig_me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>orig_me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>refined</name><operator>.</operator><name>orig_me</name></name> <operator>=</operator> <name>orig_me</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>refined</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <name><name>orig_me</name><operator>-&gt;</operator><name>owner</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>def</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>method_definition_addref_complement</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_method_entry_alloc</name><argument_list>(<argument><expr><name>called_id</name></expr></argument>, <argument><expr><name><name>src_me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_FLAGS_COPY</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>src_me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_COMPLEMENTED_SET</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>def</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>rb_method_definition_create</name><argument_list>(<argument><expr><name>VM_METHOD_TYPE_REFINED</name></expr></argument>, <argument><expr><name>called_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_method_definition_set</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>me</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_method_entry_copy</name><parameter_list>(<parameter><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>rb_method_definition_t</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <call><name>method_definition_addref</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>method_definition_reset</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>called_id</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>called_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dst</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_FLAGS_COPY</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>make_method_entry_refined</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<struct>struct <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>rb_method_entry_struct</name></name> <modifier>*</modifier></type><name>orig_me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>owner</name></decl>;</decl_stmt>

}</block> <decl><name>refined</name></decl>;</struct>

<decl_stmt><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_vm_check_redefinition_opt_method</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>refined</name><operator>.</operator><name>orig_me</name></name> <operator>=</operator>

<call><name>rb_method_entry_alloc</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr> ?</condition><then>

<expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr> </then><else>: <expr><name>owner</name></expr></else></ternary></expr></argument>,

<argument><expr><call><name>method_definition_addref</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_FLAGS_COPY</name><argument_list>(<argument><expr><name><name>refined</name><operator>.</operator><name>orig_me</name></name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>refined</name><operator>.</operator><name>owner</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>

<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>rb_method_definition_create</name><argument_list>(<argument><expr><name>VM_METHOD_TYPE_REFINED</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_method_definition_set</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>refined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>METHOD_ENTRY_VISI_SET</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>lookup_method_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>m_tbl</name> <init>= <expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>m_tbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>body</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator> <name>body</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_add_refined_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>refined_class</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>lookup_method_table</name><argument_list>(<argument><expr><name>refined_class</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>make_method_entry_refined</name><argument_list>(<argument><expr><name>refined_class</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_clear_method_cache</name><argument_list>(<argument><expr><name>refined_class</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>refined_class</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_REFINED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>check_override_opt_method_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>ID</name><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>newme</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_redefinition_check_flag</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>lookup_method_table</name><argument_list>(<argument><expr><call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>newme</name> <operator>=</operator> <call><name>rb_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newme</name> <operator>!=</operator> <name>me</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_vm_check_redefinition_opt_method</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_class_foreach_subclass</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>check_override_opt_method_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>check_override_opt_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_vm_check_optimizable_mid</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_override_opt_method_i</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry_make</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>defined_class</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>,

<parameter><decl><type><name>rb_method_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>original_id</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>mtbl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>make_refined</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <name>rb_cObject</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>type</name> <operator>!=</operator> <name>VM_METHOD_TYPE_NOTIMPLEMENTED</name> <operator>&amp;&amp;</operator>

<name>type</name> <operator>!=</operator> <name>VM_METHOD_TYPE_ZSUPER</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>mid</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>idInitialize</name></expr>:</case>

<case>case <expr><name>idInitialize_copy</name></expr>:</case>

<case>case <expr><name>idInitialize_clone</name></expr>:</case>

<case>case <expr><name>idInitialize_dup</name></expr>:</case>

<case>case <expr><name>idRespond_to_missing</name></expr>:</case>

<expr_stmt><expr><name>visi</name> <operator>=</operator> <name>METHOD_VISI_PRIVATE</name></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_class_modify_check</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>RMODULE_IS_REFINEMENT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>refined_class</name> <init>= <expr><call><name>rb_refinement_module_get_refined_class</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_add_refined_method_entry</name><argument_list>(<argument><expr><name>refined_class</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>old_me</name> <init>= <expr><call><name>lookup_method_table</name><argument_list>(<argument><expr><call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>old_me</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_vm_check_redefinition_opt_method</name><argument_list>(<argument><expr><name>old_me</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>mtbl</name> <operator>=</operator> <call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>mtbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>old_me</name> <init>= <expr><operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_definition_t</name> <modifier>*</modifier></type><name>old_def</name> <init>= <expr><name><name>old_me</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_method_definition_eq</name><argument_list>(<argument><expr><name>old_def</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>old_me</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_vm_check_redefinition_opt_method</name><argument_list>(<argument><expr><name>old_me</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>old_def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>make_refined</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<name>type</name> <operator>!=</operator> <name>VM_METHOD_TYPE_UNDEF</name> <operator>&amp;&amp;</operator>

<operator>(</operator><name><name>old_def</name><operator>-&gt;</operator><name>alias_count</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>!</operator><name>make_refined</name> <operator>&amp;&amp;</operator>

<name><name>old_def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_UNDEF</name> <operator>&amp;&amp;</operator>

<name><name>old_def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_ZSUPER</name> <operator>&amp;&amp;</operator>

<name><name>old_def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_ALIAS</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"method redefined; discarding old %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>old_def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>def_iseq_ptr</name><argument_list>(<argument><expr><name>old_def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<expr_stmt><expr><name>iseq</name> <operator>=</operator> <call><name>rb_proc_get_iseq</name><argument_list>(<argument><expr><name><name>old_def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>iseq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_compile_warning</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>rb_iseq_path</name><argument_list>(<argument><expr><name>iseq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>location</name><operator>.</operator><name>first_lineno</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><literal type="string">"previous definition of %"</literal><name>PRIsVALUE</name><literal type="string">" was here"</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>old_def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_method_entry_create</name><argument_list>(<argument><expr><name>mid</name></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>def</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>rb_method_definition_create</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>original_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_method_definition_set</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_clear_method_cache</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>mid</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>idInitialize</name></expr>:</case>

<case>case <expr><name>idRespond_to_missing</name></expr>:</case>

<case>case <expr><name>idMethodMissing</name></expr>:</case>

<case>case <expr><name>idRespond_to</name></expr>:</case>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"redefining Object#%s may cause infinite loop"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>==</operator> <name>object_id</name> <operator>||</operator> <name>mid</name> <operator>==</operator> <name>id__send__</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VM_METHOD_TYPE_ISEQ</name> <operator>&amp;&amp;</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"redefining `%s' may cause serious problems"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>make_refined</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>make_method_entry_refined</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>mtbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>check_override_opt_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>me</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALL_METHOD_HOOK</name><parameter_list>(<parameter><type><name>klass</name></type></parameter>, <parameter><type><name>hook</name></type></parameter>, <parameter><type><name>mid</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const VALUE arg = ID2SYM(mid); VALUE recv_class = (klass); ID hook_id = (hook); if (FL_TEST((klass), FL_SINGLETON)) { recv_class = rb_ivar_get((klass), attached); hook_id = singleton_##hook; } rb_funcallv(recv_class, hook_id, 1, &amp;arg); } while (0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>method_added</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ruby_running</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CALL_METHOD_HOOK</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>added</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_add_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>rb_method_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opts</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_method_entry_make</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>VM_METHOD_TYPE_UNDEF</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>method_added</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>

<name>rb_add_method_iseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name></decl></parameter>, <parameter><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<struct>struct <block>{ 

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseqptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name></decl>;</decl_stmt>

}</block> <decl><name>iseq_body</name></decl>;</struct>

<expr_stmt><expr><name><name>iseq_body</name><operator>.</operator><name>iseqptr</name></name> <operator>=</operator> <name>iseq</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>iseq_body</name><operator>.</operator><name>cref</name></name> <operator>=</operator> <name>cref</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_ISEQ</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iseq_body</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>method_entry_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>,

<parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>defined_class</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>newme</name> <init>= <expr><call><name>rb_method_entry_make</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>,

<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><call><name>method_definition_addref</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>method_added</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>newme</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>method_entry_set</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDEF_ALLOC_FUNC</name></cpp:macro> <cpp:value>((rb_alloc_func_t)-1)</cpp:value></cpp:define>

<function><type><name>void</name></type>

<name>rb_define_alloc_func</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>allocator</name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_undef_alloc_func</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>UNDEF_ALLOC_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>rb_alloc_func_t</name></type>

<name>rb_get_alloc_func</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>klass</name></expr>;</condition> <incr><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>rb_alloc_func_t</name></type> <name>allocator</name> <init>= <expr><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>allocator</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>allocator</name> <operator>==</operator> <name>UNDEF_ALLOC_FUNC</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>allocator</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>allocator</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>lookup_method_table</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>rb_method_entry_t</name><modifier>*</modifier></type>

<name>search_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>mc_search</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>klass</name></expr>;</condition> <incr><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>mc_search_super</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>me</name> <operator>=</operator> <call><name>lookup_method_table</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>defined_class_ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>defined_class_ptr</name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>mc_search_notfound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>me</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>me</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>search_method_protect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>search_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>defined_class_ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>me</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>search_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>prepare_callable_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>defined_class</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>me</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>create</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>mtbl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>mc_cme_complement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>defined_class</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>defined_class</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mtbl</name> <operator>=</operator> <call><name>RCLASS_CALLABLE_M_TBL</name><argument_list>(<argument><expr><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mtbl</name> <operator>&amp;&amp;</operator> <call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>mtbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>cme</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>mc_cme_complement_hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>callable_method_entry_p</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>create</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mtbl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mtbl</name> <operator>=</operator> <call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>defined_class</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>callable_m_tbl</name> <operator>=</operator> <call><name>rb_id_table_create</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <call><name>rb_method_entry_complement_defined_class</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>mtbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>callable_method_entry_p</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>me</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>callable_method_entry_p</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>cme</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>copmplemented_callable_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>search_method_protect</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>prepare_callable_method_entry</name><argument_list>(<argument><expr><name>defined_class</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>cached_callable_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>cc_tbl</name> <init>= <expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc_tbl</name> <operator>&amp;&amp;</operator> <call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ccs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>vm_ccs_p</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>METHOD_ENTRY_INVALIDATED</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>cme</name><operator>-&gt;</operator><name>called_id</name></name> <operator>==</operator> <name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ccs_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_ccs_free</name><argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_delete</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>cache_callable_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>cc_tbl</name> <init>= <expr><call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rb_class_cc_entries</name></name> <modifier>*</modifier></type><name>ccs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cc_tbl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cc_tbl</name> <operator>=</operator> <call><name>RCLASS_CC_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>rb_id_table_create</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ccs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name><name>ccs</name><operator>-&gt;</operator><name>cme</name></name> <operator>==</operator> <name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ccs</name> <operator>=</operator> <call><name>vm_ccs_create</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>cc_tbl</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>callable_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_CLASS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><call><name>cached_callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cme</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>defined_class_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>defined_class_ptr</name> <operator>=</operator> <name><name>cme</name><operator>-&gt;</operator><name>defined_class</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>search_method_protect</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>defined_class_ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>defined_class_ptr</name> <operator>=</operator> <name>defined_class</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cme</name> <operator>=</operator> <call><name>prepare_callable_method_entry</name><argument_list>(<argument><expr><name>defined_class</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cme</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>cache_callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>cme</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_callable_method_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>resolve_refined_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>refinements</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>method_entry_resolve_refinement</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>with_refinement</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>search_method_protect</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>defined_class_ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>with_refinement</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>rb_vm_cref</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>refinements</name> <init>= <expr><ternary><condition><expr><name>cref</name></expr> ?</condition><then> <expr><call><name>CREF_REFINEMENTS</name><argument_list>(<argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>resolve_refined_method</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>defined_class_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>resolve_refined_method</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>defined_class_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>me</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>me</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry_with_refinements</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>method_entry_resolve_refinement</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>defined_class_ptr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_callable_method_entry_with_refinements</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name> <init>= <expr><call><name>callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>defined_class_ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cme</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>cme</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>cme</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dcp</name> <init>= <expr><ternary><condition><expr><name>defined_class_ptr</name></expr> ?</condition><then> <expr><name>defined_class_ptr</name></expr> </then><else>: <expr><operator>&amp;</operator><name>defined_class</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>method_entry_resolve_refinement</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>dcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>prepare_callable_method_entry</name><argument_list>(<argument><expr><operator>*</operator><name>dcp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_method_entry_without_refinements</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>method_entry_resolve_refinement</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>defined_class_ptr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_callable_method_entry_without_refinements</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dcp</name> <init>= <expr><ternary><condition><expr><name>defined_class_ptr</name></expr> ?</condition><then> <expr><name>defined_class_ptr</name></expr> </then><else>: <expr><operator>&amp;</operator><name>defined_class</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><call><name>method_entry_resolve_refinement</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>dcp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>prepare_callable_method_entry</name><argument_list>(<argument><expr><operator>*</operator><name>dcp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>resolve_refined_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>refinements</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>defined_class_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>me</name> <operator>&amp;&amp;</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>refinement</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>tmp_me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>super</name></decl>;</decl_stmt>

<expr_stmt><expr><name>refinement</name> <operator>=</operator> <call><name>find_refinement</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp_me</name> <operator>=</operator> <call><name>search_method_protect</name><argument_list>(<argument><expr><name>refinement</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name>defined_class_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp_me</name> <operator>&amp;&amp;</operator> <name><name>tmp_me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>tmp_me</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp_me</name> <operator>=</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp_me</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>defined_class_ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>defined_class_ptr</name> <operator>=</operator> <name><name>tmp_me</name><operator>-&gt;</operator><name>defined_class</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>tmp_me</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>super</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>super</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>search_method_protect</name><argument_list>(<argument><expr><name>super</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name>defined_class_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>me</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_resolve_refined_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>refinements</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>resolve_refined_method</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name>

<specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type>

<name>rb_resolve_refined_method_callable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>refinements</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>resolved_me</name> <init>= <expr><call><name>resolve_refined_method</name><argument_list>(<argument><expr><name>refinements</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name>me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>resolved_me</name> <operator>&amp;&amp;</operator> <name><name>resolved_me</name><operator>-&gt;</operator><name>defined_class</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_method_entry_complement_defined_class</name><argument_list>(<argument><expr><name>resolved_me</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><operator>(</operator><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <operator>*</operator><operator>)</operator><name>resolved_me</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>remove_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>self</name> <init>= <expr><name>klass</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_class_modify_check</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mid</name> <operator>==</operator> <name>object_id</name> <operator>||</operator> <name>mid</name> <operator>==</operator> <name>id__send__</name> <operator>||</operator> <name>mid</name> <operator>==</operator> <name>idInitialize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"removing `%s' may cause serious problems"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><operator>(</operator><name>me</name> <operator>=</operator> <operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name>data</name><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>!</operator><name><name>me</name><operator>-&gt;</operator><name>def</name></name> <operator>||</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_UNDEF</name><operator>)</operator> <operator>||</operator>

<call><name>UNDEFINED_REFINED_METHOD_P</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"method `%1$s' not defined in %2$s"</literal></expr></argument>,

<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_clear_method_cache</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_id_table_delete</name><argument_list>(<argument><expr><call><name>RCLASS_M_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_check_redefinition_opt_method</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_add_refined_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>CALL_METHOD_HOOK</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>removed</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_remove_method_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>mid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>remove_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_remove_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>remove_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_remove_method</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"method `%1$s' not defined in %2$s"</literal></expr></argument>,

<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>remove_method</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>mod</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_export_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>origin_class</name> <init>= <expr><call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>origin_class</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>me</name> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>UNDEFINED_REFINED_METHOD_P</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_print_undef</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>METHOD_VISI_UNDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>visi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_vm_check_redefinition_opt_method</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>defined_class</name> <operator>||</operator> <name>origin_class</name> <operator>==</operator> <name>defined_class</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>METHOD_ENTRY_VISI_SET</name><argument_list>(<argument><expr><name>me</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name> <operator>&amp;&amp;</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>METHOD_ENTRY_VISI_SET</name><argument_list>(<argument><expr><operator>(</operator><name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_clear_method_cache</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_ZSUPER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOUND_PRIVATE</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOUND_RESPONDS</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>

<function><type><name>int</name></type>

<name>rb_method_boundp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ex</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ex</name> <operator>&amp;</operator> <name>BOUND_RESPONDS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>method_entry_resolve_refinement</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_method_entry_without_refinements</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ex</name> <operator>&amp;</operator> <operator>~</operator><name>BOUND_RESPONDS</name><operator>)</operator> <operator>&amp;&amp;</operator>

<operator>(</operator><operator>(</operator><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>METHOD_VISI_PRIVATE</name><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>(</operator><name>ex</name> <operator>&amp;</operator> <name>BOUND_RESPONDS</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>METHOD_VISI_PROTECTED</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ex</name> <operator>&amp;</operator> <name>BOUND_RESPONDS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vm_cref_set_visibility</name><parameter_list>(<parameter><decl><type><name>rb_method_visibility_t</name></type> <name>method_visi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>module_func</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_scope_visibility_t</name> <modifier>*</modifier></type><name>scope_visi</name> <init>= <expr><operator>(</operator><name>rb_scope_visibility_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><call><name>rb_vm_cref</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>scope_visi</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>scope_visi</name><operator>-&gt;</operator><name>method_visi</name></name> <operator>=</operator> <name>method_visi</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scope_visi</name><operator>-&gt;</operator><name>module_func</name></name> <operator>=</operator> <name>module_func</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_scope_visibility_set</name><parameter_list>(<parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vm_cref_set_visibility</name><argument_list>(<argument><expr><name>visi</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>scope_visibility_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>rb_current_execution_context</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>cfp</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name> <operator>&amp;&amp;</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name> <operator>&amp;&amp;</operator> <name><name>cfp</name><operator>-&gt;</operator><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ISEQ_TYPE_METHOD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"calling %s without arguments inside a method may not have the intended effect"</literal></expr></argument>,

<argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><call><name>rb_frame_this_func</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_scope_module_func_set</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>scope_visibility_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vm_cref_set_visibility</name><argument_list>(<argument><expr><name>METHOD_VISI_PRIVATE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>rb_vm_cref_in_context</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cbase</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>

<name>rb_attr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>read</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>write</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ex</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>attriv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_cref_t</name> <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>rb_vm_cref_in_context</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ex</name> <operator>||</operator> <operator>!</operator><name>cref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>visi</name> <operator>=</operator> <name>METHOD_VISI_PUBLIC</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<switch>switch <condition>(<expr><call><name>vm_scope_visibility_get</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>METHOD_VISI_PRIVATE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>vm_scope_module_func_check</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"attribute accessor as module_function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>visi</name> <operator>=</operator> <name>METHOD_VISI_PRIVATE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>METHOD_VISI_PROTECTED</name></expr>:</case>

<expr_stmt><expr><name>visi</name> <operator>=</operator> <name>METHOD_VISI_PROTECTED</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>visi</name> <operator>=</operator> <name>METHOD_VISI_PUBLIC</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>attriv</name> <operator>=</operator> <call><name>rb_intern_str</name><argument_list>(<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"@%"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>read</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_IVAR</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>attriv</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>write</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>rb_id_attrset</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_ATTRSET</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>attriv</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_undef</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"no class to undef method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_class_modify_check</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>object_id</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>id__send__</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>idInitialize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"undefining `%s' may cause serious problems"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name> <operator>&amp;&amp;</operator> <name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_resolve_refined_method</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>UNDEFINED_REFINED_METHOD_P</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_method_name_error</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_add_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>VM_METHOD_TYPE_UNDEF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CALL_METHOD_HOOK</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>undefined</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_undef_method</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_method_name_error</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_undef</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>mod</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_method_visibility_t</name></type>

<name>check_definition_visibility</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mid</name></decl>, <decl><type ref="prev"/><name>include_super</name></decl>, <decl><type ref="prev"/><name>lookup_mod</name> <init>= <expr><name>mod</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>inc_super</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>include_super</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>METHOD_VISI_UNDEF</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inc_super</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>inc_super</name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name>include_super</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inc_super</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>lookup_mod</name> <operator>=</operator> <call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>rb_method_entry_without_refinements</name><argument_list>(<argument><expr><name>lookup_mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>METHOD_VISI_UNDEF</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>inc_super</name> <operator>&amp;&amp;</operator> <name><name>me</name><operator>-&gt;</operator><name>owner</name></name> <operator>!=</operator> <name>mod</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>METHOD_VISI_UNDEF</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>METHOD_VISI_UNDEF</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_method_defined</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name> <init>= <expr><call><name>check_definition_visibility</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>visi</name> <operator>==</operator> <name>METHOD_VISI_PUBLIC</name> <operator>||</operator> <name>visi</name> <operator>==</operator> <name>METHOD_VISI_PROTECTED</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>check_definition</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>check_definition_visibility</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>visi</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_public_method_defined</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>check_definition</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_private_method_defined</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>check_definition</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>METHOD_VISI_PRIVATE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_protected_method_defined</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>check_definition</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>METHOD_VISI_PROTECTED</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_method_entry_eq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>m1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>m2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_method_definition_eq</name><argument_list>(<argument><expr><name><name>m1</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name><name>m2</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type>

<name>original_method_definition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<label><name>again</name>:</label>

<if_stmt><if>if <condition>(<expr><name>def</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>def</name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>refined</name><operator>.</operator><name>orig_me</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<expr_stmt><expr><name>def</name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>alias</name><operator>.</operator><name>original_me</name><operator>-&gt;</operator><name>def</name></name></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>def</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>int</name></type>

<name>rb_method_definition_eq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>d1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>d2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>d1</name> <operator>=</operator> <call><name>original_method_definition</name><argument_list>(<argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>d2</name> <operator>=</operator> <call><name>original_method_definition</name><argument_list>(<argument><expr><name>d2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>d1</name> <operator>==</operator> <name>d2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>d1</name> <operator>||</operator> <operator>!</operator><name>d2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>d1</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name><name>d2</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>d1</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<return>return <expr><name><name>d1</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name> <operator>==</operator> <name><name>d2</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<return>return

<expr><name><name>d1</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>cfunc</name><operator>.</operator><name>func</name></name> <operator>==</operator> <name><name>d2</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>cfunc</name><operator>.</operator><name>func</name></name> <operator>&amp;&amp;</operator>

<name><name>d1</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>cfunc</name><operator>.</operator><name>argc</name></name> <operator>==</operator> <name><name>d2</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>cfunc</name><operator>.</operator><name>argc</name></name></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<return>return <expr><name><name>d1</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>id</name></name> <operator>==</operator> <name><name>d2</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>id</name></name></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<return>return <expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_equal</name><argument_list>(<argument><expr><name><name>d1</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>, <argument><expr><name><name>d2</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<return>return <expr><name><name>d1</name><operator>-&gt;</operator><name>original_id</name></name> <operator>==</operator> <name><name>d2</name><operator>-&gt;</operator><name>original_id</name></name></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<return>return <expr><literal type="number">1</literal></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<return>return <expr><name><name>d1</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>optimize_type</name></name> <operator>==</operator> <name><name>d2</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>optimize_type</name></name></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_method_definition_eq: unsupported type: %d\n"</literal></expr></argument>, <argument><expr><name><name>d1</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>

<name>rb_hash_method_definition</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_definition_t</name> <modifier>*</modifier></type><name>def</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>original_method_definition</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>def</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>hash</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<return>return <expr><call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_CFUNC</name></expr>:</case>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>cfunc</name><operator>.</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>cfunc</name><operator>.</operator><name>argc</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ATTRSET</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_IVAR</name></expr>:</case>

<return>return <expr><call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>attr</name><operator>.</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case>

<return>return <expr><call><name>rb_hash_proc</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_MISSING</name></expr>:</case>

<return>return <expr><call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_ZSUPER</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_NOTIMPLEMENTED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_UNDEF</name></expr>:</case>

<return>return <expr><name>hash</name></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_OPTIMIZED</name></expr>:</case>

<return>return <expr><call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>optimize_type</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VM_METHOD_TYPE_REFINED</name></expr>:</case>

<case>case <expr><name>VM_METHOD_TYPE_ALIAS</name></expr>:</case>

<break>break;</break> 

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_hash_method_definition: unsupported method type (%d)\n"</literal></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>st_index_t</name></type>

<name>rb_hash_method_entry</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_hash_method_definition</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_alias</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>alias_name</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>original_name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>target_klass</name> <init>= <expr><name>klass</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>orig_me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name> <init>= <expr><name>METHOD_VISI_UNDEF</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"no class to make alias"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_class_modify_check</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>again</name>:</label>

<expr_stmt><expr><name>orig_me</name> <operator>=</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>original_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>orig_me</name> <operator>&amp;&amp;</operator> <name><name>orig_me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_REFINED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>orig_me</name> <operator>=</operator> <call><name>rb_resolve_refined_method</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>orig_me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>orig_me</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>UNDEFINED_REFINED_METHOD_P</name><argument_list>(<argument><expr><name><name>orig_me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>orig_me</name> <operator>=</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>original_name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call><operator>,</operator>

<call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>orig_me</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_print_undef</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>original_name</name></expr></argument>, <argument><expr><name>METHOD_VISI_UNDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>orig_me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VM_METHOD_TYPE_ZSUPER</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>original_name</name> <operator>=</operator> <name><name>orig_me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>original_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>visi</name> <operator>=</operator> <call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>orig_me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>visi</name> <operator>==</operator> <name>METHOD_VISI_UNDEF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>visi</name> <operator>=</operator> <call><name>METHOD_ENTRY_VISI</name><argument_list>(<argument><expr><name>orig_me</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>orig_me</name><operator>-&gt;</operator><name>defined_class</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_method_entry_make</name><argument_list>(<argument><expr><name>target_klass</name></expr></argument>, <argument><expr><name>alias_name</name></expr></argument>, <argument><expr><name>target_klass</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>,

<argument><expr><name>VM_METHOD_TYPE_ALIAS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>orig_me</name><operator>-&gt;</operator><name>called_id</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>rb_method_entry_clone</name><argument_list>(<argument><expr><name>orig_me</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>method_added</name><argument_list>(<argument><expr><name>target_klass</name></expr></argument>, <argument><expr><name>alias_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>alias_me</name></decl>;</decl_stmt>

<expr_stmt><expr><name>alias_me</name> <operator>=</operator> <call><name>method_entry_set</name><argument_list>(<argument><expr><name>target_klass</name></expr></argument>, <argument><expr><name>alias_name</name></expr></argument>, <argument><expr><name>orig_me</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>, <argument><expr><name><name>orig_me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>alias_me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alias_me</name><operator>-&gt;</operator><name>owner</name></name></expr></argument>, <argument><expr><name>target_klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>alias_me</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alias_me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>, <argument><expr><name><name>orig_me</name><operator>-&gt;</operator><name>defined_class</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_alias_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>newname</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>oldname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>oldid</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oldname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oldid</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_print_undef_str</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>oldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_alias</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><call><name>rb_to_id</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>mod</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>set_method_visibility</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">" with no argument is just ignored"</literal></expr></argument>,

<argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><call><name>rb_frame_callee</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_print_undef_str</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_export_method</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>set_visibility</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>, <parameter><decl><type><name>rb_method_visibility_t</name></type> <name>visi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>scope_visibility_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_scope_visibility_set</name><argument_list>(<argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>set_method_visibility</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>visi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>module</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_public</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>set_visibility</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>module</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_protected</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>set_visibility</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>module</name></expr></argument>, <argument><expr><name>METHOD_VISI_PROTECTED</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_private</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>set_visibility</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>module</name></expr></argument>, <argument><expr><name>METHOD_VISI_PRIVATE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_ruby2_keywords</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>origin_class</name> <init>= <expr><call><name>RCLASS_ORIGIN</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>name</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_print_undef_str</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>origin_class</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>me</name> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>UNDEFINED_REFINED_METHOD_P</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_print_undef</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>METHOD_VISI_UNDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>module</name> <operator>==</operator> <name>defined_class</name> <operator>||</operator> <name>origin_class</name> <operator>==</operator> <name>defined_class</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>VM_METHOD_TYPE_ISEQ</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>iseq</name><operator>.</operator><name>iseqptr</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ruby2_keywords</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_clear_method_cache</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"Skipping set of ruby2_keywords flag for %s (method accepts keywords or method does not accept argument splat)"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>VM_METHOD_TYPE_BMETHOD</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procval</name> <init>= <expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>body</name><operator>.</operator><name>bmethod</name><operator>.</operator><name>proc</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>block_handler_type_proc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>procval</name> <operator>=</operator> <call><name>vm_proc_to_block_handler</name><argument_list>(<argument><expr><call><name>VM_BH_TO_PROC</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vm_block_handler_type</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>block_handler_type_iseq</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_captured_block</name></name> <modifier>*</modifier></type><name>captured</name> <init>= <expr><call><name>VM_BH_TO_ISEQ_BLOCK</name><argument_list>(<argument><expr><name>procval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type><name>iseq</name> <init>= <expr><call><name>rb_iseq_check</name><argument_list>(<argument><expr><name><name>captured</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_rest</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kw</name></name> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>has_kwrest</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>iseq</name><operator>-&gt;</operator><name>body</name><operator>-&gt;</operator><name>param</name><operator>.</operator><name>flags</name><operator>.</operator><name>ruby2_keywords</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_clear_method_cache</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"Skipping set of ruby2_keywords flag for %s (method accepts keywords or method does not accept argument splat)"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"Skipping set of ruby2_keywords flag for %s (method not defined in Ruby)"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"Skipping set of ruby2_keywords flag for %s (can only set in method defining module)"</literal></expr></argument>, <argument><expr><call><name>rb_id2name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_public_method</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>set_method_visibility</name><argument_list>(<argument><expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_private_method</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>set_method_visibility</name><argument_list>(<argument><expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>METHOD_VISI_PRIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>top_public</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_mod_public</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>top_private</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_mod_private</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>top_ruby2_keywords</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_mod_ruby2_keywords</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_mod_modfunc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>module</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_method_entry_t</name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"module_function must be called for modules"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_scope_module_func_set</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>module</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>set_method_visibility</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>METHOD_VISI_PRIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>m</name> <init>= <expr><name>module</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_to_id</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>me</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>me</name> <operator>=</operator> <call><name>search_method</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNDEFINED_METHOD_ENTRY_P</name><argument_list>(<argument><expr><name>me</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_print_undef</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>METHOD_VISI_UNDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>me</name><operator>-&gt;</operator><name>def</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>VM_METHOD_TYPE_ZSUPER</name></expr>)</condition> <block>{<block_content>

<break>break;</break> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>m</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_method_entry_set</name><argument_list>(<argument><expr><call><name>rb_singleton_class</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>me</name></expr></argument>, <argument><expr><name>METHOD_VISI_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>module</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>push_macro</name><name>(</name><cpp:literal>"rb_method_basic_definition_p"</cpp:literal><name>)</name></cpp:pragma>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_method_basic_definition_p</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>rb_method_basic_definition_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>klass</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>cme</name> <operator>=</operator> <call><name>rb_callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>cme</name> <operator>&amp;&amp;</operator> <call><name>METHOD_ENTRY_BASIC</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pop_macro</name><name>(</name><cpp:literal>"rb_method_basic_definition_p"</cpp:literal><name>)</name></cpp:pragma>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_method_entry</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>defined_class</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier></type><name>cme</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>passed_block_handler</name> <init>= <expr><call><name>vm_passed_block_handler</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_vm_call_kw</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vm_passed_block_handler_set</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>passed_block_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>basic_obj_respond_to_missing</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>mid</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>priv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>, <decl><type ref="prev"/><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>rtmid</name> <init>= <expr><name>idRespond_to_missing</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cme</name> <init>= <expr><call><name>callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>rtmid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cme</name> <operator>||</operator> <call><name>METHOD_ENTRY_BASIC</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qundef</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>priv</name></expr>;</expr_stmt>

<return>return <expr><call><name>call_method_entry</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>defined_class</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>rtmid</name></expr></argument>, <argument><expr><name>cme</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>basic_obj_respond_to</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pub</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>rb_method_boundp</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pub</name><operator>|</operator><name>BOUND_RESPONDS</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<return>return <expr><name>FALSE</name></expr>;</return>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>basic_obj_respond_to_missing</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name>pub</name></expr> ?</condition><then> <expr><name>Qfalse</name></expr> </then><else>: <expr><name>Qtrue</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ret</name> <operator>!=</operator> <name>Qundef</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vm_respond_to</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>priv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>defined_class</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>resid</name> <init>= <expr><name>idRespond_to</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_callable_method_entry_t</name> <modifier>*</modifier><specifier>const</specifier></type> <name>cme</name> <init>= <expr><call><name>callable_method_entry</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>resid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>defined_class</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cme</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>METHOD_ENTRY_BASIC</name><argument_list>(<argument><expr><name>cme</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>priv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_method_entry_arity</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name>cme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>,

<argument><expr><literal type="string">"respond_to? must accept 1 or 2 arguments (requires %d)"</literal></expr></argument>,

<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>location</name> <init>= <expr><call><name>rb_method_entry_location</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>rb_method_entry_t</name> <operator>*</operator><operator>)</operator><name>cme</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>rb_warn</name><argument_list>(<argument><literal type="string">"%"</literal>PRIsVALUE<literal type="string">"%c""</literal>respond_to?(:%<literal type="string">"PRIsVALUE"</literal>) uses<literal type="string">"

"</literal> the deprecated method signature</argument>, <argument>which takes one parameter<literal type="string">",

(FL_TEST(klass, FL_SINGLETON) ? obj : klass),

(FL_TEST(klass, FL_SINGLETON) ? '.' : '#'),

QUOTE_ID(id));

if (!NIL_P(location)) {

VALUE path = RARRAY_AREF(location, 0);

VALUE line = RARRAY_AREF(location, 1);

if (!NIL_P(path)) {

rb_compile_warn(RSTRING_PTR(path), NUM2INT(line),

"</literal>respond_to? is defined here<literal type="string">");

}

}

}

}

result = call_method_entry(ec, defined_class, obj, resid, cme, argc, args, RB_NO_KEYWORDS);

return RTEST(result);

}

}

int

rb_obj_respond_to(VALUE obj, ID id, int priv)

{

rb_execution_context_t *ec = GET_EC();

VALUE klass = CLASS_OF(obj);

int ret = vm_respond_to(ec, klass, obj, id, priv);

if (ret == -1) ret = basic_obj_respond_to(ec, obj, id, !priv);

return ret;

}

int

rb_respond_to(VALUE obj, ID id)

{

return rb_obj_respond_to(obj, id, FALSE);

}

/*

* call-seq:

* obj.respond_to?(symbol, include_all=false) -&gt; true or false

* obj.respond_to?(string, include_all=false) -&gt; true or false

*

* Returns +true+ if _obj_ responds to the given method. Private and

* protected methods are included in the search only if the optional

* second parameter evaluates to +true+.

*

* If the method is not implemented,

* as Process.fork on Windows, File.lchmod on GNU/Linux, etc.,

* false is returned.

*

* If the method is not defined, &lt;code&gt;respond_to_missing?&lt;/code&gt;

* method is called and the result is returned.

*

* When the method name parameter is given as a string, the string is

* converted to a symbol.

*/

static VALUE

obj_respond_to(int argc, VALUE *argv, VALUE obj)

{

VALUE mid, priv;

ID id;

rb_execution_context_t *ec = GET_EC();

rb_scan_args(argc, argv, "</literal><literal type="number">11</literal><literal type="string">", &amp;mid, &amp;priv);

if (!(id = rb_check_id(&amp;mid))) {

VALUE ret = basic_obj_respond_to_missing(ec, CLASS_OF(obj), obj,

rb_to_symbol(mid), priv);

if (ret == Qundef) ret = Qfalse;

return ret;

}

if (basic_obj_respond_to(ec, obj, id, !RTEST(priv)))

return Qtrue;

return Qfalse;

}

/*

* call-seq:

* obj.respond_to_missing?(symbol, include_all) -&gt; true or false

* obj.respond_to_missing?(string, include_all) -&gt; true or false

*

* DO NOT USE THIS DIRECTLY.

*

* Hook method to return whether the _obj_ can respond to _id_ method

* or not.

*

* When the method name parameter is given as a string, the string is

* converted to a symbol.

*

* See #respond_to?, and the example of BasicObject.

*/

static VALUE

obj_respond_to_missing(VALUE obj, VALUE mid, VALUE priv)

{

return Qfalse;

}

void

Init_Method(void)

{

//

}

void

Init_eval_method(void)

{

#undef rb_intern

#define rb_intern(str) rb_intern_const(str)

rb_define_method(rb_mKernel, "</literal>respond_to?<literal type="string">", obj_respond_to, -1);

rb_define_method(rb_mKernel, "</literal>respond_to_missing?<literal type="string">", obj_respond_to_missing, 2);

rb_define_method(rb_cModule, "</literal>remove_method<literal type="string">", rb_mod_remove_method, -1);

rb_define_method(rb_cModule, "</literal>undef_method<literal type="string">", rb_mod_undef_method, -1);

rb_define_method(rb_cModule, "</literal>alias_method<literal type="string">", rb_mod_alias_method, 2);

rb_define_private_method(rb_cModule, "</literal>public<literal type="string">", rb_mod_public, -1);

rb_define_private_method(rb_cModule, "</literal>protected<literal type="string">", rb_mod_protected, -1);

rb_define_private_method(rb_cModule, "</literal>private<literal type="string">", rb_mod_private, -1);

rb_define_private_method(rb_cModule, "</literal>module_function<literal type="string">", rb_mod_modfunc, -1);

rb_define_private_method(rb_cModule, "</literal>ruby2_keywords<literal type="string">", rb_mod_ruby2_keywords, -1);

rb_define_method(rb_cModule, "</literal>method_defined?<literal type="string">", rb_mod_method_defined, -1);

rb_define_method(rb_cModule, "</literal>public_method_defined?<literal type="string">", rb_mod_public_method_defined, -1);

rb_define_method(rb_cModule, "</literal>private_method_defined?<literal type="string">", rb_mod_private_method_defined, -1);

rb_define_method(rb_cModule, "</literal>protected_method_defined?<literal type="string">", rb_mod_protected_method_defined, -1);

rb_define_method(rb_cModule, "</literal>public_class_method<literal type="string">", rb_mod_public_method, -1);

rb_define_method(rb_cModule, "</literal>private_class_method<literal type="string">", rb_mod_private_method, -1);

rb_define_private_method(rb_singleton_class(rb_vm_top_self()),

"</literal>public<literal type="string">", top_public, -1);

rb_define_private_method(rb_singleton_class(rb_vm_top_self()),

"</literal>private<literal type="string">", top_private, -1);

rb_define_private_method(rb_singleton_class(rb_vm_top_self()),

"</literal>ruby2_keywords<literal type="string">"</literal></argument></argument_list></macro></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></else></if_stmt></block_content></block></function>, top_ruby2_keywords, -1);

{

#define REPLICATE_METHOD(klass, id) do { const rb_method_entry_t *me = rb_method_entry((klass), (id)); rb_method_entry_set((klass), (id), me, METHOD_ENTRY_VISI(me)); } while (0)

REPLICATE_METHOD(rb_eException, idMethodMissing);

REPLICATE_METHOD(rb_eException, idRespond_to);

REPLICATE_METHOD(rb_eException, idRespond_to_missing);

}

}

</unit>
