<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\re.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"encindex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/imemo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/re.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regint.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/re.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eRegexpError</name></decl>;</decl_stmt>

<typedef>typedef <type><name>char</name></type> <name><name>onig_errmsg_buffer</name><index>[<expr><name>ONIG_MAX_ERROR_MESSAGE_LEN</name></expr>]</index></name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>errcpy</name><parameter_list>(<parameter><type><name>err</name></type></parameter>, <parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strlcpy((err), (msg), ONIG_MAX_ERROR_MESSAGE_LEN)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEG</name><parameter_list>(<parameter><type><name>no</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(regs-&gt;beg[(no)])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END</name><parameter_list>(<parameter><type><name>no</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(regs-&gt;end[(no)])</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="char">'a'</literal> <operator>==</operator> <literal type="number">97</literal></expr></cpp:if> 

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>casetable</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="char">'\000'</literal></expr>, <expr><literal type="char">'\001'</literal></expr>, <expr><literal type="char">'\002'</literal></expr>, <expr><literal type="char">'\003'</literal></expr>, <expr><literal type="char">'\004'</literal></expr>, <expr><literal type="char">'\005'</literal></expr>, <expr><literal type="char">'\006'</literal></expr>, <expr><literal type="char">'\007'</literal></expr>,

<expr><literal type="char">'\010'</literal></expr>, <expr><literal type="char">'\011'</literal></expr>, <expr><literal type="char">'\012'</literal></expr>, <expr><literal type="char">'\013'</literal></expr>, <expr><literal type="char">'\014'</literal></expr>, <expr><literal type="char">'\015'</literal></expr>, <expr><literal type="char">'\016'</literal></expr>, <expr><literal type="char">'\017'</literal></expr>,

<expr><literal type="char">'\020'</literal></expr>, <expr><literal type="char">'\021'</literal></expr>, <expr><literal type="char">'\022'</literal></expr>, <expr><literal type="char">'\023'</literal></expr>, <expr><literal type="char">'\024'</literal></expr>, <expr><literal type="char">'\025'</literal></expr>, <expr><literal type="char">'\026'</literal></expr>, <expr><literal type="char">'\027'</literal></expr>,

<expr><literal type="char">'\030'</literal></expr>, <expr><literal type="char">'\031'</literal></expr>, <expr><literal type="char">'\032'</literal></expr>, <expr><literal type="char">'\033'</literal></expr>, <expr><literal type="char">'\034'</literal></expr>, <expr><literal type="char">'\035'</literal></expr>, <expr><literal type="char">'\036'</literal></expr>, <expr><literal type="char">'\037'</literal></expr>,

<expr><literal type="char">'\040'</literal></expr>, <expr><literal type="char">'\041'</literal></expr>, <expr><literal type="char">'\042'</literal></expr>, <expr><literal type="char">'\043'</literal></expr>, <expr><literal type="char">'\044'</literal></expr>, <expr><literal type="char">'\045'</literal></expr>, <expr><literal type="char">'\046'</literal></expr>, <expr><literal type="char">'\047'</literal></expr>,

<expr><literal type="char">'\050'</literal></expr>, <expr><literal type="char">'\051'</literal></expr>, <expr><literal type="char">'\052'</literal></expr>, <expr><literal type="char">'\053'</literal></expr>, <expr><literal type="char">'\054'</literal></expr>, <expr><literal type="char">'\055'</literal></expr>, <expr><literal type="char">'\056'</literal></expr>, <expr><literal type="char">'\057'</literal></expr>,

<expr><literal type="char">'\060'</literal></expr>, <expr><literal type="char">'\061'</literal></expr>, <expr><literal type="char">'\062'</literal></expr>, <expr><literal type="char">'\063'</literal></expr>, <expr><literal type="char">'\064'</literal></expr>, <expr><literal type="char">'\065'</literal></expr>, <expr><literal type="char">'\066'</literal></expr>, <expr><literal type="char">'\067'</literal></expr>,

<expr><literal type="char">'\070'</literal></expr>, <expr><literal type="char">'\071'</literal></expr>, <expr><literal type="char">'\072'</literal></expr>, <expr><literal type="char">'\073'</literal></expr>, <expr><literal type="char">'\074'</literal></expr>, <expr><literal type="char">'\075'</literal></expr>, <expr><literal type="char">'\076'</literal></expr>, <expr><literal type="char">'\077'</literal></expr>,

<expr><literal type="char">'\100'</literal></expr>, <expr><literal type="char">'\141'</literal></expr>, <expr><literal type="char">'\142'</literal></expr>, <expr><literal type="char">'\143'</literal></expr>, <expr><literal type="char">'\144'</literal></expr>, <expr><literal type="char">'\145'</literal></expr>, <expr><literal type="char">'\146'</literal></expr>, <expr><literal type="char">'\147'</literal></expr>,

<expr><literal type="char">'\150'</literal></expr>, <expr><literal type="char">'\151'</literal></expr>, <expr><literal type="char">'\152'</literal></expr>, <expr><literal type="char">'\153'</literal></expr>, <expr><literal type="char">'\154'</literal></expr>, <expr><literal type="char">'\155'</literal></expr>, <expr><literal type="char">'\156'</literal></expr>, <expr><literal type="char">'\157'</literal></expr>,

<expr><literal type="char">'\160'</literal></expr>, <expr><literal type="char">'\161'</literal></expr>, <expr><literal type="char">'\162'</literal></expr>, <expr><literal type="char">'\163'</literal></expr>, <expr><literal type="char">'\164'</literal></expr>, <expr><literal type="char">'\165'</literal></expr>, <expr><literal type="char">'\166'</literal></expr>, <expr><literal type="char">'\167'</literal></expr>,

<expr><literal type="char">'\170'</literal></expr>, <expr><literal type="char">'\171'</literal></expr>, <expr><literal type="char">'\172'</literal></expr>, <expr><literal type="char">'\133'</literal></expr>, <expr><literal type="char">'\134'</literal></expr>, <expr><literal type="char">'\135'</literal></expr>, <expr><literal type="char">'\136'</literal></expr>, <expr><literal type="char">'\137'</literal></expr>,

<expr><literal type="char">'\140'</literal></expr>, <expr><literal type="char">'\141'</literal></expr>, <expr><literal type="char">'\142'</literal></expr>, <expr><literal type="char">'\143'</literal></expr>, <expr><literal type="char">'\144'</literal></expr>, <expr><literal type="char">'\145'</literal></expr>, <expr><literal type="char">'\146'</literal></expr>, <expr><literal type="char">'\147'</literal></expr>,

<expr><literal type="char">'\150'</literal></expr>, <expr><literal type="char">'\151'</literal></expr>, <expr><literal type="char">'\152'</literal></expr>, <expr><literal type="char">'\153'</literal></expr>, <expr><literal type="char">'\154'</literal></expr>, <expr><literal type="char">'\155'</literal></expr>, <expr><literal type="char">'\156'</literal></expr>, <expr><literal type="char">'\157'</literal></expr>,

<expr><literal type="char">'\160'</literal></expr>, <expr><literal type="char">'\161'</literal></expr>, <expr><literal type="char">'\162'</literal></expr>, <expr><literal type="char">'\163'</literal></expr>, <expr><literal type="char">'\164'</literal></expr>, <expr><literal type="char">'\165'</literal></expr>, <expr><literal type="char">'\166'</literal></expr>, <expr><literal type="char">'\167'</literal></expr>,

<expr><literal type="char">'\170'</literal></expr>, <expr><literal type="char">'\171'</literal></expr>, <expr><literal type="char">'\172'</literal></expr>, <expr><literal type="char">'\173'</literal></expr>, <expr><literal type="char">'\174'</literal></expr>, <expr><literal type="char">'\175'</literal></expr>, <expr><literal type="char">'\176'</literal></expr>, <expr><literal type="char">'\177'</literal></expr>,

<expr><literal type="char">'\200'</literal></expr>, <expr><literal type="char">'\201'</literal></expr>, <expr><literal type="char">'\202'</literal></expr>, <expr><literal type="char">'\203'</literal></expr>, <expr><literal type="char">'\204'</literal></expr>, <expr><literal type="char">'\205'</literal></expr>, <expr><literal type="char">'\206'</literal></expr>, <expr><literal type="char">'\207'</literal></expr>,

<expr><literal type="char">'\210'</literal></expr>, <expr><literal type="char">'\211'</literal></expr>, <expr><literal type="char">'\212'</literal></expr>, <expr><literal type="char">'\213'</literal></expr>, <expr><literal type="char">'\214'</literal></expr>, <expr><literal type="char">'\215'</literal></expr>, <expr><literal type="char">'\216'</literal></expr>, <expr><literal type="char">'\217'</literal></expr>,

<expr><literal type="char">'\220'</literal></expr>, <expr><literal type="char">'\221'</literal></expr>, <expr><literal type="char">'\222'</literal></expr>, <expr><literal type="char">'\223'</literal></expr>, <expr><literal type="char">'\224'</literal></expr>, <expr><literal type="char">'\225'</literal></expr>, <expr><literal type="char">'\226'</literal></expr>, <expr><literal type="char">'\227'</literal></expr>,

<expr><literal type="char">'\230'</literal></expr>, <expr><literal type="char">'\231'</literal></expr>, <expr><literal type="char">'\232'</literal></expr>, <expr><literal type="char">'\233'</literal></expr>, <expr><literal type="char">'\234'</literal></expr>, <expr><literal type="char">'\235'</literal></expr>, <expr><literal type="char">'\236'</literal></expr>, <expr><literal type="char">'\237'</literal></expr>,

<expr><literal type="char">'\240'</literal></expr>, <expr><literal type="char">'\241'</literal></expr>, <expr><literal type="char">'\242'</literal></expr>, <expr><literal type="char">'\243'</literal></expr>, <expr><literal type="char">'\244'</literal></expr>, <expr><literal type="char">'\245'</literal></expr>, <expr><literal type="char">'\246'</literal></expr>, <expr><literal type="char">'\247'</literal></expr>,

<expr><literal type="char">'\250'</literal></expr>, <expr><literal type="char">'\251'</literal></expr>, <expr><literal type="char">'\252'</literal></expr>, <expr><literal type="char">'\253'</literal></expr>, <expr><literal type="char">'\254'</literal></expr>, <expr><literal type="char">'\255'</literal></expr>, <expr><literal type="char">'\256'</literal></expr>, <expr><literal type="char">'\257'</literal></expr>,

<expr><literal type="char">'\260'</literal></expr>, <expr><literal type="char">'\261'</literal></expr>, <expr><literal type="char">'\262'</literal></expr>, <expr><literal type="char">'\263'</literal></expr>, <expr><literal type="char">'\264'</literal></expr>, <expr><literal type="char">'\265'</literal></expr>, <expr><literal type="char">'\266'</literal></expr>, <expr><literal type="char">'\267'</literal></expr>,

<expr><literal type="char">'\270'</literal></expr>, <expr><literal type="char">'\271'</literal></expr>, <expr><literal type="char">'\272'</literal></expr>, <expr><literal type="char">'\273'</literal></expr>, <expr><literal type="char">'\274'</literal></expr>, <expr><literal type="char">'\275'</literal></expr>, <expr><literal type="char">'\276'</literal></expr>, <expr><literal type="char">'\277'</literal></expr>,

<expr><literal type="char">'\300'</literal></expr>, <expr><literal type="char">'\301'</literal></expr>, <expr><literal type="char">'\302'</literal></expr>, <expr><literal type="char">'\303'</literal></expr>, <expr><literal type="char">'\304'</literal></expr>, <expr><literal type="char">'\305'</literal></expr>, <expr><literal type="char">'\306'</literal></expr>, <expr><literal type="char">'\307'</literal></expr>,

<expr><literal type="char">'\310'</literal></expr>, <expr><literal type="char">'\311'</literal></expr>, <expr><literal type="char">'\312'</literal></expr>, <expr><literal type="char">'\313'</literal></expr>, <expr><literal type="char">'\314'</literal></expr>, <expr><literal type="char">'\315'</literal></expr>, <expr><literal type="char">'\316'</literal></expr>, <expr><literal type="char">'\317'</literal></expr>,

<expr><literal type="char">'\320'</literal></expr>, <expr><literal type="char">'\321'</literal></expr>, <expr><literal type="char">'\322'</literal></expr>, <expr><literal type="char">'\323'</literal></expr>, <expr><literal type="char">'\324'</literal></expr>, <expr><literal type="char">'\325'</literal></expr>, <expr><literal type="char">'\326'</literal></expr>, <expr><literal type="char">'\327'</literal></expr>,

<expr><literal type="char">'\330'</literal></expr>, <expr><literal type="char">'\331'</literal></expr>, <expr><literal type="char">'\332'</literal></expr>, <expr><literal type="char">'\333'</literal></expr>, <expr><literal type="char">'\334'</literal></expr>, <expr><literal type="char">'\335'</literal></expr>, <expr><literal type="char">'\336'</literal></expr>, <expr><literal type="char">'\337'</literal></expr>,

<expr><literal type="char">'\340'</literal></expr>, <expr><literal type="char">'\341'</literal></expr>, <expr><literal type="char">'\342'</literal></expr>, <expr><literal type="char">'\343'</literal></expr>, <expr><literal type="char">'\344'</literal></expr>, <expr><literal type="char">'\345'</literal></expr>, <expr><literal type="char">'\346'</literal></expr>, <expr><literal type="char">'\347'</literal></expr>,

<expr><literal type="char">'\350'</literal></expr>, <expr><literal type="char">'\351'</literal></expr>, <expr><literal type="char">'\352'</literal></expr>, <expr><literal type="char">'\353'</literal></expr>, <expr><literal type="char">'\354'</literal></expr>, <expr><literal type="char">'\355'</literal></expr>, <expr><literal type="char">'\356'</literal></expr>, <expr><literal type="char">'\357'</literal></expr>,

<expr><literal type="char">'\360'</literal></expr>, <expr><literal type="char">'\361'</literal></expr>, <expr><literal type="char">'\362'</literal></expr>, <expr><literal type="char">'\363'</literal></expr>, <expr><literal type="char">'\364'</literal></expr>, <expr><literal type="char">'\365'</literal></expr>, <expr><literal type="char">'\366'</literal></expr>, <expr><literal type="char">'\367'</literal></expr>,

<expr><literal type="char">'\370'</literal></expr>, <expr><literal type="char">'\371'</literal></expr>, <expr><literal type="char">'\372'</literal></expr>, <expr><literal type="char">'\373'</literal></expr>, <expr><literal type="char">'\374'</literal></expr>, <expr><literal type="char">'\375'</literal></expr>, <expr><literal type="char">'\376'</literal></expr>, <expr><literal type="char">'\377'</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:error>#<cpp:directive>error</cpp:directive> &gt;&gt;&gt; "You lose. You will need a translation table for your character set." &lt;&lt;&lt;</cpp:error>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>rb_memcicmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>x</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name> <init>= <expr><name>y</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tmp</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp</name> <operator>=</operator> <name><name>casetable</name><index>[<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>*</operator><name>p1</name><operator>++</operator></expr>]</index></name> <operator>-</operator> <name><name>casetable</name><index>[<expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>*</operator><name>p2</name><operator>++</operator></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>tmp</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMMEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>

<name>rb_memsearch_ss</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>xs</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ys</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>y</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>y</name> <operator>=</operator> <call><name>memmem</name><argument_list>(<argument><expr><name>ys</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>xs</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>y</name> <operator>-</operator> <name>ys</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>

<name>rb_memsearch_ss</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>xs</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ys</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name>xs</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xe</name> <init>= <expr><name>xs</name> <operator>+</operator> <name>m</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>y</name> <init>= <expr><name>ys</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ye</name> <init>= <expr><name>ys</name> <operator>+</operator> <name>n</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALUE_MAX</name></cpp:macro> <cpp:value>((VALUE)~(VALUE)0)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hx</name></decl>, <decl><type ref="prev"/><name>hy</name></decl>, <decl><type ref="prev"/><name>mask</name> <init>= <expr><name>VALUE_MAX</name> <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><name>SIZEOF_VALUE</name> <operator>-</operator> <name>m</name><operator>)</operator> <operator>*</operator> <name>CHAR_BIT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&gt;</operator> <name>SIZEOF_VALUE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"!!too long pattern string!!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>y</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><operator>*</operator><name>x</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>hx</name> <operator>=</operator> <operator>*</operator><name>x</name><operator>++</operator></expr><operator>,</operator> <expr><name>hy</name> <operator>=</operator> <operator>*</operator><name>y</name><operator>++</operator></expr>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>xe</name></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr><operator>,</operator> <expr><operator>++</operator><name>y</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>hx</name> <operator>&lt;&lt;=</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hy</name> <operator>&lt;&lt;=</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hx</name> <operator>|=</operator> <operator>*</operator><name>x</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hy</name> <operator>|=</operator> <operator>*</operator><name>y</name></expr>;</expr_stmt>

</block_content>}</block></for>

<while>while <condition>(<expr><name>hx</name> <operator>!=</operator> <name>hy</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>==</operator> <name>ye</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hy</name> <operator>&lt;&lt;=</operator> <name>CHAR_BIT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hy</name> <operator>|=</operator> <operator>*</operator><name>y</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hy</name> <operator>&amp;=</operator> <name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>y</name> <operator>-</operator> <name>ys</name> <operator>-</operator> <name>m</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>

<name>rb_memsearch_qs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>xs</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ys</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name>xs</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xe</name> <init>= <expr><name>xs</name> <operator>+</operator> <name>m</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>y</name> <init>= <expr><name>ys</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name><name>qstable</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qstable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>xe</name></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qstable</name><index>[<expr><operator>*</operator><name>x</name></expr>]</index></name> <operator>=</operator> <name>xe</name> <operator>-</operator> <name>x</name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init>;</init> <condition><expr><name>y</name> <operator>+</operator> <name>m</name> <operator>&lt;=</operator> <name>ys</name> <operator>+</operator> <name>n</name></expr>;</condition> <incr><expr><name>y</name> <operator>+=</operator> <operator>*</operator><operator>(</operator><name>qstable</name> <operator>+</operator> <name><name>y</name><index>[<expr><name>m</name></expr>]</index></name><operator>)</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>xs</name> <operator>==</operator> <operator>*</operator><name>y</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>xs</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>y</name> <operator>-</operator> <name>ys</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type>

<name>rb_memsearch_qs_utf8_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>mix</name> <init>= <expr><literal type="number">8353</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><operator>*</operator><name>x</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>h</name> <operator>&lt;</operator> <literal type="number">0xC0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>h</name> <operator>+</operator> <literal type="number">256</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>h</name> <operator>&lt;</operator> <literal type="number">0xE0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>mix</name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>h</name> <operator>&lt;</operator> <literal type="number">0xF0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>mix</name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>mix</name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>h</name> <operator>&lt;</operator> <literal type="number">0xF5</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>mix</name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>mix</name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>mix</name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>+=</operator> <name><name>x</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><name>h</name> <operator>+</operator> <literal type="number">256</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>h</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>

<name>rb_memsearch_qs_utf8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>xs</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ys</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name>xs</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>xe</name> <init>= <expr><name>xs</name> <operator>+</operator> <name>m</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>y</name> <init>= <expr><name>ys</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name><name>qstable</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">512</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>qstable</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init>;</init> <condition><expr><name>x</name> <operator>&lt;</operator> <name>xe</name></expr>;</condition> <incr><expr><operator>++</operator><name>x</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>qstable</name><index>[<expr><call><name>rb_memsearch_qs_utf8_hash</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>xe</name> <operator>-</operator> <name>x</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init>;</init> <condition><expr><name>y</name> <operator>+</operator> <name>m</name> <operator>&lt;=</operator> <name>ys</name> <operator>+</operator> <name>n</name></expr>;</condition> <incr><expr><name>y</name> <operator>+=</operator> <name><name>qstable</name><index>[<expr><call><name>rb_memsearch_qs_utf8_hash</name><argument_list>(<argument><expr><name>y</name><operator>+</operator><name>m</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>xs</name> <operator>==</operator> <operator>*</operator><name>y</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>xs</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>y</name> <operator>-</operator> <name>ys</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>

<name>rb_memsearch_wchar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>xs</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ys</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name>xs</name></expr></init></decl>, <decl><type ref="prev"/><name>x0</name> <init>= <expr><operator>*</operator><name>xs</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name> <init>= <expr><name>ys</name></expr></init></decl>;</decl_stmt>

<enum>enum <block>{<decl><name>char_size</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>}</block>;</enum>

<for>for <control>(<init><expr><name>n</name> <operator>-=</operator> <name>m</name></expr>;</init> <condition><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name> <operator>-=</operator> <name>char_size</name></expr><operator>,</operator> <expr><name>y</name> <operator>+=</operator> <name>char_size</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>x0</name> <operator>==</operator> <operator>*</operator><name>y</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>y</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>m</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>y</name> <operator>-</operator> <name>ys</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>

<name>rb_memsearch_qchar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>xs</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ys</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name>xs</name></expr></init></decl>, <decl><type ref="prev"/><name>x0</name> <init>= <expr><operator>*</operator><name>xs</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name> <init>= <expr><name>ys</name></expr></init></decl>;</decl_stmt>

<enum>enum <block>{<decl><name>char_size</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>}</block>;</enum>

<for>for <control>(<init><expr><name>n</name> <operator>-=</operator> <name>m</name></expr>;</init> <condition><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name> <operator>-=</operator> <name>char_size</name></expr><operator>,</operator> <expr><name>y</name> <operator>+=</operator> <name>char_size</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>x0</name> <operator>==</operator> <operator>*</operator><name>y</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>x</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>y</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>m</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>y</name> <operator>-</operator> <name>ys</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>long</name></type>

<name>rb_memsearch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>x0</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>y0</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><name>x0</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>y</name> <init>= <expr><name>y0</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&gt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>m</name> <operator>==</operator> <name>n</name></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>m</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>m</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ys</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><operator>*</operator><name>x</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ys</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ys</name> <operator>-</operator> <name>y</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>m</name> <operator>&lt;=</operator> <name>SIZEOF_VALUE</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_memsearch_ss</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>enc</name> <operator>==</operator> <call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr>)</condition><block>{<block_content>

<return>return <expr><call><name>rb_memsearch_qs_utf8</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_memsearch_wchar</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_memsearch_qchar</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_memsearch_qs</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>y0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REG_LITERAL</name></cpp:macro> <cpp:value>FL_USER5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REG_ENCODING_NONE</name></cpp:macro> <cpp:value>FL_USER6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KCODE_FIXED</name></cpp:macro> <cpp:value>FL_USER4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_REG_OPTION_MASK</name></cpp:macro> <cpp:value>(ONIG_OPTION_IGNORECASE|ONIG_OPTION_MULTILINE|ONIG_OPTION_EXTEND)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_ENCODING_FIXED</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARG_ENCODING_NONE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>char_to_option</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'i'</literal></expr>:</case>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name>ONIG_OPTION_IGNORECASE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name>ONIG_OPTION_EXTEND</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name>ONIG_OPTION_MULTILINE</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>option_to_str</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>ONIG_OPTION_MULTILINE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'m'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>ONIG_OPTION_IGNORECASE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'i'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>ONIG_OPTION_EXTEND</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>extern</specifier> <name>int</name></type>

<name>rb_char_to_option_kcode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>kcode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>option</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>kcode</name> <operator>=</operator> <call><name>rb_ascii8bit_encindex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><operator>*</operator><name>option</name> <operator>=</operator> <name>ARG_ENCODING_NONE</name><operator>)</operator></expr>;</return>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>kcode</name> <operator>=</operator> <name>ENCINDEX_EUC_JP</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>kcode</name> <operator>=</operator> <name>ENCINDEX_Windows_31J</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case>

<expr_stmt><expr><operator>*</operator><name>kcode</name> <operator>=</operator> <call><name>rb_utf8_encindex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><operator>*</operator><name>kcode</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><operator>*</operator><name>option</name> <operator>=</operator> <call><name>char_to_option</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>option</name> <operator>=</operator> <name>ARG_ENCODING_FIXED</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_reg_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>RREGEXP_SRC</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized Regexp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_reg_expr_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>resenc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>term</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><name>ENC_CODERANGE_UNKNOWN</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>need_escape</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>clen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt> <expr_stmt><expr><name>pend</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_coderange_scan_restartable</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ENC_CODERANGE_CLEAN_P</name><argument_list>(<argument><expr><name>cr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <name>resenc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>need_escape</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <name>term</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>need_escape</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>need_escape</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_escape</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>unicode_p</name> <init>= <expr><call><name>rb_enc_unicode_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name><operator>&lt;</operator><name>pend</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>p</name><operator>+</operator><name>clen</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>clen</name> <operator>+</operator> <call><name>mbclen</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>clen</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<goto>goto <name>hex</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>resenc</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pend</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat_escaped_char</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>unicode_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>term</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="char">'\\'</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_enc_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>b</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

<label><name>hex</name>:</label>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"\\x%02X"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_desc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_buf_new2</name><argument_list>(<argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>resenc</name> <init>= <expr><call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>resenc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>resenc</name> <operator>=</operator> <call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>re</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_reg_expr_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>resenc</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>re</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>opts</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>option_to_str</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>options</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>REG_ENCODING_NONE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_source</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><call><name>RREGEXP_SRC</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>RREGEXP_SRC</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_any_to_s</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_reg_desc</name><argument_list>(<argument><expr><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_reg_str_with_term</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>term</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_str_with_term</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_str_with_term</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>term</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>, <decl><type ref="prev"/><name>opt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>embeddable</name> <init>= <expr><name>ONIG_OPTION_MULTILINE</name><operator>|</operator><name>ONIG_OPTION_IGNORECASE</name><operator>|</operator><name>ONIG_OPTION_EXTEND</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_buf_new2</name><argument_list>(<argument><expr><literal type="string">"(?"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>optbuf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>options</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>again</name>:</label>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>-=</operator> <literal type="number">2</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>char_to_option</name><argument_list>(<argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>opt</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<break>break;</break>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>++</operator><name>ptr</name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>char_to_option</name><argument_list>(<argument><expr><operator>(</operator><name>int</name> <operator>)</operator><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>options</name> <operator>&amp;=</operator> <operator>~</operator><name>opt</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<break>break;</break>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>++</operator><name>ptr</name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>--</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>ptr</name></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>Regexp</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>verbose</name> <init>= <expr><name>ruby_verbose</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ruby_verbose</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>onig_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,

<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>OnigDefaultSyntax</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ruby_verbose</name> <operator>=</operator> <name>verbose</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>options</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>option_to_str</name><argument_list>(<argument><expr><name>optbuf</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>optbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>embeddable</name><operator>)</operator> <operator>!=</operator> <name>embeddable</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>optbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>option_to_str</name><argument_list>(<argument><expr><name>optbuf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>~</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>optbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_reg_expr_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>paren</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_encode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RSTRING_END</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>rb_enc_left_char_head</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>paren</name> <operator>=</operator> <call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>paren</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_reg_expr_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>paren</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void rb_reg_raise(const char *s, long len, const char *err, VALUE re)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_reg_raise</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>desc</name> <init>= <expr><call><name>rb_reg_desc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRegexpError</name></expr></argument>, <argument><expr><literal type="string">"%s: %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_enc_reg_error_desc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>opts</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>desc</name> <init>= <expr><call><name>rb_str_buf_new2</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>resenc</name> <init>= <expr><call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>resenc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>resenc</name> <operator>=</operator> <call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="string">": /"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_reg_expr_str</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>resenc</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>opts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>option_to_str</name><argument_list>(<argument><expr><name>opts</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eRegexpError</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void rb_enc_reg_raise(const char *s, long len, rb_encoding *enc, int options, const char *err)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_enc_reg_raise</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_enc_reg_error_desc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_error_desc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_enc_reg_error_desc</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void rb_reg_raise_str(VALUE str, int options, const char *err)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_reg_raise_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_reg_error_desc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_casefold_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>options</name> <operator>&amp;</operator> <name>ONIG_OPTION_IGNORECASE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_options_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><call><name>rb_reg_options</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>reg_names_iter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>name_end</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>back_num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>back_refs</name></decl></parameter>, <parameter><decl><type><name>OnigRegex</name></type> <name>regex</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><name>name_end</name><operator>-</operator><name>name</name></expr></argument>, <argument><expr><name><name>regex</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_names</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><call><name>onig_number_of_names</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onig_foreach_name</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>reg_names_iter</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>reg_named_captures_iter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>name_end</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>back_num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>back_refs</name></decl></parameter>, <parameter><decl><type><name>OnigRegex</name></type> <name>regex</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>back_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>back_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name><name>back_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>rb_str_new</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><name>name_end</name><operator>-</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_named_captures</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><operator>(</operator><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call>, <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><call><name>onig_number_of_names</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>onig_foreach_name</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>reg_named_captures_iter</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>onig_new_with_source</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern_end</name></decl></parameter>,

<parameter><decl><type><name>OnigOptionType</name></type> <name>option</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>syntax</name></decl></parameter>,

<parameter><decl><type><name>OnigErrorInfo</name><modifier>*</modifier></type> <name>einfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>reg</name> <operator>=</operator> <operator>(</operator><name>regex_t</name><operator>*</operator> <operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regex_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_NULL</name><argument_list>(<argument><expr><operator>*</operator><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_reg_init</name><argument_list>(<argument><expr><operator>*</operator><name>reg</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><name>ONIGENC_CASE_FOLD_DEFAULT</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>syntax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_compile_ruby</name><argument_list>(<argument><expr><operator>*</operator><name>reg</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_end</name></expr></argument>, <argument><expr><name>einfo</name></expr></argument>, <argument><expr><name>sourcefile</name></expr></argument>, <argument><expr><name>sourceline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<label><name>err</name>:</label>

<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><operator>*</operator><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>reg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Regexp</name><modifier>*</modifier></type>

<name>make_regexp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Regexp</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigErrorInfo</name></type> <name>einfo</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_new_with_source</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rp</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><operator>(</operator><name>s</name> <operator>+</operator> <name>len</name><operator>)</operator></expr></argument>, <argument><expr><name>flags</name></expr></argument>,

<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>OnigDefaultSyntax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>einfo</name></expr></argument>, <argument><expr><name>sourcefile</name></expr></argument>, <argument><expr><name>sourceline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>onig_error_code_to_str</name><argument_list>(<argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>err</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>einfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>rp</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cMatch</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>NEWOBJ_OF</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr>struct <name>RMatch</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>rmatch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>regexp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>rmatch</name></name> <operator>=</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr>struct <name>rmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>match</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_reg_region_copy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>from</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>onig_region_copy</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><operator>(</operator><name>OnigRegion</name> <operator>*</operator><operator>)</operator><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>allocated</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_gc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onig_region_copy</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><operator>(</operator><name>OnigRegion</name> <operator>*</operator><operator>)</operator><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>allocated</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>ONIGERR_MEMORY</name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>long</name></type> <name>byte_pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>char_pos</name></decl>;</decl_stmt>

}</block></struct></type> <name>pair_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>pair_byte_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pair1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pair2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>diff</name> <init>= <expr><operator>(</operator><operator>(</operator><name>pair_t</name><operator>*</operator><operator>)</operator><name>pair1</name><operator>)</operator><operator>-&gt;</operator><name>byte_pos</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>pair_t</name><operator>*</operator><operator>)</operator><name>pair2</name><operator>)</operator><operator>-&gt;</operator><name>byte_pos</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&gt;</operator> <name>SIZEOF_INT</name></expr></cpp:if>

<return>return <expr><ternary><condition><expr><name>diff</name></expr> ?</condition><then> <expr><ternary><condition><expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>diff</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>update_char_offset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rmatch</name></name> <modifier>*</modifier></type><name>rm</name> <init>= <expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rmatch</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num_regs</name></decl>, <decl><type ref="prev"/><name>num_pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pair_t</name> <modifier>*</modifier></type><name>pairs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset_num_allocated</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>regs</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>num_regs</name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>num_regs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset_num_allocated</name></name> <operator>&lt;</operator> <name>num_regs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>REALLOC_N</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name></name></expr></argument>, <argument><expr>struct <name>rmatch_offset</name></expr></argument>, <argument><expr><name>num_regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset_num_allocated</name></name> <operator>=</operator> <name>num_regs</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_regs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>beg</name> <operator>=</operator> <call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pairs</name> <operator>=</operator> <call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>pair_t</name></expr></argument>, <argument><expr><name>num_regs</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>num_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_regs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pairs</name><index>[<expr><name>num_pos</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>byte_pos</name> <operator>=</operator> <call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pairs</name><index>[<expr><name>num_pos</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>byte_pos</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>, <argument><expr><name>num_pos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pair_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pair_byte_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_pos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>q</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>byte_pos</name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>+=</operator> <call><name>rb_enc_strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>char_pos</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_regs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>pair_t</name></type> <name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>beg</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>key</name><operator>.</operator><name>byte_pos</name></name> <operator>=</operator> <call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>pairs</name></expr></argument>, <argument><expr><name>num_pos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pair_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pair_byte_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>beg</name> <operator>=</operator> <name><name>found</name><operator>-&gt;</operator><name>char_pos</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>key</name><operator>.</operator><name>byte_pos</name></name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>pairs</name></expr></argument>, <argument><expr><name>num_pos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pair_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>pair_byte_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end</name> <operator>=</operator> <name><name>found</name><operator>-&gt;</operator><name>char_pos</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>match_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized MatchData"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_init_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rmatch</name></name> <modifier>*</modifier></type><name>rm</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OBJ_INIT_COPY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>obj</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name> <operator>=</operator> <call><name>RMATCH</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name> <operator>=</operator> <call><name>RMATCH</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rm</name> <operator>=</operator> <call><name>RMATCH</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>rmatch</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_reg_region_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rm</name><operator>-&gt;</operator><name>regs</name></name></expr></argument>, <argument><expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>rmatch</name><operator>-&gt;</operator><name>char_offset_num_allocated</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset_num_allocated</name></name> <operator>&lt;</operator> <name><name>rm</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>num_regs</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>REALLOC_N</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name></name></expr></argument>, <argument><expr>struct <name>rmatch_offset</name></expr></argument>, <argument><expr><name><name>rm</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>num_regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset_num_allocated</name></name> <operator>=</operator> <name><name>rm</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>num_regs</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name><name>rm</name><operator>-&gt;</operator><name>char_offset</name></name></expr></argument>, <argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>rmatch</name><operator>-&gt;</operator><name>char_offset</name></name></expr></argument>,

<argument><expr>struct <name>rmatch_offset</name></expr></argument>, <argument><expr><name><name>rm</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>num_regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_regexp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>regexp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regexp</name> <operator>=</operator> <call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>regexp</name> <operator>=</operator> <call><name>rb_reg_regcomp</name><argument_list>(<argument><expr><call><name>rb_reg_quote</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name> <operator>=</operator> <name>regexp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>regexp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_names</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_reg_names</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>num_regs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>name_to_backref_number</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>match_backref_number</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>backref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>regexp</name> <init>= <expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>backref</name> <operator>=</operator> <call><name>rb_sym2str</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>backref</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>StringValueCStr</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>name_to_backref_number</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><name>regexp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"undefined group name reference: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>num</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_reg_backref_number</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>backref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>match_backref_number</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_offset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>match_backref_number</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %d out of matches"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>update_char_offset</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>rmatch</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>beg</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>rmatch</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_begin</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>match_backref_number</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %d out of matches"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>update_char_offset</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>rmatch</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>beg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_end</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>match_backref_number</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %d out of matches"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>update_char_offset</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>rmatch</name><operator>-&gt;</operator><name>char_offset</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_BUSY</name></cpp:macro> <cpp:value>FL_USER2</cpp:value></cpp:define>

<function><type><name>void</name></type>

<name>rb_match_busy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>MATCH_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_match_unbusy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>MATCH_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_match_count</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>regs</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_match_nth_defined</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>regs</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&gt;=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nth</name> <operator>+=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>BEG</name><argument_list>(<argument><expr><name>nth</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>match_set_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>string</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>RMatch</name></name> <modifier>*</modifier></type><name>match</name> <init>= <expr><operator>(</operator>struct <name>RMatch</name> <operator>*</operator><operator>)</operator><name>m</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rmatch</name></name> <modifier>*</modifier></type><name>rmatch</name> <init>= <expr><name><name>match</name><operator>-&gt;</operator><name>rmatch</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>regexp</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>onig_region_resize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rmatch</name><operator>-&gt;</operator><name>regs</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>rmatch</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>beg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rmatch</name><operator>-&gt;</operator><name>regs</name><operator>.</operator><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>pos</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_backref_set_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>string</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name> <init>= <expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>FL_TEST</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>MATCH_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>match_alloc</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>match_set_string</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_fixed_encoding_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>KCODE_FIXED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_preprocess</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>fixed_enc</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>NORETURN</name><argument_list>(<argument>static void reg_enc_error(VALUE re, VALUE str)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>reg_enc_error</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncCompatError</name></expr></argument>,

<argument><expr><literal type="string">"incompatible encoding regexp match (%s regexp with %s string)"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>str_coderange</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><call><name>ENC_CODERANGE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_UNKNOWN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>cr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name><modifier>*</modifier></type>

<name>rb_reg_prepare_enc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>warn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cr</name> <init>= <expr><call><name>str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_BROKEN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>,

<argument><expr><literal type="string">"invalid byte sequence in %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>enc</name> <operator>==</operator> <name>enc</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>cr</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name> <operator>&amp;&amp;</operator>

<call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>enc</name> <operator>==</operator> <call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>enc</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>reg_enc_error</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_reg_fixed_encoding_p</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>enc</name></expr></argument>)</argument_list></call> <operator>||</operator>

<name>cr</name> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>reg_enc_error</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>enc</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>warn</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>REG_ENCODING_NONE</name><operator>)</operator> <operator>&amp;&amp;</operator>

<name>enc</name> <operator>!=</operator> <call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>

<name>cr</name> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"historical binary regexp match /.../n against %s string"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>enc</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>regex_t</name> <modifier>*</modifier></type>

<name>rb_reg_prepare_re0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigErrorInfo</name></type> <name>einfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>unescaped</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fixed_enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_reg_prepare_enc</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>reg</name><operator>-&gt;</operator><name>enc</name></name> <operator>==</operator> <name>enc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>reg</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pattern</name> <operator>=</operator> <call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>unescaped</name> <operator>=</operator> <call><name>rb_reg_preprocess</name><argument_list>(

<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern</name> <operator>+</operator> <call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>fixed_enc</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>unescaped</name> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"regexp preprocess failed: %s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>onig_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reg</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>unescaped</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><name>UChar</name><operator>*</operator> <operator>)</operator><operator>(</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>unescaped</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>unescaped</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,

<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,

<argument><expr><name>OnigDefaultSyntax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>einfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>onig_error_code_to_str</name><argument_list>(<argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>err</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>einfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_reg_raise</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>unescaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>reg</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>regex_t</name> <modifier>*</modifier></type>

<name>rb_reg_prepare_re</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_reg_prepare_re0</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>long</name></type>

<name>rb_reg_adjust_startpos</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>range</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>UChar</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_reg_prepare_enc</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>range</name> <operator>=</operator> <operator>-</operator><name>pos</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>range</name> <operator>=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ONIGENC_MBC_MAXLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>string</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>range</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>onigenc_get_right_adjust_char_head</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>string</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>string</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ONIGENC_LEFT_ADJUST_CHAR_HEAD</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>string</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>string</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>p</name> <operator>-</operator> <name>string</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>pos</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>long</name></type>

<name>rb_reg_search0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>set_backref_str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name></type> <name>regi</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>regs</name> <init>= <expr><operator>&amp;</operator><name>regi</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>range</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>reg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tmpreg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>rb_reg_prepare_re0</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <name>reg</name> <operator>!=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpreg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>usecnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>MATCH_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr>struct <name>re_registers</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reverse</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>range</name> <operator>+=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>onig_search</name><argument_list>(<argument><expr><name>reg</name></expr></argument>,

<argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <name>pos</name><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>range</name><operator>)</operator></expr></argument>,

<argument><expr><name>regs</name></expr></argument>, <argument><expr><name>ONIG_OPTION_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpreg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>usecnt</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tmpreg</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>usecnt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>regs</name> <operator>==</operator> <operator>&amp;</operator><name>regi</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>onig_region_free</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>ONIG_MISMATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>onig_error_code_to_str</name><argument_list>(<argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>err</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_reg_raise</name><argument_list>(<argument><expr><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>match_alloc</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>rb_reg_region_copy</name><argument_list>(<argument><expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onig_region_free</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>set_backref_str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name> <operator>=</operator> <call><name>rb_str_new4</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name> <operator>=</operator> <name>re</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>long</name></type>

<name>rb_reg_search</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_search0</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>bool</name></type>

<name>rb_reg_start_with_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name></type> <name>regi</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>regs</name> <init>= <expr><operator>&amp;</operator><name>regi</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>reg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tmpreg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>rb_reg_prepare_re0</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <name>reg</name> <operator>!=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpreg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>usecnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>MATCH_BUSY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr>struct <name>re_registers</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>onig_match</name><argument_list>(<argument><expr><name>reg</name></expr></argument>,

<argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><operator>(</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,

<argument><expr><name>regs</name></expr></argument>, <argument><expr><name>ONIG_OPTION_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpreg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>usecnt</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tmpreg</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>usecnt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>regs</name> <operator>==</operator> <operator>&amp;</operator><name>regi</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>onig_region_free</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>ONIG_MISMATCH</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>onig_error_code_to_str</name><argument_list>(<argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>err</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_reg_raise</name><argument_list>(<argument><expr><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>match_alloc</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>rb_reg_region_copy</name><argument_list>(<argument><expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onig_region_free</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_memerror</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name> <operator>=</operator> <call><name>rb_str_new4</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name> <operator>=</operator> <name>re</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_nth_defined</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&gt;=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nth</name> <operator>+=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>nth</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_nth_match</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&gt;=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nth</name> <operator>+=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>BEG</name><argument_list>(<argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_last_match</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_match_pre</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BEG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_match_post</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>END</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_match_last</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><call><name>BEG</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>last_match_getter</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>_x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_last_match</name><argument_list>(<argument><expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>prematch_getter</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>_x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_match_pre</name><argument_list>(<argument><expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>postmatch_getter</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>_x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_match_post</name><argument_list>(<argument><expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>last_paren_match_getter</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>_x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_match_last</name><argument_list>(<argument><expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_array</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>target</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><name>start</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>regs</name><operator>-&gt;</operator><name>beg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>regs</name><operator>-&gt;</operator><name>beg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>regs</name><operator>-&gt;</operator><name>end</name><index>[<expr><name>i</name></expr>]</index></name><operator>-</operator><name><name>regs</name><operator>-&gt;</operator><name>beg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_to_a</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>match_array</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_captures</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>match_array</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>name_to_backref_number</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>regexp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name_end</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>onig_name_to_backref_number</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name_end</name></expr></argument>, <argument><expr><name>regs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void name_to_backref_error(VALUE name)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>name_to_backref_error</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"undefined group name reference: % "</literal><name>PRIsVALUE</name></expr></argument>,

<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAME_TO_NUMBER</name><parameter_list>(<parameter><type><name>regs</name></type></parameter>, <parameter><type><name>re</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>name_ptr</name></type></parameter>, <parameter><type><name>name_end</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(NIL_P(re) ? 0 : !rb_enc_compatible(RREGEXP_SRC(re), (name)) ? 0 : name_to_backref_number((regs), (re), (name_ptr), (name_end)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>namev_to_backref_number</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>rb_sym2str</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>NAME_TO_NUMBER</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,

<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>name_to_backref_error</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>num</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_ary_subseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>olen</name> <init>= <expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>num_regs</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>end</name> <init>= <expr><ternary><condition><expr><name>olen</name> <operator>&lt;</operator> <name>beg</name><operator>+</operator><name>len</name></expr> ?</condition><then> <expr><name>olen</name></expr> </then><else>: <expr><name>beg</name><operator>+</operator><name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>beg</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>j</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>j</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_resize</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>beg</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_ary_aref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_regs</name> <init>= <expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>num_regs</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>num_regs</name></expr></argument>, <argument><expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Qfalse</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

<case>case <expr><name>Qnil</name></expr>:</case>

<return>return <expr><name>Qnil</name></expr>;</return>

<default>default:</default>

<return>return <expr><call><name>match_ary_subseq</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_aref</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><call><name>namev_to_backref_number</name><argument_list>(<argument><expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>match_ary_aref</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>beg</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>num_regs</name> <init>= <expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>num_regs</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>beg</name> <operator>+=</operator> <name>num_regs</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>beg</name> <operator>&gt;</operator> <name>num_regs</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>beg</name><operator>+</operator><name>len</name> <operator>&gt;</operator> <name>num_regs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>num_regs</name> <operator>-</operator> <name>beg</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>match_ary_subseq</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_values_at</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><call><name>namev_to_backref_number</name><argument_list>(<argument><expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>match_ary_aref</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_reg_last_match</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>match_named_captures_iter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>name_end</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>back_num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>back_refs</name></decl></parameter>, <parameter><decl><type><name>OnigRegex</name></type> <name>regex</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>memo</name> <init>= <expr><call><name>MEMO_CAST</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><name><name>memo</name><operator>-&gt;</operator><name>v1</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name> <init>= <expr><name><name>memo</name><operator>-&gt;</operator><name>v2</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><name>name_end</name><operator>-</operator><name>name</name></expr></argument>, <argument><expr><name><name>regex</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>back_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><name><name>back_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_named_captures</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>memo</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>memo</name> <operator>=</operator> <call><name>MEMO_NEW</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onig_foreach_name</name><argument_list>(<argument><expr><call><name>RREGEXP</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><name>match_named_captures_iter</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr>;</return> 

</block_content>}</block></function>

<struct>struct <name>backref_name_tag</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>match_inspect_name_iter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnigUChar</name> <modifier>*</modifier></type><name>name_end</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>back_num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>back_refs</name></decl></parameter>, <parameter><decl><type><name>OnigRegex</name></type> <name>regex</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg0</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>backref_name_tag</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>backref_name_tag</name> <operator>*</operator><operator>)</operator><name>arg0</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>back_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>arg</name><index>[<expr><name><name>back_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arg</name><index>[<expr><name><name>back_refs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>name_end</name> <operator>-</operator> <name>name</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>cname</name> <init>= <expr><call><name>rb_class_path</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name> <init>= <expr><call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_regs</name> <init>= <expr><name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>backref_name_tag</name></name> <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>regexp</name> <init>= <expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>regexp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">":%p&gt;"</literal></expr></argument>, <argument><expr><name>cname</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>match</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": %"</literal><name>PRIsVALUE</name><literal type="string">"&gt;"</literal></expr></argument>,

<argument><expr><name>cname</name></expr></argument>, <argument><expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>names</name> <operator>=</operator> <call><name>ALLOCA_N</name><argument_list>(<argument><expr>struct <name>backref_name_tag</name></expr></argument>, <argument><expr><name>num_regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr>struct <name>backref_name_tag</name></expr></argument>, <argument><expr><name>num_regs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onig_foreach_name</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>match_inspect_name_iter</name></expr></argument>, <argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_buf_new2</name><argument_list>(<argument><expr><literal type="string">"#&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_regs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>i</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>names</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>Qnil</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_str_inspect</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cRegexp</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>read_escaped_byte</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>meta_prefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ctrl_prefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>end</name> <operator>||</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"too short escaped multibyte character"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<label><name>again</name>:</label>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"too short escape sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case> <expr_stmt><expr><name>code</name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> <expr_stmt><expr><name>code</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> <expr_stmt><expr><name>code</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> <expr_stmt><expr><name>code</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> <expr_stmt><expr><name>code</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> <expr_stmt><expr><name>code</name> <operator>=</operator> <literal type="char">'\013'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><name>code</name> <operator>=</operator> <literal type="char">'\007'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> <expr_stmt><expr><name>code</name> <operator>=</operator> <literal type="char">'\033'</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case>

<case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case>

<expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>scan_oct</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>end</name> <operator>&lt;</operator> <name>p</name><operator>+</operator><literal type="number">3</literal></expr> ?</condition><then> <expr><name>end</name><operator>-</operator><name>p</name></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>scan_hex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>end</name> <operator>&lt;</operator> <name>p</name><operator>+</operator><literal type="number">2</literal></expr> ?</condition><then> <expr><name>end</name><operator>-</operator><name>p</name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid hex escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'M'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name>meta_prefix</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"duplicate meta escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>meta_prefix</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>code</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"too short meta escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>end</name> <operator>||</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"too short control escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name>ctrl_prefix</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"duplicate control escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ctrl_prefix</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>code</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"too short control escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"unexpected escape sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <literal type="number">0xff</literal> <operator>&lt;</operator> <name>code</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid escape code"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ctrl_prefix</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>code</name> <operator>&amp;=</operator> <literal type="number">0x1f</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>meta_prefix</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>code</name> <operator>|=</operator> <literal type="number">0x80</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><name>code</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>unescape_escaped_nonascii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>encp</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>chmaxlen</name> <init>= <expr><call><name>rb_enc_mbmaxlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>area</name> <init>= <macro><name>ALLOCA_N</name><argument_list>(<argument>unsigned char</argument>, <argument>chmaxlen</argument>)</argument_list></macro></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>chbuf</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>area</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>chlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>byte</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>chbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>chmaxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>byte</name> <operator>=</operator> <call><name>read_escaped_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>byte</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>area</name><index>[<expr><name>chlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>chlen</name> <operator>&lt;</operator> <name>chmaxlen</name> <operator>&amp;&amp;</operator>

<call><name>MBCLEN_NEEDMORE_P</name><argument_list>(<argument><expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>chbuf</name></expr></argument>, <argument><expr><name>chbuf</name><operator>+</operator><name>chlen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>byte</name> <operator>=</operator> <call><name>read_escaped_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>byte</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>area</name><index>[<expr><name>chlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>chbuf</name></expr></argument>, <argument><expr><name>chbuf</name><operator>+</operator><name>chlen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_INVALID_P</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid multibyte escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>chlen</name> <operator>||</operator> <operator>(</operator><name><name>area</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>chbuf</name></expr></argument>, <argument><expr><name>chlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>encp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>encp</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>encp</name> <operator>!=</operator> <name>enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"escaped non ASCII character in UTF-8 regexp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>escbuf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>escbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>escbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"\\x%02X"</literal></expr></argument>, <argument><expr><name><name>area</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>escbuf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>check_unicode_range</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xd800</literal> <operator>&lt;=</operator> <name>code</name> <operator>&amp;&amp;</operator> <name>code</name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal><operator>)</operator> <operator>||</operator> 

<literal type="number">0x10ffff</literal> <operator>&lt;</operator> <name>code</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>append_utf8</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>uv</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>encp</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>check_unicode_range</name><argument_list>(<argument><expr><name>uv</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>uv</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>escbuf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>escbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>escbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"\\x%02X"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>escbuf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>utf8buf</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>rb_uv_to_utf8</name><argument_list>(<argument><expr><name>utf8buf</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>utf8buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>encp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>encp</name> <operator>=</operator> <call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>encp</name> <operator>!=</operator> <call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"UTF-8 character in non UTF-8 regexp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>unescape_unicode_list</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>encp</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_unicode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>ISSPACE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>ruby_scan_hex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name><operator>-</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">6</literal> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>append_utf8</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>encp</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>has_unicode</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>ISSPACE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>has_unicode</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>unescape_unicode_bmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>encp</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>code</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <name>p</name><operator>+</operator><literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>ruby_scan_hex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode escape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>append_utf8</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>encp</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>unescape_nonascii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>encp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>has_property</name></decl></parameter>,

<parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>smallbuf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>chlen</name> <init>= <expr><call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>chlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<label><name>invalid_multibyte</name>:</label>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid multibyte character"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>chlen</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>chlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>&lt;</operator> <name>chlen</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<label><name>multibyte</name>:</label>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>chlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>chlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>encp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>encp</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>encp</name> <operator>!=</operator> <name>enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"non ASCII character in UTF-8 regexp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"too short escape sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>chlen</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>chlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>invalid_multibyte</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>chlen</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>chlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>chlen</name></expr>;</expr_stmt>

<goto>goto <name>multibyte</name>;</goto>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case>

<case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>end</name><operator>-</operator><operator>(</operator><name>p</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>, <decl><type ref="prev"/><name>octlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ruby_scan_oct</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>len</name> <operator>&lt;</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></argument>, <argument><expr><operator>&amp;</operator><name>octlen</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0177</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>escape_asis</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<case>case <expr><literal type="char">'0'</literal></expr>:</case> 

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<case>case <expr><literal type="char">'M'</literal></expr>:</case> 

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>p</name><operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>==</operator> <call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pbeg</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>byte</name> <init>= <expr><call><name>read_escaped_byte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>byte</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pbeg</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>pbeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>unescape_escaped_nonascii</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>encp</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"too short escape sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>unescape_unicode_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>encp</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>end</name> <operator>||</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid Unicode list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>unescape_unicode_bmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>encp</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<case>case <expr><literal type="char">'P'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>encp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>has_property</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>escape_asis</name>;</goto>

<default>default:</default> 

<label><name>escape_asis</name>:</label>

<expr_stmt><expr><name><name>smallbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>smallbuf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>smallbuf</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_preprocess</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier><modifier>*</modifier></type><name>fixed_enc</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_property</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>fixed_enc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>fixed_enc</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>unescape_nonascii</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fixed_enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_property</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_property</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>fixed_enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>fixed_enc</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fixed_enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>fixed_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_check_preprocess</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fixed_enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>rb_reg_preprocess</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fixed_enc</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_reg_error_desc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_preprocess_dregexp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fixed_enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>regexp_enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>ascii8bit</name> <init>= <expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no arguments given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>src_enc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>src_enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>ARG_ENCODING_NONE</name> <operator>&amp;&amp;</operator>

<name>src_enc</name> <operator>!=</operator> <name>ascii8bit</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRegexpError</name></expr></argument>, <argument><expr><literal type="string">"/.../n has a non escaped non ASCII character in non ASCII-8BIT script"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>src_enc</name> <operator>=</operator> <name>ascii8bit</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>rb_reg_preprocess</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>src_enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fixed_enc</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>Qnil</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fixed_enc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>regexp_enc</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>regexp_enc</name> <operator>!=</operator> <name>fixed_enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRegexpError</name></expr></argument>, <argument><expr><literal type="string">"encoding mismatch in dynamic regexp : %s and %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>regexp_enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>fixed_enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>regexp_enc</name> <operator>=</operator> <name>fixed_enc</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_new3</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>regexp_enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>regexp_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_reg_initialize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>RRegexp</name></name> <modifier>*</modifier></type><name>re</name> <init>= <expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>unescaped</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>fixed_enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>a_enc</name> <init>= <expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>REG_LITERAL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eSecurityError</name></expr></argument>, <argument><expr><literal type="string">"can't modify literal regexp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>ptr</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"already initialized regexp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_dummy_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"can't make regexp with dummy encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>unescaped</name> <operator>=</operator> <call><name>rb_reg_preprocess</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name><operator>+</operator><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fixed_enc</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>unescaped</name> <operator>==</operator> <name>Qnil</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fixed_enc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fixed_enc</name> <operator>!=</operator> <name>enc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>ARG_ENCODING_FIXED</name><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>fixed_enc</name> <operator>!=</operator> <name>a_enc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>ARG_ENCODING_NONE</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"incompatible character encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fixed_enc</name> <operator>!=</operator> <name>a_enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>ARG_ENCODING_FIXED</name></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <name>fixed_enc</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>ARG_ENCODING_FIXED</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>re</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>ARG_ENCODING_FIXED</name><operator>)</operator> <operator>||</operator> <name>fixed_enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>KCODE_FIXED</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>ARG_ENCODING_NONE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>REG_ENCODING_NONE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>make_regexp</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>unescaped</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>unescaped</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>,

<argument><expr><name>options</name> <operator>&amp;</operator> <name>ARG_REG_OPTION_MASK</name></expr></argument>, <argument><expr><name>err</name></expr></argument>,

<argument><expr><name>sourcefile</name></expr></argument>, <argument><expr><name>sourceline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>re</name><operator>-&gt;</operator><name>ptr</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>unescaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>reg_set_source</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>regenc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>regenc</name> <operator>!=</operator> <name>enc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_enc_associate</name><argument_list>(<argument><expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name> <operator>=</operator> <name>regenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RREGEXP</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>src</name></expr></argument>, <argument><expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>rb_reg_initialize_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>str_enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>enc</name> <init>= <expr><name>str_enc</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>ARG_ENCODING_NONE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>ascii8bit</name> <init>= <expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <name>ascii8bit</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>str_coderange</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>errcpy</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"/.../n has a non escaped non ASCII character in non ASCII-8BIT script"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <name>ascii8bit</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>rb_reg_initialize</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>,

<argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>sourcefile</name></expr></argument>, <argument><expr><name>sourceline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>reg_set_source</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_s_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>NEWOBJ_OF</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr>struct <name>RRegexp</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_REGEXP</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>RGENGC_WB_PROTECTED_REGEXP</name></expr> ?</condition><then> <expr><name>FL_WB_PROTECTED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>re</name><operator>-&gt;</operator><name>src</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>usecnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>re</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_s_alloc</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_new_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_init_str</name><argument_list>(<argument><expr><call><name>rb_reg_alloc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_init_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_reg_initialize_str</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_reg_raise_str</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>re</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_init_str_enc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_reg_initialize</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_reg_raise_str</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>reg_set_source</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>re</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_reg_new_ary</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_new_str</name><argument_list>(<argument><expr><call><name>rb_reg_preprocess_dregexp</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_enc_reg_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>re</name> <init>= <expr><call><name>rb_reg_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_reg_initialize</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_reg_raise</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>src</name></expr></argument>, <argument><expr><call><name>rb_fstring</name><argument_list>(<argument><expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>re</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_enc_reg_new</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_compile</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>re</name> <init>= <expr><call><name>rb_reg_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_reg_initialize_str</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>sourcefile</name></expr></argument>, <argument><expr><name>sourceline</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_set_errinfo</name><argument_list>(<argument><expr><call><name>rb_reg_error_desc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>REG_LITERAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>re</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>reg_cache</name></decl>;</decl_stmt>

<function><type><name>VALUE</name></type>

<name>rb_reg_regcomp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>reg_cache</name> <operator>&amp;&amp;</operator> <call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>reg_cache</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>reg_cache</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>reg_cache</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>reg_cache</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>reg_cache</name> <operator>=</operator> <call><name>rb_reg_new_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>st_index_t</name></type> <name>reg_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>hashval</name> <init>= <expr><call><name>reg_hash</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>hashval</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>

<name>reg_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>hashval</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hashval</name> <operator>=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>options</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hashval</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hashval</name></expr></argument>, <argument><expr><call><name>rb_memhash</name><argument_list>(<argument><expr><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_hash_end</name><argument_list>(<argument><expr><name>hashval</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>re1</name> <operator>==</operator> <name>re2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>re2</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>re1</name></expr></argument>, <argument><expr><name>KCODE_FIXED</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>FL_TEST</name><argument_list>(<argument><expr><name>re2</name></expr></argument>, <argument><expr><name>KCODE_FIXED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>options</name> <operator>!=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>options</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>re1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ENCODING_GET</name><argument_list>(<argument><expr><name>re2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>hashval</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>match_check</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hashval</name> <operator>=</operator> <call><name>rb_hash_start</name><argument_list>(<argument><expr><call><name>rb_str_hash</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hashval</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hashval</name></expr></argument>, <argument><expr><call><name>reg_hash</name><argument_list>(<argument><expr><call><name>match_regexp</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hashval</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hashval</name></expr></argument>, <argument><expr><name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hashval</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hashval</name></expr></argument>, <argument><expr><call><name>rb_memhash</name><argument_list>(<argument><expr><name><name>regs</name><operator>-&gt;</operator><name>beg</name></name></expr></argument>, <argument><expr><name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>regs</name><operator>-&gt;</operator><name>beg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hashval</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hashval</name></expr></argument>, <argument><expr><call><name>rb_memhash</name><argument_list>(<argument><expr><name><name>regs</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>regs</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hashval</name> <operator>=</operator> <call><name>rb_hash_end</name><argument_list>(<argument><expr><name>hashval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>hashval</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>match1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>match2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>regs2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>match1</name> <operator>==</operator> <name>match2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>match2</name></expr></argument>, <argument><expr><name>T_MATCH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RMATCH</name><argument_list>(<argument><expr><name>match1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name> <operator>||</operator> <operator>!</operator><call><name>RMATCH</name><argument_list>(<argument><expr><name>match2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>regexp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_str_equal</name><argument_list>(<argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr></argument>, <argument><expr><call><name>RMATCH</name><argument_list>(<argument><expr><name>match2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_reg_equal</name><argument_list>(<argument><expr><call><name>match_regexp</name><argument_list>(<argument><expr><name>match1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>match_regexp</name><argument_list>(<argument><expr><name>match2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>regs1</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regs2</name> <operator>=</operator> <call><name>RMATCH_REGS</name><argument_list>(<argument><expr><name>match2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>regs1</name><operator>-&gt;</operator><name>num_regs</name></name> <operator>!=</operator> <name><name>regs2</name><operator>-&gt;</operator><name>num_regs</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>regs1</name><operator>-&gt;</operator><name>beg</name></name></expr></argument>, <argument><expr><name><name>regs2</name><operator>-&gt;</operator><name>beg</name></name></expr></argument>, <argument><expr><name><name>regs1</name><operator>-&gt;</operator><name>num_regs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>regs1</name><operator>-&gt;</operator><name>beg</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>regs1</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>regs2</name><operator>-&gt;</operator><name>end</name></name></expr></argument>, <argument><expr><name><name>regs1</name><operator>-&gt;</operator><name>num_regs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>regs1</name><operator>-&gt;</operator><name>end</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>reg_operand</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><ternary><condition><expr><name>check</name></expr> ?</condition><then> <expr><call><name>rb_str_to_str</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>

<name>reg_match_pos</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>strp</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><operator>*</operator><name>strp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>strp</name> <operator>=</operator> <name>str</name> <operator>=</operator> <call><name>reg_operand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>l</name> <init>= <expr><call><name>rb_str_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>pos</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_offset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_reg_search</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_match</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><call><name>reg_match_pos</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>rb_str_sublen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_eqq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>start</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>reg_operand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>rb_reg_search</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_match2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>line</name> <init>= <expr><call><name>rb_lastline_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>rb_reg_search</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>rb_str_sublen</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_match_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>str</name></decl>, <decl><type ref="prev"/><name>initpos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>initpos</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>initpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>reg_match_pos</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_match_busy</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_match_m_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><ternary><condition><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_reg_match_p</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_match_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>reg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>onig_errmsg_buffer</name></type> <name>err</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigPosition</name></type> <name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tmpreg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <ternary><condition><expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_sym2str</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>+=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><call><name>rb_str_length</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>beg</name> <init>= <expr><call><name>rb_str_subpos</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>beg</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>beg</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>rb_reg_prepare_re0</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmpreg</name> <operator>=</operator> <name>reg</name> <operator>!=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpreg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>usecnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>onig_search</name><argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>start</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>end</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ONIG_OPTION_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmpreg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>usecnt</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tmpreg</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RREGEXP</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>usecnt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>onig_free</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>ONIG_MISMATCH</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>onig_error_code_to_str</name><argument_list>(<argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>err</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_reg_raise</name><argument_list>(<argument><expr><call><name>RREGEXP_SRC_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RREGEXP_SRC_LEN</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_initialize_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>re</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"flags ignored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>rb_reg_options</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>RREGEXP_SRC</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>ONIG_OPTION_IGNORECASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>kcode</name> <init>= <expr><call><name>StringValuePtr</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>kcode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal> <operator>||</operator> <name><name>kcode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'N'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ARG_ENCODING_NONE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"encoding option is ignored - %s"</literal></expr></argument>, <argument><expr><name>kcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>StringValue</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>&amp;&amp;</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>enc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_reg_init_str_enc</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_reg_init_str</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_quote</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>send</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>clen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ascii_only</name> <init>= <expr><call><name>rb_enc_str_asciionly_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>send</name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'['</literal></expr>:</case> <case>case <expr><literal type="char">']'</literal></expr>:</case> <case>case <expr><literal type="char">'{'</literal></expr>:</case> <case>case <expr><literal type="char">'}'</literal></expr>:</case>

<case>case <expr><literal type="char">'('</literal></expr>:</case> <case>case <expr><literal type="char">')'</literal></expr>:</case> <case>case <expr><literal type="char">'|'</literal></expr>:</case> <case>case <expr><literal type="char">'-'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <case>case <expr><literal type="char">'.'</literal></expr>:</case> <case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> <case>case <expr><literal type="char">'+'</literal></expr>:</case> <case>case <expr><literal type="char">'^'</literal></expr>:</case> <case>case <expr><literal type="char">'$'</literal></expr>:</case>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <case>case <expr><literal type="char">'#'</literal></expr>:</case>

<case>case <expr><literal type="char">'\t'</literal></expr>:</case> <case>case <expr><literal type="char">'\f'</literal></expr>:</case> <case>case <expr><literal type="char">'\v'</literal></expr>:</case> <case>case <expr><literal type="char">'\n'</literal></expr>:</case> <case>case <expr><literal type="char">'\r'</literal></expr>:</case>

<goto>goto <name>meta_found</name>;</goto>

</block_content>}</block></switch>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_new3</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ascii_only</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>tmp</name></expr>;</return>

<label><name>meta_found</name>:</label>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ascii_only</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <name>s</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>send</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_ascget</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>send</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>n</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'['</literal></expr>:</case> <case>case <expr><literal type="char">']'</literal></expr>:</case> <case>case <expr><literal type="char">'{'</literal></expr>:</case> <case>case <expr><literal type="char">'}'</literal></expr>:</case>

<case>case <expr><literal type="char">'('</literal></expr>:</case> <case>case <expr><literal type="char">')'</literal></expr>:</case> <case>case <expr><literal type="char">'|'</literal></expr>:</case> <case>case <expr><literal type="char">'-'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <case>case <expr><literal type="char">'.'</literal></expr>:</case> <case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> <case>case <expr><literal type="char">'+'</literal></expr>:</case> <case>case <expr><literal type="char">'^'</literal></expr>:</case> <case>case <expr><literal type="char">'$'</literal></expr>:</case>

<case>case <expr><literal type="char">'#'</literal></expr>:</case>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'\t'</literal></expr>:</case>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'t'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'\n'</literal></expr>:</case>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'n'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'\r'</literal></expr>:</case>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'r'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'\f'</literal></expr>:</case>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'f'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'\v'</literal></expr>:</case>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><literal type="char">'v'</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></switch>

<expr_stmt><expr><name>t</name> <operator>+=</operator> <call><name>rb_enc_mbcput</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>rb_str_resize</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>t</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>tmp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_s_quote</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_reg_quote</name><argument_list>(<argument><expr><call><name>reg_operand</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_reg_options</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>options</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>options</name> <operator>=</operator> <call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>options</name> <operator>&amp;</operator> <name>ARG_REG_OPTION_MASK</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>KCODE_FIXED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>ARG_ENCODING_FIXED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>REG_ENCODING_NONE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>ARG_ENCODING_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>options</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_check_regexp_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_convert_type</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>T_REGEXP</name></expr></argument>, <argument><expr><literal type="string">"Regexp"</literal></expr></argument>, <argument><expr><literal type="string">"to_regexp"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_s_try_convert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_regexp_type</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_s_union</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args0</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>argc</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>args0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"(?!)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>rb_cRegexp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>re</name> <init>= <expr><call><name>rb_check_regexp_type</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>re</name></expr>;</return></block_content></block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>quoted</name></decl>;</decl_stmt>

<expr_stmt><expr><name>quoted</name> <operator>=</operator> <call><name>rb_reg_s_quote</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_reg_new_str</name><argument_list>(<argument><expr><name>quoted</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>source</name> <init>= <expr><call><name>rb_str_buf_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>result_enc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_asciionly</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>has_ascii_compat_fixed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>has_ascii_incompat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_buf_cat_ascii</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_check_regexp_type</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_ascii_incompat</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>has_ascii_incompat</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>has_ascii_incompat</name> <operator>!=</operator> <name>enc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"incompatible encodings: %s and %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>has_ascii_incompat</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_reg_fixed_encoding_p</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_ascii_compat_fixed</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>has_ascii_compat_fixed</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>has_ascii_compat_fixed</name> <operator>!=</operator> <name>enc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"incompatible encodings: %s and %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>has_ascii_compat_fixed</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>has_asciionly</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_reg_str_with_term</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_get</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_ascii_incompat</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>has_ascii_incompat</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>has_ascii_incompat</name> <operator>!=</operator> <name>enc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"incompatible encodings: %s and %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>has_ascii_incompat</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_enc_str_asciionly_p</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>has_asciionly</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_ascii_compat_fixed</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>has_ascii_compat_fixed</name> <operator>=</operator> <name>enc</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>has_ascii_compat_fixed</name> <operator>!=</operator> <name>enc</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"incompatible encodings: %s and %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>has_ascii_compat_fixed</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_reg_s_quote</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_ascii_incompat</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_asciionly</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"ASCII incompatible encoding: %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>has_ascii_incompat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_ascii_compat_fixed</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"incompatible encodings: %s and %s"</literal></expr></argument>,

<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>has_ascii_incompat</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>has_ascii_compat_fixed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>has_ascii_incompat</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result_enc</name> <operator>=</operator> <name>has_ascii_incompat</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>has_ascii_compat_fixed</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result_enc</name> <operator>=</operator> <name>has_ascii_compat_fixed</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>result_enc</name> <operator>=</operator> <call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>result_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>source</name></expr></argument>, <argument><expr><name>rb_cRegexp</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_s_union_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_reg_s_union</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_reg_s_union</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_init_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>copy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>re</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OBJ_INIT_COPY</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>copy</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_reg_check</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_reg_init_str</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><call><name>RREGEXP_SRC</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_reg_options</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_reg_regsub</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>re_registers</name></name> <modifier>*</modifier></type><name>regs</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>regexp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>no</name></decl>, <decl><type ref="prev"/><name>clen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>str_enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>src_enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>acompat</name> <init>= <expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASCGET</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>e</name></type></parameter>,<parameter><type><name>cl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(acompat ? (*(cl)=1,ISASCII((s)[0])?(s)[0]:-1) : rb_enc_ascget((s), (e), (cl), str_enc))</cpp:value></cpp:define>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>ASCGET</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ss</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>s</name> <operator>==</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><name>ss</name><operator>-</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ss</name><operator>-</operator><name>p</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>ASCGET</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>mbclen</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><name>ss</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case>

<case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>regexp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>onig_noname_group_capture_is_active</name><argument_list>(<argument><expr><call><name>RREGEXP_PTR</name><argument_list>(<argument><expr><name>regexp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>no</name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name> <operator>&amp;&amp;</operator> <call><name>ASCGET</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name_end</name></decl>;</decl_stmt>

<expr_stmt><expr><name>name_end</name> <operator>=</operator> <name>name</name> <operator>=</operator> <name>s</name> <operator>+</operator> <name>clen</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>name_end</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>ASCGET</name><argument_list>(<argument><expr><name>name_end</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>name_end</name> <operator>+=</operator> <ternary><condition><expr><name>c</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>mbclen</name><argument_list>(<argument><expr><name>name_end</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>clen</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>name_end</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>n</name> <init>= <expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>name</name> <operator>-</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>name_end</name> <operator>-</operator> <name>name</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>no</name> <operator>=</operator> <call><name>NAME_TO_NUMBER</name><argument_list>(<argument><expr><name>regs</name></expr></argument>, <argument><expr><name>regexp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_end</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>name_to_backref_error</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>=</operator> <name>name_end</name> <operator>+</operator> <name>clen</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"invalid group name reference format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><name>ss</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'0'</literal></expr>:</case>

<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>

<expr_stmt><expr><name>no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'`'</literal></expr>:</case>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BEG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>src_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'\''</literal></expr>:</case>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>END</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call><operator>-</operator><call><name>END</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>src_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'+'</literal></expr>:</case>

<expr_stmt><expr><name>no</name> <operator>=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>no</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>no</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>no</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name>no</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><name>clen</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

<default>default:</default>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><name>ss</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>no</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>no</name> <operator>&gt;=</operator> <name><name>regs</name><operator>-&gt;</operator><name>num_regs</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BEG</name><argument_list>(<argument><expr><name>no</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>BEG</name><argument_list>(<argument><expr><name>no</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>END</name><argument_list>(<argument><expr><name>no</name></expr></argument>)</argument_list></call><operator>-</operator><call><name>BEG</name><argument_list>(<argument><expr><name>no</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>src_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>str</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_enc_str_buf_cat</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name><operator>-</operator><name>p</name></expr></argument>, <argument><expr><name>str_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>val</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>kcode_getter</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>_x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"variable $KCODE is no longer effective"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>kcode_setter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"variable $KCODE is no longer effective; ignored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ignorecase_getter</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>_x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"variable $= is no longer effective"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ignorecase_setter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"variable $= is no longer effective; ignored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>match_getter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name> <init>= <expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_match_busy</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>match</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>get_LAST_MATCH_INFO</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>_x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>match_getter</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>match_setter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>_x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_y</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>T_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_backref_set</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_reg_s_last_match</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>match</name> <init>= <expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>match_backref_number</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_reg_nth_match</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>match_getter</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>re_warn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_Regexp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>rb_eRegexpError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"RegexpError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onigenc_set_default_encoding</name><argument_list>(<argument><expr><name>ONIG_ENCODING_ASCII</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onig_set_warn_func</name><argument_list>(<argument><expr><name>re_warn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>onig_set_verb_warn_func</name><argument_list>(<argument><expr><name>re_warn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_virtual_variable</name><argument_list>(<argument><expr><literal type="string">"$~"</literal></expr></argument>, <argument><expr><name>get_LAST_MATCH_INFO</name></expr></argument>, <argument><expr><name>match_setter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_virtual_variable</name><argument_list>(<argument><expr><literal type="string">"$&amp;"</literal></expr></argument>, <argument><expr><name>last_match_getter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_virtual_variable</name><argument_list>(<argument><expr><literal type="string">"$`"</literal></expr></argument>, <argument><expr><name>prematch_getter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_virtual_variable</name><argument_list>(<argument><expr><literal type="string">"$'"</literal></expr></argument>, <argument><expr><name>postmatch_getter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_virtual_variable</name><argument_list>(<argument><expr><literal type="string">"$+"</literal></expr></argument>, <argument><expr><name>last_paren_match_getter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_virtual_variable</name><argument_list>(<argument><expr><literal type="string">"$="</literal></expr></argument>, <argument><expr><name>ignorecase_getter</name></expr></argument>, <argument><expr><name>ignorecase_setter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_virtual_variable</name><argument_list>(<argument><expr><literal type="string">"$KCODE"</literal></expr></argument>, <argument><expr><name>kcode_getter</name></expr></argument>, <argument><expr><name>kcode_setter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_virtual_variable</name><argument_list>(<argument><expr><literal type="string">"$-K"</literal></expr></argument>, <argument><expr><name>kcode_getter</name></expr></argument>, <argument><expr><name>kcode_setter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cRegexp</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Regexp"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><name>rb_reg_s_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"compile"</literal></expr></argument>, <argument><expr><name>rb_class_new_instance</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"quote"</literal></expr></argument>, <argument><expr><name>rb_reg_s_quote</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"escape"</literal></expr></argument>, <argument><expr><name>rb_reg_s_quote</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"union"</literal></expr></argument>, <argument><expr><name>rb_reg_s_union_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"last_match"</literal></expr></argument>, <argument><expr><name>rb_reg_s_last_match</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"try_convert"</literal></expr></argument>, <argument><expr><name>rb_reg_s_try_convert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>rb_reg_initialize_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>, <argument><expr><name>rb_reg_init_copy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>rb_reg_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"eql?"</literal></expr></argument>, <argument><expr><name>rb_reg_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>rb_reg_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"=~"</literal></expr></argument>, <argument><expr><name>rb_reg_match</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"==="</literal></expr></argument>, <argument><expr><name>rb_reg_eqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"~"</literal></expr></argument>, <argument><expr><name>rb_reg_match2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"match"</literal></expr></argument>, <argument><expr><name>rb_reg_match_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"match?"</literal></expr></argument>, <argument><expr><name>rb_reg_match_m_p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>rb_reg_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>rb_reg_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"source"</literal></expr></argument>, <argument><expr><name>rb_reg_source</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"casefold?"</literal></expr></argument>, <argument><expr><name>rb_reg_casefold_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"options"</literal></expr></argument>, <argument><expr><name>rb_reg_options_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>, <argument><expr><name>rb_obj_encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"fixed_encoding?"</literal></expr></argument>, <argument><expr><name>rb_reg_fixed_encoding_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"names"</literal></expr></argument>, <argument><expr><name>rb_reg_names</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"named_captures"</literal></expr></argument>, <argument><expr><name>rb_reg_named_captures</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"IGNORECASE"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ONIG_OPTION_IGNORECASE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"EXTENDED"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ONIG_OPTION_EXTEND</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"MULTILINE"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ONIG_OPTION_MULTILINE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"FIXEDENCODING"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ARG_ENCODING_FIXED</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cRegexp</name></expr></argument>, <argument><expr><literal type="string">"NOENCODING"</literal></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>ARG_ENCODING_NONE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_global_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>reg_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cMatch</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"MatchData"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><name>match_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"allocate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>, <argument><expr><name>match_init_copy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"regexp"</literal></expr></argument>, <argument><expr><name>match_regexp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"names"</literal></expr></argument>, <argument><expr><name>match_names</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>match_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><name>match_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name>match_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"begin"</literal></expr></argument>, <argument><expr><name>match_begin</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"end"</literal></expr></argument>, <argument><expr><name>match_end</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"to_a"</literal></expr></argument>, <argument><expr><name>match_to_a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>match_aref</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"captures"</literal></expr></argument>, <argument><expr><name>match_captures</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"named_captures"</literal></expr></argument>, <argument><expr><name>match_named_captures</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"values_at"</literal></expr></argument>, <argument><expr><name>match_values_at</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"pre_match"</literal></expr></argument>, <argument><expr><name>rb_reg_match_pre</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"post_match"</literal></expr></argument>, <argument><expr><name>rb_reg_match_post</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>match_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>match_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"string"</literal></expr></argument>, <argument><expr><name>match_string</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>match_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"eql?"</literal></expr></argument>, <argument><expr><name>match_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cMatch</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>match_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
