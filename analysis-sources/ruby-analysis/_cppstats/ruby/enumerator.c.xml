<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\enumerator.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FLOAT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/enumerator.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/imemo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/numeric.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/range.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/ruby.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cEnumerator</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_cLazy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_rewind</name></decl>, <decl><type ref="prev"/><name>id_new</name></decl>, <decl><type ref="prev"/><name>id_to_enum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_next</name></decl>, <decl><type ref="prev"/><name>id_result</name></decl>, <decl><type ref="prev"/><name>id_receiver</name></decl>, <decl><type ref="prev"/><name>id_arguments</name></decl>, <decl><type ref="prev"/><name>id_memo</name></decl>, <decl><type ref="prev"/><name>id_method</name></decl>, <decl><type ref="prev"/><name>id_force</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_begin</name></decl>, <decl><type ref="prev"/><name>id_end</name></decl>, <decl><type ref="prev"/><name>id_step</name></decl>, <decl><type ref="prev"/><name>id_exclude_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>sym_each</name></decl>, <decl><type ref="prev"/><name>sym_cycle</name></decl>, <decl><type ref="prev"/><name>sym_yield</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>lazy_use_super_method</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_call</name></cpp:macro> <cpp:value>idCall</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_each</name></cpp:macro> <cpp:value>idEach</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_eqq</name></cpp:macro> <cpp:value>idEqq</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_initialize</name></cpp:macro> <cpp:value>idInitialize</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_size</name></cpp:macro> <cpp:value>idSize</cpp:value></cpp:define>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eStopIteration</name></decl>;</decl_stmt>

<struct>struct <name>enumerator</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>meth</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>fib</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>lookahead</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>feedvalue</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>stop_exc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_enumerator_size_func</name> <modifier>*</modifier></type><name>size_fn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kw_splat</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_cGenerator</name></decl>, <decl><type ref="prev"/><name>rb_cYielder</name></decl>, <decl><type ref="prev"/><name>rb_cEnumProducer</name></decl>;</decl_stmt>

<struct>struct <name>generator</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>yielder</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>producer</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>init</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>;</decl_stmt>

}</block>;</struct>

<typedef>typedef <function_decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>lazyenum_proc_func</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>long</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>VALUE</name></type> <name>lazyenum_size_func</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>lazyenum_proc_func</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lazyenum_size_func</name> <modifier>*</modifier></type><name>size</name></decl>;</decl_stmt>

}</block></struct></type> <name>lazyenum_funcs</name>;</typedef>

<struct>struct <name>proc_entry</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>lazyenum_funcs</name> <modifier>*</modifier></type><name>fn</name></decl>;</decl_stmt>

}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>generator_allocate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>generator_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_cEnumChain</name></decl>;</decl_stmt>

<struct>struct <name>enum_chain</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>enums</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cArithSeq</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>enumerator_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>fib</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>dst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>lookahead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>feedvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>stop_exc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>procs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>enumerator_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>fib</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>fib</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>dst</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>dst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>lookahead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>feedvalue</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>feedvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>stop_exc</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>stop_exc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>procs</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>procs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>enumerator_free</name></cpp:macro> <cpp:value>RUBY_TYPED_DEFAULT_FREE</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>enumerator_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>enumerator</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>enumerator_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"enumerator"</literal></expr>,

<expr><block>{

<expr><name>enumerator_mark</name></expr>,

<expr><name>enumerator_free</name></expr>,

<expr><name>enumerator_memsize</name></expr>,

<expr><name>enumerator_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type>

<name>enumerator_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>enumerator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enumerator_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>||</operator> <name><name>ptr</name><operator>-&gt;</operator><name>obj</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized enumerator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>proc_entry_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>memo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>proc_entry_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>memo</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>memo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>proc_entry_free</name></cpp:macro> <cpp:value>RUBY_TYPED_DEFAULT_FREE</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>proc_entry_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><name>p</name></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>proc_entry</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>proc_entry_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"proc_entry"</literal></expr>,

<expr><block>{

<expr><name>proc_entry_mark</name></expr>,

<expr><name>proc_entry_free</name></expr>,

<expr><name>proc_entry_memsize</name></expr>,

<expr><name>proc_entry_compact</name></expr>,

}</block></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type>

<name>proc_entry_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>, <argument><expr>struct <name>proc_entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_entry_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>obj_to_enum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>enumerator</name></decl>, <decl><type ref="prev"/><name>meth</name> <init>= <expr><name>sym_each</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>meth</name> <operator>=</operator> <operator>*</operator><name>argv</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enumerator</name> <operator>=</operator> <call><name>rb_enumeratorize_with_size</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>enumerator</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>size</name> <operator>=</operator> <call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>enumerator</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_allocate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>enum_obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>enum_obj</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>struct <name>enumerator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enumerator_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<return>return <expr><name>enum_obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enum_obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>meth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_enumerator_size_func</name> <modifier>*</modifier></type><name>size_fn</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>enum_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>enum_obj</name></expr></argument>, <argument><expr>struct <name>enumerator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enumerator_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unallocated enumerator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>meth</name></name> <operator>=</operator> <call><name>rb_to_id</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>fib</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>dst</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>feedvalue</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>stop_exc</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>size_fn</name></name> <operator>=</operator> <name>size_fn</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>kw_splat</name></name> <operator>=</operator> <name>kw_splat</name></expr>;</expr_stmt>

<return>return <expr><name>enum_obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name></decl>, <decl><type ref="prev"/><name>meth</name> <init>= <expr><name>sym_each</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>size</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kw_splat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>recv</name> <operator>=</operator> <call><name>generator_init</name><argument_list>(<argument><expr><call><name>generator_allocate</name><argument_list>(<argument><expr><name>rb_cGenerator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>rb_respond_to</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>id_call</name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>(</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_FLOAT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>HUGE_VAL</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>rb_to_int</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_warn_deprecated</name><argument_list>(<argument><expr><literal type="string">"Enumerator.new without a block"</literal></expr></argument>, <argument><expr><literal type="string">"Object#to_enum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>recv</name> <operator>=</operator> <operator>*</operator><name>argv</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>argc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>meth</name> <operator>=</operator> <operator>*</operator><name>argv</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>kw_splat</name> <operator>=</operator> <call><name>rb_keyword_given_p</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>enumerator_init</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_init_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>ptr0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr1</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OBJ_INIT_COPY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>obj</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr0</name> <operator>=</operator> <call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr0</name><operator>-&gt;</operator><name>fib</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"can't copy execution context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>enumerator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enumerator_data_type</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unallocated enumerator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name><name>ptr0</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>meth</name></name> <operator>=</operator> <name><name>ptr0</name><operator>-&gt;</operator><name>meth</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name><name>ptr0</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>fib</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>feedvalue</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>ptr0</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>size_fn</name></name> <operator>=</operator> <name><name>ptr0</name><operator>-&gt;</operator><name>size_fn</name></name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_enumeratorize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>meth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_enumeratorize_with_size</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_to_enum_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>meth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_enumerator_size_func</name> <modifier>*</modifier></type><name>size_fn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>VALUE</name></type>

<name>rb_enumeratorize_with_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>meth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_enumerator_size_func</name> <modifier>*</modifier></type><name>size_fn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>rb_cLazy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>lazy_to_enum_i</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>size_fn</name></expr></argument>, <argument><expr><call><name>rb_keyword_given_p</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>enumerator_init</name><argument_list>(<argument><expr><call><name>enumerator_allocate</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>size_fn</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><call><name>rb_keyword_given_p</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_enumeratorize_with_size_kw</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>meth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_enumerator_size_func</name> <modifier>*</modifier></type><name>size_fn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>rb_cLazy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>lazy_to_enum_i</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>size_fn</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>enumerator_init</name><argument_list>(<argument><expr><call><name>enumerator_allocate</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>size_fn</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_block_call</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>rb_block_call_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>meth</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>meth</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_block_call_kw</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_each</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name> <operator>=</operator> <call><name>rb_obj_dup</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>args</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>args</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> <operator>&lt;</operator> <name>SIZEOF_LONG</name></expr></cpp:if>

<expr_stmt><expr><call><name>rb_long2int</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_cat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>size_fn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>obj</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>enumerator_block_call</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_with_index_i</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>memo</name> <init>= <expr><operator>(</operator>struct <name>MEMO</name> <operator>*</operator><operator>)</operator><name>m</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>idx</name> <init>= <expr><name><name>memo</name><operator>-&gt;</operator><name>v1</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMO_V1_SET</name><argument_list>(<argument><expr><name>memo</name></expr></argument>, <argument><expr><call><name>rb_int_succ</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_enum_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enumerator_size</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_with_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memo</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>enumerator_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>memo</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><name>argc</name> <operator>||</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name>memo</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>rb_to_int</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<return>return <expr><call><name>enumerator_block_call</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>enumerator_with_index_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><call><name>MEMO_NEW</name><argument_list>(<argument><expr><name>memo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_each_with_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enumerator_with_index</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_with_object_i</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_with_object</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memo</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>memo</name></expr></argument>, <argument><expr><name>enumerator_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>enumerator_block_call</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>enumerator_with_object_i</name></expr></argument>, <argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>memo</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>next_ii</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>feedvalue</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>args</name> <init>= <expr><call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_fiber_yield</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>feedvalue</name></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>feedvalue</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>feedvalue</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>feedvalue</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>feedvalue</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>next_i</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>_</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>nil</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_block_call</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>next_ii</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>stop_exc</name></name> <operator>=</operator> <call><name>rb_exc_new2</name><argument_list>(<argument><expr><name>rb_eStopIteration</name></expr></argument>, <argument><expr><literal type="string">"iteration reached an end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>stop_exc</name></name></expr></argument>, <argument><expr><name>id_result</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_fiber_yield</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nil</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>next_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>curr</name> <init>= <expr><call><name>rb_fiber_current</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>dst</name></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>fib</name></name> <operator>=</operator> <call><name>rb_fiber_new</name><argument_list>(<argument><expr><name>next_i</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>get_next_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>curr</name></decl>, <decl><type ref="prev"/><name>vs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>stop_exc</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>stop_exc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>curr</name> <operator>=</operator> <call><name>rb_fiber_current</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>e</name><operator>-&gt;</operator><name>fib</name></name> <operator>||</operator> <operator>!</operator><call><name>rb_fiber_alive_p</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>fib</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>next_init</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vs</name> <operator>=</operator> <call><name>rb_fiber_resume</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>fib</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>stop_exc</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>fib</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>dst</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>feedvalue</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>stop_exc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>vs</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_next_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vs</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<return>return <expr><name>vs</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>get_next_values</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>ary2sv</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dup</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>args</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<return>return <expr><name>Qnil</name></expr>;</return>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<return>return <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><name>dup</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>args</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_next</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vs</name> <init>= <expr><call><name>enumerator_next_values</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ary2sv</name><argument_list>(<argument><expr><name>vs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_peek_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <call><name>get_next_values</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>e</name><operator>-&gt;</operator><name>lookahead</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_peek_values_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_ary_dup</name><argument_list>(<argument><expr><call><name>enumerator_peek_values</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_peek</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vs</name> <init>= <expr><call><name>enumerator_peek_values</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ary2sv</name><argument_list>(<argument><expr><name>vs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_feed</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>feedvalue</name></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"feed value already set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>feedvalue</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_rewind</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_funcall</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>, <argument><expr><name>id_rewind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>fib</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>dst</name></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>lookahead</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>feedvalue</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>stop_exc</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>generator_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>append_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>default_method</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>default_args</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>inspect_enumerator</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>eobj</name></decl>, <decl><type ref="prev"/><name>str</name></decl>, <decl><type ref="prev"/><name>cname</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>enumerator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enumerator_data_type</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cname</name> <operator>=</operator> <call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name> <operator>||</operator> <name><name>e</name><operator>-&gt;</operator><name>obj</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": uninitialized&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_class_path</name><argument_list>(<argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": ...&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_class_path</name><argument_list>(<argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>procs</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>eobj</name> <operator>=</operator> <call><name>generator_ptr</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>obj</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>eobj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>cname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><name>eobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": %+"</literal><name>PRIsVALUE</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_class_path</name><argument_list>(<argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>eobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>procs</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>cname</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_method</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>procs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>meth</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>eobj</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>eobj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>eobj</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": %+"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><call><name>rb_class_path</name><argument_list>(<argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>eobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>meth</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>key_symbol_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>arg</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<return>return <expr><name>ST_STOP</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>kwd_append</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"non-symbol key inserted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"% "</literal><name>PRIsVALUE</name><literal type="string">": %"</literal><name>PRIsVALUE</name><literal type="string">", "</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>append_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>default_method</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>default_args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>method</name></decl>, <decl><type ref="prev"/><name>eargs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>method</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>method</name> <operator>!=</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><name>T_SYMBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>method</name> <operator>=</operator> <call><name>rb_sym2str</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>method</name> <operator>=</operator> <call><name>rb_id2str</name><argument_list>(<argument><expr><name>default_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>eargs</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_arguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>eargs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>eargs</name> <operator>=</operator> <name>default_args</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>eargs</name> <operator>!=</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>argc</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>eargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>eargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>kwds</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>all_key</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>key_symbol_p</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>all_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>all_key</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>kwds</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>--</operator><name>argc</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>argc</name><operator>--</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name> <init>= <expr><operator>*</operator><name>argv</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>, <argument><expr><name>kwd_append</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_exec_recursive</name><argument_list>(<argument><expr><name>inspect_enumerator</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>procs</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>generator_ptr</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>receiver</name> <init>= <expr><call><name>rb_check_funcall</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>, <argument><expr><name>id_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>procs</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>procs</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lazyenum_size_func</name> <modifier>*</modifier></type><name>size_fn</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size_fn</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>receiver</name> <operator>=</operator> <call>(<modifier>*</modifier><name>size_fn</name>)<argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>receiver</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>size_fn</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call>(<modifier>*</modifier><name><name>e</name><operator>-&gt;</operator><name>size_fn</name></name>)<argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>rb_check_funcall_kw</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>id_call</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>kw_splat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>size</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>e</name><operator>-&gt;</operator><name>size</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>yielder_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>yielder</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>yielder_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>yielder</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yielder_free</name></cpp:macro> <cpp:value>RUBY_TYPED_DEFAULT_FREE</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>yielder_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>yielder</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>yielder_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"yielder"</literal></expr>,

<expr><block>{

<expr><name>yielder_mark</name></expr>,

<expr><name>yielder_free</name></expr>,

<expr><name>yielder_memsize</name></expr>,

<expr><name>yielder_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>yielder</name></name> <modifier>*</modifier></type>

<name>yielder_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>yielder</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>yielder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yielder_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>||</operator> <name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized yielder"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>yielder_allocate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>yielder</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>struct <name>yielder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yielder_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>yielder_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>yielder</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>yielder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>yielder_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unallocated yielder"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>yielder_initialize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_need_block</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>yielder_init</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>yielder_yield</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>yielder</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>yielder_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_proc_call_kw</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>yielder_yield_push</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>yielder</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>yielder_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_proc_call_with_block</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>yielder_to_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>method</name> <init>= <expr><call><name>rb_obj_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>sym_yield</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>method</name></expr></argument>, <argument><expr><name>idTo_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>yielder_yield_i</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<return>return <expr><call><name>rb_yield_values_kw</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>yielder_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>yielder_init</name><argument_list>(<argument><expr><call><name>yielder_allocate</name><argument_list>(<argument><expr><name>rb_cYielder</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_proc_new</name><argument_list>(<argument><expr><name>yielder_yield_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>generator_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>generator_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>generator_free</name></cpp:macro> <cpp:value>RUBY_TYPED_DEFAULT_FREE</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>generator_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>generator</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>generator_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"generator"</literal></expr>,

<expr><block>{

<expr><name>generator_mark</name></expr>,

<expr><name>generator_free</name></expr>,

<expr><name>generator_memsize</name></expr>,

<expr><name>generator_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type>

<name>generator_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>generator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>generator_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>||</operator> <name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized generator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>generator_allocate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>struct <name>generator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>generator_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>generator_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>generator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>generator_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unallocated generator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>generator_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_need_block</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,

<argument><expr><literal type="string">"wrong argument type %"</literal><name>PRIsVALUE</name><literal type="string">" (expected Proc)"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>generator_init</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>generator_init_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>ptr0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr1</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OBJ_INIT_COPY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>obj</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr0</name> <operator>=</operator> <call><name>generator_ptr</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>generator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>generator_data_type</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unallocated generator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name><name>ptr0</name><operator>-&gt;</operator><name>proc</name></name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>generator_each</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>generator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>args</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>argc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>yielder_new</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_cat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_proc_call_kw</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>r</name> <init>= <expr><call><name>rb_check_funcall</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>r</name> <operator>==</operator> <name>Qundef</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><name>r</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazyenum_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enum_size</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enum_size</name><argument_list>(<argument><expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_receiver</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_receiver_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>generator</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>lazy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>lazy_size</name><argument_list>(<argument><expr><name>lazy</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_init_iterator</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_yield_values2</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>rb_long2int</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>argc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>nargv</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>nargv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>nargv</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_yield_values2</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>nargv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_iter_break</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_init_block_i</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_block_call</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>id_each</name></expr></argument>, <argument><expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>argv</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>lazy_init_iterator</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>memo_value</name></cpp:macro> <cpp:value>v2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>memo_flags</name></cpp:macro> <cpp:value>u3.state</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_MEMO_BREAK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_MEMO_PACKED</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_MEMO_BREAK_P</name><parameter_list>(<parameter><type><name>memo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((memo)-&gt;memo_flags &amp; LAZY_MEMO_BREAK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_MEMO_PACKED_P</name><parameter_list>(<parameter><type><name>memo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((memo)-&gt;memo_flags &amp; LAZY_MEMO_PACKED)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_MEMO_SET_BREAK</name><parameter_list>(<parameter><type><name>memo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((memo)-&gt;memo_flags |= LAZY_MEMO_BREAK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_MEMO_SET_VALUE</name><parameter_list>(<parameter><type><name>memo</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MEMO_V2_SET(memo, value)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_MEMO_SET_PACKED</name><parameter_list>(<parameter><type><name>memo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((memo)-&gt;memo_flags |= LAZY_MEMO_PACKED)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAZY_MEMO_RESET_PACKED</name><parameter_list>(<parameter><type><name>memo</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((memo)-&gt;memo_flags &amp;= ~LAZY_MEMO_PACKED)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_init_yielder</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>_</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>yielder</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procs_array</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memos</name> <init>= <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>id_memo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cont</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>MEMO_NEW</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><call><name>rb_enum_values_pack</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>LAZY_MEMO_PACKED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>procs_array</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>proc</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>procs_array</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call>(<modifier>*</modifier><name><name>entry</name><operator>-&gt;</operator><name>fn</name><operator>-&gt;</operator><name>proc</name></name>)<argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>memos</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cont</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>cont</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_funcall2</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>idLTLT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LAZY_MEMO_BREAK_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_iter_break</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_init_block</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>procs</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>id_memo</name></expr></argument>, <argument><expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>procs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_block_call</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>lazy_init_yielder</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>procs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_generator_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enumerator</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>procs</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>generator</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>gen_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>enumerator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>procs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>generator</name></name> <modifier>*</modifier></type><name>old_gen_ptr</name> <init>= <expr><call><name>generator_ptr</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <name><name>old_gen_ptr</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <name>enumerator</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>generator</name> <operator>=</operator> <call><name>generator_allocate</name><argument_list>(<argument><expr><name>rb_cGenerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_block_call</name><argument_list>(<argument><expr><name>generator</name></expr></argument>, <argument><expr><name>id_initialize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>lazy_init_block</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>procs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>gen_ptr</name> <operator>=</operator> <call><name>generator_ptr</name><argument_list>(<argument><expr><name>generator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gen_ptr</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>

<return>return <expr><name>generator</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>generator</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to call lazy new without a block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>generator</name> <operator>=</operator> <call><name>generator_allocate</name><argument_list>(<argument><expr><name>rb_cGenerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_block_call</name><argument_list>(<argument><expr><name>generator</name></expr></argument>, <argument><expr><name>id_initialize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lazy_init_block_i</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>enumerator_init</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>generator</name></expr></argument>, <argument><expr><name>sym_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_receiver</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

static VALUE lazy_to_a(VALUE self)

{

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>lazy_set_args</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>lazy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_frame_this_func</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>lazy</name></expr></argument>, <argument><expr><name>id_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>lazy</name></expr></argument>, <argument><expr><name>id_arguments</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>lazy</name></expr></argument>, <argument><expr><name>id_arguments</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_set_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>lazy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>rb_enumerator_size_func</name> <modifier>*</modifier></type><name>size_fn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>lazy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>lazy_set_args</name><argument_list>(<argument><expr><name>lazy</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>size_fn</name></name> <operator>=</operator> <name>size_fn</name></expr>;</expr_stmt>

<return>return <expr><name>lazy</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_add_method</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memo</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>lazyenum_funcs</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>new_e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>new_obj</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>new_generator</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>new_procs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>entry_obj</name> <init>= <expr><call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr>struct <name>proc_entry</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>proc_entry_data_type</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>fn</name></name> <operator>=</operator> <name>fn</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>memo</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>lazy_set_args</name><argument_list>(<argument><expr><name>entry_obj</name></expr></argument>, <argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>new_procs</name> <operator>=</operator> <ternary><condition><expr><call><name>RTEST</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>procs</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>rb_ary_dup</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>procs</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>new_generator</name> <operator>=</operator> <call><name>lazy_generator_init</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>new_procs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>new_procs</name></expr></argument>, <argument><expr><name>entry_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>new_obj</name> <operator>=</operator> <call><name>enumerator_init_copy</name><argument_list>(<argument><expr><call><name>enumerator_allocate</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>new_e</name> <operator>=</operator> <call><name>DATA_PTR</name><argument_list>(<argument><expr><name>new_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>new_generator</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>procs</name></name> <operator>=</operator> <name>new_procs</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>meth</name></name> <operator>=</operator> <call><name>rb_to_id</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>meth</name></name> <operator>=</operator> <name>id_each</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>new_obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerable_lazy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>lazy_to_enum_i</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>sym_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lazyenum_size</name></expr></argument>, <argument><expr><call><name>rb_keyword_given_p</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>id_method</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_to_enum_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>meth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>rb_enumerator_size_func</name> <modifier>*</modifier></type><name>size_fn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kw_splat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enumerator_init</name><argument_list>(<argument><expr><call><name>enumerator_allocate</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>size_fn</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>kw_splat</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_to_enum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>lazy</name></decl>, <decl><type ref="prev"/><name>meth</name> <init>= <expr><name>sym_each</name></expr></init></decl>, <decl><type ref="prev"/><name>super_meth</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>meth</name> <operator>=</operator> <operator>*</operator><name>argv</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><operator>(</operator><name>super_meth</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>meth</name> <operator>=</operator> <name>super_meth</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lazy</name> <operator>=</operator> <call><name>lazy_to_enum_i</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>rb_keyword_given_p</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>enumerator_ptr</name><argument_list>(<argument><expr><name>lazy</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>size</name> <operator>=</operator> <call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>lazy</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_eager_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enum_size</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_eager</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enumerator_init</name><argument_list>(<argument><expr><call><name>enumerator_allocate</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>self</name></expr></argument>, <argument><expr><name>sym_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lazy_eager_size</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazyenum_yield</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_proc_call_with_block</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazyenum_yield_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>LAZY_MEMO_PACKED_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>args</name> <init>= <expr><operator>*</operator><name>argv</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argv</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_proc_call_with_block</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_map_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name> <init>= <expr><call><name>lazyenum_yield_values</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_SET_VALUE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_RESET_PACKED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_map_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>receiver</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>receiver</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_map_funcs</name> <init>= <expr><block>{

<expr><name>lazy_map_proc</name></expr>, <expr><name>lazy_map_size</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_map</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to call lazy map without a block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lazy_map_funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_flat_map_i</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>yielder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name> <init>= <expr><call><name>rb_enum_values_pack</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>idLTLT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_flat_map_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>yielder</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_block_call</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lazy_flat_map_i</name></expr></argument>, <argument><expr><name>yielder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_flat_map_to_ary</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>yielder</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>idLTLT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>idLTLT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_flat_map_proc</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_yield_values2</name><argument_list>(<argument><expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>idLTLT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_respond_to</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>id_force</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rb_respond_to</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>id_each</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>lazy_flat_map_each</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>lazy_flat_map_to_ary</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_flat_map</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to call lazy flat_map without a block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>lazy_set_method</name><argument_list>(<argument><expr><call><name>rb_block_call</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_new</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>,

<argument><expr><name>lazy_flat_map_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_select_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>chain</name> <init>= <expr><call><name>lazyenum_yield</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_select_funcs</name> <init>= <expr><block>{

<expr><name>lazy_select_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_select</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to call lazy select without a block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lazy_select_funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_filter_map_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name> <init>= <expr><call><name>lazyenum_yield_values</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_SET_VALUE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_RESET_PACKED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_filter_map_funcs</name> <init>= <expr><block>{

<expr><name>lazy_filter_map_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_filter_map</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to call lazy filter_map without a block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lazy_filter_map_funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_reject_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>chain</name> <init>= <expr><call><name>lazyenum_yield</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_reject_funcs</name> <init>= <expr><block>{

<expr><name>lazy_reject_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_reject</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to call lazy reject without a block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lazy_reject_funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_grep_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>chain</name> <init>= <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>memo</name></name></expr></argument>, <argument><expr><name>id_eqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_grep_iter_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>, <decl><type ref="prev"/><name>chain</name> <init>= <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>memo</name></name></expr></argument>, <argument><expr><name>id_eqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>rb_proc_call_with_block</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name><operator>)</operator></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_SET_VALUE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_RESET_PACKED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_grep_iter_funcs</name> <init>= <expr><block>{

<expr><name>lazy_grep_iter_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_grep_funcs</name> <init>= <expr><block>{

<expr><name>lazy_grep_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_grep</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pattern</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>lazyenum_funcs</name> <modifier>*</modifier><specifier>const</specifier></type> <name>funcs</name> <init>= <expr><ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then>

<expr><operator>&amp;</operator><name>lazy_grep_iter_funcs</name></expr> </then><else>: <expr><operator>&amp;</operator><name>lazy_grep_funcs</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_grep_v_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>chain</name> <init>= <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>memo</name></name></expr></argument>, <argument><expr><name>id_eqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_grep_v_iter_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>, <decl><type ref="prev"/><name>chain</name> <init>= <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>memo</name></name></expr></argument>, <argument><expr><name>id_eqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>rb_proc_call_with_block</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name><operator>)</operator></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_SET_VALUE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_RESET_PACKED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_grep_v_iter_funcs</name> <init>= <expr><block>{

<expr><name>lazy_grep_v_iter_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_grep_v_funcs</name> <init>= <expr><block>{

<expr><name>lazy_grep_v_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_grep_v</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pattern</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>lazyenum_funcs</name> <modifier>*</modifier><specifier>const</specifier></type> <name>funcs</name> <init>= <expr><ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then>

<expr><operator>&amp;</operator><name>lazy_grep_v_iter_funcs</name></expr> </then><else>: <expr><operator>&amp;</operator><name>lazy_grep_v_funcs</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>call_next</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_next</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>next_stopped</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_zip_arrays_func</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>arrays</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>yielder</name></decl>, <decl><type ref="prev"/><name>ary</name></decl>, <decl><type ref="prev"/><name>memo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>

<expr_stmt><expr><name>yielder</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>memo</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>id_memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>arrays</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>arrays</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>arrays</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>idLTLT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>id_memo</name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><operator>++</operator><name>count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_zip_func</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>zip_args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>yielder</name></decl>, <decl><type ref="prev"/><name>ary</name></decl>, <decl><type ref="prev"/><name>arg</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>yielder</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>id_memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>zip_args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>zip_args</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>zip_args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id_to_enum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>id_memo</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>argv</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <ternary><condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>rb_ary_new_from_values</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>*</operator><name>argv</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_rescue2</name><argument_list>(<argument><expr><name>call_next</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>next_stopped</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>rb_eStopIteration</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>yielder</name></expr></argument>, <argument><expr><name>idLTLT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_zip</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_block_call_func</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><name>lazy_zip_arrays_func</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_call_super</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_respond_to</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>id_each</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"wrong argument type %"</literal><name>PRIsVALUE</name><literal type="string">" (must respond to :each)"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>func</name> <operator>=</operator> <name>lazy_zip_func</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><call><name>lazy_set_method</name><argument_list>(<argument><expr><call><name>rb_block_call</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_new</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>,

<argument><expr><name>func</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>lazy_receiver_size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_take_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>remain</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memo</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>memo</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>memo</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>remain</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>remain</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>LAZY_MEMO_SET_BREAK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>remain</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>LAZY_MEMO_SET_BREAK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>remain</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_take_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>receiver</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>id_arguments</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>len</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>receiver</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_take_funcs</name> <init>= <expr><block>{

<expr><name>lazy_take_proc</name></expr>, <expr><name>lazy_take_size</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_take</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"attempt to take negative size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>sym_cycle</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2NUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>lazy_take_funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_take_while_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>take</name> <init>= <expr><call><name>lazyenum_yield_values</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>take</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>LAZY_MEMO_SET_BREAK</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_take_while_funcs</name> <init>= <expr><block>{

<expr><name>lazy_take_while_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_take_while</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to call lazy take_while without a block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lazy_take_while_funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_drop_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>receiver</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>, <argument><expr><name>id_arguments</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>receiver</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><ternary><condition><expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_drop_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>remain</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memo</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>memo</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>memo</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>remain</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>remain</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>remain</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>remain</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_drop_funcs</name> <init>= <expr><block>{

<expr><name>lazy_drop_proc</name></expr>, <expr><name>lazy_drop_size</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_drop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>sym_each</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"attempt to drop negative size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>lazy_drop_funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_drop_while_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name><modifier>*</modifier></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memo</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>memo</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>memo</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>drop</name> <init>= <expr><call><name>lazyenum_yield_values</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>drop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>, <argument><expr><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_drop_while_funcs</name> <init>= <expr><block>{

<expr><name>lazy_drop_while_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_drop_while</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to call lazy drop_while without a block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lazy_drop_while_funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>lazy_uniq_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>chain</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_obj_hide</name><argument_list>(<argument><expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_hash_add_new_element</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>chain</name></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_uniq_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>lazy_uniq_check</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name></expr></argument>, <argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_uniq_iter_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>chain</name> <init>= <expr><call><name>lazyenum_yield</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lazy_uniq_check</name><argument_list>(<argument><expr><name>chain</name></expr></argument>, <argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_uniq_iter_funcs</name> <init>= <expr><block>{

<expr><name>lazy_uniq_iter_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_uniq_funcs</name> <init>= <expr><block>{

<expr><name>lazy_uniq_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_uniq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>lazyenum_funcs</name> <modifier>*</modifier><specifier>const</specifier></type> <name>funcs</name> <init>=

<expr><ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>&amp;</operator><name>lazy_uniq_iter_funcs</name></expr> </then><else>: <expr><operator>&amp;</operator><name>lazy_uniq_funcs</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>MEMO</name></name> <modifier>*</modifier></type>

<name>lazy_with_index_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc_entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>MEMO</name></name><modifier>*</modifier></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>memos</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>memo_index</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>proc_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>proc_entry_ptr</name><argument_list>(<argument><expr><name>proc_entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memo</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>memo</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>memo</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>memo_value</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>memo</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>proc</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_proc_call_with_block</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_RESET_PACKED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>LAZY_MEMO_SET_VALUE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_ary_new_from_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LAZY_MEMO_SET_PACKED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>memos</name></expr></argument>, <argument><expr><name>memo_index</name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lazyenum_funcs</name></type> <name>lazy_with_index_funcs</name> <init>= <expr><block>{

<expr><name>lazy_with_index_proc</name></expr>, <expr><literal type="number">0</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_with_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>memo</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"01"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>memo</name> <operator>=</operator> <call><name>LONG2NUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>lazy_add_method</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>memo</name></expr></argument>, <argument><expr><call><name>rb_ary_new_from_values</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>memo</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>lazy_with_index_funcs</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

static VALUE lazy_chunk(VALUE self)

{

}

static VALUE lazy_chunk_while(VALUE self)

{

}

static VALUE lazy_slice_after(VALUE self)

{

}

static VALUE lazy_slice_before(VALUE self)

{

}

static VALUE lazy_slice_when(VALUE self)

{

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_super</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>lazy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enumerable_lazy</name><argument_list>(<argument><expr><call><name>rb_call_super</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>lazy_lazy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>stop_result</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_result</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>producer_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>producer</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>producer_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>producer</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>init</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>init</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>producer_free</name></cpp:macro> <cpp:value>RUBY_TYPED_DEFAULT_FREE</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>producer_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>producer</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>producer_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"producer"</literal></expr>,

<expr><block>{

<expr><name>producer_mark</name></expr>,

<expr><name>producer_free</name></expr>,

<expr><name>producer_memsize</name></expr>,

<expr><name>producer_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>producer</name></name> <modifier>*</modifier></type>

<name>producer_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>producer</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>producer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>producer_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>||</operator> <name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized producer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>producer_allocate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>producer</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>struct <name>producer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>producer_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>init</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>producer_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>init</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>producer</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>producer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>producer_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unallocated producer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>init</name></name> <operator>=</operator> <name>init</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name> <operator>=</operator> <name>proc</name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>producer_each_stop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_result</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>producer_each_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>producer</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>init</name></decl>, <decl><type ref="prev"/><name>proc</name></decl>, <decl><type ref="prev"/><name>curr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>producer_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>init</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>init</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>proc</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>proc</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>init</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>curr</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curr</name> <operator>=</operator> <name>init</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><name>curr</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>id_call</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>producer_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_need_block</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_rescue2</name><argument_list>(<argument><expr><name>producer_each_i</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>producer_each_stop</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_eStopIteration</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>producer_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>HUGE_VAL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_s_produce</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>init</name></decl>, <decl><type ref="prev"/><name>producer</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no block given"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"01"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>init</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>init</name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>producer</name> <operator>=</operator> <call><name>producer_init</name><argument_list>(<argument><expr><call><name>producer_allocate</name><argument_list>(<argument><expr><name>rb_cEnumProducer</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_enumeratorize_with_size_kw</name><argument_list>(<argument><expr><name>producer</name></expr></argument>, <argument><expr><name>sym_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>producer_size</name></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>enum_chain_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>enums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>enum_chain_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>enums</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>enums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>enum_chain_free</name></cpp:macro> <cpp:value>RUBY_TYPED_DEFAULT_FREE</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>enum_chain_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>enum_chain</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>enum_chain_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"chain"</literal></expr>,

<expr><block>{

<expr><name>enum_chain_mark</name></expr>,

<expr><name>enum_chain_free</name></expr>,

<expr><name>enum_chain_memsize</name></expr>,

<expr><name>enum_chain_compact</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type>

<name>enum_chain_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>enum_chain</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enum_chain_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>||</operator> <name><name>ptr</name><operator>-&gt;</operator><name>enums</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"uninitialized chain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_allocate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr>struct <name>enum_chain</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enum_chain_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>enums</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_initialize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>enums</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>enum_chain</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enum_chain_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unallocated chain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>enums</name></name> <operator>=</operator> <call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>enums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_init_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type><name>ptr0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr1</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OBJ_INIT_COPY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>obj</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr0</name> <operator>=</operator> <call><name>enum_chain_ptr</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>enum_chain</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enum_chain_data_type</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr1</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unallocated chain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>enums</name></name> <operator>=</operator> <name><name>ptr0</name><operator>-&gt;</operator><name>enums</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr1</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>ptr0</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_total_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enums</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>total</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>enums</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>size</name> <init>= <expr><call><name>enum_size</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>enums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>T_FLOAT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>NUM2DBL</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>total</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>total</name></expr></argument>, <argument><expr><literal type="char">'+'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>total</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enum_chain_total_size</name><argument_list>(<argument><expr><call><name>enum_chain_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>enums</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_enum_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>enum_chain_size</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_enum_no_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_each</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>enums</name></decl>, <decl><type ref="prev"/><name>block</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type><name>objptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><ternary><condition><expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>enum_chain_enum_no_size</name></expr> </then><else>: <expr><name>enum_chain_enum_size</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>objptr</name> <operator>=</operator> <call><name>enum_chain_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>enums</name> <operator>=</operator> <name><name>objptr</name><operator>-&gt;</operator><name>enums</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>enums</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>objptr</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall_with_block</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>enums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id_each</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_rewind</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type><name>objptr</name> <init>= <expr><call><name>enum_chain_ptr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>enums</name> <init>= <expr><name><name>objptr</name><operator>-&gt;</operator><name>enums</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>objptr</name><operator>-&gt;</operator><name>pos</name></name></expr>;</init> <condition><expr><literal type="number">0</literal> <operator>&lt;=</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>enums</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name><name>objptr</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_check_funcall</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>enums</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id_rewind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>inspect_enum_chain</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>enum_chain</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>struct <name>enum_chain</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enum_chain_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name> <operator>||</operator> <name><name>ptr</name><operator>-&gt;</operator><name>enums</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": uninitialized&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_class_path</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": ...&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_class_path</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">": %+"</literal><name>PRIsVALUE</name><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_class_path</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>enums</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_exec_recursive</name><argument_list>(<argument><expr><name>inspect_enum_chain</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enum_chain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>enums</name> <init>= <expr><call><name>rb_ary_new_from_values</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_cat</name><argument_list>(<argument><expr><name>enums</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>enum_chain_initialize</name><argument_list>(<argument><expr><call><name>enum_chain_allocate</name><argument_list>(<argument><expr><name>rb_cEnumChain</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enums</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>enumerator_plus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>enums</name> <init>= <expr><call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>eobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>enum_chain_initialize</name><argument_list>(<argument><expr><call><name>enum_chain_allocate</name><argument_list>(<argument><expr><name>rb_cEnumChain</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enums</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_arith_seq_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>meth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <specifier>const</specifier> <modifier>*</modifier></type><name>argv</name></decl></parameter>,

<parameter><decl><type><name>rb_enumerator_size_func</name> <modifier>*</modifier></type><name>size_fn</name></decl></parameter>,

<parameter><decl><type><name>VALUE</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>excl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>aseq</name> <init>= <expr><call><name>enumerator_init</name><argument_list>(<argument><expr><call><name>enumerator_allocate</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>size_fn</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><call><name>rb_keyword_given_p</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>aseq</name></expr></argument>, <argument><expr><name>id_begin</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>aseq</name></expr></argument>, <argument><expr><name>id_end</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>aseq</name></expr></argument>, <argument><expr><name>id_step</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>aseq</name></expr></argument>, <argument><expr><name>id_exclude_end</name></expr></argument>, <argument><expr><ternary><condition><expr><name>excl</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>aseq</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>arith_seq_begin</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_begin</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>arith_seq_end</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_end</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>arith_seq_step</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_step</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>

<name>arith_seq_exclude_end</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_exclude_end</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>arith_seq_exclude_end_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>arith_seq_exclude_end</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_arithmetic_sequence_extract</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>rb_arithmetic_sequence_components_t</name> <modifier>*</modifier></type><name>component</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>rb_cArithSeq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>component</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <call><name>arith_seq_begin</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>component</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <call><name>arith_seq_end</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>component</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <call><name>arith_seq_step</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>component</name><operator>-&gt;</operator><name>exclude_end</name></name> <operator>=</operator> <call><name>arith_seq_exclude_end_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>rb_cRange</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>component</name><operator>-&gt;</operator><name>begin</name></name> <operator>=</operator> <call><name>RANGE_BEG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>component</name><operator>-&gt;</operator><name>end</name></name> <operator>=</operator> <call><name>RANGE_END</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>component</name><operator>-&gt;</operator><name>step</name></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>component</name><operator>-&gt;</operator><name>exclude_end</name></name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><call><name>RANGE_EXCL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>arith_seq_first</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>e</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>ary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>arith_seq_begin</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>arith_seq_end</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>arith_seq_step</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>zero</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>rb_cmpint</name><argument_list>(<argument><expr><call><name>rb_num_coerce_cmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>, <argument><expr><name>idCmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>b</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"attempt to take negative size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>arith_seq_exclude_end_p</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>unit</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>FIXABLE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>unit</name></expr>;</expr_stmt> 

<expr_stmt><expr><operator>--</operator><name>n</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>rb_big_plus</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>n</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>end</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>unit</name> <init>= <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>unit</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>n</name> <operator>&lt;</operator> <name>len</name><operator>)</operator></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <name>unit</name> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>unit</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>n</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>x</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>end</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>n</name> <operator>&lt;</operator> <name>len</name><operator>)</operator></expr> ?</condition><then> <expr><name>n</name></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <name>unit</name> <operator>&gt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>unit</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>n</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>unit</name> <init>= <expr><call><name>NUM2DBL</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>beg</name> <init>= <expr><call><name>NUM2DBL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>end</name> <init>= <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>unit</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator><operator>*</operator><name>HUGE_VAL</name></expr> </then><else>: <expr><call><name>NUM2DBL</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>len</name> <init>= <expr><call><name>ruby_float_step_size</name><argument_list>(<argument><expr><name>beg</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>unit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>d</name> <init>= <expr><name>i</name><operator>*</operator><name>unit</name><operator>+</operator><name>beg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>unit</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>end</name> <operator>&lt;</operator> <name>d</name></expr> </then><else>: <expr><name>d</name> <operator>&lt;</operator> <name>end</name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_call_super</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>arith_seq_last</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>e</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>len_1</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>last</name></decl>, <decl><type ref="prev"/><name>nv</name></decl>, <decl><type ref="prev"/><name>ary</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>last_is_adjusted</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>arith_seq_end</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>,

<argument><expr><literal type="string">"cannot get the last element of endless arithmetic sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>arith_seq_begin</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>arith_seq_step</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len_1</name> <operator>=</operator> <call><name>rb_int_idiv</name><argument_list>(<argument><expr><call><name>rb_int_minus</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_num_negative_int_p</name><argument_list>(<argument><expr><name>len_1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>rb_int_mul</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len_1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>last_is_adjusted</name> <operator>=</operator> <call><name>arith_seq_exclude_end_p</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rb_equal</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>rb_int_minus</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>last</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>last_is_adjusted</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>len_1</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>len_1</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_INTEGER_TYPE_P</name><argument_list>(<argument><expr><name>nv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nv</name> <operator>=</operator> <call><name>rb_to_int</name><argument_list>(<argument><expr><name>nv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_int_gt</name><argument_list>(<argument><expr><name>nv</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nv</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>nv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative array size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>rb_int_minus</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><call><name>rb_int_mul</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>nv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>n</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>ary</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>arith_seq_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>enumerator</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>eobj</name></decl>, <decl><type ref="prev"/><name>str</name></decl>, <decl><type ref="prev"/><name>eargs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>range_p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>struct <name>enumerator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enumerator_data_type</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>eobj</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>eobj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>eobj</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>range_p</name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>eobj</name></expr></argument>, <argument><expr><name>rb_cRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"(%s%"</literal><name>PRIsVALUE</name><literal type="string">"%s."</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>range_p</name></expr> ?</condition><then> <expr><literal type="string">"("</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>eobj</name></expr></argument>, <argument><expr><ternary><condition><expr><name>range_p</name></expr> ?</condition><then> <expr><literal type="string">")"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>meth</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>eargs</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>eobj</name></expr></argument>, <argument><expr><name>id_arguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>eargs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>eargs</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>eargs</name> <operator>!=</operator> <name>Qfalse</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>argc</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>eargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>eargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>kwds</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>all_key</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>key_symbol_p</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>all_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>all_key</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>kwds</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>--</operator><name>argc</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>argc</name><operator>--</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name> <init>= <expr><operator>*</operator><name>argv</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>, <argument><expr><name>kwd_append</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>arith_seq_eq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>rb_cArithSeq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_equal</name><argument_list>(<argument><expr><call><name>arith_seq_begin</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>arith_seq_begin</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_equal</name><argument_list>(<argument><expr><call><name>arith_seq_end</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>arith_seq_end</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_equal</name><argument_list>(<argument><expr><call><name>arith_seq_step</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>arith_seq_step</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>arith_seq_exclude_end_p</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>arith_seq_exclude_end_p</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>arith_seq_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_index_t</name></type> <name>hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_start</name><argument_list>(<argument><expr><call><name>arith_seq_exclude_end_p</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash</name><argument_list>(<argument><expr><call><name>arith_seq_begin</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash</name><argument_list>(<argument><expr><call><name>arith_seq_end</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_hash</name><argument_list>(<argument><expr><call><name>arith_seq_step</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_end</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_GE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RTEST(rb_num_coerce_relop((x), (y), idGE))</cpp:value></cpp:define>

<struct>struct <name>arith_seq_gen</name> <block>{

<decl_stmt><decl><type><name>VALUE</name></type> <name>current</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>step</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>excl</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>arith_seq_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>e</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>len_1</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>self</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>arith_seq_begin</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>arith_seq_end</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>arith_seq_step</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>arith_seq_exclude_end_p</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>T_COMPLEX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ruby_float_step</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len_1</name> <operator>=</operator> <call><name>rb_int_idiv</name><argument_list>(<argument><expr><call><name>rb_int_minus</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>rb_int_mul</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len_1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <call><name>rb_equal</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>rb_int_minus</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_num_negative_int_p</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><call><name>NUM_GE</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<else>else <block>{<block_content>

<while>while <condition>(<expr><call><name>NUM_GE</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>arith_seq_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>b</name></decl>, <decl><type ref="prev"/><name>e</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>len_1</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>arith_seq_begin</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>arith_seq_end</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>arith_seq_step</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>arith_seq_exclude_end_p</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>ee</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rb_num_negative_int_p</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ee</name> <operator>=</operator> <operator>-</operator><name>HUGE_VAL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ee</name> <operator>=</operator> <name>HUGE_VAL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>ee</name> <operator>=</operator> <call><name>NUM2DBL</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ruby_float_step_size</name><argument_list>(<argument><expr><call><name>NUM2DBL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ee</name></expr></argument>, <argument><expr><call><name>NUM2DBL</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>POSFIXABLE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_dbl2big</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>HUGE_VAL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>rb_cNumeric</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>rb_to_int</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>HUGE_VAL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len_1</name> <operator>=</operator> <call><name>rb_int_idiv</name><argument_list>(<argument><expr><call><name>rb_int_minus</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_num_negative_int_p</name><argument_list>(<argument><expr><name>len_1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>rb_int_mul</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len_1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <call><name>rb_equal</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>len_1</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>rb_int_plus</name><argument_list>(<argument><expr><name>len_1</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>InitVM_Enumerator</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id_private</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"private"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mKernel</name></expr></argument>, <argument><expr><literal type="string">"to_enum"</literal></expr></argument>, <argument><expr><name>obj_to_enum</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mKernel</name></expr></argument>, <argument><expr><literal type="string">"enum_for"</literal></expr></argument>, <argument><expr><name>obj_to_enum</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cEnumerator</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Enumerator"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><name>rb_mEnumerable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><name>enumerator_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>enumerator_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>, <argument><expr><name>enumerator_init_copy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>enumerator_each</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"each_with_index"</literal></expr></argument>, <argument><expr><name>enumerator_each_with_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"each_with_object"</literal></expr></argument>, <argument><expr><name>enumerator_with_object</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"with_index"</literal></expr></argument>, <argument><expr><name>enumerator_with_index</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"with_object"</literal></expr></argument>, <argument><expr><name>enumerator_with_object</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"next_values"</literal></expr></argument>, <argument><expr><name>enumerator_next_values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"peek_values"</literal></expr></argument>, <argument><expr><name>enumerator_peek_values_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"next"</literal></expr></argument>, <argument><expr><name>enumerator_next</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"peek"</literal></expr></argument>, <argument><expr><name>enumerator_peek</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"feed"</literal></expr></argument>, <argument><expr><name>enumerator_feed</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"rewind"</literal></expr></argument>, <argument><expr><name>enumerator_rewind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>enumerator_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>enumerator_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><name>enumerator_plus</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mEnumerable</name></expr></argument>, <argument><expr><literal type="string">"chain"</literal></expr></argument>, <argument><expr><name>enum_chain</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cLazy</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"Lazy"</literal></expr></argument>, <argument><expr><name>rb_cEnumerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mEnumerable</name></expr></argument>, <argument><expr><literal type="string">"lazy"</literal></expr></argument>, <argument><expr><name>enumerable_lazy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_map"</literal></expr></argument>, <argument><expr><literal type="string">"map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_collect"</literal></expr></argument>, <argument><expr><literal type="string">"collect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_flat_map"</literal></expr></argument>, <argument><expr><literal type="string">"flat_map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_collect_concat"</literal></expr></argument>, <argument><expr><literal type="string">"collect_concat"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_select"</literal></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_find_all"</literal></expr></argument>, <argument><expr><literal type="string">"find_all"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_filter"</literal></expr></argument>, <argument><expr><literal type="string">"filter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_filter_map"</literal></expr></argument>, <argument><expr><literal type="string">"filter_map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_reject"</literal></expr></argument>, <argument><expr><literal type="string">"reject"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_grep"</literal></expr></argument>, <argument><expr><literal type="string">"grep"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_grep_v"</literal></expr></argument>, <argument><expr><literal type="string">"grep_v"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_zip"</literal></expr></argument>, <argument><expr><literal type="string">"zip"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_take"</literal></expr></argument>, <argument><expr><literal type="string">"take"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_take_while"</literal></expr></argument>, <argument><expr><literal type="string">"take_while"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_drop"</literal></expr></argument>, <argument><expr><literal type="string">"drop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_drop_while"</literal></expr></argument>, <argument><expr><literal type="string">"drop_while"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_uniq"</literal></expr></argument>, <argument><expr><literal type="string">"uniq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_private_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"_enumerable_with_index"</literal></expr></argument>, <argument><expr><name>enumerator_with_index</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_map"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_collect"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_flat_map"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_collect_concat"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_select"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_find_all"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_filter"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_filter_map"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_reject"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_grep"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_grep_v"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_zip"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_take"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_take_while"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_drop"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_drop_while"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><name>id_private</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_uniq"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>lazy_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"to_enum"</literal></expr></argument>, <argument><expr><name>lazy_to_enum</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"enum_for"</literal></expr></argument>, <argument><expr><name>lazy_to_enum</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"eager"</literal></expr></argument>, <argument><expr><name>lazy_eager</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"map"</literal></expr></argument>, <argument><expr><name>lazy_map</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"collect"</literal></expr></argument>, <argument><expr><name>lazy_map</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"flat_map"</literal></expr></argument>, <argument><expr><name>lazy_flat_map</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"collect_concat"</literal></expr></argument>, <argument><expr><name>lazy_flat_map</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>, <argument><expr><name>lazy_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"find_all"</literal></expr></argument>, <argument><expr><name>lazy_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"filter"</literal></expr></argument>, <argument><expr><name>lazy_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"filter_map"</literal></expr></argument>, <argument><expr><name>lazy_filter_map</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"reject"</literal></expr></argument>, <argument><expr><name>lazy_reject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"grep"</literal></expr></argument>, <argument><expr><name>lazy_grep</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"grep_v"</literal></expr></argument>, <argument><expr><name>lazy_grep_v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"zip"</literal></expr></argument>, <argument><expr><name>lazy_zip</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"take"</literal></expr></argument>, <argument><expr><name>lazy_take</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"take_while"</literal></expr></argument>, <argument><expr><name>lazy_take_while</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"drop"</literal></expr></argument>, <argument><expr><name>lazy_drop</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"drop_while"</literal></expr></argument>, <argument><expr><name>lazy_drop_while</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"lazy"</literal></expr></argument>, <argument><expr><name>lazy_lazy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"chunk"</literal></expr></argument>, <argument><expr><name>lazy_super</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"slice_before"</literal></expr></argument>, <argument><expr><name>lazy_super</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"slice_after"</literal></expr></argument>, <argument><expr><name>lazy_super</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"slice_when"</literal></expr></argument>, <argument><expr><name>lazy_super</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"chunk_while"</literal></expr></argument>, <argument><expr><name>lazy_super</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"uniq"</literal></expr></argument>, <argument><expr><name>lazy_uniq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"with_index"</literal></expr></argument>, <argument><expr><name>lazy_with_index</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lazy_use_super_method</name> <operator>=</operator> <call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"map"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_map"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"collect"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_collect"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"flat_map"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_flat_map"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"collect_concat"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_collect_concat"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"select"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_select"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"find_all"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_find_all"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"filter"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_filter"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"filter_map"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_filter_map"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"reject"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_reject"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"grep"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_grep"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"grep_v"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_grep_v"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"zip"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_zip"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"take"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_take"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"take_while"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_take_while"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"drop"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_drop"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"drop_while"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_drop_while"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"uniq"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_uniq"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"with_index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"_enumerable_with_index"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>lazy_use_super_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

rb_define_method(rb_cLazy, "to_a", lazy_to_a, 0);

rb_define_method(rb_cLazy, "chunk", lazy_chunk, 0);

rb_define_method(rb_cLazy, "chunk_while", lazy_chunk_while, 0);

rb_define_method(rb_cLazy, "slice_after", lazy_slice_after, 0);

rb_define_method(rb_cLazy, "slice_before", lazy_slice_before, 0);

rb_define_method(rb_cLazy, "slice_when", lazy_slice_when, 0);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cLazy</name></expr></argument>, <argument><expr><literal type="string">"force"</literal></expr></argument>, <argument><expr><literal type="string">"to_a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eStopIteration</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"StopIteration"</literal></expr></argument>, <argument><expr><name>rb_eIndexError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eStopIteration</name></expr></argument>, <argument><expr><literal type="string">"result"</literal></expr></argument>, <argument><expr><name>stop_result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cGenerator</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"Generator"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cGenerator</name></expr></argument>, <argument><expr><name>rb_mEnumerable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cGenerator</name></expr></argument>, <argument><expr><name>generator_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cGenerator</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>generator_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cGenerator</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>, <argument><expr><name>generator_init_copy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cGenerator</name></expr></argument>, <argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>generator_each</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cYielder</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"Yielder"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cYielder</name></expr></argument>, <argument><expr><name>yielder_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cYielder</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>yielder_initialize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cYielder</name></expr></argument>, <argument><expr><literal type="string">"yield"</literal></expr></argument>, <argument><expr><name>yielder_yield</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cYielder</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>, <argument><expr><name>yielder_yield_push</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cYielder</name></expr></argument>, <argument><expr><literal type="string">"to_proc"</literal></expr></argument>, <argument><expr><name>yielder_to_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cEnumProducer</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"Producer"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cEnumProducer</name></expr></argument>, <argument><expr><name>producer_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumProducer</name></expr></argument>, <argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>producer_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"produce"</literal></expr></argument>, <argument><expr><name>enumerator_s_produce</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cEnumChain</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"Chain"</literal></expr></argument>, <argument><expr><name>rb_cEnumerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cEnumChain</name></expr></argument>, <argument><expr><name>enum_chain_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumChain</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>enum_chain_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumChain</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>, <argument><expr><name>enum_chain_init_copy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumChain</name></expr></argument>, <argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>enum_chain_each</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumChain</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>enum_chain_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumChain</name></expr></argument>, <argument><expr><literal type="string">"rewind"</literal></expr></argument>, <argument><expr><name>enum_chain_rewind</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEnumChain</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>enum_chain_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cArithSeq</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEnumerator</name></expr></argument>, <argument><expr><literal type="string">"ArithmeticSequence"</literal></expr></argument>, <argument><expr><name>rb_cEnumerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_alloc_func</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"begin"</literal></expr></argument>, <argument><expr><name>arith_seq_begin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"end"</literal></expr></argument>, <argument><expr><name>arith_seq_end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"exclude_end?"</literal></expr></argument>, <argument><expr><name>arith_seq_exclude_end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"step"</literal></expr></argument>, <argument><expr><name>arith_seq_step</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"first"</literal></expr></argument>, <argument><expr><name>arith_seq_first</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"last"</literal></expr></argument>, <argument><expr><name>arith_seq_last</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>arith_seq_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>arith_seq_eq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"==="</literal></expr></argument>, <argument><expr><name>arith_seq_eq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"eql?"</literal></expr></argument>, <argument><expr><name>arith_seq_eq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>arith_seq_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>arith_seq_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArithSeq</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>arith_seq_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_provide</name><argument_list>(<argument><expr><literal type="string">"enumerator.so"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>

<function><type><name>void</name></type>

<name>Init_Enumerator</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>id_rewind</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"rewind"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_new</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_next</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"next"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_result</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_receiver</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"receiver"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_arguments</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_memo</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"memo"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_method</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"method"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_force</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"force"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_to_enum</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"to_enum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_begin</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"begin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_end</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_step</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"step"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_exclude_end</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"exclude_end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_each</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><name>id_each</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_cycle</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"cycle"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sym_yield</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"yield"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>InitVM</name><argument_list>(<argument><expr><name>Enumerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
