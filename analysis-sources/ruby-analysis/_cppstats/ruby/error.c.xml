<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats\ruby\error.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__APPLE__</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;AvailabilityMacros.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/eval.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/load.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/symbol.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/thread.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/variable.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/st.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_assert.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXIT_SUCCESS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIFEXITED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIFEXITED</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WEXITSTATUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WEXITSTATUS</name><parameter_list>(<parameter><type><name>status</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(status)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><name>VALUE</name></type> <name>rb_iseqw_local_variables</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>iseqval</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VALUE</name></type> <name>rb_iseqw_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_iseq_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>rb_str_end_with_asciichar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eEAGAIN</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eEWOULDBLOCK</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eEINPROGRESS</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_mWarning</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_cWarningBuffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_warn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ruby_description</name><index>[]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_strerrno</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>defined_error</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (err == (num)) return (name);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>undefined_error</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"known_errors.inc"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>defined_error</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>undefined_error</name></cpp:undef>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>err_position_0</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>line</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else <block>{<block_content>

<return>return <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: "</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>err_vcatf</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pre</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>file</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">":%d"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pre</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_vcatf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_syntax_error_append</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>column</name></decl></parameter>,

<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn</name> <init>= <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exc</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name> <init>= <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>err_vcatf</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_write_error_str</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_enc_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mesg</name></expr></argument>, <argument><expr><name>rb_eSyntaxError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>idMesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>err_vcatf</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>warning_disabled_categories</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>

<name>rb_warning_category_mask</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>category</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <call><name>rb_warning_category_from_name</name><argument_list>(<argument><expr><name>category</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>rb_warning_category_t</name></type>

<name>rb_warning_category_from_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>category</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_warning_category_t</name></type> <name>cat</name> <init>= <expr><name>RB_WARN_CATEGORY_NONE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>category</name></expr></argument>, <argument><expr><name>T_SYMBOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>category</name> <operator>==</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"deprecated"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cat</name> <operator>=</operator> <name>RB_WARN_CATEGORY_DEPRECATED</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>category</name> <operator>==</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"experimental"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cat</name> <operator>=</operator> <name>RB_WARN_CATEGORY_EXPERIMENTAL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unknown category: %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>category</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>cat</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_warning_category_update</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>warning_disabled_categories</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><name>warning_disabled_categories</name> <operator>|=</operator> <name>mask</name> <operator>&amp;</operator> <operator>~</operator><name>bits</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>bool</name></type>

<name>rb_warning_category_enabled_p</name><parameter_list>(<parameter><decl><type><name>rb_warning_category_t</name></type> <name>category</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>!</operator><operator>(</operator><name>warning_disabled_categories</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>category</name><operator>)</operator><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_warning_s_aref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>category</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>rb_warning_category_t</name></type> <name>cat</name> <init>= <expr><call><name>rb_warning_category_from_name</name><argument_list>(<argument><expr><name>category</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_warning_category_enabled_p</name><argument_list>(<argument><expr><name>cat</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_warning_s_aset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>category</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flag</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mask</name> <init>= <expr><call><name>rb_warning_category_mask</name><argument_list>(<argument><expr><name>category</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>disabled</name> <init>= <expr><name>warning_disabled_categories</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>disabled</name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>disabled</name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>warning_disabled_categories</name> <operator>=</operator> <name>disabled</name></expr>;</expr_stmt>

<return>return <expr><name>flag</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_warning_s_warn</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_write_error_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_warning_warn</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id_warn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>rb_write_warning_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warning_warn</name><argument_list>(<argument><expr><name>rb_mWarning</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>warn_vsprintf</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>err_vcatf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"warning: "</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_compile_warn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>warn_vsprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_write_warning_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_compile_warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>warn_vsprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_write_warning_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>warning_string</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>rb_source_location_cstr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>warn_vsprintf</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>with_warning_string</name><parameter_list>(<parameter><type><name>mesg</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>, <parameter><type><name>fmt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>VALUE mesg; va_list args; va_start(args, fmt); mesg = warning_string(enc, fmt, args); va_end(args);</cpp:value></cpp:define>

<function><type><name>void</name></type>

<name>rb_warn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<macro><name>with_warning_string</name><argument_list>(<argument>mesg</argument>, <argument><literal type="number">0</literal></argument>, <argument>fmt</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>rb_write_warning_str</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_enc_warn</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<macro><name>with_warning_string</name><argument_list>(<argument>mesg</argument>, <argument>enc</argument>, <argument>fmt</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>rb_write_warning_str</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<macro><name>with_warning_string</name><argument_list>(<argument>mesg</argument>, <argument><literal type="number">0</literal></argument>, <argument>fmt</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>rb_write_warning_str</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_warning_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<macro><name>with_warning_string</name><argument_list>(<argument>mesg</argument>, <argument><literal type="number">0</literal></argument>, <argument>fmt</argument>)</argument_list></macro> <block>{<block_content>

</block_content>}</block>

<return>return <expr><name>mesg</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

void

rb_enc_warning(rb_encoding *enc, const char *fmt, ...)

{

if (RTEST(ruby_verbose)) {

with_warning_string(mesg, enc, fmt) {

rb_write_warning_str(mesg);

}

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_warn_deprecated</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suggest</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_warning_category_enabled_p</name><argument_list>(<argument><expr><name>RB_WARN_CATEGORY_DEPRECATED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>suggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name> <init>= <expr><call><name>warning_string</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">" is deprecated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>suggest</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"; use %s instead"</literal></expr></argument>, <argument><expr><name>suggest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_write_warning_str</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_warn_deprecated_to_remove</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>removal</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_warning_category_enabled_p</name><argument_list>(<argument><expr><name>RB_WARN_CATEGORY_DEPRECATED</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>removal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name> <init>= <expr><call><name>warning_string</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">" is deprecated and will be removed in Ruby %s\n"</literal></expr></argument>, <argument><expr><name>removal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_write_warning_str</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>

<name>end_with_asciichar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<call><name>rb_str_end_with_asciichar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>warning_write</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>argc</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><name>VALUE</name></type> <name>rb_ec_backtrace_location_ary</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>lev</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_warn_m</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>msgs</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>uplevel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>location</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><call><name>RARRAY_LENINT</name><argument_list>(<argument><expr><name>msgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>msgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>uplevel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>lev</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>uplevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lev</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative level (%ld)"</literal></expr></argument>, <argument><expr><name>lev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>rb_ec_backtrace_location_ary</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>lev</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>uplevel</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>end_with_asciichar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>uplevel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_tmp_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>||</operator>

<call><name>NIL_P</name><argument_list>(<argument><expr><name>path</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"path"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><literal type="string">"warning: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"%s:%ld: warning: "</literal></expr></argument>,

<argument><expr><call><name>rb_string_value_ptr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"lineno"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>rb_cWarningBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_io_puts</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>rb_cString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exc</name> <operator>==</operator> <name>rb_mWarning</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_write_error_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_write_warning_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BUG_REPORTERS</name></cpp:macro> <cpp:value>0x100</cpp:value></cpp:define>

<struct><specifier>static</specifier> struct <name>bug_reporters</name> <block>{

<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

}</block> <decl><name><name>bug_reporters</name><index>[<expr><name>MAX_BUG_REPORTERS</name></expr>]</index></name></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bug_reporters_size</name></decl>;</decl_stmt>

<function><type><name>int</name></type>

<name>rb_bug_reporter_add</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>bug_reporters</name></name> <modifier>*</modifier></type><name>reporter</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bug_reporters_size</name> <operator>&gt;=</operator> <name>MAX_BUG_REPORTERS</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>reporter</name> <operator>=</operator> <operator>&amp;</operator><name><name>bug_reporters</name><index>[<expr><name>bug_reporters_size</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>reporter</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>reporter</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPORT_BUG_BUFSIZ</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>

<name>bug_report_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>REPORT_BUG_BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>stderr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>err_position_0</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name>len</name> <operator>||</operator>

<operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>fwrite</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>out</name> <operator>=</operator> <name>stdout</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name>len</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>out</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<macro><name>FUNC_MINIMIZED</name><argument_list>(<argument>static void bug_important_message(FILE *out, const char *const msg, size_t len)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>bug_important_message</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>msg</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>endmsg</name> <init>= <expr><name>msg</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>msg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>red</name><index>[]</index></name> <init>= <expr><literal type="string">"\033[;31;1;7m"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>green</name><index>[]</index></name> <init>= <expr><literal type="string">"\033[;32;7m"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>reset</name><index>[]</index></name> <init>= <expr><literal type="string">"\033[m"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>w</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr> ?</condition><then> <expr><name>green</name></expr> </then><else>: <expr><name>red</name></expr></else></ternary></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <name>p</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>w</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>reset</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <name>e</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>endmsg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>e</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>e</name> <operator>&gt;</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>endmsg</name> <operator>-</operator> <name>p</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>preface_dump</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__APPLE__</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>msg</name><index>[]</index></name> <init>= <expr><literal type="string">""</literal>

<literal type="string">"-- Crash Report log information "</literal>

<literal type="string">"--------------------------------------------\n"</literal>

<literal type="string">" See Crash Report log file under the one of following:\n"</literal>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAC_OS_X_VERSION_MIN_REQUIRED</name> <operator>&lt;</operator> <name>MAC_OS_X_VERSION_10_6</name></expr></cpp:if>

<literal type="string">" * ~/Library/Logs/CrashReporter\n"</literal>

<literal type="string">" * /Library/Logs/CrashReporter\n"</literal>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<literal type="string">" * ~/Library/Logs/DiagnosticReports\n"</literal>

<literal type="string">" * /Library/Logs/DiagnosticReports\n"</literal>

<literal type="string">" for more details.\n"</literal>

<literal type="string">"Don't forget to include the above Crash Report log file in bug reports.\n"</literal>

<literal type="string">"\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>msglen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>msglen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>bug_important_message</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>postscript_dump</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__APPLE__</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>msg</name><index>[]</index></name> <init>= <expr><literal type="string">""</literal>

<literal type="string">"[IMPORTANT]"</literal>

<literal type="string">"\n""</literal><name>Don</name><literal type="char">'t forget to include the Crash Report log file under\n"

#if MAC_OS_X_VERSION_MIN_REQUIRED &lt; MAC_OS_X_VERSION_10_6

"CrashReporter or "

#endif

"DiagnosticReports directory in bug reports.\n"

/*"------------------------------------------------------------\n"*/

"\n";

const size_t msglen = sizeof(msg) - 1;

#else

const char *msg = NULL;

const size_t msglen = 0;

#endif

bug_important_message(out, msg, msglen);

}

static void

bug_report_begin_valist(FILE *out, const char *fmt, va_list args)

{

char buf[REPORT_BUG_BUFSIZ];

fputs("[BUG] ", out);

vsnprintf(buf, sizeof(buf), fmt, args);

fputs(buf, out);

snprintf(buf, sizeof(buf), "\n%s\n\n", ruby_description);

fputs(buf, out);

preface_dump(out);

}

#define bug_report_begin(out, fmt) do { va_list args; va_start(args, fmt); bug_report_begin_valist(out, fmt, args); va_end(args); } while (0)

static void

bug_report_end(FILE *out)

{

/* call additional bug reporters */

{

int i;

for (i=0; i&lt;bug_reporters_size; i++) {

struct bug_reporters *reporter = &amp;bug_reporters[i];

(*reporter-&gt;func)(out, reporter-&gt;data);

}

}

postscript_dump(out);

}

#define report_bug(file, line, fmt, ctx) do { FILE *out = bug_report_file(file, line); if (out) { bug_report_begin(out, fmt); rb_vm_bugreport(ctx); bug_report_end(out); } } while (0) 

#define report_bug_valist(file, line, fmt, ctx, args) do { FILE *out = bug_report_file(file, line); if (out) { bug_report_begin_valist(out, fmt, args); rb_vm_bugreport(ctx); bug_report_end(out); } } while (0) 

NORETURN(static void die(void));

static void

die(void)

{

#if defined(_WIN32) &amp;&amp; defined(RUBY_MSVCRT_VERSION) &amp;&amp; RUBY_MSVCRT_VERSION &gt;= 80

_set_abort_behavior( 0, _CALL_REPORTFAULT);

#endif

abort();

}

void

rb_bug(const char *fmt, ...)

{

const char *file = NULL;

int line = 0;

if (GET_EC()) {

file = rb_source_location_cstr(&amp;line);

}

report_bug(file, line, fmt, NULL);

die();

}

void

rb_bug_for_fatal_signal(ruby_sighandler_t default_sighandler, int sig, const void *ctx, const char *fmt, ...)

{

const char *file = NULL;

int line = 0;

if (GET_EC()) {

file = rb_source_location_cstr(&amp;line);

}

report_bug(file, line, fmt, ctx);

if (default_sighandler) default_sighandler(sig);

die();

}

void

rb_bug_errno(const char *mesg, int errno_arg)

{

if (errno_arg == 0)

rb_bug("%s: errno == 0 (NOERROR)", mesg);

else {

const char *errno_str = rb_strerrno(errno_arg);

if (errno_str)

rb_bug("%s: %s (%s)", mesg, strerror(errno_arg), errno_str);

else

rb_bug("%s: %s (%d)", mesg, strerror(errno_arg), errno_arg);

}

}

/*

* this is safe to call inside signal handler and timer thread

* (which isn'</literal><name>t</name> <name>a</name> <name>Ruby</name> <name>Thread</name> <name>object</name></expr>)</init>

<modifier>*</modifier>/

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>write_or_abort</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>, <parameter><type><name>str</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(write((fd), (str), (len)) &lt; 0 ? abort() : (void)0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_CONST</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>,<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>write_or_abort((fd),(str),sizeof(str) - 1)</cpp:value></cpp:define>

<name>void</name>

<name>rb_async_bug_errno</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>mesg</name></expr></argument>, <argument><expr><name>int</name> <name>errno_arg</name></expr></argument>)</argument_list>

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_CONST</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"[ASYNC BUG] "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_or_abort</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_CONST</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>errno_arg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>WRITE_CONST</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"errno == 0 (NOERROR)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errno_str</name> <init>= <expr><call><name>rb_strerrno</name><argument_list>(<argument><expr><name>errno_arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errno_str</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>errno_str</name> <operator>=</operator> <literal type="string">"undefined errno"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>write_or_abort</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>errno_str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>errno_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>WRITE_CONST</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_or_abort</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ruby_description</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ruby_description</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type>

<name>rb_report_bug_valist</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>report_bug_valist</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>

<name>rb_assert_failure</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>stderr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"Assertion Failed: %s:%d:"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"%s\n%s\n\n"</literal></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ruby_description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>preface_dump</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vm_bugreport</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bug_report_end</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>builtin_types</name><index>[]</index><index>[<expr><literal type="number">10</literal></expr>]</index></name> <init>= <expr><block>{

<expr><literal type="string">""</literal></expr>, 

<expr><literal type="string">"Object"</literal></expr>,

<expr><literal type="string">"Class"</literal></expr>,

<expr><literal type="string">"Module"</literal></expr>,

<expr><literal type="string">"Float"</literal></expr>,

<expr><literal type="string">"String"</literal></expr>,

<expr><literal type="string">"Regexp"</literal></expr>,

<expr><literal type="string">"Array"</literal></expr>,

<expr><literal type="string">"Hash"</literal></expr>,

<expr><literal type="string">"Struct"</literal></expr>,

<expr><literal type="string">"Bignum"</literal></expr>,

<expr><literal type="string">"File"</literal></expr>,

<expr><literal type="string">"Data"</literal></expr>, 

<expr><literal type="string">"MatchData"</literal></expr>, 

<expr><literal type="string">"Complex"</literal></expr>,

<expr><literal type="string">"Rational"</literal></expr>,

<expr><literal type="string">""</literal></expr>, 

<expr><literal type="string">"nil"</literal></expr>,

<expr><literal type="string">"true"</literal></expr>,

<expr><literal type="string">"false"</literal></expr>,

<expr><literal type="string">"Symbol"</literal></expr>, 

<expr><literal type="string">"Fixnum"</literal></expr>,

<expr><literal type="string">"undef"</literal></expr>, 

<expr><literal type="string">""</literal></expr>, 

<expr><literal type="string">""</literal></expr>, 

<expr><literal type="string">""</literal></expr>, 

<expr><literal type="string">"Memo"</literal></expr>, 

<expr><literal type="string">"Node"</literal></expr>, 

<expr><literal type="string">"iClass"</literal></expr>, 

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_builtin_type_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>t</name> <operator>&gt;=</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>builtin_types</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>builtin_types</name><index>[<expr><name>t</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>name</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>builtin_class_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>etype</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>etype</name> <operator>=</operator> <literal type="string">"nil"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>etype</name> <operator>=</operator> <literal type="string">"Integer"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>etype</name> <operator>=</operator> <literal type="string">"Symbol"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>T_TRUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>etype</name> <operator>=</operator> <literal type="string">"true"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>T_FALSE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>etype</name> <operator>=</operator> <literal type="string">"false"</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>etype</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>etype</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>rb_builtin_class_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>etype</name> <init>= <expr><call><name>builtin_class_name</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>etype</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>etype</name> <operator>=</operator> <call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>etype</name></expr>;</return>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void unexpected_type(VALUE, int, int)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDEF_LEAKED</name></cpp:macro> <cpp:value>"undef leaked to the Ruby space"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>unexpected_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tname</name> <init>= <expr><call><name>rb_builtin_type_name</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>, <decl><type ref="prev"/><name>exc</name> <init>= <expr><name>rb_eFatal</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tname</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cname</name> <init>= <expr><call><name>builtin_class_name</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cname</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"wrong argument type %s (expected %s)"</literal></expr></argument>,

<argument><expr><name>cname</name></expr></argument>, <argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"wrong argument type %"</literal><name>PRIsVALUE</name><literal type="string">" (expected %s)"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <name>rb_eTypeError</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>xt</name> <operator>&gt;</operator> <name>T_MASK</name> <operator>&amp;&amp;</operator> <name>xt</name> <operator>&lt;=</operator> <literal type="number">0x3f</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"unknown type 0x%x (0x%x given, probably comes"</literal>

<literal type="string">" from extension library for ruby 1.8)"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>xt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"unknown type 0x%x (0x%x given)"</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>xt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_exc_new_str</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_check_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>xt</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><name>UNDEF_LEAKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>xt</name> <operator>=</operator> <call><name>TYPE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xt</name> <operator>!=</operator> <name>t</name> <operator>||</operator> <operator>(</operator><name>xt</name> <operator>==</operator> <name>T_DATA</name> <operator>&amp;&amp;</operator> <call><name>RTYPEDDATA_P</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>unexpected_type</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_unexpected_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><name>UNDEF_LEAKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>unexpected_type</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call><name>TYPE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_typeddata_inherited_p</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_data_type_t</name> <modifier>*</modifier></type><name>child</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_data_type_t</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>child</name> <operator>==</operator> <name>parent</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>child</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>rb_typeddata_is_kind_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_data_type_t</name> <modifier>*</modifier></type><name>data_type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_DATA</name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>RTYPEDDATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>rb_typeddata_inherited_p</name><argument_list>(<argument><expr><call><name>RTYPEDDATA_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_typeddata_is_instance_of</name></cpp:undef>

<function><type><name>int</name></type>

<name>rb_typeddata_is_instance_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_data_type_t</name> <modifier>*</modifier></type><name>data_type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_typeddata_is_instance_of_inline</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>data_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>rb_check_typeddata</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>rb_data_type_t</name> <modifier>*</modifier></type><name>data_type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>etype</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_DATA</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<label><name>wrong_type</name>:</label>

<expr_stmt><expr><name>etype</name> <operator>=</operator> <call><name>builtin_class_name</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>etype</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"wrong argument type %"</literal><name>PRIsVALUE</name><literal type="string">" (expected %s)"</literal></expr></argument>,

<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>data_type</name><operator>-&gt;</operator><name>wrap_struct_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>wrong_datatype</name>:</label>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"wrong argument type %s (expected %s)"</literal></expr></argument>,

<argument><expr><name>etype</name></expr></argument>, <argument><expr><name><name>data_type</name><operator>-&gt;</operator><name>wrap_struct_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTYPEDDATA_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>wrong_type</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_typeddata_inherited_p</name><argument_list>(<argument><expr><call><name>RTYPEDDATA_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>etype</name> <operator>=</operator> <call><name>RTYPEDDATA_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>wrap_struct_name</name></expr>;</expr_stmt>

<goto>goto <name>wrong_datatype</name>;</goto>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eException</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eSystemExit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eInterrupt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eSignal</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eFatal</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eStandardError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eRuntimeError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eFrozenError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eTypeError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eArgError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eIndexError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eKeyError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eRangeError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eNameError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eEncodingError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eEncCompatError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eNoMethodError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eSecurityError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eNotImpError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eNoMemError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cNameErrorMesg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eNoMatchingPatternError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eScriptError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eSyntaxError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eLoadError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_eSystemCallError</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_mErrno</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_eNOERROR</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ID</name></type> <name>ruby_static_id_cause</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_cause</name></cpp:macro> <cpp:value>ruby_static_id_cause</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_message</name></decl>, <decl><type ref="prev"/><name>id_backtrace</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_key</name></decl>, <decl><type ref="prev"/><name>id_args</name></decl>, <decl><type ref="prev"/><name>id_Errno</name></decl>, <decl><type ref="prev"/><name>id_errno</name></decl>, <decl><type ref="prev"/><name>id_i_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_receiver</name></decl>, <decl><type ref="prev"/><name>id_recv</name></decl>, <decl><type ref="prev"/><name>id_iseq</name></decl>, <decl><type ref="prev"/><name>id_local_variables</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_private_call_p</name></decl>, <decl><type ref="prev"/><name>id_top</name></decl>, <decl><type ref="prev"/><name>id_bottom</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_bt</name></cpp:macro> <cpp:value>idBt</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_bt_locations</name></cpp:macro> <cpp:value>idBt_locations</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_mesg</name></cpp:macro> <cpp:value>idMesg</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_name</name></cpp:macro> <cpp:value>idName</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_exc_new_cstr</name></cpp:undef>

<function><type><name>VALUE</name></type>

<name>rb_exc_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>etype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name> <init>= <expr><call><name>rb_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mesg</name></expr></argument>, <argument><expr><name>etype</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_exc_new_cstr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>etype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_exc_new</name><argument_list>(<argument><expr><name>etype</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_exc_new_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>etype</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>etype</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_mesg</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_bt</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>!</operator><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><call><name>exc_init</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_exception</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>self</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>self</name> <operator>==</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>self</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>rb_obj_clone</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_mesg</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name> <init>= <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>idMesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_class_name</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_String</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>rb_error_write</name><argument_list>(<argument><expr><name>VALUE</name> <name>errinfo</name></expr></argument>, <argument><expr><name>VALUE</name> <name>emesg</name></expr></argument>, <argument><expr><name>VALUE</name> <name>errat</name></expr></argument>, <argument><expr><name>VALUE</name> <name>str</name></expr></argument>, <argument><expr><name>VALUE</name> <name>highlight</name></expr></argument>, <argument><expr><name>VALUE</name> <name>reverse</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>VALUE</name></type>

<name>rb_get_message</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>rb_check_funcall</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>e</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_s_to_tty_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>rb_stderr_tty_p</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_full_message</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>opt</name></decl>, <decl><type ref="prev"/><name>str</name></decl>, <decl><type ref="prev"/><name>emesg</name></decl>, <decl><type ref="prev"/><name>errat</name></decl>;</decl_stmt>

<enum>enum <block>{<decl><name>kw_highlight</name></decl>, <decl><name>kw_order</name></decl>, <decl><name>kw_max_</name></decl>}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name><name>kw</name><index>[<expr><name>kw_max_</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><name>kw_max_</name></expr>]</index></name> <init>= <expr><block>{<expr><name>Qnil</name></expr>, <expr><name>Qnil</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"0:"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>kw</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_KW</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kw[kw_##n] = rb_intern_const(#n)</cpp:value></cpp:define>

<expr_stmt><expr><call><name>INIT_KW</name><argument_list>(<argument><expr><name>highlight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INIT_KW</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INIT_KW</name></cpp:undef>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>kw_max_</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>args</name><index>[<expr><name>kw_highlight</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<default>default:</default>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"expected true or false as "</literal>

<literal type="string">"highlight: %+"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>kw_highlight</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Qundef</name></expr>:</case> <expr_stmt><expr><name><name>args</name><index>[<expr><name>kw_highlight</name></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>Qtrue</name></expr>:</case> <case>case <expr><name>Qfalse</name></expr>:</case> <case>case <expr><name>Qnil</name></expr>:</case> <break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><name>kw_order</name></expr>]</index></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>args</name><index>[<expr><name>kw_order</name></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>args</name><index>[<expr><name>kw_order</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>id_bottom</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>args</name><index>[<expr><name>kw_order</name></expr>]</index></name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>id</name> <operator>==</operator> <name>id_top</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>args</name><index>[<expr><name>kw_order</name></expr>]</index></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"expected :top or :bottom as "</literal>

<literal type="string">"order: %+"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>kw_order</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>errat</name> <operator>=</operator> <call><name>rb_get_backtrace</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>emesg</name> <operator>=</operator> <call><name>rb_get_message</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_error_write</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>emesg</name></expr></argument>, <argument><expr><name>errat</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>kw_highlight</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><name>kw_order</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_message</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>idTo_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>, <decl><type ref="prev"/><name>klass</name></decl>;</decl_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>CLASS_OF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>rb_class_name</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_buf_new2</name><argument_list>(<argument><expr><literal type="string">"#&lt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>rb_class_name</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_backtrace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_bt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_backtrace_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_backtrace_to_str_ary</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_check_backtrace</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>VALUE</name></type>

<name>rb_get_backtrace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name>mid</name> <init>= <expr><name>id_backtrace</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>info</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_method_basic_definition_p</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id_backtrace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><name>rb_eException</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_C_CALL</name></expr></argument>, <argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>exc_backtrace</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>EXEC_EVENT_HOOK</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>RUBY_EVENT_C_RETURN</name></expr></argument>, <argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_check_backtrace</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_backtrace_locations</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_bt_locations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_backtrace_to_location_ary</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_check_backtrace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>bt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>err</name><index>[]</index></name> <init>= <expr><literal type="string">"backtrace must be Array of String"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>bt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>bt</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bt</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_backtrace_p</name><argument_list>(<argument><expr><name>bt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>bt</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>bt</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init><condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>bt</name></expr></argument>)</argument_list></call></expr>;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>bt</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>bt</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_set_backtrace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>bt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_bt</name></expr></argument>, <argument><expr><call><name>rb_check_backtrace</name><argument_list>(<argument><expr><name>bt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>

<name>rb_exc_set_backtrace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>bt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>exc_set_backtrace</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>bt</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_cause</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_cause</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>try_convert_to_exception</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_check_funcall</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>idException</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exc_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>, <decl><type ref="prev"/><name>backtrace</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>exc</name> <operator>==</operator> <name>obj</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_protect</name><argument_list>(<argument><expr><name>try_convert_to_exception</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>||</operator> <name>obj</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_set_errinfo</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_check_funcall</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mesg</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>backtrace</name> <operator>=</operator> <call><name>rb_check_funcall</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_backtrace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>backtrace</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>backtrace</name> <operator>=</operator> <call><name>exc_backtrace</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_equal</name><argument_list>(<argument><expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_mesg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_equal</name><argument_list>(<argument><expr><call><name>exc_backtrace</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>backtrace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exit_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>status</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>*</operator><name>argv</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>status</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Qtrue</name></expr>:</case>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>argv</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>Qfalse</name></expr>:</case>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>argv</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>rb_check_to_int</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXIT_SUCCESS</name> <operator>!=</operator> <literal type="number">0</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>++</operator><name>argv</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>argc</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_call_super</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_status</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exit_status</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_status</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>exit_success_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>status_val</name> <init>= <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_status</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>status_val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>status_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EXIT_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>err_init_recv</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>recv</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_recv</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>frozen_err_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>values</name><index>[<expr><call><name>numberof</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>, <decl><type ref="prev"/><name>options</name></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"*:"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>id_receiver</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_call_super</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>err_init_recv</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>frozen_err_receiver</name></cpp:macro> <cpp:value>name_err_receiver</cpp:value></cpp:define>

<function><type><name>void</name></type>

<name>rb_name_error</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>, <decl><type ref="prev"/><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_vsprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rb_eNameError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_name_error_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>, <decl><type ref="prev"/><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_vsprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rb_eNameError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_init_attr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_control_frame_t</name> <modifier>*</modifier></type><name>cfp</name> <init>= <expr><call><name>RUBY_VM_PREVIOUS_CONTROL_FRAME</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>cfp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cfp</name> <operator>=</operator> <call><name>rb_vm_get_ruby_level_next_cfp</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_name</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>err_init_recv</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cfp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_iseq</name></expr></argument>, <argument><expr><call><name>rb_iseqw_new</name><argument_list>(<argument><expr><name><name>cfp</name><operator>-&gt;</operator><name>iseq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>values</name><index>[<expr><call><name>numberof</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>, <decl><type ref="prev"/><name>name</name></decl>, <decl><type ref="prev"/><name>options</name></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"*:"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>id_receiver</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><operator>--</operator><name>argc</name></expr>]</index></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_call_super</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>name_err_init_attr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_name_err_mesg_new</name><argument_list>(<argument><expr><name>VALUE</name> <name>mesg</name></expr></argument>, <argument><expr><name>VALUE</name> <name>recv</name></expr></argument>, <argument><expr><name>VALUE</name> <name>method</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_init</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>exc_init</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_name_err_mesg_new</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>name_err_init_attr</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_name_err_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_obj_alloc</name><argument_list>(<argument><expr><name>rb_eNameError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>name_err_init</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_name</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_local_variables</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>vars</name> <init>= <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_local_variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>iseqw</name> <init>= <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_iseq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>iseqw</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>rb_iseqw_local_variables</name><argument_list>(<argument><expr><name>iseqw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_local_variables</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>vars</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>nometh_err_init_attr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>priv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_args</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_private_call_p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>priv</name></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>nometh_err_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>priv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>args</name></decl>, <decl><type ref="prev"/><name>options</name></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"*:"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>priv</name> <operator>=</operator> <operator>(</operator><name>argc</name> <operator>&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>--</operator><name>argc</name><operator>,</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><operator>--</operator><name>argc</name></expr>]</index></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_call_super_kw</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>RB_PASS_CALLED_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>nometh_err_init_attr</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>priv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_nomethod_err_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>priv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_obj_alloc</name><argument_list>(<argument><expr><name>rb_eNoMethodError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>name_err_init</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>, <argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>nometh_err_init_attr</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>priv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<enum>enum <block>{

<decl><name>NAME_ERR_MESG__MESG</name></decl>,

<decl><name>NAME_ERR_MESG__RECV</name></decl>,

<decl><name>NAME_ERR_MESG__NAME</name></decl>,

<decl><name>NAME_ERR_MESG_COUNT</name></decl>

}</block>;</enum>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>name_err_mesg_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_locations</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name><operator>+</operator><name>NAME_ERR_MESG_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>name_err_mesg_free</name></cpp:macro> <cpp:value>RUBY_TYPED_DEFAULT_FREE</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>size_t</name></type>

<name>name_err_mesg_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>NAME_ERR_MESG_COUNT</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>name_err_mesg_data_type</name> <init>= <expr><block>{

<expr><literal type="string">"name_err_mesg"</literal></expr>,

<expr><block>{

<expr><name>name_err_mesg_mark</name></expr>,

<expr><name>name_err_mesg_free</name></expr>,

<expr><name>name_err_mesg_memsize</name></expr>,

}</block></expr>,

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>rb_name_err_mesg_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>method</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><name>rb_cNameErrorMesg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_err_mesg_data_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>NAME_ERR_MESG_COUNT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>NAME_ERR_MESG__MESG</name></expr>]</index></name> <operator>=</operator> <name>mesg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>NAME_ERR_MESG__RECV</name></expr>]</index></name> <operator>=</operator> <name>recv</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>NAME_ERR_MESG__NAME</name></expr>]</index></name> <operator>=</operator> <name>method</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RTYPEDDATA_DATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_mesg_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj1</name> <operator>==</operator> <name>obj2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rb_cNameErrorMesg</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj1</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_err_mesg_data_type</name></expr></argument>, <argument><expr><name>ptr1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_err_mesg_data_type</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>NAME_ERR_MESG_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_equal</name><argument_list>(<argument><expr><name><name>ptr1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ptr2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>Qtrue</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_mesg_to_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"/><name>mesg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TypedData_Get_Struct</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_err_mesg_data_type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>NAME_ERR_MESG__MESG</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>RString</name></name></type> <name>s_str</name></decl>, <decl><type ref="prev"/><name>d_str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>d</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>singleton</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>usascii</name> <init>= <expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAKE_CSTR</name><parameter_list>(<parameter><type><name>v</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_setup_fake_str((v), (str), rb_strlen_lit(str), usascii)</cpp:value></cpp:define>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>NAME_ERR_MESG__RECV</name></expr>]</index></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>obj</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Qnil</name></expr>:</case>

<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>FAKE_CSTR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d_str</name></expr></argument>, <argument><expr><literal type="string">"nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>Qtrue</name></expr>:</case>

<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>FAKE_CSTR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d_str</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>Qfalse</name></expr>:</case>

<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>FAKE_CSTR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d_str</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>rb_protect</name><argument_list>(<argument><expr><name>rb_inspect</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rb_set_errinfo</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">65</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>rb_any_to_s</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>singleton</name> <operator>=</operator> <operator>(</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'#'</literal><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>singleton</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>FAKE_CSTR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s_str</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_class_name</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>s</name> <operator>=</operator> <call><name>FAKE_CSTR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s_str</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><name>NAME_ERR_MESG__NAME</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_str_format</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>mesg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_mesg_dump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>limit</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>name_err_mesg_to_str</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_mesg_load</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>name_err_receiver</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"/><name>recv</name></decl>, <decl><type ref="prev"/><name>mesg</name></decl>;</decl_stmt>

<expr_stmt><expr><name>recv</name> <operator>=</operator> <call><name>rb_ivar_lookup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_recv</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>recv</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>recv</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_typeddata_is_kind_of</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_err_mesg_data_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no receiver is available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>DATA_PTR</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>ptr</name><index>[<expr><name>NAME_ERR_MESG__RECV</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>nometh_err_args</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_args</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>nometh_err_private_call_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_private_call_p</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_invalid_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name> <init>= <expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid value for %s: %+"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>key_err_receiver</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>recv</name></decl>;</decl_stmt>

<expr_stmt><expr><name>recv</name> <operator>=</operator> <call><name>rb_ivar_lookup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_receiver</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>recv</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>recv</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no receiver is available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>key_err_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>;</decl_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>rb_ivar_lookup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_key</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>key</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"no key is available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_key_err_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_obj_alloc</name><argument_list>(<argument><expr><name>rb_eKeyError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_mesg</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_bt</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_key</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_receiver</name></expr></argument>, <argument><expr><name>recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>exc</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>key_err_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>options</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_call_super</name><argument_list>(<argument><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"01:"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ID</name></type> <name><name>keywords</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>values</name><index>[<expr><call><name>numberof</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>id_receiver</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>keywords</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>id_key</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_get_kwargs</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>numberof</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name><name>keywords</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>syntax_error_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_fstring_lit</name><argument_list>(<argument><expr><literal type="string">"compile error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>argv</name> <operator>=</operator> <operator>&amp;</operator><name>mesg</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_call_super</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>syserr_tbl</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>set_syserr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>error</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>syserr_tbl</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_mErrno</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>rb_eSystemCallError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EAGAIN</name></expr>:</case>

<expr_stmt><expr><name>rb_eEAGAIN</name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name></expr></cpp:if>

<break>break;</break>

<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>rb_eEWOULDBLOCK</name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EINPROGRESS</name></expr>:</case>

<expr_stmt><expr><name>rb_eEINPROGRESS</name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>error</name></expr></argument>, <argument><expr><literal type="string">"Errno"</literal></expr></argument>, <argument><expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name>syserr_tbl</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_mErrno</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>error</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>get_syserr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>error</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>syserr_tbl</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"E%03d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>set_syserr</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>error</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>syserr_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><name>char</name> <modifier>*</modifier></type><name>strerror</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>, <decl><type ref="prev"/><name>error</name></decl>, <decl><type ref="prev"/><name>func</name></decl>, <decl><type ref="prev"/><name>errmsg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_eSystemCallError</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>st_data_t</name></type> <name>data</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>klass</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"12"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mesg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <name>mesg</name></expr>;</expr_stmt> <expr_stmt><expr><name>mesg</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>st_lookup</name><argument_list>(<argument><expr><name>syserr_tbl</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>klass</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>T_OBJECT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"invalid instance type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"02"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mesg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id_Errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>strerror</name><argument_list>(<argument><expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="string">"unknown error"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>rb_enc_str_new_cstr</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>rb_locale_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>StringValue</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>errmsg</name></expr></argument>, <argument><expr><literal type="string">" @ %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>errmsg</name></expr></argument>, <argument><expr><literal type="string">" - %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <name>errmsg</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_call_super</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_errno</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>syserr_errno</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_attr_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_errno</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>syserr_eqq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>rb_eSystemCallError</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_respond_to</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_errno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>self</name> <operator>==</operator> <name>rb_eSystemCallError</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_errno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_const_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_Errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>num</name> <operator>==</operator> <name>e</name></expr> </then><else>: <expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_Exception</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>rb_eException</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Exception"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"exception"</literal></expr></argument>, <argument><expr><name>rb_class_new_instance</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"to_tty?"</literal></expr></argument>, <argument><expr><name>exc_s_to_tty_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"exception"</literal></expr></argument>, <argument><expr><name>exc_exception</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>exc_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>exc_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>exc_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"message"</literal></expr></argument>, <argument><expr><name>exc_message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"full_message"</literal></expr></argument>, <argument><expr><name>exc_full_message</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>exc_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"backtrace"</literal></expr></argument>, <argument><expr><name>exc_backtrace</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"backtrace_locations"</literal></expr></argument>, <argument><expr><name>exc_backtrace_locations</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"set_backtrace"</literal></expr></argument>, <argument><expr><name>exc_set_backtrace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eException</name></expr></argument>, <argument><expr><literal type="string">"cause"</literal></expr></argument>, <argument><expr><name>exc_cause</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eSystemExit</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"SystemExit"</literal></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eSystemExit</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>exit_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eSystemExit</name></expr></argument>, <argument><expr><literal type="string">"status"</literal></expr></argument>, <argument><expr><name>exit_status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eSystemExit</name></expr></argument>, <argument><expr><literal type="string">"success?"</literal></expr></argument>, <argument><expr><name>exit_success_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eFatal</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"fatal"</literal></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eSignal</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"SignalException"</literal></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eInterrupt</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Interrupt"</literal></expr></argument>, <argument><expr><name>rb_eSignal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eStandardError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"StandardError"</literal></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eTypeError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"TypeError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eArgError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"ArgumentError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eIndexError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"IndexError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eKeyError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"KeyError"</literal></expr></argument>, <argument><expr><name>rb_eIndexError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eKeyError</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>key_err_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eKeyError</name></expr></argument>, <argument><expr><literal type="string">"receiver"</literal></expr></argument>, <argument><expr><name>key_err_receiver</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eKeyError</name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>, <argument><expr><name>key_err_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eRangeError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"RangeError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eScriptError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"ScriptError"</literal></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eSyntaxError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"SyntaxError"</literal></expr></argument>, <argument><expr><name>rb_eScriptError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eSyntaxError</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>syntax_error_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eLoadError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"LoadError"</literal></expr></argument>, <argument><expr><name>rb_eScriptError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_attr</name><argument_list>(<argument><expr><name>rb_eLoadError</name></expr></argument>, <argument><expr><call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"path"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qfalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eNotImpError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"NotImplementedError"</literal></expr></argument>, <argument><expr><name>rb_eScriptError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eNameError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"NameError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eNameError</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>name_err_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eNameError</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>name_err_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eNameError</name></expr></argument>, <argument><expr><literal type="string">"receiver"</literal></expr></argument>, <argument><expr><name>name_err_receiver</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eNameError</name></expr></argument>, <argument><expr><literal type="string">"local_variables"</literal></expr></argument>, <argument><expr><name>name_err_local_variables</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cNameErrorMesg</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_eNameError</name></expr></argument>, <argument><expr><literal type="string">"message"</literal></expr></argument>, <argument><expr><name>rb_cData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cNameErrorMesg</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>name_err_mesg_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cNameErrorMesg</name></expr></argument>, <argument><expr><literal type="string">"to_str"</literal></expr></argument>, <argument><expr><name>name_err_mesg_to_str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cNameErrorMesg</name></expr></argument>, <argument><expr><literal type="string">"_dump"</literal></expr></argument>, <argument><expr><name>name_err_mesg_dump</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cNameErrorMesg</name></expr></argument>, <argument><expr><literal type="string">"_load"</literal></expr></argument>, <argument><expr><name>name_err_mesg_load</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eNoMethodError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"NoMethodError"</literal></expr></argument>, <argument><expr><name>rb_eNameError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eNoMethodError</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>nometh_err_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eNoMethodError</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>, <argument><expr><name>nometh_err_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eNoMethodError</name></expr></argument>, <argument><expr><literal type="string">"private_call?"</literal></expr></argument>, <argument><expr><name>nometh_err_private_call_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eRuntimeError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"RuntimeError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eFrozenError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"FrozenError"</literal></expr></argument>, <argument><expr><name>rb_eRuntimeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eFrozenError</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>frozen_err_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eFrozenError</name></expr></argument>, <argument><expr><literal type="string">"receiver"</literal></expr></argument>, <argument><expr><name>frozen_err_receiver</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eSecurityError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"SecurityError"</literal></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eNoMemError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"NoMemoryError"</literal></expr></argument>, <argument><expr><name>rb_eException</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eEncodingError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"EncodingError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eEncCompatError</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"CompatibilityError"</literal></expr></argument>, <argument><expr><name>rb_eEncodingError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eNoMatchingPatternError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"NoMatchingPatternError"</literal></expr></argument>, <argument><expr><name>rb_eRuntimeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>syserr_tbl</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_eSystemCallError</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"SystemCallError"</literal></expr></argument>, <argument><expr><name>rb_eStandardError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eSystemCallError</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>syserr_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eSystemCallError</name></expr></argument>, <argument><expr><literal type="string">"errno"</literal></expr></argument>, <argument><expr><name>syserr_errno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_eSystemCallError</name></expr></argument>, <argument><expr><literal type="string">"==="</literal></expr></argument>, <argument><expr><name>syserr_eqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_mErrno</name> <operator>=</operator> <call><name>rb_define_module</name><argument_list>(<argument><expr><literal type="string">"Errno"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_mWarning</name> <operator>=</operator> <call><name>rb_define_module</name><argument_list>(<argument><expr><literal type="string">"Warning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mWarning</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>rb_warning_s_aref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_mWarning</name></expr></argument>, <argument><expr><literal type="string">"[]="</literal></expr></argument>, <argument><expr><name>rb_warning_s_aset</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_mWarning</name></expr></argument>, <argument><expr><literal type="string">"warn"</literal></expr></argument>, <argument><expr><name>rb_warning_s_warn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_extend_object</name><argument_list>(<argument><expr><name>rb_mWarning</name></expr></argument>, <argument><expr><name>rb_mWarning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cWarningBuffer</name> <operator>=</operator> <call><name>rb_define_class_under</name><argument_list>(<argument><expr><name>rb_mWarning</name></expr></argument>, <argument><expr><literal type="string">"buffer"</literal></expr></argument>, <argument><expr><name>rb_cString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cWarningBuffer</name></expr></argument>, <argument><expr><literal type="string">"write"</literal></expr></argument>, <argument><expr><name>warning_write</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_cause</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"cause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_message</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_backtrace</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"backtrace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_key</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_args</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_receiver</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"receiver"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_private_call_p</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"private_call?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_local_variables</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"local_variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_Errno</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"Errno"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_errno</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"errno"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_i_path</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"@path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_warn</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"warn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_top</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"top"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_bottom</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"bottom"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_iseq</name> <operator>=</operator> <call><name>rb_make_internal_id</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>id_recv</name> <operator>=</operator> <call><name>rb_make_internal_id</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_enc_raise</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_enc_vsprintf</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_vraise</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><call><name>rb_vsprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_raise</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>exc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_vraise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void raise_loaderror(VALUE path, VALUE mesg)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>raise_loaderror</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>err</name> <init>= <expr><call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eLoadError</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>id_i_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_loaderror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_enc_vsprintf</name><argument_list>(<argument><expr><call><name>rb_locale_encoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_loaderror</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_loaderror_with_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_enc_vsprintf</name><argument_list>(<argument><expr><call><name>rb_locale_encoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_loaderror</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_notimplement</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eNotImpError</name></expr></argument>,

<argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">"() function is unimplemented on this machine"</literal></expr></argument>,

<argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><call><name>rb_frame_this_func</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_fatal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>ruby_thread_has_gvl_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[FATAL] rb_fatal() outside of GVL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_print_backtrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>die</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_vsprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_fatal</name><argument_list>(<argument><expr><call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eFatal</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>make_errno_exc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_sys_fail(%s) - errno == 0"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>mesg</name></expr> ?</condition><then> <expr><name>mesg</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_syserr_new</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>make_errno_exc_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mesg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mesg</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><ternary><condition><expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_sys_fail_str(%s) - errno == 0"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_syserr_new_str</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_syserr_new</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <ternary><condition><expr><name>mesg</name></expr> ?</condition><then> <expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</expr_stmt>

<return>return <expr><call><name>rb_syserr_new_str</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>VALUE</name></type>

<name>rb_syserr_new_str</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><call><name>get_syserr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_syserr_fail</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_syserr_new</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_syserr_fail_str</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_syserr_new_str</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_sys_fail</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>make_errno_exc</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_sys_fail_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>make_errno_exc_str</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY_FUNCTION_NAME_STRING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>

<name>rb_sys_fail_path_in</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_syserr_fail_path_in</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_syserr_fail_path_in</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>path</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><ternary><condition><expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>func_name</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>func_name</name> <operator>=</operator> <literal type="string">"(null)"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_sys_fail_path_in(%s, %s) - errno == 0"</literal></expr></argument>,

<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><call><name>rb_class_new_instance</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>get_syserr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_mod_sys_fail</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>make_errno_exc</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_extend_object</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_mod_sys_fail_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>make_errno_exc_str</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_extend_object</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_mod_syserr_fail</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_syserr_new</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_extend_object</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_mod_syserr_fail_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_syserr_new_str</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_extend_object</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>syserr_warning</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">": %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_write_warning_str</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

void

rb_sys_warn(const char *fmt, ...)

{

if (!NIL_P(ruby_verbose)) {

int errno_save = errno;

with_warning_string(mesg, 0, fmt) {

syserr_warning(mesg, errno_save);

}

errno = errno_save;

}

}

void

rb_syserr_warn(int err, const char *fmt, ...)

{

if (!NIL_P(ruby_verbose)) {

with_warning_string(mesg, 0, fmt) {

syserr_warning(mesg, err);

}

}

}

void

rb_sys_enc_warn(rb_encoding *enc, const char *fmt, ...)

{

if (!NIL_P(ruby_verbose)) {

int errno_save = errno;

with_warning_string(mesg, enc, fmt) {

syserr_warning(mesg, errno_save);

}

errno = errno_save;

}

}

void

rb_syserr_enc_warn(int err, rb_encoding *enc, const char *fmt, ...)

{

if (!NIL_P(ruby_verbose)) {

with_warning_string(mesg, enc, fmt) {

syserr_warning(mesg, err);

}

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_sys_warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>errno_save</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<macro><name>with_warning_string</name><argument_list>(<argument>mesg</argument>, <argument><literal type="number">0</literal></argument>, <argument>fmt</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>syserr_warning</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>errno_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>errno_save</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

void

rb_syserr_warning(int err, const char *fmt, ...)

{

if (RTEST(ruby_verbose)) {

with_warning_string(mesg, 0, fmt) {

syserr_warning(mesg, err);

}

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>rb_sys_enc_warning</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>errno_save</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

<macro><name>with_warning_string</name><argument_list>(<argument>mesg</argument>, <argument>enc</argument>, <argument>fmt</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>syserr_warning</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>errno_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>errno_save</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_syserr_enc_warning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<macro><name>with_warning_string</name><argument_list>(<argument>mesg</argument>, <argument>enc</argument>, <argument>fmt</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>syserr_warning</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_load_fail</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name> <init>= <expr><call><name>rb_str_buf_new_cstr</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">" -- "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>raise_loaderror</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_error_frozen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eFrozenError</name></expr></argument>, <argument><expr><literal type="string">"can't modify frozen %s"</literal></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_frozen_error_raise</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>frozen_obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>va_list</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name></decl>, <decl><type ref="prev"/><name>mesg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mesg</name> <operator>=</operator> <call><name>rb_vsprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exc</name> <operator>=</operator> <call><name>rb_exc_new3</name><argument_list>(<argument><expr><name>rb_eFrozenError</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_recv</name></expr></argument>, <argument><expr><name>frozen_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>

<name>inspect_frozen_obj</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mesg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_cat_cstr</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">" ..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><call><name>rb_inspect</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>mesg</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_error_frozen_object</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>frozen_obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>debug_info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>created_info</name> <init>= <expr><name>id_debug_created_info</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>mesg</name> <init>= <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"can't modify frozen %"</literal><name>PRIsVALUE</name><literal type="string">": "</literal></expr></argument>,

<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>frozen_obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>exc</name> <init>= <expr><call><name>rb_exc_new_str</name><argument_list>(<argument><expr><name>rb_eFrozenError</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>id_recv</name></expr></argument>, <argument><expr><name>frozen_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_exec_recursive</name><argument_list>(<argument><expr><name>inspect_frozen_obj</name></expr></argument>, <argument><expr><name>frozen_obj</name></expr></argument>, <argument><expr><name>mesg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>debug_info</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>frozen_obj</name></expr></argument>, <argument><expr><name>created_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>debug_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>line</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>debug_info</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_str_catf</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="string">", created at %"</literal><name>PRIsVALUE</name><literal type="string">":%"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_exc_raise</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_check_frozen</name></cpp:undef>

<function><type><name>void</name></type>

<name>rb_check_frozen</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_check_frozen_internal</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_error_untrusted</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn_deprecated_to_remove</name><argument_list>(<argument><expr><literal type="string">"rb_error_untrusted"</literal></expr></argument>, <argument><expr><literal type="string">"3.2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_check_trusted</name></cpp:undef>

<function><type><name>void</name></type>

<name>rb_check_trusted</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rb_warn_deprecated_to_remove</name><argument_list>(<argument><expr><literal type="string">"rb_check_trusted"</literal></expr></argument>, <argument><expr><literal type="string">"3.2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>rb_check_copyable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_ABLE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_frozen_internal</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_ABLE</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>Init_syserr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>rb_eNOERROR</name> <operator>=</operator> <call><name>set_syserr</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"NOERROR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>defined_error</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>set_syserr((num), (name));</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>undefined_error</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>set_syserr(0, (name));</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"known_errors.inc"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>defined_error</name></cpp:undef>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>undefined_error</name></cpp:undef>

</block_content>}</block></function></block_content></block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"warning.rbinc"</cpp:file></cpp:include>

</unit>
