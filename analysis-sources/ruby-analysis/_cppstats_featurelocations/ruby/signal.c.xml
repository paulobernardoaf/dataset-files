<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\signal.c">












<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_UIO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/uio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UCONTEXT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ucontext.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_PTHREAD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_counter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval_intern.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/sanitizers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/signal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/thread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_atomic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEED_RUBY_ATOMIC_OPS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>rb_atomic_t</name></type>
<name>ruby_atomic_exchange</name><parameter_list>(<parameter><decl><type><name>rb_atomic_t</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>rb_atomic_t</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>old</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_atomic_t</name></type>
<name>ruby_atomic_compare_and_swap</name><parameter_list>(<parameter><decl><type><name>rb_atomic_t</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>rb_atomic_t</name></type> <name>cmp</name></decl></parameter>,
<parameter><decl><type><name>rb_atomic_t</name></type> <name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>old</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>old</name> <operator>==</operator> <name>cmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>old</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOREACH_SIGNAL</name><parameter_list>(<parameter><type><name>sig</name></type></parameter>, <parameter><type><name>offset</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for (sig = siglist + (offset); sig &lt; siglist + numberof(siglist); ++sig)</cpp:value></cpp:define>

<enum>enum <block>{ <decl><name>LONGEST_SIGNAME</name> <init>= <expr><literal type="number">7</literal></expr></init></decl> }</block>;</enum> 
<struct><specifier>static</specifier> <specifier>const</specifier> struct <name>signals</name> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>signm</name><index>[<expr><name>LONGEST_SIGNAME</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>signo</name></decl>;</decl_stmt>
}</block> <decl><name><name>siglist</name> <index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"EXIT"</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"HUP"</literal></expr>, <expr><name>SIGHUP</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr><literal type="string">"INT"</literal></expr>, <expr><name>SIGINT</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"QUIT"</literal></expr>, <expr><name>SIGQUIT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"ILL"</literal></expr>, <expr><name>SIGILL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTRAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"TRAP"</literal></expr>, <expr><name>SIGTRAP</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGABRT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"ABRT"</literal></expr>, <expr><name>SIGABRT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGIOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"IOT"</literal></expr>, <expr><name>SIGIOT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGEMT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"EMT"</literal></expr>, <expr><name>SIGEMT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"FPE"</literal></expr>, <expr><name>SIGFPE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"KILL"</literal></expr>, <expr><name>SIGKILL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"BUS"</literal></expr>, <expr><name>SIGBUS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"SEGV"</literal></expr>, <expr><name>SIGSEGV</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSYS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"SYS"</literal></expr>, <expr><name>SIGSYS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"PIPE"</literal></expr>, <expr><name>SIGPIPE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"ALRM"</literal></expr>, <expr><name>SIGALRM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"TERM"</literal></expr>, <expr><name>SIGTERM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGURG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"URG"</literal></expr>, <expr><name>SIGURG</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSTOP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"STOP"</literal></expr>, <expr><name>SIGSTOP</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTSTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"TSTP"</literal></expr>, <expr><name>SIGTSTP</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGCONT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"CONT"</literal></expr>, <expr><name>SIGCONT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_SIGCHLD</name></expr></cpp:if>
<expr><block>{<expr><literal type="string">"CHLD"</literal></expr>, <expr><name>RUBY_SIGCHLD</name></expr> }</block></expr>,
<expr><block>{<expr><literal type="string">"CLD"</literal></expr>, <expr><name>RUBY_SIGCHLD</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTTIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"TTIN"</literal></expr>, <expr><name>SIGTTIN</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTTOU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"TTOU"</literal></expr>, <expr><name>SIGTTOU</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGIO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"IO"</literal></expr>, <expr><name>SIGIO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGXCPU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"XCPU"</literal></expr>, <expr><name>SIGXCPU</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"XFSZ"</literal></expr>, <expr><name>SIGXFSZ</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGVTALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"VTALRM"</literal></expr>, <expr><name>SIGVTALRM</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPROF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"PROF"</literal></expr>, <expr><name>SIGPROF</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGWINCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"WINCH"</literal></expr>, <expr><name>SIGWINCH</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"USR1"</literal></expr>, <expr><name>SIGUSR1</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"USR2"</literal></expr>, <expr><name>SIGUSR2</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGLOST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"LOST"</literal></expr>, <expr><name>SIGLOST</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGMSG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"MSG"</literal></expr>, <expr><name>SIGMSG</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPWR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"PWR"</literal></expr>, <expr><name>SIGPWR</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"POLL"</literal></expr>, <expr><name>SIGPOLL</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGDANGER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"DANGER"</literal></expr>, <expr><name>SIGDANGER</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGMIGRATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"MIGRATE"</literal></expr>, <expr><name>SIGMIGRATE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPRE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"PRE"</literal></expr>, <expr><name>SIGPRE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGGRANT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"GRANT"</literal></expr>, <expr><name>SIGGRANT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGRETRACT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"RETRACT"</literal></expr>, <expr><name>SIGRETRACT</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSOUND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"SOUND"</literal></expr>, <expr><name>SIGSOUND</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"INFO"</literal></expr>, <expr><name>SIGINFO</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>signame_prefix</name><index>[]</index></name> <init>= <expr><literal type="string">"SIG"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>signame_prefix_len</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>signm2signo</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>sig_ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>negative</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exit</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>prefix_ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>signals</name></name> <modifier>*</modifier></type><name>sigs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>vsig</name> <init>= <expr><operator>*</operator><name>sig_ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>nmlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prefix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_SYMBOL_P</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>sig_ptr</name> <operator>=</operator> <name>vsig</name> <operator>=</operator> <call><name>rb_sym2str</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"bad signal type %s"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>sig_ptr</name> <operator>=</operator> <name>vsig</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_must_asciicompat</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>, <argument><expr><name>nm</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name>nm</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"signal name with null byte"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>nm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>negative</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative signal name: % "</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>vsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>negative</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>prefix</name> <operator>+</operator> <name>signame_prefix_len</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>nm</name> <operator>+</operator> <name>prefix</name></expr></argument>, <argument><expr><name>signame_prefix</name></expr></argument>, <argument><expr><name>signame_prefix_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>prefix</name> <operator>+=</operator> <name>signame_prefix_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>prefix</name></expr>)</condition> <block>{<block_content>
<label><name>unsupported</name>:</label>
<if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>==</operator> <name>signame_prefix_len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>prefix</name> <operator>&gt;</operator> <name>signame_prefix_len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prefix</name> <operator>-=</operator> <name>signame_prefix_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vsig</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name>vsig</name> <operator>=</operator> <call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <name>signame_prefix_len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unsupported signal `%.*s%"</literal><name>PRIsVALUE</name><literal type="string">"'"</literal></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>signame_prefix</name></expr></argument>, <argument><expr><name>vsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prefix_ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>prefix_ptr</name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nmlen</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nm</name> <operator>+=</operator> <name>prefix</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nmlen</name> <operator>&gt;</operator> <name>LONGEST_SIGNAME</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>unsupported</name>;</goto></block_content></block></if></if_stmt>
<macro><name>FOREACH_SIGNAL</name><argument_list>(<argument>sigs</argument>, <argument>!exit</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>sigs</name><operator>-&gt;</operator><name>signm</name></name></expr></argument>, <argument><expr><name>nm</name></expr></argument>, <argument><expr><name>nmlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>sigs</name><operator>-&gt;</operator><name>signm</name><index>[<expr><name>nmlen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>negative</name></expr> ?</condition><then> <expr><operator>-</operator><name><name>sigs</name><operator>-&gt;</operator><name>signo</name></name></expr> </then><else>: <expr><name><name>sigs</name><operator>-&gt;</operator><name>signo</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<goto>goto <name>unsupported</name>;</goto>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>signo2signm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>signals</name></name> <modifier>*</modifier></type><name>sigs</name></decl>;</decl_stmt>

<macro><name>FOREACH_SIGNAL</name><argument_list>(<argument>sigs</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sigs</name><operator>-&gt;</operator><name>signo</name></name> <operator>==</operator> <name>no</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>sigs</name><operator>-&gt;</operator><name>signm</name></name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>sig_signame</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>recv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>signo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>signame</name> <init>= <expr><call><name>signo2signm</name><argument_list>(<argument><expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>signame</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>signame</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ruby_signal_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>no</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>signo2signm</name><argument_list>(<argument><expr><name>no</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_signo2signm</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>signm</name> <init>= <expr><call><name>signo2signm</name><argument_list>(<argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>signm</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"SIG%s"</literal></expr></argument>, <argument><expr><name>signm</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"SIG%u"</literal></expr></argument>, <argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>esignal_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>argnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>sig</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>signo</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>rb_check_to_integer</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"to_int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>argnum</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>sig</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argnum</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>signo</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>signo</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>signo</name></expr></argument> &gt;</argument_list></name> <name>NSIG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid signal number (%d)"</literal></expr></argument>, <argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>rb_signo2signm</name><argument_list>(<argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>prefix</name></decl>;</decl_stmt>
<expr_stmt><expr><name>signo</name> <operator>=</operator> <call><name>signm2signo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sig</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>!=</operator> <name>signame_prefix_len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>rb_str_append</name><argument_list>(<argument><expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><literal type="string">"SIG"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_call_super</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_signo</name></expr></argument>, <argument><expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>signo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>self</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>esignal_signo</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>id_signo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>interrupt_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><call><name>rb_call_super</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>rb_malloc_info_show_results</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 

<function><type><name>void</name></type>
<name>ruby_default_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_DEBUG_COUNTER</name></expr></cpp:if>
<expr_stmt><expr><call><name>rb_debug_counter_show_results</name><argument_list>(<argument><expr><literal type="string">"killed by signal."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>rb_malloc_info_show_results</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>RETSIGTYPE</name></type> <name>sighandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>signal_ignored</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>signal_enque</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>VALUE</name></type>
<name>rb_f_kill</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_KILLPG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>killpg</name><parameter_list>(<parameter><type><name>pg</name></type></parameter>, <parameter><type><name>sig</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>kill(-(pg), (sig))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>sig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>signm2signo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <operator>-</operator><name>sig</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>killpg</name><argument_list>(<argument><expr><call><name>NUM2PIDT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>rb_pid_t</name></type> <name>self</name> <init>= <expr><ternary><condition><expr><operator>(</operator><call><name>GET_THREAD</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>main_thread</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wakeup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>rb_pid_t</name></type> <name>pid</name> <init>= <expr><call><name>NUM2PIDT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sig</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>self</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>pid</name> <operator>==</operator> <name>self</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>




<switch>switch <condition>(<expr><name>sig</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SIGSEGV</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGBUS</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGKILL</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGILL</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGFPE</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSTOP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGSTOP</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>signal_ignored</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>signal_enque</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wakeup</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_sys_fail</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>wakeup</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_threadptr_check_signal</name><argument_list>(<argument><expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>main_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_thread_execute_interrupts</name><argument_list>(<argument><expr><call><name>rb_thread_current</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name><name>cnt</name><index>[<expr><name>RUBY_NSIG</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_atomic_t</name></type> <name>size</name></decl>;</decl_stmt>
}</block> <decl><name>signal_buff</name></decl>;</struct>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_SIGCHLD</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>int</name></type> <name>ruby_nocldwait</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sighandler_t</name></cpp:macro> <cpp:value>ruby_sighandler_t</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <function_decl><type><name>void</name></type> <name>ruby_sigaction_t</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>siginfo_t</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGINFO_ARG</name></cpp:macro> <cpp:value>, siginfo_t *info, void *ctx</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGINFO_CTX</name></cpp:macro> <cpp:value>ctx</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <function_decl><type><name>RETSIGTYPE</name></type> <name>ruby_sigaction_t</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGINFO_ARG</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGINFO_CTX</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_sigaltstack_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">16</literal><operator>*</operator><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MINSIGSTKSZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>minsigstksz</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>MINSIGSTKSZ</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>minsigstksz</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>minsigstksz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYSCONF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_SC_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pagesize</name></decl>;</decl_stmt>
<expr_stmt><expr><name>pagesize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>sysconf</name><argument_list>(<argument><expr><name>_SC_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>pagesize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>pagesize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>rb_sigaltstack_size_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>rb_allocate_sigaltstack</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rb_sigaltstack_size_value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rb_sigaltstack_size_value</name> <operator>=</operator> <call><name>rb_sigaltstack_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>xmalloc</name><argument_list>(<argument><expr><name>rb_sigaltstack_size_value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name> <modifier>*</modifier></type>
<name>rb_register_sigaltstack</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>altstack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>stack_t</name></type> <name>newSS</name></decl>, <decl><type ref="prev"/><name>oldSS</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>newSS</name><operator>.</operator><name>ss_size</name></name> <operator>=</operator> <name>rb_sigaltstack_size_value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newSS</name><operator>.</operator><name>ss_sp</name></name> <operator>=</operator> <name>altstack</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newSS</name><operator>.</operator><name>ss_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigaltstack</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newSS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldSS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name><name>newSS</name><operator>.</operator><name>ss_sp</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_SIGNAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>sighandler_t</name></type>
<name>ruby_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>, <parameter><decl><type><name>sighandler_t</name></type> <name>handler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>sigact</name></decl>, <decl><type ref="prev"/><name>old</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
rb_trap_accept_nativethreads[signum] = 0;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sigact</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>handler</name> <operator>==</operator> <name>SIG_IGN</name> <operator>||</operator> <name>handler</name> <operator>==</operator> <name>SIG_DFL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_sigaction</name></name> <operator>=</operator> <operator>(</operator><name>ruby_sigaction_t</name><operator>*</operator><operator>)</operator><name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <name>SA_SIGINFO</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><name>signum</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_SIGCHLD</name></expr></cpp:if>
<case>case <expr><name>RUBY_SIGCHLD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>handler</name> <operator>==</operator> <name>SIG_IGN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ruby_nocldwait</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>sigact</name><operator>.</operator><name>sa_flags</name></name> <operator>&amp;</operator> <name>SA_SIGINFO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_sigaction</name></name> <operator>=</operator> <operator>(</operator><name>ruby_sigaction_t</name><operator>*</operator><operator>)</operator><name>sighandler</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>sighandler</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ruby_nocldwait</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SA_ONSTACK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGSEGV</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGBUS</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>sigact</name><operator>.</operator><name>sa_flags</name></name> <operator>|=</operator> <name>SA_ONSTACK</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></switch>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigact</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>SIG_ERR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>old</name><operator>.</operator><name>sa_flags</name></name> <operator>&amp;</operator> <name>SA_SIGINFO</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>handler</name> <operator>=</operator> <operator>(</operator><name>sighandler_t</name><operator>)</operator><name><name>old</name><operator>.</operator><name>sa_sigaction</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>handler</name> <operator>=</operator> <name><name>old</name><operator>.</operator><name>sa_handler</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>ASSUME</name><argument_list>(<argument><expr><name>handler</name> <operator>!=</operator> <name>SIG_ERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>handler</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>sighandler_t</name></type>
<name>posix_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>, <parameter><decl><type><name>sighandler_t</name></type> <name>handler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ruby_signal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>sighandler_t</name></type>
<name>ruby_signal</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>, <parameter><decl><type><name>sighandler_t</name></type> <name>handler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>signum</name> <operator>==</operator> <name>SIGKILL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINVAL</name></expr>;</expr_stmt>
<return>return <expr><name>SIG_ERR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>signal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ruby_signal</name><parameter_list>(<parameter><type><name>sig</name></type></parameter>,<parameter><type><name>handler</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( signal((sig),(handler)))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 
static sighandler_t
ruby_nativethread_signal(int signum, sighandler_t handler)
{
sighandler_t old;

old = signal(signum, handler);
rb_trap_accept_nativethreads[signum] = 1;
return old;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>signal_ignored</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>func</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_SIGNAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>old</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name><name>old</name><operator>.</operator><name>sa_handler</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>old</name> <init>= <expr><call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>old</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>SIG_IGN</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name>func</name> <operator>==</operator> <name>sighandler</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>signal_enque</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ATOMIC_INC</name><argument_list>(<argument><expr><name><name>signal_buff</name><operator>.</operator><name>cnt</name><index>[<expr><name>sig</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ATOMIC_INC</name><argument_list>(<argument><expr><name><name>signal_buff</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_SIGCHLD</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>rb_atomic_t</name></type> <name>sigchld_hit</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_SIGCHLD_HIT</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>ATOMIC_EXCHANGE(sigchld_hit, 0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_SIGCHLD_HIT</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>RETSIGTYPE</name></type>
<name>sighandler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>old_errnum</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>==</operator> <name>RUBY_SIGCHLD</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_SIGCHLD</name></expr></cpp:if>
<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ATOMIC_EXCHANGE</name><argument_list>(<argument><expr><name>sigchld_hit</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>vm</name> <operator>&amp;&amp;</operator> <call><name>ACCESS_ONCE</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name><name>vm</name><operator>-&gt;</operator><name>trap_list</name><operator>.</operator><name>cmd</name><index>[<expr><name>sig</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>signal_enque</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>signal_enque</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_thread_wakeup_timer_thread</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BSD_SIGNAL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>POSIX_SIGNAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ruby_signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>old_errnum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_signal_buff_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>signal_buff</name><operator>.</operator><name>size</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_disable_interrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_SIGMASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>sigset_t</name></type> <name>mask</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sigfillset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_enable_interrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_SIGMASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>sigset_t</name></type> <name>mask</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_get_next_signal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>sig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>signal_buff</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>RUBY_NSIG</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>signal_buff</name><operator>.</operator><name>cnt</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ATOMIC_DEC</name><argument_list>(<argument><expr><name><name>signal_buff</name><operator>.</operator><name>cnt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ATOMIC_DEC</name><argument_list>(<argument><expr><name><name>signal_buff</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>sig</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SIGSEGV</name> <operator>||</operator> <name>defined</name> <name>SIGBUS</name> <operator>||</operator> <name>defined</name> <name>SIGILL</name> <operator>||</operator> <name>defined</name> <name>SIGFPE</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>received_signal</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_received_signal</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(void)(ruby_disable_gc = 0, received_signal = 0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>clear_received_signal</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SIGALTSTACK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>NORETURN</name><argument_list>(<argument>void rb_ec_stack_overflow(rb_execution_context_t *ec, int crit)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__HAIKU__</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_UCONTEXT_REG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UCONTEXT_H</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>defined</name> <name>__i386__</name> <operator>||</operator> <name>defined</name> <name>__x86_64__</name> <operator>||</operator> <name>defined</name> <name>__amd64__</name><operator>)</operator><operator>)</operator></expr></cpp:elif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__linux__</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_UCONTEXT_REG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__APPLE__</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_UCONTEXT_REG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__FreeBSD__</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_UCONTEXT_REG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PTHREAD_SIGMASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ruby_sigunmask</name></cpp:macro> <cpp:value>pthread_sigmask</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGPROCMASK</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ruby_sigunmask</name></cpp:macro> <cpp:value>sigprocmask</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reset_sigmask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_sigunmask</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>sigset_t</name></type> <name>mask</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>clear_received_signal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ruby_sigunmask</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ruby_sigunmask</name><argument_list>(<argument><expr><name>SIG_UNBLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_bug_errno</name><argument_list>(<argument><expr><call><name>STRINGIZE</name><argument_list>(<argument><expr><name>ruby_sigunmask</name></expr></argument>)</argument_list></call><literal type="string">":unblock"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_UCONTEXT_REG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_stack_overflow</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ucontext_t</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><specifier>const</specifier> <call><name>DEFINE_MCONTEXT_PTR</name><argument_list>(<argument><expr><name>mctx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__linux__</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>REG_RSP</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>greg_t</name></type> <name>sp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>gregs</name><index>[<expr><name>REG_RSP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>greg_t</name></type> <name>bp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>gregs</name><index>[<expr><name>REG_RBP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>greg_t</name></type> <name>sp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>gregs</name><index>[<expr><name>REG_ESP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>greg_t</name></type> <name>bp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>gregs</name><index>[<expr><name>REG_EBP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__APPLE__</name></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__DARWIN_UNIX03</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCTX_SS_REG</name><parameter_list>(<parameter><type><name>reg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__ss.__##reg</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCTX_SS_REG</name><parameter_list>(<parameter><type><name>reg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ss.reg</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__LP64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>sp</name> <init>= <expr><call><name><name>mctx</name><operator>-&gt;</operator><name>MCTX_SS_REG</name></name><argument_list>(<argument><expr><name>rsp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>bp</name> <init>= <expr><call><name><name>mctx</name><operator>-&gt;</operator><name>MCTX_SS_REG</name></name><argument_list>(<argument><expr><name>rbp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>sp</name> <init>= <expr><call><name><name>mctx</name><operator>-&gt;</operator><name>MCTX_SS_REG</name></name><argument_list>(<argument><expr><name>esp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>bp</name> <init>= <expr><call><name><name>mctx</name><operator>-&gt;</operator><name>MCTX_SS_REG</name></name><argument_list>(<argument><expr><name>ebp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__FreeBSD__</name></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__amd64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>__register_t</name></type> <name>sp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>mc_rsp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>__register_t</name></type> <name>bp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>mc_rbp</name></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>__register_t</name></type> <name>sp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>mc_esp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>__register_t</name></type> <name>bp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>mc_ebp</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__HAIKU__</name></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__amd64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>long</name></type> <name>sp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>rsp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>long</name></type> <name>bp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>rbp</name></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>long</name></type> <name>sp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>esp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>long</name></type> <name>bp</name> <init>= <expr><name><name>mctx</name><operator>-&gt;</operator><name>ebp</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<enum>enum <block>{<decl><name>pagesize</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>}</block>;</enum>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>sp_page</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>sp</name> <operator>/</operator> <name>pagesize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>bp_page</name> <init>= <expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>bp</name> <operator>/</operator> <name>pagesize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name></type> <name>fault_page</name> <init>= <expr><name>addr</name> <operator>/</operator> <name>pagesize</name></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>sp_page</name> <operator>==</operator> <name>fault_page</name> <operator>||</operator> <name>sp_page</name> <operator>==</operator> <name>fault_page</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator>
<operator>(</operator><name>sp_page</name> <operator>&lt;=</operator> <name>fault_page</name> <operator>&amp;&amp;</operator> <name>fault_page</name> <operator>&lt;=</operator> <name>bp_page</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>crit</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>buf</name></name> <operator>/</operator> <name>pagesize</name> <operator>&lt;=</operator> <name>fault_page</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>tag</name></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>tag</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>crit</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>reset_sigmask</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ec_stack_overflow</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>crit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_stack_overflow</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ruby_stack_overflowed_p</name><argument_list>(<argument><expr><specifier>const</specifier> <name>rb_thread_t</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>GET_THREAD</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ruby_stack_overflowed_p</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>reset_sigmask</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ec_stack_overflow</name><argument_list>(<argument><expr><name><name>th</name><operator>-&gt;</operator><name>ec</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STACK_OVERFLOW</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>check_stack_overflow(sig, 0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FAULT_ADDRESS</name></cpp:macro> <cpp:value>info-&gt;si_addr</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_UCONTEXT_REG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STACK_OVERFLOW</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>check_stack_overflow(sig, (uintptr_t)FAULT_ADDRESS, ctx)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STACK_OVERFLOW</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>check_stack_overflow(sig, FAULT_ADDRESS)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MESSAGE_FAULT_ADDRESS</name></cpp:macro> <cpp:value>" at %p", FAULT_ADDRESS</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STACK_OVERFLOW</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(void)0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MESSAGE_FAULT_ADDRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MESSAGE_FAULT_ADDRESS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SIGSEGV</name> <operator>||</operator> <name>defined</name> <name>SIGBUS</name> <operator>||</operator> <name>defined</name> <name>SIGILL</name> <operator>||</operator> <name>defined</name> <name>SIGFPE</name></expr></cpp:if>
<macro><name>NOINLINE</name><argument_list>(<argument>static void check_reserved_signal_(const char *name, size_t name_len)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_reserved_signal</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>check_reserved_signal_(name, sizeof(name)-1)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>sighandler_t</name></type> <name>default_sigbus_handler</name></decl>;</decl_stmt>
<macro><name>NORETURN</name><argument_list>(<argument>static ruby_sigaction_t sigbus</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>RETSIGTYPE</name></type>
<name>sigbus</name><parameter_list>(<parameter><decl><type><name>int</name> <name>sig</name></type> <name>SIGINFO_ARG</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>check_reserved_signal</name><argument_list>(<argument><expr><literal type="string">"BUS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__APPLE__</name> <operator>||</operator> <name>defined</name> <name>__linux__</name></expr></cpp:if>
<expr_stmt><expr><call><name>CHECK_STACK_OVERFLOW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>rb_bug_for_fatal_signal</name><argument_list>(<argument><expr><name>default_sigbus_handler</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIGINFO_CTX</name></expr></argument>, <argument><expr><literal type="string">"Bus Error"</literal> <name>MESSAGE_FAULT_ADDRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>sighandler_t</name></type> <name>default_sigsegv_handler</name></decl>;</decl_stmt>
<macro><name>NORETURN</name><argument_list>(<argument>static ruby_sigaction_t sigsegv</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>RETSIGTYPE</name></type>
<name>sigsegv</name><parameter_list>(<parameter><decl><type><name>int</name> <name>sig</name></type> <name>SIGINFO_ARG</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>check_reserved_signal</name><argument_list>(<argument><expr><literal type="string">"SEGV"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_STACK_OVERFLOW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_bug_for_fatal_signal</name><argument_list>(<argument><expr><name>default_sigsegv_handler</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIGINFO_CTX</name></expr></argument>, <argument><expr><literal type="string">"Segmentation fault"</literal> <name>MESSAGE_FAULT_ADDRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>sighandler_t</name></type> <name>default_sigill_handler</name></decl>;</decl_stmt>
<macro><name>NORETURN</name><argument_list>(<argument>static ruby_sigaction_t sigill</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>RETSIGTYPE</name></type>
<name>sigill</name><parameter_list>(<parameter><decl><type><name>int</name> <name>sig</name></type> <name>SIGINFO_ARG</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>check_reserved_signal</name><argument_list>(<argument><expr><literal type="string">"ILL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__APPLE__</name></expr></cpp:if>
<expr_stmt><expr><call><name>CHECK_STACK_OVERFLOW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>rb_bug_for_fatal_signal</name><argument_list>(<argument><expr><name>default_sigill_handler</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIGINFO_CTX</name></expr></argument>, <argument><expr><literal type="string">"Illegal instruction"</literal> <name>MESSAGE_FAULT_ADDRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>NORETURN</name><argument_list>(<argument>static void ruby_abort(void)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ruby_abort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:if>



<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGABRT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_reserved_signal_</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>name_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><call><name>ATOMIC_PTR_EXCHANGE</name><argument_list>(<argument><expr><name>received_signal</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>RB_UNUSED_VAR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOZ</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>name[sizeof(str)-1] = str</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name>NOZ</name><argument_list>(<argument><expr><name>msg1</name></expr></argument>, <argument><expr><literal type="string">" received in "</literal></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name>NOZ</name><argument_list>(<argument><expr><name>msg2</name></expr></argument>, <argument><expr><literal type="string">" handler\n"</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WRITEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name></type> <name><name>iov</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <name>name_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>msg1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>msg1</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>prev</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>msg2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>msg2</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>writev</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>iov</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>msg1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>msg2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>ruby_abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ruby_disable_gc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SIGPIPE</name> <operator>||</operator> <name>defined</name> <name>SIGSYS</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>RETSIGTYPE</name></type>
<name>sig_do_nothing</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>signal_exec</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>rb_atomic_t</name></type> <name>old_interrupt_mask</name> <init>= <expr><name><name>ec</name><operator>-&gt;</operator><name>interrupt_mask</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>ruby_tag_type</name></name></type> <name>state</name></decl>;</decl_stmt>







<if_stmt><if>if <condition>(<expr><call><name>IMMEDIATE_P</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>interrupt_mask</name></name> <operator>|=</operator> <name>TRAP_INTERRUPT_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EC_PUSH_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>state</name> <operator>=</operator> <call><name>EC_EXEC_TAG</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAG_NONE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>signum</name> <init>= <expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_eval_cmd_kw</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EC_POP_TAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ec</name> <operator>=</operator> <call><name>GET_EC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ec</name><operator>-&gt;</operator><name>interrupt_mask</name></name> <operator>=</operator> <name>old_interrupt_mask</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>EC_JUMP_TAG</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_vm_trap_exit</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>trap_exit</name> <init>= <expr><name><name>vm</name><operator>-&gt;</operator><name>trap_list</name><operator>.</operator><name>cmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>trap_exit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>vm</name><operator>-&gt;</operator><name>trap_list</name><operator>.</operator><name>cmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal_exec</name><argument_list>(<argument><expr><name>trap_exit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>ruby_waitpid_all</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> 

<function><type><name>void</name></type>
<name>ruby_sigchld_handler</name><parameter_list>(<parameter><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>SIGCHLD_LOSSY</name> <operator>||</operator> <call><name>GET_SIGCHLD_HIT</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ruby_waitpid_all</name><argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>rb_signal_exec</name><parameter_list>(<parameter><decl><type><name>rb_thread_t</name> <modifier>*</modifier></type><name>th</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>cmd</name> <init>= <expr><name><name>vm</name><operator>-&gt;</operator><name>trap_list</name><operator>.</operator><name>cmd</name><index>[<expr><name>sig</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>sig</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SIGINT</name></expr>:</case>
<expr_stmt><expr><call><name>rb_interrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGHUP</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGQUIT</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGTERM</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGALRM</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGUSR1</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGUSR2</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>rb_threadptr_signal_raise</name><argument_list>(<argument><expr><name>th</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_threadptr_signal_exit</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>signal_exec</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sighandler_t</name></type>
<name>default_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>func</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>sig</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SIGINT</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGHUP</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGQUIT</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGTERM</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGALRM</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGUSR1</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGUSR2</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_SIGCHLD</name></expr></cpp:if>
<case>case <expr><name>RUBY_SIGCHLD</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>sighandler</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGBUS</name></expr>:</case>
<expr_stmt><expr><name>func</name> <operator>=</operator> <operator>(</operator><name>sighandler_t</name><operator>)</operator><name>sigbus</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGSEGV</name></expr>:</case>
<expr_stmt><expr><name>func</name> <operator>=</operator> <operator>(</operator><name>sighandler_t</name><operator>)</operator><name>sigsegv</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGPIPE</name></expr>:</case>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>sig_do_nothing</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSYS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>SIGSYS</name></expr>:</case>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>sig_do_nothing</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>SIG_DFL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>func</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>sighandler_t</name></type>
<name>trap_handler</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>func</name> <init>= <expr><name>sighandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>command</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><operator>*</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>SIG_IGN</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><operator>*</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SYMBOL_P</name><argument_list>(<argument><expr><operator>*</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>rb_sym2str</name><argument_list>(<argument><expr><operator>*</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>command</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"bad handler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cmd</name> <operator>=</operator> <name>command</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RSTRING_GETMEM</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>cptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<goto>goto <name>sig_ign</name>;</goto>
<break>break;</break>
<case>case <expr><literal type="number">14</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><literal type="string">"SYSTEM_DEFAULT"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>==</operator> <name>RUBY_SIGCHLD</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>sig_dfl</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>SIG_DFL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cmd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">7</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><literal type="string">"SIG_IGN"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<label><name>sig_ign</name>:</label>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>SIG_IGN</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cmd</name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><literal type="string">"SIG_DFL"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<label><name>sig_dfl</name>:</label>
<expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>default_handler</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cmd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>sig_dfl</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">6</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><literal type="string">"IGNORE"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>sig_ign</name>;</goto>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>cptr</name></expr></argument>, <argument><expr><literal type="string">"EXIT"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cmd</name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>rb_proc_t</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>GetProcPtr</name><argument_list>(<argument><expr><operator>*</operator><name>cmd</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>proc</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>func</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>trap_signm</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>vsig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sig</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>FIX2INT</name><argument_list>(<argument><expr><name>vsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>sig</name> <operator>&gt;=</operator> <name>NSIG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid signal number (%d)"</literal></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>signm2signo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vsig</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>sig</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>trap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>, <parameter><decl><type><name>sighandler_t</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>oldfunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>oldcmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><name>sig</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>oldfunc</name> <operator>=</operator> <name>SIG_ERR</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>oldfunc</name> <operator>=</operator> <call><name>ruby_signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oldfunc</name> <operator>==</operator> <name>SIG_ERR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_sys_fail_str</name><argument_list>(<argument><expr><call><name>rb_signo2signm</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>oldcmd</name> <operator>=</operator> <name><name>vm</name><operator>-&gt;</operator><name>trap_list</name><operator>.</operator><name>cmd</name><index>[<expr><name>sig</name></expr>]</index></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>oldcmd</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<case>case <expr><name>Qtrue</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>oldfunc</name> <operator>==</operator> <name>SIG_IGN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oldcmd</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"IGNORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>oldfunc</name> <operator>==</operator> <name>SIG_DFL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oldcmd</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"SYSTEM_DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>oldfunc</name> <operator>==</operator> <name>sighandler</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>oldcmd</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>oldcmd</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>Qnil</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>Qundef</name></expr>:</case>
<expr_stmt><expr><name>oldcmd</name> <operator>=</operator> <call><name>rb_str_new2</name><argument_list>(<argument><expr><literal type="string">"EXIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>ACCESS_ONCE</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name><name>vm</name><operator>-&gt;</operator><name>trap_list</name><operator>.</operator><name>cmd</name><index>[<expr><name>sig</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <name>command</name></expr>;</expr_stmt>

<return>return <expr><name>oldcmd</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>reserved_signal_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signo</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>signo</name> <operator>==</operator> <name>SIGSEGV</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>signo</name> <operator>==</operator> <name>SIGBUS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>signo</name> <operator>==</operator> <name>SIGILL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>signo</name> <operator>==</operator> <name>SIGFPE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGVTALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>signo</name> <operator>==</operator> <name>SIGVTALRM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>sig_trap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>cmd</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sig</name> <operator>=</operator> <call><name>trap_signm</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>reserved_signal_p</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>signo2signm</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"can't trap reserved signal: SIG%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"can't trap reserved signal: %d"</literal></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>sighandler</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name> <operator>=</operator> <call><name>trap_handler</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>trap</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>sig_list</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>h</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>signals</name></name> <modifier>*</modifier></type><name>sigs</name></decl>;</decl_stmt>

<macro><name>FOREACH_SIGNAL</name><argument_list>(<argument>sigs</argument>, <argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><name><name>sigs</name><operator>-&gt;</operator><name>signm</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name><name>sigs</name><operator>-&gt;</operator><name>signo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSTALL_SIGHANDLER</name><parameter_list>(<parameter><type><name>cond</name></type></parameter>, <parameter><type><name>signame</name></type></parameter>, <parameter><type><name>signum</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { static const char failed[] = "failed to install "signame" handler"; if (!(cond)) break; if (reserved_signal_p(signum)) rb_bug(failed); perror(failed); } while (0)</cpp:value></cpp:define>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>install_sighandler_core</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>, <parameter><decl><type><name>sighandler_t</name></type> <name>handler</name></decl></parameter>, <parameter><decl><type><name>sighandler_t</name> <modifier>*</modifier></type><name>old_handler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>old</name></decl>;</decl_stmt>

<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>ruby_signal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>old</name> <operator>==</operator> <name>SIG_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>old_handler</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>old_handler</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>old</name> <operator>==</operator> <name>SIG_DFL</name> <operator>||</operator> <name>old</name> <operator>==</operator> <name>SIG_IGN</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>old</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>old</name> <operator>!=</operator> <name>SIG_DFL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ruby_signal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>install_sighandler</name><parameter_list>(<parameter><type><name>signum</name></type></parameter>, <parameter><type><name>handler</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>INSTALL_SIGHANDLER(install_sighandler_core(signum, handler, NULL), #signum, signum)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>force_install_sighandler</name><parameter_list>(<parameter><type><name>signum</name></type></parameter>, <parameter><type><name>handler</name></type></parameter>, <parameter><type><name>old_handler</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>INSTALL_SIGHANDLER(install_sighandler_core(signum, handler, old_handler), #signum, signum)</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_SIGCHLD</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>init_sigchld</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>oldfunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>func</name> <init>= <expr><name>sighandler</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>oldfunc</name> <operator>=</operator> <call><name>ruby_signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oldfunc</name> <operator>==</operator> <name>SIG_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ruby_signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ACCESS_ONCE</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name><name>trap_list</name><operator>.</operator><name>cmd</name><index>[<expr><name>sig</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>init_sigchld</name><parameter_list>(<parameter><type><name>signum</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>INSTALL_SIGHANDLER(init_sigchld(signum), #signum, signum)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>ruby_sig_finalize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sighandler_t</name></type> <name>oldfunc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>oldfunc</name> <operator>=</operator> <call><name>ruby_signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oldfunc</name> <operator>==</operator> <name>sighandler</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ruby_signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><name>int</name></type> <name>ruby_enable_coredump</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






































<function><type><name>void</name></type>
<name>Init_signal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>mSignal</name> <init>= <expr><call><name>rb_define_module</name><argument_list>(<argument><expr><literal type="string">"Signal"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_define_global_function</name><argument_list>(<argument><expr><literal type="string">"trap"</literal></expr></argument>, <argument><expr><name>sig_trap</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_module_function</name><argument_list>(<argument><expr><name>mSignal</name></expr></argument>, <argument><expr><literal type="string">"trap"</literal></expr></argument>, <argument><expr><name>sig_trap</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_module_function</name><argument_list>(<argument><expr><name>mSignal</name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>, <argument><expr><name>sig_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_module_function</name><argument_list>(<argument><expr><name>mSignal</name></expr></argument>, <argument><expr><literal type="string">"signame"</literal></expr></argument>, <argument><expr><name>sig_signame</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eSignal</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>esignal_init</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eSignal</name></expr></argument>, <argument><expr><literal type="string">"signo"</literal></expr></argument>, <argument><expr><name>esignal_signo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_alias</name><argument_list>(<argument><expr><name>rb_eSignal</name></expr></argument>, <argument><expr><call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"signm"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"message"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_eInterrupt</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>interrupt_init</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>rb_disable_interrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>install_sighandler</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>install_sighandler</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>install_sighandler</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>install_sighandler</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>install_sighandler</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>install_sighandler</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>install_sighandler</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>sighandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ruby_enable_coredump</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>force_install_sighandler</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>, <argument><expr><operator>(</operator><name>sighandler_t</name><operator>)</operator><name>sigbus</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_sigbus_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>force_install_sighandler</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>, <argument><expr><operator>(</operator><name>sighandler_t</name><operator>)</operator><name>sigill</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_sigill_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>RB_ALTSTACK_INIT</name><argument_list>(<argument><expr><call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>main_altstack</name></expr></argument>, <argument><expr><call><name>rb_allocate_sigaltstack</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>force_install_sighandler</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>, <argument><expr><operator>(</operator><name>sighandler_t</name><operator>)</operator><name>sigsegv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>default_sigsegv_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>install_sighandler</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>sig_do_nothing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGSYS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>install_sighandler</name><argument_list>(<argument><expr><name>SIGSYS</name></expr></argument>, <argument><expr><name>sig_do_nothing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RUBY_SIGCHLD</name></expr></cpp:if>
<expr_stmt><expr><call><name>init_sigchld</name><argument_list>(<argument><expr><name>RUBY_SIGCHLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_enable_interrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GRANTPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>grantpt</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>fake_grantfd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>masterfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSYS</name></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>grantpt</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fake_grantfd(fd)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>
<name>rb_grantpt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>masterfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>RUBY_SIGCHLD</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>rb_vm_t</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><call><name>GET_VM</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>













<expr_stmt><expr><call><name>rb_nativethread_lock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>waitpid_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>grantpt</name><argument_list>(<argument><expr><name>masterfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>rb_nativethread_lock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>-&gt;</operator><name>waitpid_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>grantpt</name><argument_list>(<argument><expr><name>masterfd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
