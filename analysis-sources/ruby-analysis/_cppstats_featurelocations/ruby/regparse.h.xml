<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\regparse.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ONIGMO_REGPARSE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONIGMO_REGPARSE_H</name></cpp:macro></cpp:define>






























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regint.h"</cpp:file></cpp:include>

<macro><name>RUBY_SYMBOL_EXPORT_BEGIN</name></macro>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_STR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_CCLASS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_CTYPE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_CANY</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_BREF</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_QTFR</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_ENCLOSE</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_ANCHOR</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_LIST</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_ALT</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NT_CALL</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTYPE2BIT</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1&lt;&lt;(type))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_STR</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_STR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_CCLASS</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_CCLASS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_CTYPE</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_CTYPE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_CANY</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_CANY)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_BREF</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_BREF)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_QTFR</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_QTFR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_ENCLOSE</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_ENCLOSE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_ANCHOR</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_ANCHOR)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_LIST</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_LIST)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_ALT</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_ALT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT_NT_CALL</name></cpp:macro> <cpp:value>NTYPE2BIT(NT_CALL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NODE_TYPE_SIMPLE</name><parameter_list>(<parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((NTYPE2BIT(type) &amp; (BIT_NT_STR | BIT_NT_CCLASS | BIT_NT_CTYPE |BIT_NT_CANY | BIT_NT_BREF)) != 0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTYPE</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((node)-&gt;u.base.type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_NTYPE</name><parameter_list>(<parameter><type><name>node</name></type></parameter>, <parameter><type><name>ntype</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int value = ntype; memcpy(&amp;((node)-&gt;u.base.type), &amp;value, sizeof(int)); } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTR</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((node)-&gt;u.str))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCCLASS</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((node)-&gt;u.cclass))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCTYPE</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((node)-&gt;u.ctype))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBREF</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((node)-&gt;u.bref))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NQTFR</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((node)-&gt;u.qtfr))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NENCLOSE</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((node)-&gt;u.enclose))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NANCHOR</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((node)-&gt;u.anchor))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCONS</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((node)-&gt;u.cons))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCALL</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;((node)-&gt;u.call))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCAR</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(NCONS(node)-&gt;car)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCDR</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(NCONS(node)-&gt;cdr)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANCHOR_ANYCHAR_STAR_MASK</name></cpp:macro> <cpp:value>(ANCHOR_ANYCHAR_STAR | ANCHOR_ANYCHAR_STAR_ML)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANCHOR_END_BUF_MASK</name></cpp:macro> <cpp:value>(ANCHOR_END_BUF | ANCHOR_SEMI_END_BUF)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCLOSE_MEMORY</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCLOSE_OPTION</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCLOSE_STOP_BACKTRACK</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCLOSE_CONDITION</name></cpp:macro> <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCLOSE_ABSENT</name></cpp:macro> <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_STR_MARGIN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_STR_BUF_SIZE</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_BACKREFS_SIZE</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTR_RAW</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTR_AMBIG</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTR_DONT_GET_OPT_INFO</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTRING_LEN</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(OnigDistance )((node)-&gt;u.str.end - (node)-&gt;u.str.s)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTRING_SET_RAW</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(node)-&gt;u.str.flag |= NSTR_RAW</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTRING_CLEAR_RAW</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(node)-&gt;u.str.flag &amp;= ~NSTR_RAW</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTRING_SET_AMBIG</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(node)-&gt;u.str.flag |= NSTR_AMBIG</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTRING_SET_DONT_GET_OPT_INFO</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(node)-&gt;u.str.flag |= NSTR_DONT_GET_OPT_INFO</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTRING_IS_RAW</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((node)-&gt;u.str.flag &amp; NSTR_RAW) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTRING_IS_AMBIG</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((node)-&gt;u.str.flag &amp; NSTR_AMBIG) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTRING_IS_DONT_GET_OPT_INFO</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((node)-&gt;u.str.flag &amp; NSTR_DONT_GET_OPT_INFO) != 0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKREFS_P</name><parameter_list>(<parameter><type><name>br</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(IS_NOT_NULL((br)-&gt;back_dynamic) ? (br)-&gt;back_dynamic : (br)-&gt;back_static);</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NQ_TARGET_ISNOT_EMPTY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NQ_TARGET_IS_EMPTY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NQ_TARGET_IS_EMPTY_MEM</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NQ_TARGET_IS_EMPTY_REC</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_MIN_FIXED</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_MAX_FIXED</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_CLEN_FIXED</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_MARK1</name></cpp:macro> <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_MARK2</name></cpp:macro> <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_MEM_BACKREFED</name></cpp:macro> <cpp:value>(1&lt;&lt;5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_STOP_BT_SIMPLE_REPEAT</name></cpp:macro> <cpp:value>(1&lt;&lt;6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_RECURSION</name></cpp:macro> <cpp:value>(1&lt;&lt;7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_CALLED</name></cpp:macro> <cpp:value>(1&lt;&lt;8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_ADDR_FIXED</name></cpp:macro> <cpp:value>(1&lt;&lt;9)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_NAMED_GROUP</name></cpp:macro> <cpp:value>(1&lt;&lt;10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_NAME_REF</name></cpp:macro> <cpp:value>(1&lt;&lt;11)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_IN_REPEAT</name></cpp:macro> <cpp:value>(1&lt;&lt;12)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_NEST_LEVEL</name></cpp:macro> <cpp:value>(1&lt;&lt;13)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NST_BY_NUMBER</name></cpp:macro> <cpp:value>(1&lt;&lt;14)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_ENCLOSE_STATUS</name><parameter_list>(<parameter><type><name>node</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(node)-&gt;u.enclose.state |= (f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLEAR_ENCLOSE_STATUS</name><parameter_list>(<parameter><type><name>node</name></type></parameter>,<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(node)-&gt;u.enclose.state &amp;= ~(f)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_CALLED</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_CALLED) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_ADDR_FIXED</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_ADDR_FIXED) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_RECURSION</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_RECURSION) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_MARK1</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_MARK1) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_MARK2</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_MARK2) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_MIN_FIXED</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_MIN_FIXED) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_MAX_FIXED</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_MAX_FIXED) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_CLEN_FIXED</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_CLEN_FIXED) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_STOP_BT_SIMPLE_REPEAT</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_STOP_BT_SIMPLE_REPEAT) != 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_NAMED_GROUP</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_NAMED_GROUP) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ENCLOSE_NAME_REF</name><parameter_list>(<parameter><type><name>en</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((en)-&gt;state &amp; NST_NAME_REF) != 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_CALL_RECURSION</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(node)-&gt;u.call.state |= NST_RECURSION</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_CALL_RECURSION</name><parameter_list>(<parameter><type><name>cn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((cn)-&gt;state &amp; NST_RECURSION) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_CALL_NAME_REF</name><parameter_list>(<parameter><type><name>cn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((cn)-&gt;state &amp; NST_NAME_REF) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_BACKREF_NAME_REF</name><parameter_list>(<parameter><type><name>bn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((bn)-&gt;state &amp; NST_NAME_REF) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_BACKREF_NEST_LEVEL</name><parameter_list>(<parameter><type><name>bn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((bn)-&gt;state &amp; NST_NEST_LEVEL) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_QUANTIFIER_IN_REPEAT</name><parameter_list>(<parameter><type><name>qn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((qn)-&gt;state &amp; NST_IN_REPEAT) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_QUANTIFIER_BY_NUMBER</name><parameter_list>(<parameter><type><name>qn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((qn)-&gt;state &amp; NST_BY_NUMBER) != 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLNODE_REFNUM_UNDEF</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NodeBase</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>capa</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><name>NODE_STR_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>StrNode</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NodeBase</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lower</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>upper</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>greedy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>target_empty_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>head_exact</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>next_head_exact</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_referred</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COMBINATION_EXPLOSION_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>comb_exp_check_num</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>QtfrNode</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NodeBase</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>regnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AbsAddrType</name></type> <name>call_addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>target</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OnigDistance</name></type> <name>min_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>OnigDistance</name></type> <name>max_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>char_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>opt_count</name></decl>;</decl_stmt> 
}</block></struct></type> <name>EncloseNode</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>target</name></decl>;</decl_stmt>
}</block></struct></type> <name>UnsetAddr</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UnsetAddr</name><modifier>*</modifier></type> <name>us</name></decl>;</decl_stmt>
}</block></struct></type> <name>UnsetAddrList</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NodeBase</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>group_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>name_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>target</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>UnsetAddrList</name><modifier>*</modifier></type> <name>unset_addr_list</name></decl>;</decl_stmt>
}</block></struct></type> <name>CallNode</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NodeBase</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>back_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>back_static</name><index>[<expr><name>NODE_BACKREFS_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name><modifier>*</modifier></type> <name>back_dynamic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nest_level</name></decl>;</decl_stmt>
}</block></struct></type> <name>BRefNode</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NodeBase</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>char_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ascii_range</name></decl>;</decl_stmt>
}</block></struct></type> <name>AnchorNode</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NodeBase</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>car</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>_Node</name></name><modifier>*</modifier></type> <name>cdr</name></decl>;</decl_stmt>
}</block></struct></type> <name>ConsAltNode</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NodeBase</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ctype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>not</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ascii_range</name></decl>;</decl_stmt>
}</block></struct></type> <name>CtypeNode</name>;</typedef>

<typedef>typedef <type><struct>struct <name>_Node</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>NodeBase</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StrNode</name></type> <name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CClassNode</name></type> <name>cclass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QtfrNode</name></type> <name>qtfr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EncloseNode</name></type> <name>enclose</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BRefNode</name></type> <name>bref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AnchorNode</name></type> <name>anchor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ConsAltNode</name></type> <name>cons</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CtypeNode</name></type> <name>ctype</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>CallNode</name></type> <name>call</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block> <decl><name>u</name></decl>;</union>
}</block></struct></type> <name>Node</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NULL_NODE</name></cpp:macro> <cpp:value>((Node* )0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCANENV_MEMNODES_SIZE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCANENV_MEM_NODES</name><parameter_list>(<parameter><type><name>senv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(IS_NOT_NULL((senv)-&gt;mem_nodes_dynamic) ? (senv)-&gt;mem_nodes_dynamic : (senv)-&gt;mem_nodes_static)</cpp:value></cpp:define>



<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>OnigOptionType</name></type> <name>option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigCaseFoldType</name></type> <name>case_fold_flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>OnigSyntaxType</name><modifier>*</modifier></type> <name>syntax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitStatusType</name></type> <name>capture_history</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitStatusType</name></type> <name>bt_mem_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitStatusType</name></type> <name>bt_mem_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BitStatusType</name></type> <name>backrefed_mem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>pattern</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>pattern_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>error_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SUBEXP_CALL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UnsetAddrList</name><modifier>*</modifier></type> <name>unset_addr_list</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>num_call</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_mem</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>num_named</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>mem_alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name><name>mem_nodes_static</name><index>[<expr><name>SCANENV_MEMNODES_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>mem_nodes_dynamic</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_COMBINATION_EXPLOSION_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>num_comb_exp_check</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>comb_exp_max_regnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curr_max_regnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_recursion</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>parse_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>warnings_flag</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>sourcefile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sourceline</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>ScanEnv</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SYNTAX_OP</name><parameter_list>(<parameter><type><name>syn</name></type></parameter>, <parameter><type><name>opm</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((syn)-&gt;op &amp; (opm)) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SYNTAX_OP2</name><parameter_list>(<parameter><type><name>syn</name></type></parameter>, <parameter><type><name>opm</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((syn)-&gt;op2 &amp; (opm)) != 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SYNTAX_BV</name><parameter_list>(<parameter><type><name>syn</name></type></parameter>, <parameter><type><name>bvm</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((syn)-&gt;behavior &amp; (bvm)) != 0)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>new_val</name></decl>;</decl_stmt>
}</block></struct></type> <name>GroupNumRemap</name>;</typedef>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>onig_renumber_name_table</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>GroupNumRemap</name><modifier>*</modifier></type> <name>map</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>onig_strncmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>onig_strcpy</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>onig_scan_env_set_error_string</name><parameter_list>(<parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ecode</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>UChar</name><modifier>*</modifier></type> <name>arg_end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>onig_scan_unsigned_number</name><parameter_list>(<parameter><decl><type><name>UChar</name><modifier>*</modifier><modifier>*</modifier></type> <name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>OnigEncoding</name></type> <name>enc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>onig_reduce_nested_quantifier</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>pnode</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>cnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>onig_node_conv_to_str_node</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>raw</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>onig_node_str_cat</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>onig_node_str_set</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>onig_node_free</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type> <name>onig_node_new_enclose</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type> <name>onig_node_new_anchor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type> <name>onig_node_new_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type> <name>onig_node_new_list</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>right</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type> <name>onig_node_list_add</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>list</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Node</name><modifier>*</modifier></type> <name>onig_node_new_alt</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>left</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>right</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>onig_node_str_clear</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>onig_names_free</name><parameter_list>(<parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>onig_parse_make_tree</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier><modifier>*</modifier></type> <name>root</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UChar</name><modifier>*</modifier></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>ScanEnv</name><modifier>*</modifier></type> <name>env</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>onig_free_shared_cclass_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ONIG_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NAMED_GROUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>onig_print_names</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>regex_t</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>RUBY_SYMBOL_EXPORT_END</name></expr>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
