<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\variable.c">












<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"constant.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_counter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compilers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/re.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/symbol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/stdbool.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ccan/list/list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/thread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/st.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transient_heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vm_core.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>rb_global_tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>autoload</name></decl>, <decl><type ref="prev"/><name>classpath</name></decl>, <decl><type ref="prev"/><name>tmp_classpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>autoload_featuremap</name></decl>;</decl_stmt> 

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_before_mod_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>ID</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_const_entry</name><parameter_list>(<parameter><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>rb_const_flag_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_const_search</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>visibility</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>generic_iv_tbl</name></decl>;</decl_stmt>

<struct>struct <name>ivar_update</name> <block>{
<union>union <block>{
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>iv_index_tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>
}</block> <decl><name>u</name></decl>;</union>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>iv_extended</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><name>void</name></type>
<name>Init_var_tables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>rb_global_tbl</name> <operator>=</operator> <call><name>rb_id_table_create</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>generic_iv_tbl</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>autoload</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"__autoload__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>classpath</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"__classpath__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp_classpath</name> <operator>=</operator> <call><name>rb_intern_const</name><argument_list>(<argument><expr><literal type="string">"__tmp_classpath__"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>rb_namespace_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RB_SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>RB_BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_MODULE</name></expr>:</case> <case>case <expr><name>T_CLASS</name></expr>:</case> <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>classname</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>permanent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>permanent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RCLASS_EXT</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ivtbl</name> <operator>=</operator> <call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>ivtbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>classpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>permanent</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>n</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>ivtbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>tmp_classpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>n</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>VALUE</name></type>
<name>rb_mod_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>permanent</name></decl>;</decl_stmt>
<return>return <expr><call><name>classname</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>permanent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>make_temporary_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>klass</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Qnil</name></expr>:</case>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;Class:%p&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>Qfalse</name></expr>:</case>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;Module:%p&gt;"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">":%p&gt;"</literal></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>fallback_func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_tmp_class_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>permanent</name></decl></parameter>, <parameter><decl><type><name>fallback_func</name></type> <name>fallback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>classname</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>permanent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_MODULE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cModule</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>perm</name></decl>;</decl_stmt>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_tmp_class_path</name><argument_list>(<argument><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>perm</name></expr></argument>, <argument><expr><name>fallback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>permanent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><call><name>fallback</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_class_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>permanent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_tmp_class_path</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>permanent</name></expr></argument>, <argument><expr><name>make_temporary_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>rb_str_dup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_class_path_cached</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>permanent</name></decl>;</decl_stmt>
<return>return <expr><call><name>classname</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>permanent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>no_fallback</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_search_class_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>permanent</name></decl>;</decl_stmt>
<return>return <expr><call><name>rb_tmp_class_path</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>permanent</name></expr></argument>, <argument><expr><name>no_fallback</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>build_const_pathname</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_str_dup</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_str_cat2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"::"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_append</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>build_const_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>head</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>tail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>build_const_pathname</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_set_class_path_string</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>under</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>pathid</name> <init>= <expr><name>classpath</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>under</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>permanent</name></decl>;</decl_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_tmp_class_path</name><argument_list>(<argument><expr><name>under</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>permanent</name></expr></argument>, <argument><expr><name>make_temporary_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>build_const_pathname</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>permanent</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pathid</name> <operator>=</operator> <name>tmp_classpath</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>pathid</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_set_class_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>under</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_set_class_path_string</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>under</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_path_to_class</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>pathname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pbeg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name> <init>= <expr><name>rb_cObject</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid class path encoding (non ASCII)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pbeg</name> <operator>=</operator> <name>p</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>path</name> <operator>+</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>pend</name> <operator>||</operator> <name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"can't retrieve anonymous class %"</literal><name>PRIsVALUE</name></expr></argument>,
<argument><expr><call><name>QUOTE</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_check_id_cstr</name><argument_list>(<argument><expr><name>pbeg</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>pbeg</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>pend</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>pend</name> <operator>-</operator> <name>p</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>undefined_class</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pbeg</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>
<label><name>undefined_class</name>:</label>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"undefined class/module % "</literal><name>PRIsVALUE</name></expr></argument>,
<argument><expr><call><name>rb_str_subseq</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p</name><operator>-</operator><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_const_search</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>undefined_class</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_namespace_p</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">" does not refer to class/module"</literal></expr></argument>,
<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_path2class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_path_to_class</name><argument_list>(<argument><expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_class_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_class_path</name><argument_list>(<argument><expr><call><name>rb_class_real</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>rb_class2name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>permanent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>path</name> <init>= <expr><call><name>rb_tmp_class_path</name><argument_list>(<argument><expr><call><name>rb_class_real</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>permanent</name></expr></argument>, <argument><expr><name>make_temporary_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>rb_obj_classname</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_class2name</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>trace_var</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>removed</name></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>VALUE</name></type> <name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>rb_global_variable</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>counter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>block_trace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_gvar_getter_t</name> <modifier>*</modifier></type><name>getter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_gvar_setter_t</name> <modifier>*</modifier></type><name>setter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_gvar_marker_t</name> <modifier>*</modifier></type><name>marker</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>trace</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>rb_global_entry</name></name><modifier>*</modifier></type>
<name>rb_find_global_entry</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>rb_global_tbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator>struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASSUME</name><argument_list>(<argument><expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name><name>struct</name> <name>rb_global_entry</name></name><modifier>*</modifier></type>
<name>rb_global_entry</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>rb_find_global_entry</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>rb_global_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>rb_global_variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>var</name></name> <operator>=</operator> <name>var</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>counter</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>getter</name></name> <operator>=</operator> <name>rb_gvar_undef_getter</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>setter</name></name> <operator>=</operator> <name>rb_gvar_undef_setter</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>marker</name></name> <operator>=</operator> <name>rb_gvar_undef_marker</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>block_trace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>rb_global_tbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_gvar_undef_getter</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"global variable `%"</literal><name>PRIsVALUE</name><literal type="string">"' not initialized"</literal></expr></argument>, <argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_gvar_undef_setter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>rb_global_entry</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>var</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>getter</name></name> <operator>=</operator> <name>rb_gvar_val_getter</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>setter</name></name> <operator>=</operator> <name>rb_gvar_val_setter</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>marker</name></name> <operator>=</operator> <name>rb_gvar_val_marker</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_gvar_undef_marker</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_gvar_val_getter</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_gvar_val_setter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>rb_global_entry</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>var</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_gvar_val_marker</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>data</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>var</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_gvar_var_getter</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>*</operator><name>var</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_gvar_var_setter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_gvar_var_marker</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_gc_mark_maybe</name><argument_list>(<argument><expr><operator>*</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_gvar_readonly_setter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_name_error</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">" is a read-only variable"</literal></expr></argument>, <argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>
<name>mark_global_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ignored</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator>struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>trace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>var</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>var</name><operator>-&gt;</operator><name>marker</name></name>)<argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>trace</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>trace</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>trace</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_gc_mark_maybe</name><argument_list>(<argument><expr><name><name>trace</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <name><name>trace</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_gc_mark_global_tbl</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rb_global_tbl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_id_table_foreach_values</name><argument_list>(<argument><expr><name>rb_global_tbl</name></expr></argument>, <argument><expr><name>mark_global_entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name></type>
<name>global_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>vbuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_intern2</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name></type>
<name>find_global_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_check_id_cstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>vbuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>vbuf</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_check_id_cstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>vbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_define_hooked_variable</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
<parameter><decl><type><name>rb_gvar_getter_t</name> <modifier>*</modifier></type><name>getter</name></decl></parameter>,
<parameter><decl><type><name>rb_gvar_setter_t</name> <modifier>*</modifier></type><name>setter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>tmp</name> <init>= <expr><ternary><condition><expr><name>var</name></expr> ?</condition><then> <expr><operator>*</operator><name>var</name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>global_id</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>gvar</name> <init>= <expr><call><name>rb_global_entry</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>var</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>gvar</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>var</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gvar</name><operator>-&gt;</operator><name>getter</name></name> <operator>=</operator> <ternary><condition><expr><name>getter</name></expr> ?</condition><then> <expr><operator>(</operator><name>rb_gvar_getter_t</name> <operator>*</operator><operator>)</operator><name>getter</name></expr> </then><else>: <expr><name>rb_gvar_var_getter</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gvar</name><operator>-&gt;</operator><name>setter</name></name> <operator>=</operator> <ternary><condition><expr><name>setter</name></expr> ?</condition><then> <expr><operator>(</operator><name>rb_gvar_setter_t</name> <operator>*</operator><operator>)</operator><name>setter</name></expr> </then><else>: <expr><name>rb_gvar_var_setter</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gvar</name><operator>-&gt;</operator><name>marker</name></name> <operator>=</operator> <name>rb_gvar_var_marker</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_define_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_define_hooked_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_define_readonly_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_define_hooked_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>var</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_gvar_readonly_setter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_define_virtual_variable</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>rb_gvar_getter_t</name> <modifier>*</modifier></type><name>getter</name></decl></parameter>,
<parameter><decl><type><name>rb_gvar_setter_t</name> <modifier>*</modifier></type><name>setter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>getter</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>getter</name> <operator>=</operator> <name>rb_gvar_val_getter</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>setter</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>setter</name> <operator>=</operator> <name>rb_gvar_readonly_setter</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_define_hooked_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>getter</name></expr></argument>, <argument><expr><name>setter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_trace_eval</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_eval_cmd_kw</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RB_NO_KEYWORDS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_f_trace_var</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>var</name></decl>, <decl><type ref="prev"/><name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>trace</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_f_untrace_var</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>rb_global_entry</name><argument_list>(<argument><expr><call><name>rb_to_id</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>trace_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>trace</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>rb_trace_eval</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>removed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <name>trace</name></expr>;</expr_stmt>

<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_trace</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>trace</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>trace</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>t</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>trace</name></expr>;</expr_stmt>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <operator>&amp;</operator><name>t</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>trace</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>trace</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>next</name><operator>-&gt;</operator><name>removed</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>trace</name></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_f_untrace_var</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>var</name></decl>, <decl><type ref="prev"/><name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>trace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_name_error_str</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="string">"undefined global variable %"</literal><name>PRIsVALUE</name><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>QUOTE</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>rb_global_tbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_name_error</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="string">"undefined global variable %"</literal><name>PRIsVALUE</name><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>trace</name> <operator>=</operator> <operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator>struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator><name>data</name><operator>)</operator><operator>-&gt;</operator><name><name>var</name><operator>-&gt;</operator><name>trace</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>trace</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>trace</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>trace</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>removed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>block_trace</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>remove_trace</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<while>while <condition>(<expr><name>trace</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>trace</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>cmd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>trace</name><operator>-&gt;</operator><name>removed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>block_trace</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>remove_trace</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <name><name>trace</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_gvar_get</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>var</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call>(<modifier>*</modifier><name><name>var</name><operator>-&gt;</operator><name>getter</name></name>)<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>trace_data</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>trace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>trace_ev</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>trace</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>trace</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>trace</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>trace</name><operator>-&gt;</operator><name>func</name></name>)<argument_list>(<argument><expr><name><name>trace</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <name><name>trace</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>trace_en</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>block_trace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>remove_trace</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qnil</name></expr>;</return> 
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_gvar_set</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_data</name></name></type> <name>trace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>var</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>var</name><operator>-&gt;</operator><name>setter</name></name>)<argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>trace</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>block_trace</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>block_trace</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trace</name><operator>.</operator><name>trace</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>trace</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trace</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>trace_ev</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>trace</name></expr></argument>, <argument><expr><name>trace_en</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_gv_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>rb_global_entry</name><argument_list>(<argument><expr><call><name>global_id</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_gvar_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_gv_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>find_global_id</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"global variable `%s' not initialized"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>rb_global_entry</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_gvar_get</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_gvar_defined</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>getter</name></name> <operator>==</operator> <name>rb_gvar_undef_getter</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_gvar_getter_t</name> <modifier>*</modifier></type>
<name>rb_gvar_getter_function_of</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>getter</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_gvar_setter_t</name> <modifier>*</modifier></type>
<name>rb_gvar_setter_function_of</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>setter</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>rb_gvar_is_traced</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>!</operator><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>trace</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>
<name>gvar_i</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_f_global_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>sym</name></decl>, <decl><type ref="prev"/><name>backref</name> <init>= <expr><call><name>rb_backref_get</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><name>rb_global_tbl</name></expr></argument>, <argument><expr><name>gvar_i</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nmatch</name> <init>= <expr><call><name>rb_match_count</name><argument_list>(<argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nmatch</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_match_nth_defined</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>backref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><operator>(</operator><name>i</name> <operator>+</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name> <operator>=</operator> <call><name>ID2SYM</name><argument_list>(<argument><expr><call><name>rb_intern2</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <call><name>rb_str_intern</name><argument_list>(<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_alias_variable</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>name1</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>name2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_entry</name></name> <modifier>*</modifier></type><name>entry1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>entry2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>data1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>entry2</name> <operator>=</operator> <call><name>rb_global_entry</name><argument_list>(<argument><expr><name>name2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>rb_global_tbl</name></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>entry1</name> <operator>=</operator> <call><name>ALLOC</name><argument_list>(<argument><expr>struct <name>rb_global_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry1</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>name1</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>rb_global_tbl</name></expr></argument>, <argument><expr><name>name1</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>entry1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>entry1</name> <operator>=</operator> <operator>(</operator>struct <name>rb_global_entry</name> <operator>*</operator><operator>)</operator><name>data1</name><operator>)</operator><operator>-&gt;</operator><name>var</name> <operator>!=</operator> <name><name>entry2</name><operator>-&gt;</operator><name>var</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_global_variable</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>entry1</name><operator>-&gt;</operator><name>var</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>block_trace</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"can't alias in tracer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>counter</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>counter</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>trace</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>trace</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>trace</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>trace_var</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>trace</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>trace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>trace</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>entry2</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>counter</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry1</name><operator>-&gt;</operator><name>var</name></name> <operator>=</operator> <name><name>entry2</name><operator>-&gt;</operator><name>var</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>gen_ivtbl_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>ivtbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>generic_iv_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ivtbl</name> <operator>=</operator> <operator>(</operator>struct <name>gen_ivtbl</name> <operator>*</operator><operator>)</operator><name>data</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type>
<name>rb_ivar_generic_ivtbl</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>generic_iv_tbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>generic_ivar_delete</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>undef</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>iv_index_tbl</name> <init>= <expr><call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>ret</name> <operator>==</operator> <name>Qundef</name></expr> ?</condition><then> <expr><name>undef</name></expr> </then><else>: <expr><name>ret</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>undef</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>generic_ivar_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>undef</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>iv_index_tbl</name> <init>= <expr><call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>ret</name> <operator>==</operator> <name>Qundef</name></expr> ?</condition><then> <expr><name>undef</name></expr> </then><else>: <expr><name>ret</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>undef</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>gen_ivtbl_bytes</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>gen_ivtbl</name></expr></argument>, <argument><expr><name>ivptr</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type>
<name>gen_ivtbl_resize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name>old</name></expr> ?</condition><then> <expr><name><name>old</name><operator>-&gt;</operator><name>numiv</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name> <init>= <expr><call><name>xrealloc</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><call><name>gen_ivtbl_bytes</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>len</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>ivtbl</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static struct gen_ivtbl *
gen_ivtbl_dup(const struct gen_ivtbl *orig)
{
size_t s = gen_ivtbl_bytes(orig-&gt;numiv);
struct gen_ivtbl *ivtbl = xmalloc(s);

memcpy(ivtbl, orig, s);

return ivtbl;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>iv_index_tbl_newsize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ivar_update</name></name> <modifier>*</modifier></type><name>ivup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>index</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ivup</name><operator>-&gt;</operator><name>index</name></name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>uint32_t</name></type> <name>newsize</name> <init>= <expr><operator>(</operator><name>index</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>index</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">4</literal></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ivup</name><operator>-&gt;</operator><name>iv_extended</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>newsize</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>ivup</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iv_index_tbl</name><operator>-&gt;</operator><name>num_entries</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>newsize</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>generic_ivar_update</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>u</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>k</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ivar_update</name></name> <modifier>*</modifier></type><name>ivup</name> <init>= <expr><operator>(</operator>struct <name>ivar_update</name> <operator>*</operator><operator>)</operator><name>u</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>newsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>ST_CONTINUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ivtbl</name> <operator>=</operator> <operator>(</operator>struct <name>gen_ivtbl</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>v</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ivup</name><operator>-&gt;</operator><name>index</name></name> <operator>&gt;=</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>)</condition> <block>{<block_content>
<goto>goto <name>resize</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ST_STOP</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ivtbl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<label><name>resize</name>:</label>
<expr_stmt><expr><name>newsize</name> <operator>=</operator> <call><name>iv_index_tbl_newsize</name><argument_list>(<argument><expr><name>ivup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ivtbl</name> <operator>=</operator> <call><name>gen_ivtbl_resize</name><argument_list>(<argument><expr><name>ivtbl</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>ivtbl</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>ivup</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ivtbl</name></name> <operator>=</operator> <name>ivtbl</name></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>generic_ivar_defined</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>iv_index_tbl</name> <init>= <expr><call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iv_index_tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>index</name> <operator>&lt;</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name> <operator>!=</operator> <name>Qundef</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>generic_ivar_remove</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>valp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>iv_index_tbl</name> <init>= <expr><call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iv_index_tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>valp</name> <operator>=</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gen_ivtbl_mark</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_gc_mark</name><argument_list>(<argument><expr><name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_mark_generic_ivar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gen_ivtbl_mark</name><argument_list>(<argument><expr><name>ivtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_mv_generic_ivar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>rsrc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>rsrc</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_delete</name><argument_list>(<argument><expr><name>generic_iv_tbl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>generic_iv_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dst</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_free_generic_ivar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_delete</name><argument_list>(<argument><expr><name>generic_iv_tbl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>ivtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>RUBY_FUNC_EXPORTED</name> <name>size_t</name></type>
<name>rb_generic_ivar_memsize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gen_ivtbl_bytes</name><argument_list>(<argument><expr><name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>gen_ivtbl_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ivar_lookup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>undef</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>iv_index_tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>undef</name></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_OBJECT</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iv_index_tbl</name> <operator>=</operator> <call><name>ROBJECT_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iv_index_tbl</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>index</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>val</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>T_CLASS</name></expr>:</case>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>st_lookup</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>index</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>generic_ivar_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>undef</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>undef</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ivar_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>iv</name> <init>= <expr><call><name>rb_ivar_lookup</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ivar_get_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>iv</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"instance variable %"</literal><name>PRIsVALUE</name><literal type="string">" not initialized"</literal></expr></argument>, <argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>iv</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>iv</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_attr_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ivar_lookup</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ivar_delete</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>undef</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>iv_index_tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_OBJECT</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iv_index_tbl</name> <operator>=</operator> <call><name>ROBJECT_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iv_index_tbl</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>index</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>val</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>T_CLASS</name></expr>:</case>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>st_delete</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>index</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>generic_ivar_delete</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>undef</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>undef</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_attr_delete</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ivar_delete</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type>
<name>iv_index_tbl_make</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>iv_index_tbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>klass</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"hidden object cannot have instance variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>iv_index_tbl</name> <operator>=</operator> <call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>iv_index_tbl</name> <operator>=</operator> <call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>iv_index_tbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>iv_index_tbl_extend</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ivar_update</name></name> <modifier>*</modifier></type><name>ivup</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>ivup</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iv_index_tbl</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ivup</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ivup</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iv_index_tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>&gt;=</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"too many instance variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ivup</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>ivup</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iv_index_tbl</name><operator>-&gt;</operator><name>num_entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name><name>ivup</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>iv_index_tbl</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><name><name>ivup</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ivup</name><operator>-&gt;</operator><name>iv_extended</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>generic_ivar_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ivar_update</name></name></type> <name>ivup</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ivup</name><operator>.</operator><name>iv_extended</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ivup</name><operator>.</operator><name>u</name><operator>.</operator><name>iv_index_tbl</name></name> <operator>=</operator> <call><name>iv_index_tbl_make</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iv_index_tbl_extend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivup</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_update</name><argument_list>(<argument><expr><name>generic_iv_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>obj</name></expr></argument>, <argument><expr><name>generic_ivar_update</name></expr></argument>,
<argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>ivup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ivup</name><operator>.</operator><name>u</name><operator>.</operator><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name><name>ivup</name><operator>.</operator><name>index</name></name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name> <modifier>*</modifier></type>
<name>obj_ivar_heap_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>newptr</name> <init>= <expr><call><name>rb_transient_heap_alloc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>newptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ROBJ_TRANSIENT_SET</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ROBJ_TRANSIENT_UNSET</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newptr</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>newptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name> <modifier>*</modifier></type>
<name>obj_ivar_heap_realloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>newsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>newptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ROBJ_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>orig_ptr</name> <init>= <expr><call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ivptr</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>newptr</name> <operator>=</operator> <call><name>obj_ivar_heap_alloc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>newptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ivptr</name></name> <operator>=</operator> <name>newptr</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>newptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>orig_ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>REALLOC_N</name><argument_list>(<argument><expr><call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ivptr</name></name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newptr</name> <operator>=</operator> <call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ivptr</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>newptr</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_TRANSIENT_HEAP</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>rb_obj_transient_heap_evacuate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>promote</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ROBJ_TRANSIENT_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>len</name> <init>= <expr><call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>old_ptr</name> <init>= <expr><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>new_ptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>promote</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_ptr</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ROBJ_TRANSIENT_UNSET</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>new_ptr</name> <operator>=</operator> <call><name>obj_ivar_heap_alloc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>new_ptr</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ivptr</name></name> <operator>=</operator> <name>new_ptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>obj_ivar_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ivar_update</name></name></type> <name>ivup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ivup</name><operator>.</operator><name>iv_extended</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ivup</name><operator>.</operator><name>u</name><operator>.</operator><name>iv_index_tbl</name></name> <operator>=</operator> <call><name>iv_index_tbl_make</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iv_index_tbl_extend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivup</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name><name>ivup</name><operator>.</operator><name>index</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ivup</name><operator>.</operator><name>index</name></name> <operator>&lt;</operator> <name>ROBJECT_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <name>ROBJECT_EMBED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ROBJECT_EMBED_LEN_MAX</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>newptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>newsize</name> <init>= <expr><call><name>iv_index_tbl_newsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>ROBJECT_EMBED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>newptr</name> <operator>=</operator> <call><name>obj_ivar_heap_alloc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>newptr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>ROBJECT_EMBED</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ivptr</name></name> <operator>=</operator> <name>newptr</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>newptr</name> <operator>=</operator> <call><name>obj_ivar_heap_realloc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&lt;</operator> <name>newsize</name></expr>;</condition> <incr><expr><name>len</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>newptr</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>numiv</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ROBJECT</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>iv_index_tbl</name></name> <operator>=</operator> <name><name>ivup</name><operator>.</operator><name>u</name><operator>.</operator><name>iv_index_tbl</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><index>[<expr><name><name>ivup</name><operator>.</operator><name>index</name></name></expr>]</index></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ivar_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>ivar_set_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_OBJECT</name></expr>:</case>
<expr_stmt><expr><call><name>obj_ivar_set</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>T_CLASS</name></expr>:</case>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_class_ivar_set</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>generic_ivar_set</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ivar_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ivar_set</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ivar_set_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>rb_is_instance_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ivar_set</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ivar_defined</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>iv_index_tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_OBJECT</name></expr>:</case>
<expr_stmt><expr><name>iv_index_tbl</name> <operator>=</operator> <call><name>ROBJECT_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iv_index_tbl</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>index</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>T_CLASS</name></expr>:</case>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>st_is_member</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>generic_ivar_defined</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>int</name></type> <name>rb_ivar_foreach_callback_func</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>obj_ivar_tag</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_ivar_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>arg</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>obj_ivar_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>obj_ivar_tag</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>obj_ivar_tag</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call><index>[<expr><name>index</name></expr>]</index></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator><operator>(</operator><operator>(</operator><name>ID</name><operator>)</operator><name>key</name><operator>,</operator> <name>val</name><operator>,</operator> <name><name>data</name><operator>-&gt;</operator><name>arg</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>obj_ivar_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>rb_ivar_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>obj_ivar_tag</name></name></type> <name>data</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>ROBJECT_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>obj</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>func</name></name> <operator>=</operator> <operator>(</operator><macro><name>int</name> <argument_list>(<argument>*</argument>)</argument_list></macro><operator>(</operator><name>ID</name> <name>key</name><operator>,</operator> <name>VALUE</name> <name>val</name><operator>,</operator> <name>st_data_t</name> <name>arg</name><operator>)</operator><operator>)</operator><name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach_safe</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>obj_ivar_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>gen_ivar_tag</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_ivar_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>arg</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>gen_ivar_each_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivar_tag</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>gen_ivar_tag</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name><name>arg</name><operator>-&gt;</operator><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name><name>arg</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator><operator>(</operator><operator>(</operator><name>ID</name><operator>)</operator><name>key</name><operator>,</operator> <name>val</name><operator>,</operator> <name><name>arg</name><operator>-&gt;</operator><name>arg</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gen_ivar_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>rb_ivar_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivar_tag</name></name></type> <name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>iv_index_tbl</name> <init>= <expr><call><name>RCLASS_IV_INDEX_TBL</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iv_index_tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>ivtbl</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>.</operator><name>func</name></name> <operator>=</operator> <operator>(</operator><macro><name>int</name> <argument_list>(<argument>*</argument>)</argument_list></macro><operator>(</operator><name>ID</name> <name>key</name><operator>,</operator> <name>VALUE</name> <name>val</name><operator>,</operator> <name>st_data_t</name> <name>arg</name><operator>)</operator><operator>)</operator><name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>st_foreach_safe</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><name>gen_ivar_each_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>givar_copy</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>iv_index_tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>gen_ivar_copy</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>givar_copy</name></name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator>struct <name>givar_copy</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ivar_update</name></name></type> <name>ivup</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ivup</name><operator>.</operator><name>iv_extended</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ivup</name><operator>.</operator><name>u</name><operator>.</operator><name>iv_index_tbl</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>iv_index_tbl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iv_index_tbl_extend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivup</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ivup</name><operator>.</operator><name>index</name></name> <operator>&gt;=</operator> <name><name>c</name><operator>-&gt;</operator><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>newsize</name> <init>= <expr><call><name>iv_index_tbl_newsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>ivtbl</name></name> <operator>=</operator> <call><name>gen_ivtbl_resize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>ivtbl</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name><name>ivup</name><operator>.</operator><name>index</name></name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_copy_generic_ivar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>clone</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<label><name>clear</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_free_generic_ivar</name><argument_list>(<argument><expr><name>clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>givar_copy</name></name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gen_ivtbl_count</name><argument_list>(<argument><expr><name>ivtbl</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>clear</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>.</operator><name>ivtbl</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>.</operator><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>ivtbl</name><operator>-&gt;</operator><name>ivptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>ivtbl</name></name> <operator>=</operator> <call><name>gen_ivtbl_resize</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ivtbl</name><operator>-&gt;</operator><name>numiv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>clone</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>c</name><operator>.</operator><name>iv_index_tbl</name></name> <operator>=</operator> <call><name>iv_index_tbl_make</name><argument_list>(<argument><expr><name>clone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>.</operator><name>obj</name></name> <operator>=</operator> <name>clone</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_ivar_each</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>gen_ivar_copy</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>generic_iv_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>clone</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name><name>c</name><operator>.</operator><name>ivtbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ivar_foreach</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>rb_ivar_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_OBJECT</name></expr>:</case>
<expr_stmt><expr><call><name>obj_ivar_each</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>T_CLASS</name></expr>:</case>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_foreach_safe</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gen_ivar_each</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>st_index_t</name></type>
<name>rb_ivar_count</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_OBJECT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tbl</name> <operator>=</operator> <call><name>ROBJECT_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>num</name> <init>= <expr><call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>ivptr</name> <init>= <expr><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ivptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>T_CLASS</name></expr>:</case>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tbl</name> <operator>=</operator> <call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>tbl</name><operator>-&gt;</operator><name>num_entries</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>gen_ivtbl</name></name> <modifier>*</modifier></type><name>ivtbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gen_ivtbl_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ivtbl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>gen_ivtbl_count</name><argument_list>(<argument><expr><name>ivtbl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ivar_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>ID</name><operator>)</operator><name>k</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_is_instance_id</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>


















<function><type><name>VALUE</name></type>
<name>rb_obj_instance_variables</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_foreach</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ivar_i</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_is_constant_id</name></cpp:macro> <cpp:value>rb_is_const_id</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_is_constant_name</name></cpp:macro> <cpp:value>rb_is_const_name</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_for_var</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>part</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>id_for_var_message(obj, name, type, "`%1$s' is not allowed as "#part" "#type" variable name")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_for_var_message</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>, <parameter><type><name>name</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>message</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>check_id_type(obj, &amp;(name), rb_is_##type##_id, rb_is_##type##_name, message, strlen(message))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>ID</name></type>
<name>check_id_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>pname</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>valid_id_p</name>)<parameter_list>(<parameter><decl><type><name>ID</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>valid_name_p</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>message_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id</name><argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><operator>*</operator><name>pname</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>id</name></expr> ?</condition><then> <expr><operator>!</operator><call><name>valid_id_p</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>!</operator><call><name>valid_name_p</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_name_err_raise_str</name><argument_list>(<argument><expr><call><name>rb_fstring_new</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>message_len</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

























<function><type><name>VALUE</name></type>
<name>rb_obj_remove_instance_variable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id</name> <init>= <expr><call><name>id_for_var</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>an</name></expr></argument>, <argument><expr><name>instance</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>iv_index_tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>index</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>not_defined</name>;</goto>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_OBJECT</name></expr>:</case>
<expr_stmt><expr><name>iv_index_tbl</name> <operator>=</operator> <call><name>ROBJECT_IV_INDEX_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iv_index_tbl</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>iv_index_tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ROBJECT_NUMIV</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>index</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ROBJECT_IVPTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><index>[<expr><name>index</name></expr>]</index> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>T_CLASS</name></expr>:</case>
<case>case <expr><name>T_MODULE</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>st_delete</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>v</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>generic_ivar_remove</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>

<label><name>not_defined</name>:</label>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"instance variable %1$s not defined"</literal></expr></argument>,
<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void uninitialized_constant(VALUE, VALUE)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>uninitialized_constant</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>&amp;&amp;</operator> <call><name>rb_class_real</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rb_cObject</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"uninitialized constant %2$s::%1$s"</literal></expr></argument>,
<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"uninitialized constant %1$s"</literal></expr></argument>,
<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_const_missing</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name> <init>= <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>idConst_missing</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_vm_inc_const_missing_count</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>






































<function><type><name>VALUE</name></type>
<name>rb_mod_const_missing</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ref</name> <init>= <expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>private_const_reference</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_vm_pop_cfunc_frame</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"private constant %2$s::%1$s referenced"</literal></expr></argument>,
<argument><expr><name>ref</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>uninitialized_constant</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>UNREACHABLE_RETURN</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_mark_tbl_no_pin</name><argument_list>(<argument><expr><operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>autoload_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>st_table</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>st_memsize</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_gc_update_tbl_refs</name><argument_list>(<argument><expr><operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>autoload_data_type</name> <init>= <expr><block>{
<expr><literal type="string">"autoload"</literal></expr>,
<expr><block>{<expr><name>autoload_mark</name></expr>, <expr><name>autoload_free</name></expr>, <expr><name>autoload_memsize</name></expr>, <expr><name>autoload_compact</name></expr>,}</block></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_autoload_table</name><parameter_list>(<parameter><type><name>av</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(struct st_table *)rb_check_typeddata((av), &amp;autoload_data_type)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>autoload_data</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>autoload</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><operator>(</operator><name>tbl</name> <operator>=</operator> <call><name>check_autoload_table</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>!</operator><call><name>st_lookup</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>autoload_const</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name></type> <name>cnode</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>VALUE</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ad</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_flag_t</name></type> <name>flag</name></decl>;</decl_stmt>
}</block>;</struct>


<struct>struct <name>autoload_state</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>thread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>list_node</name></name></type> <name>waitq</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>autoload_data_i</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>feature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_state</name></name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>rb_serial_t</name></type> <name>fork_gen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>list_head</name></name></type> <name>constants</name></decl>;</decl_stmt> 
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_i_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>feature</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>feature</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_i_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>feature</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>constants</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_delete</name><argument_list>(<argument><expr><name>autoload_featuremap</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>feature</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_i_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>list_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>constants</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>autoload_i_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>autoload_data_i</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>autoload_data_i_type</name> <init>= <expr><block>{
<expr><literal type="string">"autoload_i"</literal></expr>,
<expr><block>{<expr><name>autoload_i_mark</name></expr>, <expr><name>autoload_i_free</name></expr>, <expr><name>autoload_i_memsize</name></expr>, <expr><name>autoload_i_compact</name></expr>}</block></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_c_compact</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>mod</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>mod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>ad</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>ad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>rb_gc_location</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_c_mark</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>mod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>ad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_mark_movable</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_c_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>cnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>autoload_c_memsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>autoload_const</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>autoload_const_type</name> <init>= <expr><block>{
<expr><literal type="string">"autoload_const"</literal></expr>,
<expr><block>{<expr><name>autoload_c_mark</name></expr>, <expr><name>autoload_c_free</name></expr>, <expr><name>autoload_c_memsize</name></expr>, <expr><name>autoload_c_compact</name></expr>,}</block></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type>
<name>get_autoload_data</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>acv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>acp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>acv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>autoload_const_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>ad</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>autoload_data_i_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ele</name> <operator>&amp;&amp;</operator> <name><name>ele</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;&amp;</operator> <name><name>ele</name><operator>-&gt;</operator><name>fork_gen</name></name> <operator>!=</operator> <call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>fork_gen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>fork_gen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>acp</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>acp</name> <operator>=</operator> <name>ac</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ele</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>RUBY_FUNC_EXPORTED</name> <name>void</name></type>
<name>rb_autoload</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>file</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>file</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"empty file name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_autoload_str</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_autoload_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>av</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_const_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eNameError</name></expr></argument>, <argument><expr><literal type="string">"autoload must be constant name: %"</literal><name>PRIsVALUE</name><literal type="string">""</literal></expr></argument>,
<argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"empty file name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ce</name> <operator>&amp;&amp;</operator> <name><name>ce</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_const_set</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tbl</name> <operator>&amp;&amp;</operator> <call><name>st_lookup</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>autoload</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>av</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>check_autoload_table</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>av</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>autoload_data_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>autoload</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tbl</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>autoload_featuremap</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>autoload_featuremap</name> <operator>=</operator> <call><name>rb_ident_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_obj_hide</name><argument_list>(<argument><expr><name>autoload_featuremap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>autoload_featuremap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ad</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>autoload_featuremap</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ad</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ad</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr>struct <name>autoload_data_i</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>autoload_data_i_type</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>feature</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ele</name><operator>-&gt;</operator><name>constants</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>autoload_featuremap</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>ad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name>ad</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>autoload_data_i_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>acv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>
<expr_stmt><expr><name>acv</name> <operator>=</operator> <call><name>TypedData_Make_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr>struct <name>autoload_const</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>autoload_const_type</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>mod</name></name> <operator>=</operator> <name>mod</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>CONST_PUBLIC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>ad</name></name> <operator>=</operator> <name>ad</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_add_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ele</name><operator>-&gt;</operator><name>constants</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>cnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>acv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoload_delete</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>, <decl><type ref="prev"/><name>load</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><name>id</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>autoload</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>check_autoload_table</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>load</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>get_autoload_data</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ele</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>VM_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>list_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ele</name><operator>-&gt;</operator><name>constants</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><call><name>list_del_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>cnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tbl</name><operator>-&gt;</operator><name>num_entries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>autoload</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>check_autoload_required</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>loadingpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>load</name> <init>= <expr><call><name>autoload_data</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loading</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>load</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>ele</name> <operator>=</operator> <call><name>get_autoload_data</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>file</name> <operator>=</operator> <name><name>ele</name><operator>-&gt;</operator><name>feature</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><operator>*</operator><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"empty file name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name><name>ele</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;&amp;</operator> <name><name>ele</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>thread</name></name> <operator>!=</operator> <call><name>rb_thread_current</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>load</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>loading</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_feature_provided</name><argument_list>(<argument><expr><name>loading</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loading</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>load</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>loadingpath</name> <operator>&amp;&amp;</operator> <name>loading</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>loadingpath</name> <operator>=</operator> <name>loading</name></expr>;</expr_stmt>
<return>return <expr><name>load</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>autoloading_const_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>int</name></type>
<name>rb_autoloading_value</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name><modifier>*</modifier></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>rb_const_flag_t</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><call><name>autoloading_const_entry</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ac</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>ac</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>flag</name> <operator>=</operator> <name><name>ac</name><operator>-&gt;</operator><name>flag</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type>
<name>autoloading_const_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>load</name> <init>= <expr><call><name>autoload_data</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>load</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>ele</name> <operator>=</operator> <call><name>get_autoload_data</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ac</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ele</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;&amp;</operator> <name><name>ele</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>thread</name></name> <operator>==</operator> <call><name>rb_thread_current</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ac</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>autoload_defined_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ce</name> <operator>||</operator> <name><name>ce</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>!</operator><call><name>rb_autoloading_value</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>const_tbl_update</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>autoload_const_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><operator>(</operator>struct <name>autoload_const</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><name><name>ac</name><operator>-&gt;</operator><name>mod</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>ac</name><operator>-&gt;</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check_before_mod_set</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"constant"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>const_tbl_update</name><argument_list>(<argument><expr><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>autoload_require</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_state</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator>struct <name>autoload_state</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>ac</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>ad</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>autoload_data_i_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><call><name>rb_vm_top_self</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"require"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>feature</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>autoload_reset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_state</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator>struct <name>autoload_state</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_wakeups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>ac</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>rb_check_typeddata</name><argument_list>(<argument><expr><name><name>ac</name><operator>-&gt;</operator><name>ad</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>autoload_data_i_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ele</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>state</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_wakeups</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>fork_gen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<macro><name>list_for_each_safe</name><argument_list>(<argument>&amp;ele-&gt;constants</argument>, <argument>ac</argument>, <argument>next</argument>, <argument>cnode</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>autoload_const_set</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>need_wakeups</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_state</name></name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nxt</name></decl>;</decl_stmt>

<macro><name>list_for_each_safe</name><argument_list>(<argument>(struct list_head *)&amp;state-&gt;waitq</argument>, <argument>cur</argument>, <argument>nxt</argument>, <argument>waitq</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>th</name> <init>= <expr><name><name>cur</name><operator>-&gt;</operator><name>thread</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>thread</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>list_del_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cur</name><operator>-&gt;</operator><name>waitq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 





<expr_stmt><expr><call><name>rb_thread_wakeup_alive</name><argument_list>(<argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return> 
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>autoload_sleep</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_state</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator>struct <name>autoload_state</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>





<do>do <block>{<block_content>
<expr_stmt><expr><call><name>rb_thread_sleep_deadly</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>thread</name></name> <operator>!=</operator> <name>Qfalse</name></expr>)</condition>;</do>

<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>autoload_sleep_done</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_state</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator>struct <name>autoload_state</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>thread</name></name> <operator>!=</operator> <name>Qfalse</name> <operator>&amp;&amp;</operator> <call><name>rb_thread_to_be_killed</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>thread</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>list_del</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>waitq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>

<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_autoload_load</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>load</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loading</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_state</name></name></type> <name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>autoload_defined_p</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>load</name> <operator>=</operator> <call><name>check_autoload_required</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loading</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>load</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>rb_sourcefile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <name>loading</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>loading</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;</operator> <operator>(</operator><name>CONST_DEPRECATED</name> <operator>|</operator> <name>CONST_VISIBILITY_MASK</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ele</name> <operator>=</operator> <call><name>get_autoload_data</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ac</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>ac</name></name> <operator>=</operator> <name>ac</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>thread</name></name> <operator>=</operator> <call><name>rb_thread_current</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ele</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <operator>&amp;</operator><name>state</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ele</name><operator>-&gt;</operator><name>fork_gen</name></name> <operator>=</operator> <call><name>GET_VM</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>fork_gen</name></expr>;</expr_stmt>





<expr_stmt><expr><call><name>list_head_init</name><argument_list>(<argument><expr><operator>(</operator>struct <name>list_head</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>state</name><operator>.</operator><name>waitq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>.</operator><name>thread</name></name> <operator>==</operator> <name><name>ele</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>thread</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>list_add_tail</name><argument_list>(<argument><expr><operator>(</operator>struct <name>list_head</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ele</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>waitq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>.</operator><name>waitq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>autoload_sleep</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>,
<argument><expr><name>autoload_sleep_done</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name><name>state</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ensure</name><argument_list>(<argument><expr><name>autoload_require</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>,
<argument><expr><name>autoload_reset</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>flag</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>load</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_autoload_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_autoload_at_p</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_autoload_at_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>load</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>autoload_defined_p</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recur</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>mod</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mod</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>load</name> <operator>=</operator> <call><name>check_autoload_required</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>load</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>ele</name> <operator>=</operator> <call><name>get_autoload_data</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name><name>ele</name><operator>-&gt;</operator><name>feature</name></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>void</name></type>
<name>rb_const_warn_if_deprecated</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RB_CONST_DEPRECATED_P</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>rb_warning_category_enabled_p</name><argument_list>(<argument><expr><name>RB_WARN_CATEGORY_DEPRECATED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"constant ::%"</literal><name>PRIsVALUE</name><literal type="string">" is deprecated"</literal></expr></argument>, <argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"constant %"</literal><name>PRIsVALUE</name><literal type="string">"::%"</literal><name>PRIsVALUE</name><literal type="string">" is deprecated"</literal></expr></argument>,
<argument><expr><call><name>rb_class_name</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_const_get_0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>visibility</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name> <init>= <expr><call><name>rb_const_search</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>visibility</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_const_missing</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_const_search_from</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>visibility</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>am</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>visibility</name> <operator>&amp;&amp;</operator> <call><name>RB_CONST_PRIVATE_P</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ICLASS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>private_const_reference</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<return>return <expr><name>Qundef</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_const_warn_if_deprecated</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>am</name> <operator>==</operator> <name>tmp</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>am</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ac</name> <operator>=</operator> <call><name>autoloading_const_entry</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ac</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_autoload_load</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>exclude</name> <operator>&amp;&amp;</operator> <name>tmp</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>not_found</name>;</goto>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<label><name>not_found</name>:</label>
<expr_stmt><expr><call><name>GET_EC</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>private_const_reference</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>Qundef</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_const_search</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>visibility</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>exclude</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>rb_const_search_from</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>visibility</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>value</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>exclude</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>value</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_MODULE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>value</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_const_search_from</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>visibility</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_const_get_from</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_get_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_const_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_get_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_const_get_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_get_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_public_const_get_from</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_get_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_public_const_get_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_get_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void undefined_constant(VALUE mod, VALUE name)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>undefined_constant</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"constant %2$s::%1$s not defined"</literal></expr></argument>,
<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_const_location_from</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>visibility</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>visibility</name> <operator>&amp;&amp;</operator> <call><name>RB_CONST_PRIVATE_P</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>exclude</name> <operator>&amp;&amp;</operator> <name>klass</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>not_found</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<label><name>not_found</name>:</label>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_const_location</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>visibility</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>loc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>exclude</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>loc</name> <operator>=</operator> <call><name>rb_const_location_from</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>visibility</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>loc</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>exclude</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>loc</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_MODULE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>loc</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>rb_const_location_from</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>visibility</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_const_source_location</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_location</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_const_source_location_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_location</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>











<function><type><name>VALUE</name></type>
<name>rb_mod_remove_const</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id</name> <init>= <expr><call><name>id_for_var</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>constant</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>undefined_constant</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_const_remove</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_const_remove</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ce</name> <operator>||</operator> <operator>!</operator><call><name>rb_id_table_delete</name><argument_list>(<argument><expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_const_defined_at</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"cannot remove %2$s::%1$s"</literal></expr></argument>,
<argument><expr><name>mod</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>undefined_constant</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_clear_constant_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>autoload_delete</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cv_i_update</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_STOP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>
<name>sv_i</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><name>rb_const_entry_t</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_is_const_id</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_update</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><name>cv_i_update</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>
<name>rb_local_constants_i</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>const_name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>const_value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_is_const_id</name><argument_list>(<argument><expr><name>const_name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_CONST_PRIVATE_P</name><argument_list>(<argument><expr><operator>(</operator><name>rb_const_entry_t</name> <operator>*</operator><operator>)</operator><name>const_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ary</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>const_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_local_constants</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><call><name>rb_id_table_size</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>rb_local_constants_i</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type>
<name>rb_mod_const_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sv_i</name></expr></argument>, <argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>tbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type>
<name>rb_mod_const_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><name>mod</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>rb_mod_const_at</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>rb_cObject</name> <operator>&amp;&amp;</operator> <name>mod</name> <operator>!=</operator> <name>rb_cObject</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>list_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>sym</name> <init>= <expr><operator>(</operator><name>ID</name><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><name>rb_const_entry_t</name> <operator>*</operator><operator>)</operator><name>value</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_CONST_PUBLIC_P</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_const_list</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_foreach_safe</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>list_i</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>



















<function><type><name>VALUE</name></type>
<name>rb_mod_constants</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>inherit</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>inherit</name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>inherit</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_const_list</name><argument_list>(<argument><expr><call><name>rb_mod_const_of</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_local_constants</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_const_defined_0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exclude</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recurse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>visibility</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mod_retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>
<label><name>retry</name>:</label>
<while>while <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>visibility</name> <operator>&amp;&amp;</operator> <call><name>RB_CONST_PRIVATE_P</name><argument_list>(<argument><expr><name>ce</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>Qfalse</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>check_autoload_required</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>rb_autoloading_value</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exclude</name> <operator>&amp;&amp;</operator> <name>tmp</name> <operator>==</operator> <name>rb_cObject</name> <operator>&amp;&amp;</operator> <name>klass</name> <operator>!=</operator> <name>rb_cObject</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>Qfalse</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>Qtrue</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>recurse</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exclude</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>mod_retry</name> <operator>&amp;&amp;</operator> <call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_MODULE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mod_retry</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>rb_cObject</name></expr>;</expr_stmt>
<goto>goto <name>retry</name>;</goto>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_const_defined_from</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_defined_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_const_defined</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_defined_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_const_defined_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_defined_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>int</name></type>
<name>rb_public_const_defined_from</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_const_defined_0</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_before_mod_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_namespace_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>named_namespace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>rb_id_table_iterator_result</name></name></type>
<name>set_namespace_path_i</name><parameter_list>(<parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>payload</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>(</operator><name>rb_const_entry_t</name> <operator>*</operator><operator>)</operator><name>v</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name> <init>= <expr><name><name>ce</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_permanent_classpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>parental_path</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator> <name>payload</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_const_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_namespace_p</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>classname</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_permanent_classpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_permanent_classpath</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>set_namespace_path</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>build_const_path</name><argument_list>(<argument><expr><name>parental_path</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>tmp</name> <init>= <expr><name>tmp_classpath</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ID_TABLE_CONTINUE</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_namespace_path</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>named_namespace</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>namespace_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>const_table</name> <init>= <expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>named_namespace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>named_namespace</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>named_namespace</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_class_ivar_set</name><argument_list>(<argument><expr><name>named_namespace</name></expr></argument>, <argument><expr><name>classpath</name></expr></argument>, <argument><expr><name>namespace_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>const_table</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_id_table_foreach</name><argument_list>(<argument><expr><name>const_table</name></expr></argument>, <argument><expr><name>set_namespace_path_i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namespace_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_const_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"no class/module to define constant %"</literal><name>PRIsVALUE</name><literal type="string">""</literal></expr></argument>,
<argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>check_before_mod_set</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"constant"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tbl</name> <operator>=</operator> <call><name>rb_id_table_create</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_clear_constant_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>rb_const_entry_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setup_const_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>CONST_PUBLIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name></type> <name>ac</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ac</name><operator>.</operator><name>mod</name></name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>.</operator><name>flag</name></name> <operator>=</operator> <name>CONST_PUBLIC</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>const_tbl_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name>rb_cObject</name> <operator>&amp;&amp;</operator> <call><name>rb_namespace_p</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>val_path_permanent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val_path</name> <init>= <expr><call><name>classname</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_path_permanent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val_path</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><name>val_path_permanent</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_namespace_path</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>rb_id2str</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>parental_path_permanent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>parental_path</name> <init>= <expr><call><name>classname</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parental_path_permanent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>parental_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parental_path_permanent</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>val_path_permanent</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_namespace_path</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><call><name>build_const_path</name><argument_list>(<argument><expr><name>parental_path</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>parental_path_permanent</name> <operator>&amp;&amp;</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name>val_path</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>tmp_classpath</name></expr></argument>, <argument><expr><call><name>build_const_path</name><argument_list>(<argument><expr><name>parental_path</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type>
<name>current_autoload_data</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>acp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>load</name> <init>= <expr><call><name>autoload_data</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>load</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>get_autoload_data</name><argument_list>(<argument><expr><name>load</name></expr></argument>, <argument><expr><name>acp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ele</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ele</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ele</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>thread</name></name> <operator>==</operator> <call><name>rb_thread_current</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ele</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>const_tbl_update</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name> <init>= <expr><name><name>ac</name><operator>-&gt;</operator><name>mod</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><name><name>ac</name><operator>-&gt;</operator><name>id</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_flag_t</name></type> <name>visibility</name> <init>= <expr><name><name>ac</name><operator>-&gt;</operator><name>flag</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ce</name> <operator>=</operator> <operator>(</operator><name>rb_const_entry_t</name> <operator>*</operator><operator>)</operator><name>value</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><call><name>current_autoload_data</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ac</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ele</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_clear_constant_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt> 
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>autoload_delete</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>name</name> <init>= <expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>visibility</name> <operator>=</operator> <name><name>ce</name><operator>-&gt;</operator><name>flag</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>klass</name> <operator>==</operator> <name>rb_cObject</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"already initialized constant %"</literal><name>PRIsVALUE</name><literal type="string">""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"already initialized constant %"</literal><name>PRIsVALUE</name><literal type="string">"::%"</literal><name>PRIsVALUE</name><literal type="string">""</literal></expr></argument>,
<argument><expr><call><name>rb_class_name</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ce</name><operator>-&gt;</operator><name>line</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_compile_warn</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>line</name></name></expr></argument>,
<argument><expr><literal type="string">"previous definition of %"</literal><name>PRIsVALUE</name><literal type="string">" was here"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_clear_constant_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setup_const_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>visibility</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_clear_constant_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <call><name>ZALLOC</name><argument_list>(<argument><expr><name>rb_const_entry_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_id_table_insert</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setup_const_entry</name><argument_list>(<argument><expr><name>ce</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>visibility</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_const_entry</name><parameter_list>(<parameter><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>,
<parameter><decl><type><name>rb_const_flag_t</name></type> <name>visibility</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name>visibility</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><call><name>rb_source_location</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ce</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_define_const</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_const_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"rb_define_const: invalid name `%s' for constant"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_const_set</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_define_global_const</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_const_visibility</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>,
<parameter><decl><type><name>rb_const_flag_t</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>rb_const_flag_t</name></type> <name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_class_modify_check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"%"</literal><name>PRIsVALUE</name><literal type="string">" with no argument is just ignored"</literal></expr></argument>,
<argument><expr><call><name>QUOTE_ID</name><argument_list>(<argument><expr><call><name>rb_frame_callee</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_const</name></name> <modifier>*</modifier></type><name>ac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>rb_check_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_clear_constant_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>undefined_constant</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>flag</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ce</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>autoload_data_i</name></name> <modifier>*</modifier></type><name>ele</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>current_autoload_data</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ele</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ac</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>flag</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_clear_constant_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>undefined_constant</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>rb_clear_constant_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_deprecate_constant</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_const_entry_t</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_class_modify_check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>id</name> <operator>=</operator> <call><name>rb_check_id_cstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>undefined_constant</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><call><name>rb_fstring_new</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ce</name> <operator>=</operator> <call><name>rb_const_lookup</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>undefined_constant</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ce</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>CONST_DEPRECATED</name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><name>VALUE</name></type>
<name>rb_mod_private_constant</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>set_const_visibility</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>CONST_PRIVATE</name></expr></argument>, <argument><expr><name>CONST_VISIBILITY_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>








<function><type><name>VALUE</name></type>
<name>rb_mod_public_constant</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>set_const_visibility</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>CONST_PUBLIC</name></expr></argument>, <argument><expr><name>CONST_VISIBILITY_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>




















<function><type><name>VALUE</name></type>
<name>rb_mod_deprecate_constant</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>set_const_visibility</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>CONST_DEPRECATED</name></expr></argument>, <argument><expr><name>CONST_DEPRECATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>original_module</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_ICLASS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cvar_lookup_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>st_lookup</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>cvar_front_klass</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id__attached__</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_namespace_p</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cvar_overtaken</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>front</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>target</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>front</name> <operator>&amp;&amp;</operator> <name>target</name> <operator>!=</operator> <name>front</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>did</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>id</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>original_module</name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>original_module</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"class variable % "</literal><name>PRIsVALUE</name><literal type="string">" of %"</literal><name>PRIsVALUE</name><literal type="string">" is overtaken by %"</literal><name>PRIsVALUE</name><literal type="string">""</literal></expr></argument>,
<argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_class_name</name><argument_list>(<argument><expr><call><name>original_module</name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>rb_class_name</name><argument_list>(<argument><expr><call><name>original_module</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_CLASS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>front</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>did</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CVAR_FOREACH_ANCESTORS</name><parameter_list>(<parameter><type><name>klass</name></type></parameter>, <parameter><type><name>v</name></type></parameter>, <parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for (klass = cvar_front_klass(klass); klass; klass = RCLASS_SUPER(klass)) { if (cvar_lookup_at(klass, id, (v))) { r; } }</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CVAR_LOOKUP</name><parameter_list>(<parameter><type><name>v</name></type></parameter>,<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do {if (cvar_lookup_at(klass, id, (v))) {r;}CVAR_FOREACH_ANCESTORS(klass, v, r);} while(0)</cpp:value></cpp:define>




<function><type><name>void</name></type>
<name>rb_cvar_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>front</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>target</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>
<macro><name>CVAR_LOOKUP</name><argument_list>(<argument><literal type="number">0</literal></argument>, <argument>{if (!front) front = klass; target = klass;}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<if_stmt><if>if <condition>(<expr><name>target</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cvar_overtaken</name><argument_list>(<argument><expr><name>front</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>target</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>check_before_mod_set</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"class variable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_class_ivar_set</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_cvar_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>front</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>target</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>value</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>klass</name></expr>;</expr_stmt>
<macro><name>CVAR_LOOKUP</name><argument_list>(<argument>&amp;value</argument>, <argument>{if (!front) front = klass; target = klass;}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>target</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"uninitialized class variable %1$s in %2$s"</literal></expr></argument>,
<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>cvar_overtaken</name><argument_list>(<argument><expr><name>front</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_cvar_defined</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>klass</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<macro><name>CVAR_LOOKUP</name><argument_list>(<argument><literal type="number">0</literal></argument>,<argument>return Qtrue</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ID</name></type>
<name>cv_intern</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_is_class_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"wrong class variable name %1$s"</literal></expr></argument>,
<argument><expr><name>klass</name></expr></argument>, <argument><expr><call><name>rb_str_new_cstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_cv_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>cv_intern</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_cvar_set</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_cv_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>cv_intern</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>rb_cvar_get</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_define_class_variable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>cv_intern</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_cvar_set</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cv_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>key</name> <init>= <expr><operator>(</operator><name>ID</name><operator>)</operator><name>k</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><operator>(</operator><name>st_table</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_is_class_id</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_update</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><name>cv_i_update</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type>
<name>mod_cvar_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_foreach_safe</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cv_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>tbl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type>
<name>mod_cvar_of</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><name>mod</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>FL_SINGLETON</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_namespace_p</name><argument_list>(<argument><expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id__attached__</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>mod_cvar_at</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>cvar_front_klass</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>mod_cvar_at</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cv_list_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>sym</name> <init>= <expr><operator>(</operator><name>ID</name><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>cvar_list</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_foreach_safe</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>cv_list_i</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>





















<function><type><name>VALUE</name></type>
<name>rb_mod_class_variables</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>inherit</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>inherit</name> <operator>=</operator> <call><name>RTEST</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>inherit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>mod_cvar_of</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>mod_cvar_at</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><call><name>cvar_list</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





















<function><type><name>VALUE</name></type>
<name>rb_mod_remove_cvar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>mod</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ID</name></type> <name>id</name> <init>= <expr><call><name>id_for_var_message</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>class</name></expr></argument>, <argument><expr><literal type="string">"wrong class variable name %1$s"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><name>id</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>
<label><name>not_defined</name>:</label>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"class variable %1$s not defined for %2$s"</literal></expr></argument>,
<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>st_delete</name><argument_list>(<argument><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_cvar_defined</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_name_err_raise</name><argument_list>(<argument><expr><literal type="string">"cannot remove %1$s for %2$s"</literal></expr></argument>, <argument><expr><name>mod</name></expr></argument>, <argument><expr><call><name>ID2SYM</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>not_defined</name>;</goto>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_iv_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_check_id_cstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>id</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"instance variable %s not initialized"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_iv_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ID</name></type> <name>id</name> <init>= <expr><call><name>rb_intern</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>rb_class_ivar_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>st_insert</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>tbl_copy_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_iv_tbl_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dst</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>orig_tbl</name> <init>= <expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>new_tbl</name> <init>= <expr><call><name>st_copy</name><argument_list>(<argument><expr><name>orig_tbl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name>new_tbl</name></expr></argument>, <argument><expr><name>tbl_copy_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RCLASS_IV_TBL</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>new_tbl</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>rb_const_entry_t</name> <modifier>*</modifier></type>
<name>rb_const_lookup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_id_table</name></name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>RCLASS_CONST_TBL</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tbl</name> <operator>&amp;&amp;</operator> <call><name>rb_id_table_lookup</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>rb_const_entry_t</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
