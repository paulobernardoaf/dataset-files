<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\encoding.c">










<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"encindex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/enc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/inits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/load.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regenc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_assert.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ENC_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENC_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENC_ASSERT</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RUBY_ASSERT_WHEN(ENC_DEBUG, expr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUST_STRING</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ENC_ASSERT(RB_TYPE_P(str, T_STRING)), str)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_ascii8bit_encindex</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_utf8_encindex</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_usascii_encindex</name></cpp:undef>

<typedef>typedef <type><name>OnigEncodingType</name></type> <name>rb_raw_encoding</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>__GNUC__</name> <operator>&amp;&amp;</operator> <name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>visibility</name> <name>push</name><name>(</name><name>default</name><name>)</name></cpp:pragma>
<function_decl><type><name>int</name></type> <name>rb_enc_register</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>rb_enc_set_base</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>rb_enc_set_dummy</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>rb_encdb_declare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>rb_encdb_replicate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>rb_encdb_dummy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>rb_encdb_alias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>rb_encdb_set_unicode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>visibility</name> <name>pop</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cEncoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_encoding_list</name></decl>;</decl_stmt>

<struct>struct <name>rb_encoding_entry</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
}</block>;</struct>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>rb_encoding_entry</name></name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>names</name></decl>;</decl_stmt>
}</block> <decl><name>enc_table</name></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENC_DUMMY_FLAG</name></cpp:macro> <cpp:value>(1&lt;&lt;24)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENC_INDEX_MASK</name></cpp:macro> <cpp:value>(~(~0U&lt;&lt;24))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENC_TO_ENCINDEX</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(int)((enc)-&gt;ruby_encoding_index &amp; ENC_INDEX_MASK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENC_DUMMY_P</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((enc)-&gt;ruby_encoding_index &amp; ENC_DUMMY_FLAG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENC_SET_DUMMY</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((enc)-&gt;ruby_encoding_index |= ENC_DUMMY_FLAG)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODING_COUNT</name></cpp:macro> <cpp:value>ENCINDEX_BUILTIN_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNSPECIFIED_ENCODING</name></cpp:macro> <cpp:value>INT_MAX</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODING_NAMELEN_MAX</name></cpp:macro> <cpp:value>63</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>valid_encoding_name_p</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((name) &amp;&amp; strlen(name) &lt;= ENCODING_NAMELEN_MAX)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>enc_autoload_p</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!rb_enc_mbmaxlen(enc))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>load_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>rb_data_type_t</name></type> <name>encoding_data_type</name> <init>= <expr><block>{
<expr><literal type="string">"encoding"</literal></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,}</block></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>RUBY_TYPED_FREE_IMMEDIATELY</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_data_encoding</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(RTYPEDDATA_P(obj) &amp;&amp; RTYPEDDATA_TYPE(obj) == &amp;encoding_data_type)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>is_obj_encoding</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(RB_TYPE_P((obj), T_DATA) &amp;&amp; is_data_encoding(obj))</cpp:value></cpp:define>

<function><type><name>int</name></type>
<name>rb_data_is_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>is_data_encoding</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_new</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>TypedData_Wrap_Struct</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>encoding_data_type</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>encoding</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_enc_from_encoding_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>list</name></decl>, <decl><type ref="prev"/><name>enc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>list</name> <operator>=</operator> <name>rb_encoding_list</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_enc_from_encoding_index(%d): no rb_encoding_list"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"rb_enc_from_encoding_index(%d): not created yet"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>enc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_enc_from_encoding</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>encoding</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>ENC_TO_ENCINDEX</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_enc_from_encoding_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_to_index</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>enc</name></expr> ?</condition><then> <expr><call><name>ENC_TO_ENCINDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_dummy_p</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ENC_DUMMY_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>enc_autoload</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_encoding</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>enc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>enc_autoload_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>enc_autoload</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_check_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_obj_encoding</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>check_encoding</name><argument_list>(<argument><expr><call><name>RDATA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void not_encoding(VALUE enc)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>not_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"wrong argument type %"</literal><name>PRIsVALUE</name><literal type="string">" (expected Encoding)"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>
<name>must_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>enc_check_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>not_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>
<name>must_encindex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncodingError</name></expr></argument>, <argument><expr><literal type="string">"encoding index out of bound: %d"</literal></expr></argument>,
<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ENC_TO_ENCINDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>index</name> <operator>&amp;</operator> <name>ENC_INDEX_MASK</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncodingError</name></expr></argument>, <argument><expr><literal type="string">"wrong encoding index %d for %s (expected %d)"</literal></expr></argument>,
<argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ENC_TO_ENCINDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>enc_autoload_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>enc_autoload</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_loaderror</name><argument_list>(<argument><expr><literal type="string">"failed to load encoding (%s)"</literal></expr></argument>,
<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>enc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_to_encoding_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>enc_check_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>enc</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_enc_find_index</name><argument_list>(<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>str_find_encindex</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid name encoding (non ASCII)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>rb_enc_find_index</name><argument_list>(<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>str_to_encindex</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>str_find_encindex</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"unknown encoding name - %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>
<name>str_to_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><call><name>str_to_encindex</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_to_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>enc_check_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>RDATA</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>data</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>str_to_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_find_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>enc_check_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>RDATA</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>data</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>str_find_encindex</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_table_expand</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_encoding_entry</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name>newsize</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>enc_table</name><operator>.</operator><name>size</name></name> <operator>&gt;=</operator> <name>newsize</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>newsize</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newsize</name> <operator>=</operator> <operator>(</operator><name>newsize</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>/</operator> <literal type="number">8</literal> <operator>*</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>REALLOC_N</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>list</name></name></expr></argument>, <argument><expr>struct <name>rb_encoding_entry</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ent</name> <operator>+</operator> <name><name>enc_table</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ent</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>newsize</name> <operator>-</operator> <name><name>enc_table</name><operator>.</operator><name>size</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>enc_table</name><operator>.</operator><name>list</name></name> <operator>=</operator> <name>ent</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>enc_table</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_register_at</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>base_encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>rb_encoding_entry</name></name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><operator>&amp;</operator><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_raw_encoding</name> <modifier>*</modifier></type><name>encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>list</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_encoding_name_p</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ent</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCASECMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>encoding</name> <operator>=</operator> <operator>(</operator><name>rb_raw_encoding</name> <operator>*</operator><operator>)</operator><name><name>ent</name><operator>-&gt;</operator><name>enc</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>encoding</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rb_encoding</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>base_encoding</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <operator>*</operator><name>base_encoding</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>ent</name><operator>-&gt;</operator><name>enc</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>encoding</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>encoding</name><operator>-&gt;</operator><name>ruby_encoding_index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>names</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <name>rb_encoding_list</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>list</name> <operator>&amp;&amp;</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>enc_new</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_register</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name><name>enc_table</name><operator>.</operator><name>count</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>index</name> <operator>=</operator> <call><name>enc_table_expand</name><argument_list>(<argument><expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>enc_table</name><operator>.</operator><name>count</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
<return>return <expr><call><name>enc_register_at</name><argument_list>(<argument><expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_encoding_const</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>rb_enc_registered</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type>
<name>rb_enc_register</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>oldenc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRCASECMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>oldenc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>enc_register</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>enc_autoload_p</name><argument_list>(<argument><expr><name>oldenc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ENC_DUMMY_P</name><argument_list>(<argument><expr><name>oldenc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>enc_register_at</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"encoding %s is already registered"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>enc_register</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_encoding_const</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_encdb_declare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>enc_register</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>set_encoding_const</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>enc_check_duplication</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"encoding %s is already registered"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name><modifier>*</modifier></type>
<name>set_base_encoding</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>enc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>base</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ENC_DUMMY_P</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ENC_SET_DUMMY</name><argument_list>(<argument><expr><operator>(</operator><name>rb_raw_encoding</name> <operator>*</operator><operator>)</operator><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>enc</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>rb_enc_set_base</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>origidx</name> <init>= <expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>set_base_encoding</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>origidx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>rb_enc_set_dummy</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>enc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ENC_SET_DUMMY</name><argument_list>(<argument><expr><operator>(</operator><name>rb_raw_encoding</name> <operator>*</operator><operator>)</operator><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_replicate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>enc_check_duplication</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>enc_register</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_base_encoding</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_encoding_const</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_replicate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_from_encoding_index</name><argument_list>(
<argument><expr><call><name>rb_enc_replicate</name><argument_list>(<argument><expr><call><name>StringValueCStr</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>rb_to_encoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_replicate_with_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>origenc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>enc_register</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>enc_register_at</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>set_base_encoding</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>origenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_encoding_const</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"failed to replicate encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_encdb_replicate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>origidx</name> <init>= <expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>origidx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>origidx</name> <operator>=</operator> <call><name>enc_register</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>enc_replicate_with_index</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>origidx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_define_dummy_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>rb_enc_replicate</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>enc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ENC_SET_DUMMY</name><argument_list>(<argument><expr><operator>(</operator><name>rb_raw_encoding</name> <operator>*</operator><operator>)</operator><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_encdb_dummy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>enc_replicate_with_index</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>rb_ascii8bit_encoding</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>enc</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ENC_SET_DUMMY</name><argument_list>(<argument><expr><operator>(</operator><name>rb_raw_encoding</name> <operator>*</operator><operator>)</operator><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_dummy_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><call><name>ENC_DUMMY_P</name><argument_list>(<argument><expr><call><name>must_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_ascii_compatible_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><call><name>must_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>rb_enc_unicode_p</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ONIGENC_IS_UNICODE</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_data_t</name></type>
<name>enc_dup_name</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><call><name>strdup</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_alias_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_insert2</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>names</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>alias</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>idx</name></expr></argument>,
<argument><expr><name>enc_dup_name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_alias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_encoding_name_p</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>enc_alias_internal</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_encoding_const</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_alias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>enc_check_duplication</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idx</name> <operator>=</operator> <call><name>rb_enc_find_index</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>enc_alias</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_encdb_alias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>enc_register</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>enc_alias</name><argument_list>(<argument><expr><name>alias</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_encdb_set_unicode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>rb_raw_encoding</name> <operator>*</operator><operator>)</operator><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <name>ONIGENC_FLAG_UNICODE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_enc_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>enc_table_expand</name><argument_list>(<argument><expr><name>ENCODING_COUNT</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>enc_table</name><operator>.</operator><name>names</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>enc_table</name><operator>.</operator><name>names</name></name> <operator>=</operator> <call><name>st_init_strcasetable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENC_REGISTER</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>enc_register_at(ENCINDEX_##enc, rb_enc_name(&amp;OnigEncoding##enc), &amp;OnigEncoding##enc)</cpp:value></cpp:define>
<expr_stmt><expr><call><name>ENC_REGISTER</name><argument_list>(<argument><expr><name>ASCII</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENC_REGISTER</name><argument_list>(<argument><expr><name>UTF_8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENC_REGISTER</name><argument_list>(<argument><expr><name>US_ASCII</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ENC_REGISTER</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCDB_REGISTER</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>enc_register_at(ENCINDEX_##enc, name, NULL)</cpp:value></cpp:define>
<expr_stmt><expr><call><name>ENCDB_REGISTER</name><argument_list>(<argument><expr><literal type="string">"UTF-16BE"</literal></expr></argument>, <argument><expr><name>UTF_16BE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENCDB_REGISTER</name><argument_list>(<argument><expr><literal type="string">"UTF-16LE"</literal></expr></argument>, <argument><expr><name>UTF_16LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENCDB_REGISTER</name><argument_list>(<argument><expr><literal type="string">"UTF-32BE"</literal></expr></argument>, <argument><expr><name>UTF_32BE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENCDB_REGISTER</name><argument_list>(<argument><expr><literal type="string">"UTF-32LE"</literal></expr></argument>, <argument><expr><name>UTF_32LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENCDB_REGISTER</name><argument_list>(<argument><expr><literal type="string">"UTF-16"</literal></expr></argument>, <argument><expr><name>UTF_16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENCDB_REGISTER</name><argument_list>(<argument><expr><literal type="string">"UTF-32"</literal></expr></argument>, <argument><expr><name>UTF_32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENCDB_REGISTER</name><argument_list>(<argument><expr><literal type="string">"UTF8-MAC"</literal></expr></argument>, <argument><expr><name>UTF8_MAC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ENCDB_REGISTER</name><argument_list>(<argument><expr><literal type="string">"EUC-JP"</literal></expr></argument>, <argument><expr><name>EUC_JP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENCDB_REGISTER</name><argument_list>(<argument><expr><literal type="string">"Windows-31J"</literal></expr></argument>, <argument><expr><name>Windows_31J</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ENCDB_REGISTER</name></cpp:undef>
<expr_stmt><expr><name><name>enc_table</name><operator>.</operator><name>count</name></name> <operator>=</operator> <name>ENCINDEX_BUILTIN_MAX</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_enc_from_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>enc_table</name><operator>.</operator><name>count</name></name> <operator>&lt;=</operator> <operator>(</operator><name>index</name> <operator>&amp;=</operator> <name>ENC_INDEX_MASK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>enc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_enc_get_from_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>must_encindex</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_registered</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>enc_table</name><operator>.</operator><name>list</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>st_lookup</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>names</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>idx</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>load_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>enclib</name> <init>= <expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"enc/%s.so"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>verbose</name> <init>= <expr><name>ruby_verbose</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>debug</name> <init>= <expr><name>ruby_debug</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>errinfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>enclib</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>RSTRING_END</name><argument_list>(<argument><expr><name>enclib</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>loaded</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>e</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISALNUM</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>TOLOWER</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>enclib</name> <operator>=</operator> <call><name>rb_fstring</name><argument_list>(<argument><expr><name>enclib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ruby_verbose</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ruby_debug</name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errinfo</name> <operator>=</operator> <call><name>rb_errinfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>loaded</name> <operator>=</operator> <call><name>rb_require_internal</name><argument_list>(<argument><expr><name>enclib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ruby_verbose</name> <operator>=</operator> <name>verbose</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ruby_debug</name> <operator>=</operator> <name>debug</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_set_errinfo</name><argument_list>(<argument><expr><name>errinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>loaded</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>loaded</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idx</name> <operator>=</operator> <call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>enc_autoload_p</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_autoload</name><parameter_list>(<parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><call><name>ENC_TO_ENCINDEX</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>base</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>enc_table</name><operator>.</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>enc</name> <operator>!=</operator> <name>base</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>++</operator><name>i</name><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><call><name>enc_autoload_p</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>enc_autoload</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>enc</name><operator>-&gt;</operator><name>ruby_encoding_index</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>enc_register_at</name><argument_list>(<argument><expr><name>i</name> <operator>&amp;</operator> <name>ENC_INDEX_MASK</name></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>rb_raw_encoding</name> <operator>*</operator><operator>)</operator><name>enc</name><operator>)</operator><operator>-&gt;</operator><name>ruby_encoding_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>&amp;=</operator> <name>ENC_INDEX_MASK</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>load_encoding</name><argument_list>(<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>rb_enc_find_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>load_encoding</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>enc</name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>UNSPECIFIED_ENCODING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"encoding %s is not registered"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>enc_autoload_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>enc_autoload</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"failed to load encoding (%s); use ASCII-8BIT instead"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_find_index2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>ENCODING_NAMELEN_MAX</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>ENCODING_NAMELEN_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><call><name>rb_enc_find_index</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_enc_find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>rb_enc_find_index</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>enc_capable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_STRING</name></expr>:</case>
<case>case <expr><name>T_REGEXP</name></expr>:</case>
<case>case <expr><name>T_FILE</name></expr>:</case>
<case>case <expr><name>T_SYMBOL</name></expr>:</case>
<return>return <expr><name>TRUE</name></expr>;</return>
<case>case <expr><name>T_DATA</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>is_data_encoding</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<default>default:</default>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_capable</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>enc_capable</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ID</name></type>
<name>rb_id_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>CONST_ID</name><argument_list>(<argument><expr><name>id_encoding</name></expr></argument>, <argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>id_encoding</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_get_index_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>ENCODING_GET_INLINED</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>ENCODING_INLINE_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>iv</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
iv = rb_ivar_get(str, rb_id_encoding());
i = NUM2INT(iv);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>





<expr_stmt><expr><name>iv</name> <operator>=</operator> <call><name>rb_attr_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>rb_id_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>ENCINDEX_ASCII</name></expr> </then><else>: <expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_get_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_sym2str</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>T_STRING</name></expr>:</case>
<case>case <expr><name>T_SYMBOL</name></expr>:</case>
<case>case <expr><name>T_REGEXP</name></expr>:</case>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>enc_get_index_str</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>T_FILE</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"internal_encoding"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"external_encoding"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_obj_encoding</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>enc_check_encoding</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>T_DATA</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>is_data_encoding</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>enc_check_encoding</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>enc_set_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>enc_capable</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"cannot set encoding on non-encoding capable object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>ENCODING_INLINE_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ENCODING_SET_INLINED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ENCODING_SET_INLINED</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ENCODING_INLINE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ivar_set</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>rb_id_encoding</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>INT2NUM</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_enc_set_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>must_encindex</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>enc_set_index</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_enc_associate_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldidx</name></decl>, <decl><type ref="prev"/><name>oldtermlen</name></decl>, <decl><type ref="prev"/><name>termlen</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oldidx</name> <operator>=</operator> <call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oldidx</name> <operator>==</operator> <name>idx</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>obj</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"cannot set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>must_encindex</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ENC_CODERANGE_ASCIIONLY</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ENC_CODERANGE_CLEAR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>termlen</name> <operator>=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oldtermlen</name> <operator>=</operator> <call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>oldidx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oldtermlen</name> <operator>!=</operator> <name>termlen</name> <operator>&amp;&amp;</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_str_change_terminator_length</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>oldtermlen</name></expr></argument>, <argument><expr><name>termlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>enc_set_index</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_enc_associate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name><modifier>*</modifier></type>
<name>rb_enc_get</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>rb_encoding</name><modifier>*</modifier></type> <name>enc_compatible_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>rb_encoding</name><modifier>*</modifier></type>
<name>rb_enc_check_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>enc_compatible_str</name><argument_list>(<argument><expr><call><name>MUST_STRING</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>MUST_STRING</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncCompatError</name></expr></argument>, <argument><expr><literal type="string">"incompatible character encodings: %s and %s"</literal></expr></argument>,
<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>enc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name><modifier>*</modifier></type>
<name>rb_enc_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_compatible</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eEncCompatError</name></expr></argument>, <argument><expr><literal type="string">"incompatible character encodings: %s and %s"</literal></expr></argument>,
<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>enc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name><modifier>*</modifier></type>
<name>enc_compatible_latter</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>isstr1</name></decl>, <decl><type ref="prev"/><name>isstr2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc1</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc2</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>isstr2</name> <operator>=</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>str2</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>isstr2</name> <operator>&amp;&amp;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>enc1</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>isstr1</name> <operator>=</operator> <call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>isstr1</name> <operator>&amp;&amp;</operator> <name>isstr2</name> <operator>&amp;&amp;</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rb_enc_str_asciionly_p</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>enc1</name></expr> </then><else>: <expr><name>enc2</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc1</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isstr2</name> <operator>&amp;&amp;</operator> <name>idx2</name> <operator>==</operator> <name>ENCINDEX_US_ASCII</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>enc1</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isstr1</name> <operator>&amp;&amp;</operator> <name>idx1</name> <operator>==</operator> <name>ENCINDEX_US_ASCII</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>enc2</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isstr1</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><name>str1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx0</name> <init>= <expr><name>idx1</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>str1</name> <operator>=</operator> <name>str2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>str2</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx1</name> <operator>=</operator> <name>idx2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx2</name> <operator>=</operator> <name>idx0</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx0</name> <operator>=</operator> <name>isstr1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>isstr1</name> <operator>=</operator> <name>isstr2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>isstr2</name> <operator>=</operator> <name>idx0</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>isstr1</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cr1</name></decl>, <decl><type ref="prev"/><name>cr2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cr1</name> <operator>=</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>isstr2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cr2</name> <operator>=</operator> <call><name>rb_enc_str_coderange</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cr1</name> <operator>!=</operator> <name>cr2</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cr1</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>enc2</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cr2</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>enc1</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cr2</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>enc1</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cr1</name> <operator>==</operator> <name>ENC_CODERANGE_7BIT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>enc2</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>rb_encoding</name><modifier>*</modifier></type>
<name>enc_compatible_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx1</name> <init>= <expr><call><name>enc_get_index_str</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx2</name> <init>= <expr><call><name>enc_get_index_str</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx1</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>idx2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx1</name> <operator>==</operator> <name>idx2</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>enc_compatible_latter</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>, <argument><expr><name>idx1</name></expr></argument>, <argument><expr><name>idx2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>rb_encoding</name><modifier>*</modifier></type>
<name>rb_enc_compatible</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx1</name> <init>= <expr><call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx2</name> <init>= <expr><call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx1</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>idx2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx1</name> <operator>==</operator> <name>idx2</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>enc_compatible_latter</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>, <argument><expr><name>idx1</name></expr></argument>, <argument><expr><name>idx2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_enc_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_enc_associate_index</name><argument_list>(<argument><expr><name>obj1</name></expr></argument>, <argument><expr><call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><name>VALUE</name></type>
<name>rb_obj_encoding</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>rb_enc_get_index</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"unknown encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_enc_from_encoding_index</name><argument_list>(<argument><expr><name>idx</name> <operator>&amp;</operator> <name>ENC_INDEX_MASK</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_fast_mbclen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ONIGENC_MBC_ENC_LEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_mbclen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>ONIGENC_PRECISE_MBC_ENC_LEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>e</name><operator>-</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr><call><name>rb_enc_mbminlen</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>min</name> <operator>&lt;=</operator> <name>e</name><operator>-</operator><name>p</name></expr> ?</condition><then> <expr><name>min</name></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>e</name><operator>-</operator><name>p</name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_precise_mbclen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&lt;=</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ONIGENC_CONSTRUCT_MBCLEN_NEEDMORE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ONIGENC_PRECISE_MBC_ENC_LEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name><operator>-</operator><name>p</name> <operator>&lt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ONIGENC_CONSTRUCT_MBCLEN_NEEDMORE</name><argument_list>(<argument><expr><name>n</name><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>e</name><operator>-</operator><name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_ascget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&lt;=</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISASCII</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_isascii</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>l</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type>
<name>rb_enc_codepoint_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len_p</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&lt;=</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"empty string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_enc_precise_mbclen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MBCLEN_CHARFOUND_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid byte sequence in %s"</literal></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len_p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>len_p</name> <operator>=</operator> <call><name>MBCLEN_CHARFOUND_LEN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_enc_mbc_to_codepoint</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_enc_codepoint</name></cpp:undef>
<function><type><name>unsigned</name> <name>int</name></type>
<name>rb_enc_codepoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_codepoint_len</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_codelen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>ONIGENC_CODE_TO_MBCLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>,<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid codepoint 0x%x in %s"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_enc_code_to_mbclen</name></cpp:undef>
<function><type><name>int</name></type>
<name>rb_enc_code_to_mbclen</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ONIGENC_CODE_TO_MBCLEN</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_toupper</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>ONIGENC_IS_ASCII_CODE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><call><name>ONIGENC_ASCII_CODE_TO_UPPER_CASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><operator>(</operator><name>c</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_enc_tolower</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>ONIGENC_IS_ASCII_CODE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><call><name>ONIGENC_ASCII_CODE_TO_LOWER_CASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><operator>(</operator><name>c</name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_data_encoding</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>not_encoding</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>enc</name> <operator>=</operator> <call><name>DATA_PTR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><call><name>rb_enc_to_index</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>enc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"broken Encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_enc_sprintf</name><argument_list>(<argument><expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><literal type="string">"#&lt;%"</literal><name>PRIsVALUE</name><literal type="string">":%s%s%s&gt;"</literal></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><call><name>ENC_DUMMY_P</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">" (dummy)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><ternary><condition><expr><call><name>enc_autoload_p</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">" (autoload)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_name</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><operator>(</operator><name>rb_encoding</name><operator>*</operator><operator>)</operator><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_names_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>args</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>idx</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_names</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><call><name>rb_to_encoding_index</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>names</name></name></expr></argument>, <argument><expr><name>enc_names_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_list</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_replace</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>rb_encoding_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_find</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_obj_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>enc</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>str_to_encindex</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <name>UNSPECIFIED_ENCODING</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_enc_from_encoding_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_compatible_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>enc_capable</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>enc_capable</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>rb_enc_compatible</name><argument_list>(<argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_s_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_undefined_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_dump</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>enc_name</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_load</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>enc_m_loader</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>enc_find</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_ascii8bit_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>ENCINDEX_ASCII</name></expr>]</index></name><operator>.</operator><name>enc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_ascii8bit_encindex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ENCINDEX_ASCII</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_utf8_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>ENCINDEX_UTF_8</name></expr>]</index></name><operator>.</operator><name>enc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_utf8_encindex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ENCINDEX_UTF_8</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_usascii_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>ENCINDEX_US_ASCII</name></expr>]</index></name><operator>.</operator><name>enc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_usascii_encindex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ENCINDEX_US_ASCII</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>int</name></type> <name>rb_locale_charmap_index</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type>
<name>rb_locale_encindex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>rb_locale_charmap_index</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>ENCINDEX_ASCII</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><literal type="string">"locale"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name></expr></cpp:if>
<decl_stmt><decl><type><name>void</name></type> <name>Init_w32_codepage</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Init_w32_codepage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>enc_alias_internal</name><argument_list>(<argument><expr><literal type="string">"locale"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_locale_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><call><name>rb_locale_encindex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_filesystem_encindex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>rb_enc_registered</name><argument_list>(<argument><expr><literal type="string">"filesystem"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>ENCINDEX_ASCII</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_filesystem_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><call><name>rb_filesystem_encindex</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>default_encoding</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>default_encoding</name></name></type> <name>default_external</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>enc_set_default_encoding</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>default_encoding</name></name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>overridden</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>index</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>overridden</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>names</name></name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>UNSPECIFIED_ENCODING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <call><name>rb_enc_to_index</name><argument_list>(<argument><expr><call><name>rb_to_encoding</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>enc_alias_internal</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>def</name> <operator>==</operator> <operator>&amp;</operator><name>default_external</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>enc_alias_internal</name><argument_list>(<argument><expr><literal type="string">"filesystem"</literal></expr></argument>, <argument><expr><call><name>Init_enc_set_filesystem_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>overridden</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_default_external_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>default_external</name><operator>.</operator><name>enc</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>default_external</name><operator>.</operator><name>enc</name></name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>default_external</name><operator>.</operator><name>index</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>default_external</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name><name>default_external</name><operator>.</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>default_external</name><operator>.</operator><name>enc</name></name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_locale_encoding</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_enc_default_external</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><call><name>rb_default_external_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>get_default_external</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_default_external</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_enc_set_default_external</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"default external can not be nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>enc_set_default_encoding</name><argument_list>(<argument><expr><operator>&amp;</operator><name>default_external</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
<argument><expr><literal type="string">"external"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>set_default_external</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"setting Encoding.default_external"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_enc_set_default_external</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>encoding</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>default_encoding</name></name></type> <name>default_internal</name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">2</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><name>rb_encoding</name> <modifier>*</modifier></type>
<name>rb_default_internal_encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>default_internal</name><operator>.</operator><name>enc</name></name> <operator>&amp;&amp;</operator> <name><name>default_internal</name><operator>.</operator><name>index</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>default_internal</name><operator>.</operator><name>enc</name></name> <operator>=</operator> <call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name><name>default_internal</name><operator>.</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>default_internal</name><operator>.</operator><name>enc</name></name></expr>;</return> 
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_enc_default_internal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<return>return <expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>get_default_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_enc_default_internal</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_enc_set_default_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>enc_set_default_encoding</name><argument_list>(<argument><expr><operator>&amp;</operator><name>default_internal</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
<argument><expr><literal type="string">"internal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>set_default_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"setting Encoding.default_internal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_enc_set_default_internal</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>encoding</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_encoding_const</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>encoding</name> <init>= <expr><call><name>rb_enc_from_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>haslower</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>hasupper</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>valid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hasupper</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ISALNUM</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>haslower</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>-</operator> <name>name</name> <operator>&gt;</operator> <name>ENCODING_NAMELEN_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>valid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid</name> <operator>||</operator> <name>haslower</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>s</name> <operator>-</operator> <name>name</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>ENCODING_NAMELEN_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haslower</name> <operator>||</operator> <operator>!</operator><name>hasupper</name></expr>)</condition> <block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>haslower</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hasupper</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>haslower</name> <operator>||</operator> <operator>!</operator><name>hasupper</name><operator>)</operator></expr>)</condition>;</do>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>name</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name><operator>++</operator> <operator>&gt;</operator> <name>ENCODING_NAMELEN_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>s</name> <operator>=</operator> <call><name>ALLOCA_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>ONIGENC_ASCII_CODE_TO_UPPER_CASE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ISALNUM</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>hasupper</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>haslower</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <call><name>ONIGENC_ASCII_CODE_TO_UPPER_CASE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>rb_define_const</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_enc_name_list_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_enc_name_list</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>names</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>names</name></name></expr></argument>, <argument><expr><name>rb_enc_name_list_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_enc_aliases_enc_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>orig</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>aliases</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>ary</name> <init>= <expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>orig</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>str</name> <init>= <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_from_index</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRCASECMP</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>rb_fstring_cstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_enc_aliases</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>aliases</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>aliases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>aliases</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>names</name></name></expr></argument>, <argument><expr><name>rb_enc_aliases_enc_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>aliases</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>










































































































































































































<function><type><name>void</name></type>
<name>Init_Encoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_intern</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_intern_const(str)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>VALUE</name></type> <name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>rb_cEncoding</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Encoding"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><name>enc_s_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_undef_method</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>enc_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>enc_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>enc_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"names"</literal></expr></argument>, <argument><expr><name>enc_names</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"dummy?"</literal></expr></argument>, <argument><expr><name>enc_dummy_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"ascii_compatible?"</literal></expr></argument>, <argument><expr><name>enc_ascii_compatible_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"replicate"</literal></expr></argument>, <argument><expr><name>enc_replicate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>, <argument><expr><name>enc_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"name_list"</literal></expr></argument>, <argument><expr><name>rb_enc_name_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"aliases"</literal></expr></argument>, <argument><expr><name>rb_enc_aliases</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"find"</literal></expr></argument>, <argument><expr><name>enc_find</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"compatible?"</literal></expr></argument>, <argument><expr><name>enc_compatible_p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"_dump"</literal></expr></argument>, <argument><expr><name>enc_dump</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"_load"</literal></expr></argument>, <argument><expr><name>enc_load</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"default_external"</literal></expr></argument>, <argument><expr><name>get_default_external</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"default_external="</literal></expr></argument>, <argument><expr><name>set_default_external</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"default_internal"</literal></expr></argument>, <argument><expr><name>get_default_internal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"default_internal="</literal></expr></argument>, <argument><expr><name>set_default_internal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><literal type="string">"locale_charmap"</literal></expr></argument>, <argument><expr><name>rb_locale_charmap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rb_encoding_list</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_register_mark_object</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>enc_table</name><operator>.</operator><name>count</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>enc_new</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>list</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>rb_marshal_define_compat</name><argument_list>(<argument><expr><name>rb_cEncoding</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>enc_m_loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>Init_encodings</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_enc_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type>
<name>rb_enc_foreach_name</name><parameter_list>(<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>st_foreach</name><argument_list>(<argument><expr><name><name>enc_table</name><operator>.</operator><name>names</name></name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
