<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\hash.c">












<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CRT_EXTERNS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crt_externs.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"missing/crt_externs.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_counter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/bignum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/cont.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/symbol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"probes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/st.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"symbol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transient_heap.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HASH_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_DEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HASH_DEBUG</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAS_EXTRA_STATES</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>klass</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( ((klass = has_extra_methods(rb_obj_class(hash))) != 0) || FL_TEST((hash), FL_EXIVAR|RHASH_PROC_DEFAULT) || !NIL_P(RHASH_IFNONE(hash)))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_DEFAULT</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>ifnone</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( FL_UNSET_RAW(hash, RHASH_PROC_DEFAULT), RHASH_SET_IFNONE(hash, ifnone))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_PROC_DEFAULT</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>proc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>set_proc_default(hash, proc)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_DEFAULT</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>hash2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>copy_default(RHASH(hash), RHASH(hash2))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>copy_default</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>RHash</name></name> <modifier>*</modifier></type><name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>RHash</name></name> <modifier>*</modifier></type><name>hash2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>hash</name><operator>-&gt;</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>RHASH_PROC_DEFAULT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hash</name><operator>-&gt;</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name><name>hash2</name><operator>-&gt;</operator><name>basic</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>RHASH_PROC_DEFAULT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_SET_IFNONE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>RHASH_IFNONE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>hash2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>has_extra_methods</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>base</name> <init>= <expr><name>rb_cHash</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>c</name> <init>= <expr><name>klass</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>c</name> <operator>!=</operator> <name>base</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_class_has_methods</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>klass</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>RCLASS_SUPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_hash_s_try_convert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl>











<function><type><name>VALUE</name></type>
<name>rb_hash_freeze</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cHash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>envtbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_hash</name></decl>, <decl><type ref="prev"/><name>id_default</name></decl>, <decl><type ref="prev"/><name>id_flatten_bang</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ID</name></type> <name>id_hash_iter_lev</name></decl>;</decl_stmt>

<function><type><name>VALUE</name></type>
<name>rb_hash_set_ifnone</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ifnone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><operator>&amp;</operator><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ifnone</name><operator>)</operator></expr></argument>, <argument><expr><name>ifnone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_any_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name> <operator>==</operator> <name>rb_cString</name> <operator>&amp;&amp;</operator>
<call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RBASIC</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name> <operator>==</operator> <name>rb_cString</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_str_hash_cmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>Qundef</name> <operator>||</operator> <name>b</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>SYMBOL_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>a</name> <operator>!=</operator> <name>b</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>!</operator><call><name>rb_eql</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_recursive</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recurse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>recurse</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>id_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hval</name> <init>= <expr><call><name>rb_exec_recursive_outer</name><argument_list>(<argument><expr><name>hash_recursive</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>hval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>hval</name></expr></argument>, <argument><expr><name>T_BIGNUM</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ul</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <call><name>rb_integer_pack</name><argument_list>(<argument><expr><name>hval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ul</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ul</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>INTEGER_PACK_NATIVE_BYTE_ORDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ul</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">1UL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>CHAR_BIT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>long</name><operator>)</operator><name>ul</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>ul</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hval</name> <operator>=</operator> <call><name>rb_to_int</name><argument_list>(<argument><expr><name>hval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>hval</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>rb_objid_hash</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>dbl_to_index</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<union>union <block>{<decl_stmt><decl><type><name>double</name></type> <name>d</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>;</decl_stmt>}</block> <decl><name>u</name></decl>;</union>
<expr_stmt><expr><name><name>u</name><operator>.</operator><name>d</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
<return>return <expr><name><name>u</name><operator>.</operator><name>i</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>long</name></type>
<name>rb_dbl_long_hash</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> <operator>==</operator> <name>SIZEOF_VOIDP</name></expr></cpp:if>
<return>return <expr><call><name>rb_memhash</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>rb_objid_hash</name><argument_list>(<argument><expr><call><name>dbl_to_index</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>
<name>any_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><function_decl><type><name>st_index_t</name></type> (<modifier>*</modifier><name>other_func</name>)<parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>hnum</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPECIAL_CONST_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>STATIC_SYM_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hnum</name> <operator>=</operator> <name>a</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>RUBY_SPECIAL_SHIFT</name> <operator>+</operator> <name>ID_SCOPE_SHIFT</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>hnum</name> <operator>=</operator> <call><name>rb_hash_start</name><argument_list>(<argument><expr><name>hnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>FLONUM_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>flt</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hnum</name> <operator>=</operator> <call><name>rb_objid_hash</name><argument_list>(<argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_STRING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hnum</name> <operator>=</operator> <call><name>rb_str_hash</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_SYMBOL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hnum</name> <operator>=</operator> <call><name>RSYMBOL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>hashval</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_BIGNUM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hval</name> <operator>=</operator> <call><name>rb_big_hash</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hnum</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>hval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>BUILTIN_TYPE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_FLOAT</name></expr>)</condition> <block>{<block_content>
<label><name>flt</name>:</label>
<expr_stmt><expr><name>hnum</name> <operator>=</operator> <call><name>rb_dbl_long_hash</name><argument_list>(<argument><expr><call><name>rb_float_value</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>hnum</name> <operator>=</operator> <call><name>other_func</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<label><name>out</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>&lt;</operator> <name>SIZEOF_ST_INDEX_T</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>hnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hnum</name> <operator>&amp;=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>-</operator><literal type="number">1</literal> <operator>&gt;&gt;</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>hnum</name> <operator>|=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>-</operator><literal type="number">1</literal> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>hnum</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hnum</name> <operator>=</operator> <call><name>RSHIFT</name><argument_list>(<argument><expr><name>hnum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><name>long</name><operator>)</operator><name>hnum</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>obj_any_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_hash</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>rb_any_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>any_hash</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>obj_any_hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name>prime1</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">0x2e0bb864</literal> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <literal type="number">0xe9ea7df5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name>prime2</name> <init>= <expr><literal type="number">0x830fcab9</literal></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64_t</name></type>
<name>mult_and_mix</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>m1</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>m2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_UINT128_T</name></expr></cpp:if>
<decl_stmt><decl><type><name>uint128_t</name></type> <name>r</name> <init>= <expr><operator>(</operator><name>uint128_t</name><operator>)</operator> <name>m1</name> <operator>*</operator> <operator>(</operator><name>uint128_t</name><operator>)</operator> <name>m2</name></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <operator>(</operator><name>r</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name>r</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>hm1</name> <init>= <expr><name>m1</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></init></decl>, <decl><type ref="prev"/><name>hm2</name> <init>= <expr><name>m2</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>lm1</name> <init>= <expr><name>m1</name></expr></init></decl>, <decl><type ref="prev"/><name>lm2</name> <init>= <expr><name>m2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>v64_128</name> <init>= <expr><name>hm1</name> <operator>*</operator> <name>hm2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>v32_96</name> <init>= <expr><name>hm1</name> <operator>*</operator> <name>lm2</name> <operator>+</operator> <name>lm1</name> <operator>*</operator> <name>hm2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>v1_32</name> <init>= <expr><name>lm1</name> <operator>*</operator> <name>lm2</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>v64_128</name> <operator>+</operator> <operator>(</operator><name>v32_96</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator> <operator>^</operator> <operator>(</operator><operator>(</operator><name>v32_96</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>+</operator> <name>v1_32</name><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64_t</name></type>
<name>key64_hash</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>seed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>mult_and_mix</name><argument_list>(<argument><expr><name>key</name> <operator>+</operator> <name>seed</name></expr></argument>, <argument><expr><name>prime1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>st_index_hash</name><parameter_list>(<parameter><type><name>index</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>key64_hash(rb_hash_start(index), prime2)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>rb_objid_hash</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>long</name><operator>)</operator><call><name>st_index_hash</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>objid_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>object_id</name> <init>= <expr><call><name>rb_obj_id</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>object_id</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>object_id</name> <operator>=</operator> <call><name>rb_big_hash</name><argument_list>(<argument><expr><name>object_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG</name> <operator>==</operator> <name>SIZEOF_VOIDP</name></expr></cpp:if>
<return>return <expr><operator>(</operator><name>st_index_t</name><operator>)</operator><call><name>st_index_hash</name><argument_list>(<argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>object_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> <operator>==</operator> <name>SIZEOF_VOIDP</name></expr></cpp:elif>
<return>return <expr><operator>(</operator><name>st_index_t</name><operator>)</operator><call><name>st_index_hash</name><argument_list>(<argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><call><name>NUM2LL</name><argument_list>(<argument><expr><name>object_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>




















<function><type><name>VALUE</name></type>
<name>rb_obj_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>hnum</name> <init>= <expr><call><name>any_hash</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>objid_hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>hnum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>objhash</name> <init>= <expr><block>{
<expr><name>rb_any_cmp</name></expr>,
<expr><name>rb_any_hash</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_ident_cmp</name></cpp:macro> <cpp:value>st_numcmp</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>st_index_t</name></type>
<name>rb_ident_hash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_FLONUM</name></expr></argument>)</argument_list></call></expr></cpp:if>





<if_stmt><if>if <condition>(<expr><call><name>FLONUM_P</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>^=</operator> <call><name>dbl_to_index</name><argument_list>(<argument><expr><call><name>rb_float_value</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><name>st_index_t</name><operator>)</operator><call><name>st_index_hash</name><argument_list>(<argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>identhash</name></cpp:macro> <cpp:value>rb_hashtype_ident</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name></type> <name>rb_hashtype_ident</name> <init>= <expr><block>{
<expr><name>rb_ident_cmp</name></expr>,
<expr><name>rb_ident_hash</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><name>st_index_t</name></type> <name>st_hash_t</name>;</typedef>











<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_AR_TABLE_MAX_BOUND</name></cpp:macro> <cpp:value>RHASH_AR_TABLE_MAX_SIZE</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_AR_TABLE_REF</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(&amp;RHASH_AR_TABLE(hash)-&gt;pairs[n])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_AR_CLEARED_HINT</name></cpp:macro> <cpp:value>0xff</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>ar_table_pair_struct</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>
}</block></struct></type> <name>ar_table_pair</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ar_table_struct</name> <block>{

<decl_stmt><decl><type><name>ar_table_pair</name></type> <name><name>pairs</name><index>[<expr><name>RHASH_AR_TABLE_MAX_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>ar_table</name>;</typedef>

<function><type><name>size_t</name></type>
<name>rb_hash_ar_table_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ar_table</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>st_hash_t</name></type>
<name>ar_do_hash</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>st_hash_t</name><operator>)</operator><call><name>rb_any_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ar_hint_t</name></type>
<name>ar_do_hash_hint</name><parameter_list>(<parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>ar_hint_t</name><operator>)</operator><name>hash_value</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ar_hint_t</name></type>
<name>ar_hint</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ar_hint</name><operator>.</operator><name>ary</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ar_hint_set_hint</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>ar_hint_t</name></type> <name>hint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ar_hint</name><operator>.</operator><name>ary</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>hint</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ar_hint_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ar_hint_set_hint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>ar_do_hash_hint</name><argument_list>(<argument><expr><name>hash_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ar_clear_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_hint_set_hint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>RHASH_AR_CLEARED_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>ar_cleared_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ar_hint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RHASH_AR_CLEARED_HINT</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <name>Qundef</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ar_set_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_hint_set</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_AR_TABLE_SIZE</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(HASH_ASSERT(RHASH_AR_TABLE_P(h)), RHASH_AR_TABLE_SIZE_RAW(h))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_AR_TABLE_BOUND_RAW</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((unsigned int)((RBASIC(h)-&gt;flags &gt;&gt; RHASH_AR_TABLE_BOUND_SHIFT) &amp; (RHASH_AR_TABLE_BOUND_MASK &gt;&gt; RHASH_AR_TABLE_BOUND_SHIFT)))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_AR_TABLE_BOUND</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(HASH_ASSERT(RHASH_AR_TABLE_P(h)), RHASH_AR_TABLE_BOUND_RAW(h))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_ST_TABLE_SET</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_hash_st_table_set(h, s)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_TYPE</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(RHASH_AR_TABLE_P(hash) ? &amp;objhash : RHASH_ST_TABLE(hash)-&gt;type)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ASSERT</name><parameter_list>(<parameter><type><name>expr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RUBY_ASSERT_MESG_WHEN(HASH_DEBUG, expr, #expr)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HASH_DEBUG</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hash_verify</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>hash_verify_(hash, __FILE__, __LINE__)</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>rb_hash_dump</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_obj_info_dump</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" size:%u bound:%u\n"</literal></expr></argument>,
<argument><expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>b1</name><index>[<expr><literal type="number">0x100</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>b2</name><index>[<expr><literal type="number">0x100</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %d key:%s val:%s hint:%02x\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><call><name>rb_raw_obj_info</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><literal type="number">0x100</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>rb_raw_obj_info</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><literal type="number">0x100</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ar_hint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %d empty\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_verify_</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>k</name> <operator>!=</operator> <name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>v</name> <operator>!=</operator> <name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"n:%u, RHASH_AR_TABLE_SIZE:%u"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_SIZE_RAW</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_BOUND_RAW</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_TRANSIENT_HEP</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<function_decl><type><specifier>volatile</specifier> <name>st_data_t</name></type> <name>MAYBE_UNUSED</name><parameter_list>(<parameter><decl><type><name>key</name></type></decl></parameter>)</parameter_list> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <literal type="number">0</literal>)</argument_list></call><operator>-&gt;</operator><name>key</name></expr></init>;</function_decl> 
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>rb_transient_heap_managed_ptr_p</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hash_verify</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>RHASH_TABLE_NULL_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ar</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>RHASH_TABLE_EMPTY_P</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_hash_ar_table_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST_RAW</name><argument_list>(<argument><expr><operator>(</operator><name>hash</name><operator>)</operator></expr></argument>, <argument><expr><name>RHASH_ST_TABLE_FLAG</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>st</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>ar_table</name> <modifier>*</modifier></type>
<name>rb_hash_ar_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ar</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>rb_hash_st_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><operator>!</operator><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>st</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_hash_st_table_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>st</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_RAW</name><argument_list>(<argument><expr><operator>(</operator><name>hash</name><operator>)</operator></expr></argument>, <argument><expr><name>RHASH_ST_TABLE_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>st</name></name> <operator>=</operator> <name>st</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hash_ar_table_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>ar_table</name> <modifier>*</modifier></type><name>ar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>ar</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>FALSE</name></expr> </then><else>: <expr><name>TRUE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ar</name></name> <operator>=</operator> <name>ar</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_SET_ST_FLAG</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FL_SET_RAW(h, RHASH_ST_TABLE_FLAG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_UNSET_ST_FLAG</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FL_UNSET_RAW(h, RHASH_ST_TABLE_FLAG)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>RHASH_AR_TABLE_BOUND_SET</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>n</name> <operator>&lt;=</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>RHASH_AR_TABLE_BOUND_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <name>n</name> <operator>&lt;&lt;</operator> <name>RHASH_AR_TABLE_BOUND_SHIFT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>RHASH_AR_TABLE_SIZE_SET</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>n</name> <operator>&lt;=</operator> <name>RHASH_AR_TABLE_MAX_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>RHASH_AR_TABLE_SIZE_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <name>n</name> <operator>&lt;&lt;</operator> <name>RHASH_AR_TABLE_SIZE_SHIFT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>HASH_AR_TABLE_SIZE_ADD</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_SET</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_AR_TABLE_SIZE_INC</name><parameter_list>(<parameter><type><name>h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_AR_TABLE_SIZE_ADD(h, 1)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>RHASH_AR_TABLE_SIZE_DEC</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_size</name> <init>= <expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_SET</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_SET</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_BOUND_SET</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>RHASH_AR_TABLE_CLEAR</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>RHASH_AR_TABLE_SIZE_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>RHASH_AR_TABLE_BOUND_MASK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_ar_table_set</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ar_table</name><modifier>*</modifier></type>
<name>ar_alloc_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ar_table</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><operator>(</operator><name>ar_table</name><operator>*</operator><operator>)</operator><call><name>rb_transient_heap_alloc</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ar_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_SET_TRANSIENT_FLAG</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_UNSET_TRANSIENT_FLAG</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tab</name> <operator>=</operator> <operator>(</operator><name>ar_table</name><operator>*</operator><operator>)</operator><call><name>ruby_xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ar_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_BOUND_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_ar_table_set</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>tab</name></expr>;</return>
</block_content>}</block></function>

<macro><name>NOINLINE</name><argument_list>(<argument>static int ar_equal(VALUE x, VALUE y)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_any_cmp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>ar_find_entry_hint</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>ar_hint_t</name></type> <name>hint</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ar_hint_t</name> <modifier>*</modifier></type><name>hints</name> <init>= <expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ar_hint</name><operator>.</operator><name>ary</name></name></expr></init></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>hints</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>hint</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ar_equal</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>artable_hint_hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static int pid;
static char fname[256];
static FILE *fp;

if (pid != getpid()) {
snprintf(fname, sizeof(fname), "/tmp/ruby-armiss.%d", pid = getpid());
if ((fp = fopen(fname, "w")) == NULL) rb_bug("fopen");
}

st_hash_t h1 = ar_do_hash(key);
st_hash_t h2 = ar_do_hash(pair-&gt;key);

fprintf(fp, "miss: hash_eq:%d hints[%d]:%02x hint:%02x\n"
" key :%016lx %s\n"
" pair-&gt;key:%016lx %s\n",
h1 == h2, i, hints[i], hint,
h1, rb_obj_info(key), h2, rb_obj_info(pair-&gt;key));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>artable_hint_miss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>artable_hint_notfound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>RHASH_AR_TABLE_MAX_BOUND</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>ar_find_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ar_hint_t</name></type> <name>hint</name> <init>= <expr><call><name>ar_do_hash_hint</name><argument_list>(<argument><expr><name>hash_value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>ar_find_entry_hint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ar_free_and_clear_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ar_table</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tab</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_UNSET_TRANSIENT_FLAG</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_CLEAR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ar_try_convert_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>size</name> <init>= <expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>new_tab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>RHASH_AR_TABLE_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <call><name>st_init_table_with_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objhash</name></expr></argument>, <argument><expr><name>size</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name>new_tab</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ar_free_and_clear_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>new_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type>
<name>ar_force_convert_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>new_tab</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RHASH_CONVERT_TABLE_DEBUG</name></expr></cpp:if>
<expr_stmt><expr><call><name>rb_obj_info_dump</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"force_convert: %s:%d\n"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_hash_force_convert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <call><name>st_init_table_with_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objhash</name></expr></argument>, <argument><expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>st_add_direct</name><argument_list>(<argument><expr><name>new_tab</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ar_free_and_clear_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <call><name>st_init_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>new_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>new_tab</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ar_table</name> <modifier>*</modifier></type>
<name>hash_ar_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_TABLE_NULL_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ar_alloc_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_compact_table</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>size</name> <init>= <expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <name>bound</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pairs</name> <init>= <expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>pairs</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>bound</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pairs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_hint_set_hint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_hash_t</name><operator>)</operator><call><name>ar_hint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_clear_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<goto>goto <name>found</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<goto>goto <name>done</name>;</goto>
<label><name>found</name>:</label><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>i</name><operator>&lt;=</operator><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RHASH_AR_TABLE_BOUND_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_add_direct_with_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_hash_t</name></type> <name>hash_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>bin</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>RHASH_AR_TABLE_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>bin</name> <operator>&gt;=</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>ar_compact_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_ar_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>bin</name> <operator>&lt;</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ar_set_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_BOUND_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_INC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_general_foreach</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_foreach_check_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_update_callback_func</name> <modifier>*</modifier></type><name>replace</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>st_retval</name></name></type> <name>retval</name> <init>= <expr><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<switch>switch <condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ST_CONTINUE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ST_CHECK</name></expr>:</case>
<case>case <expr><name>ST_STOP</name></expr>:</case>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><name>ST_REPLACE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>replace</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ST_DELETE</name></expr>:</case>
<expr_stmt><expr><call><name>ar_clear_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_DEC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_foreach_with_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_foreach_check_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_update_callback_func</name> <modifier>*</modifier></type><name>replace</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ar_general_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>functor</name> <block>{
<decl_stmt><decl><type><name>st_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>arg</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>apply_functor</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>functor</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>d</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_foreach</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>functor</name></name></type> <name>f</name> <init>= <expr><block>{ <expr><name>func</name></expr>, <expr><name>arg</name></expr> }</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>ar_general_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>apply_functor</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_foreach_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_foreach_check_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>,
<parameter><decl><type><name>st_data_t</name></type> <name>never</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>st_retval</name></name></type> <name>retval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ar_hint_t</name></type> <name>hint</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pair</name> <operator>=</operator> <call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>hint</name> <operator>=</operator> <call><name>ar_hint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ST_CHECK</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>pair</name> <operator>=</operator> <call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <name>never</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ar_find_entry_hint</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<case>case <expr><name>ST_CONTINUE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ST_STOP</name></expr>:</case>
<case>case <expr><name>ST_REPLACE</name></expr>:</case>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<case>case <expr><name>ST_DELETE</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ar_clear_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_DEC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_update</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>,
<parameter><decl><type><name>st_update_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>, <decl><type ref="prev"/><name>existing</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>bin</name> <init>= <expr><name>RHASH_AR_TABLE_MAX_BOUND</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>old_key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash_value</name> <init>= <expr><call><name>ar_do_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>ar_find_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>existing</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>bin</name> <operator>!=</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>hash_ar_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>existing</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>old_key</name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<switch>switch <condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ST_CONTINUE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>existing</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ar_add_direct_with_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>old_key</name> <operator>!=</operator> <name>key</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>ST_DELETE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ar_clear_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_DEC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>existing</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_insert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>bin</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash_value</name> <init>= <expr><call><name>ar_do_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>hash_ar_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>ar_find_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>RHASH_AR_TABLE_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>bin</name> <operator>&gt;=</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>ar_compact_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_ar_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>bin</name> <operator>&lt;</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ar_set_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_BOUND_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_INC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>val</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_lookup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash_value</name> <init>= <expr><call><name>ar_do_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>st_lookup</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>bin</name> <init>= <expr><call><name>ar_find_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>bin</name> <operator>&lt;</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>val</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_delete</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>bin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_hash_t</name></type> <name>hash_value</name> <init>= <expr><call><name>ar_do_hash</name><argument_list>(<argument><expr><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><operator>!</operator><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>st_delete</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bin</name> <operator>=</operator> <call><name>ar_find_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hash_value</name></expr></argument>, <argument><expr><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>==</operator> <name>RHASH_AR_TABLE_MAX_BOUND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ar_clear_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_DEC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ar_shift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ar_table_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>key</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_clear_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_DEC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>ar_keys</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>keys_start</name> <init>= <expr><name>keys</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keys_end</name> <init>= <expr><name>keys</name> <operator>+</operator> <name>size</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>keys</name> <operator>==</operator> <name>keys_end</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>keys</name><operator>++</operator> <operator>=</operator> <call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>key</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>keys</name> <operator>-</operator> <name>keys_start</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>ar_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bound</name> <init>= <expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>values_start</name> <init>= <expr><name>values</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>values_end</name> <init>= <expr><name>values</name> <operator>+</operator> <name>size</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bound</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>values</name> <operator>==</operator> <name>values_end</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ar_cleared_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>values</name><operator>++</operator> <operator>=</operator> <call><name>RHASH_AR_TABLE_REF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>val</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>values</name> <operator>-</operator> <name>values_start</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ar_table</name><modifier>*</modifier></type>
<name>ar_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ar_table</name> <modifier>*</modifier></type><name>old_tab</name> <init>= <expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>old_tab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ar_table</name> <modifier>*</modifier></type><name>new_tab</name> <init>= <expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>new_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <operator>(</operator><name>ar_table</name><operator>*</operator><operator>)</operator> <call><name>rb_transient_heap_alloc</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ar_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_tab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_SET_TRANSIENT_FLAG</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_UNSET_TRANSIENT_FLAG</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <operator>(</operator><name>ar_table</name><operator>*</operator><operator>)</operator><call><name>ruby_xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ar_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>new_tab</name> <operator>=</operator> <operator>*</operator><name>old_tab</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ar_hint</name><operator>.</operator><name>word</name></name> <operator>=</operator> <call><name>RHASH</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>ar_hint</name><operator>.</operator><name>word</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_BOUND_SET</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_SET</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_ar_table_set</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><name>new_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>new_tab</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_BOUND_SET</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_SET</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_UNSET_TRANSIENT_FLAG</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ruby_xfree</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>hash_ar_table_set</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>old_tab</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ar_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_SIZE_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_AR_TABLE_BOUND_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_AR_TABLE_BOUND</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_TRANSIENT_HEAP</name></expr></cpp:if>
<function><type><name>void</name></type>
<name>rb_hash_transient_heap_evacuate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>promote</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_TRANSIENT_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ar_table</name> <modifier>*</modifier></type><name>new_tab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ar_table</name> <modifier>*</modifier></type><name>old_tab</name> <init>= <expr><call><name>RHASH_AR_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>UNLIKELY</name><argument_list>(<argument><expr><name>old_tab</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_gc_force_recycle</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>old_tab</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>promote</name></expr>)</condition> <block>{<block_content>
<label><name>promote</name>:</label>
<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <call><name>ruby_xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ar_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_UNSET_TRANSIENT_FLAG</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>new_tab</name> <operator>=</operator> <call><name>rb_transient_heap_alloc</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ar_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>promote</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>new_tab</name> <operator>=</operator> <operator>*</operator><name>old_tab</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_ar_table_set</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>new_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <function_decl><type><name>int</name></type> <name>st_foreach_func</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>foreach_safe_arg</name> <block>{
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_foreach_func</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>arg</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>foreach_safe_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>foreach_safe_arg</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>args</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_STOP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>arg</name><operator>-&gt;</operator><name>func</name></name>)<argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>ST_CONTINUE</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ST_CHECK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>st_foreach_safe</name><parameter_list>(<parameter><decl><type><name>st_table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>st_foreach_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>foreach_safe_arg</name></name></type> <name>arg</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>tbl</name></name> <operator>=</operator> <name>table</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>func</name></name> <operator>=</operator> <operator>(</operator><name>st_foreach_func</name> <operator>*</operator><operator>)</operator><name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>st_foreach_check</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>foreach_safe_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"hash modified during iteration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<typedef>typedef <function_decl><type><name>int</name></type> <name>rb_foreach_func</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>VALUE</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<struct>struct <name>hash_foreach_arg</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_foreach_func</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>arg</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>hash_ar_foreach_iter</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hash_foreach_arg</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>hash_foreach_arg</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_STOP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>arg</name><operator>-&gt;</operator><name>func</name></name>)<argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<switch>switch <condition>(<expr><name>status</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ST_DELETE</name></expr>:</case>
<return>return <expr><name>ST_DELETE</name></expr>;</return>
<case>case <expr><name>ST_CONTINUE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ST_STOP</name></expr>:</case>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>ST_CHECK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>hash_foreach_iter</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hash_foreach_arg</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>hash_foreach_arg</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_STOP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>arg</name><operator>-&gt;</operator><name>func</name></name>)<argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>value</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>tbl</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"rehash occurred during iteration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>status</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ST_DELETE</name></expr>:</case>
<return>return <expr><name>ST_DELETE</name></expr>;</return>
<case>case <expr><name>ST_CONTINUE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ST_STOP</name></expr>:</case>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>ST_CHECK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>iter_lev_in_ivar</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>levval</name> <init>= <expr><call><name>rb_ivar_get</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>id_hash_iter_lev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>levval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>FIX2INT</name><argument_list>(<argument><expr><name>levval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>rb_ivar_set_internal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>ID</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>iter_lev_in_ivar_set</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ivar_set_internal</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>id_hash_iter_lev</name></expr></argument>, <argument><expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>lev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>iter_lev_in_flags</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&gt;&gt;</operator> <name>RHASH_LEV_SHIFT</name><operator>)</operator> <operator>&amp;</operator> <name>RHASH_LEV_MAX</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>u</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>RHASH_ITER_LEV</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lev</name> <init>= <expr><call><name>iter_lev_in_flags</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>lev</name> <operator>==</operator> <name>RHASH_LEV_MAX</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>iter_lev_in_ivar</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>lev</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hash_iter_lev_inc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lev</name> <init>= <expr><call><name>iter_lev_in_flags</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lev</name> <operator>==</operator> <name>RHASH_LEV_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>iter_lev_in_ivar</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iter_lev_in_ivar_set</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>lev</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>lev</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <operator>(</operator><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>RHASH_LEV_MASK</name><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>VALUE</name><operator>)</operator><name>lev</name> <operator>&lt;&lt;</operator> <name>RHASH_LEV_SHIFT</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lev</name> <operator>==</operator> <name>RHASH_LEV_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>iter_lev_in_ivar_set</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>lev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>hash_iter_lev_dec</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lev</name> <init>= <expr><call><name>iter_lev_in_flags</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lev</name> <operator>==</operator> <name>RHASH_LEV_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lev</name> <operator>=</operator> <call><name>iter_lev_in_ivar</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>lev</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iter_lev_in_ivar_set</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>lev</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>lev</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>=</operator> <operator>(</operator><operator>(</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>RHASH_LEV_MASK</name><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><name>lev</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>RHASH_LEV_SHIFT</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_foreach_ensure_rollback</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hash_iter_lev_inc</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_foreach_ensure</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hash_iter_lev_dec</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_hash_stlike_foreach</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_foreach_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ar_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>st_foreach</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_hash_stlike_foreach_with_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_foreach_check_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_update_callback_func</name> <modifier>*</modifier></type><name>replace</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ar_foreach_with_replace</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>st_foreach_with_replace</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_foreach_call</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><operator>(</operator><operator>(</operator>struct <name>hash_foreach_arg</name> <operator>*</operator><operator>)</operator><name>arg</name><operator>)</operator><operator>-&gt;</operator><name>hash</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ar_foreach_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hash_ar_foreach_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>st_foreach_check</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hash_foreach_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"ret: %d, hash modified during iteration"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_hash_foreach</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>rb_foreach_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>farg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hash_foreach_arg</name></name></type> <name>arg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_TABLE_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hash_iter_lev_inc</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>func</name></name> <operator>=</operator> <operator>(</operator><name>rb_foreach_func</name> <operator>*</operator><operator>)</operator><name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>farg</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>hash_foreach_call</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><name>hash_foreach_ensure</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_alloc_flags</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ifnone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>wb</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>RGENGC_WB_PROTECTED_HASH</name></expr> ?</condition><then> <expr><name>FL_WB_PROTECTED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>NEWOBJ_OF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr>struct <name>RHash</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_HASH</name> <operator>|</operator> <name>wb</name> <operator>|</operator> <name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RHASH_SET_IFNONE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>hash</name></expr></argument>, <argument><expr><name>ifnone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hash_alloc_flags</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>empty_hash_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RUBY_DTRACE_CREATE_HOOK</name><argument_list>(<argument><expr><name>HASH</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>hash_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hash_alloc</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_hash_new_with_size</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>RHASH_AR_TABLE_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ar_alloc_table</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>st_init_table_with_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objhash</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ret</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ar_copy</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><call><name>st_copy</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_dup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hash_copy</name><argument_list>(<argument><expr><call><name>hash_alloc_flags</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><call><name>RHASH_IFNONE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash_dup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>flags</name> <init>= <expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>hash_dup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>FL_EXIVAR</name><operator>|</operator><name>RHASH_PROC_DEFAULT</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>FL_EXIVAR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_copy_generic_ivar</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_hash_resurrect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>hash_dup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_hash_modify_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RHASH_CONVERT_TABLE_DEBUG</name></expr></cpp:if>
<name>rb_hash_tbl_raw</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ar_force_convert_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>rb_hash_tbl_raw</name><argument_list>(<argument>VALUE hash</argument>)</argument_list></macro>
<block>{<block_content>
<return>return <expr><call><name>ar_force_convert_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name><name>struct</name> <name>st_table</name></name> <modifier>*</modifier></type>
<name>rb_hash_tbl</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>OBJ_WB_UNPROTECT</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>RHASH_TBL_RAW</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_hash_modify</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>NORETURN</name><argument_list>(<argument>static void no_new_key(void)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>no_new_key</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"can't add a new key into hash during iteration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>update_callback_arg</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>arg</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOINSERT_UPDATE_CALLBACK</name><parameter_list>(<parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static int func##_noinsert(st_data_t *key, st_data_t *val, st_data_t arg, int existing) { if (!existing) no_new_key(); return func(key, val, (struct update_arg *)arg, existing); } static int func##_insert(st_data_t *key, st_data_t *val, st_data_t arg, int existing) { return func(key, val, (struct update_arg *)arg, existing); }</cpp:value></cpp:define>













<struct>struct <name>update_arg</name> <block>{
<decl_stmt><decl><type><name>st_data_t</name></type> <name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>new_key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>old_key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>new_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>old_value</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>tbl_update_func</name>)<parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><name>int</name></type>
<name>rb_hash_stlike_update</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_update_callback_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>ar_update</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ar_try_convert_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>st_update</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>tbl_update</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>tbl_update_func</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>optional_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>update_arg</name></name></type> <name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>optional_arg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>new_key</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>old_key</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>new_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>old_value</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_hash_stlike_update</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>.</operator><name>new_key</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>old_key</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>new_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>.</operator><name>new_value</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>old_value</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>.</operator><name>new_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPDATE_CALLBACK</name><parameter_list>(<parameter><type><name>iter_lev</name></type></parameter>, <parameter><type><name>func</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((iter_lev) &gt; 0 ? func##_noinsert : func##_insert)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_UPDATE_ITER</name><parameter_list>(<parameter><type><name>h</name></type></parameter>, <parameter><type><name>iter_lev</name></type></parameter>, <parameter><type><name>key</name></type></parameter>, <parameter><type><name>func</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { tbl_update((h), (key), UPDATE_CALLBACK((iter_lev), func), (st_data_t)(a)); } while (0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RHASH_UPDATE</name><parameter_list>(<parameter><type><name>hash</name></type></parameter>, <parameter><type><name>key</name></type></parameter>, <parameter><type><name>func</name></type></parameter>, <parameter><type><name>arg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RHASH_UPDATE_ITER(hash, RHASH_ITER_LEV(hash), key, func, arg)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_proc_default</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_proc_lambda_p</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>rb_proc_arity</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"default_proc takes two arguments (2 for %d)"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FL_SET_RAW</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>RHASH_PROC_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_SET_IFNONE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ifnone</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_modify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ifnone</name> <operator>=</operator> <call><name>rb_block_proc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_PROC_DEFAULT</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>ifnone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ifnone</name> <operator>=</operator> <ternary><condition><expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_SET_IFNONE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>ifnone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>





















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_s_create</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_hash_s_try_convert</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_copy</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>val</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"wrong element type %s at %ld (expected array)"</literal></expr></argument>,
<argument><expr><call><name>rb_builtin_class_name</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<default>default:</default>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"invalid number of elements (%ld for 1..2)"</literal></expr></argument>,
<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"odd number of arguments for Hash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_bulk_insert</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_to_hash_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_convert_type_with_id</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>, <argument><expr><literal type="string">"Hash"</literal></expr></argument>, <argument><expr><name>idTo_hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>to_hash</name></cpp:macro> <cpp:value>rb_to_hash_type</cpp:value></cpp:define>

<function><type><name>VALUE</name></type>
<name>rb_check_hash_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_check_convert_type_with_id</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>, <argument><expr><literal type="string">"Hash"</literal></expr></argument>, <argument><expr><name>idTo_hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_s_try_convert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_check_hash_type</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_s_ruby2_keywords_hash_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>basic</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>RHASH_PASS_AS_KEYWORDS</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_s_ruby2_keywords_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Check_Type</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_dup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>basic</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>RHASH_PASS_AS_KEYWORDS</name></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>rehash_arg</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_hash_rehash_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ar_insert</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>





















<function><type><name>VALUE</name></type>
<name>rb_hash_rehash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_ITER_LEV</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"rehash during iteration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>hash_alloc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_alloc_table</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rb_hash_rehash_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_free_and_clear_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_copy</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_free_and_clear_table</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>old_tab</name> <init>= <expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>hash_alloc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>st_init_table_with_size</name><argument_list>(<argument><expr><name><name>old_tab</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>old_tab</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rb_hash_rehash_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>old_tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_CLEAR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>call_default_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>hash</name></expr>, <expr><name>key</name></expr>}</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>rb_proc_call_with_block</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash_default_value</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>LIKELY</name><argument_list>(<argument><expr><call><name>rb_method_basic_definition_p</name><argument_list>(<argument><expr><call><name>CLASS_OF</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id_default</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ifnone</name> <init>= <expr><call><name>RHASH_IFNONE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>RHASH_PROC_DEFAULT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ifnone</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>call_default_proc</name><argument_list>(<argument><expr><name>ifnone</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>id_default</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>hash_stlike_lookup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hash_verify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ar_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>st_lookup</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>int</name></type>
<name>rb_hash_stlike_lookup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hash_stlike_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>















<function><type><name>VALUE</name></type>
<name>rb_hash_aref</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hash_stlike_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_hash_default_value</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash_lookup2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>def</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hash_stlike_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>def</name></expr>;</return> 
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash_lookup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_hash_lookup2</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_fetch_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>block_given</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>block_given</name> <operator>=</operator> <call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>block_given</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"block supersedes default value argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>hash_stlike_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>block_given</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>desc</name> <init>= <expr><call><name>rb_protect</name><argument_list>(<argument><expr><name>rb_inspect</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>rb_any_to_s</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>rb_str_ellipsize</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">65</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_key_err_raise</name><argument_list>(<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"key not found: %"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash_fetch</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_hash_fetch_m</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_default</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ifnone</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ifnone</name> <operator>=</operator> <call><name>RHASH_IFNONE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>RHASH_PROC_DEFAULT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>call_default_proc</name><argument_list>(<argument><expr><name>ifnone</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ifnone</name></expr>;</return>
</block_content>}</block></function>





















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_set_default</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ifnone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_DEFAULT</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>ifnone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ifnone</name></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_default_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>RHASH_PROC_DEFAULT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>RHASH_IFNONE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>














<function><type><name>VALUE</name></type>
<name>rb_hash_set_default_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SET_DEFAULT</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>proc</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>rb_check_convert_type_with_id</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>T_DATA</name></expr></argument>, <argument><expr><literal type="string">"Proc"</literal></expr></argument>, <argument><expr><name>idTo_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>rb_obj_is_proc</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>,
<argument><expr><literal type="string">"wrong default_proc type %s (expected Proc)"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_classname</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_PROC_DEFAULT</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>proc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>key_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_warn_deprecated</name><argument_list>(<argument><expr><literal type="string">"Hash#index"</literal></expr></argument>, <argument><expr><literal type="string">"Hash#key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_hash_key</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_hash_stlike_delete</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>pval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ar_delete</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>st_delete</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>






<function><type><name>VALUE</name></type>
<name>rb_hash_delete_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>ktmp</name> <init>= <expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></init></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_hash_stlike_delete</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ktmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>Qundef</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>






<function><type><name>VALUE</name></type>
<name>rb_hash_delete</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>deleted_value</name> <init>= <expr><call><name>rb_hash_delete_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>deleted_value</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content> 
<return>return <expr><name>deleted_value</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_delete_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_hash_delete_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<struct>struct <name>shift_var</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>shift_i_safe</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>shift_var</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator>struct <name>shift_var</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_shift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>shift_var</name></name></type> <name>var</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>var</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_ITER_LEV</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ar_shift</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>var</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>var</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name><name>var</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>shift_i_safe</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>.</operator><name>key</name></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_delete_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>var</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name><name>var</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>var</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_ITER_LEV</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>st_shift</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>var</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>var</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name><name>var</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>shift_i_safe</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>.</operator><name>key</name></name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_delete_entry</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>var</name><operator>.</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name><name>var</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_hash_default_value</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>delete_if_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ST_DELETE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_enum_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_hash_size</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
















<function><type><name>VALUE</name></type>
<name>rb_hash_delete_if</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_TABLE_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>delete_if_i</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>










<function><type><name>VALUE</name></type>
<name>rb_hash_reject_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_modify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>delete_if_i</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>reject_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>















<function><type><name>VALUE</name></type>
<name>rb_hash_reject</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ruby_verbose</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HAS_EXTRA_STATES</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"extra states are no longer copied: %+"</literal><name>PRIsVALUE</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>reject_i</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_slice</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>value</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>rb_hash_lookup2</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>












<function><type><name>VALUE</name></type>
<name>rb_hash_values_at</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

















<function><type><name>VALUE</name></type>
<name>rb_hash_fetch_values</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_hash_fetch</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>select_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>



















<function><type><name>VALUE</name></type>
<name>rb_hash_select</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>select_i</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>keep_if_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ST_DELETE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>














<function><type><name>VALUE</name></type>
<name>rb_hash_select_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>keep_if_i</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>














<function><type><name>VALUE</name></type>
<name>rb_hash_keep_if</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_TABLE_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>keep_if_i</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>clear_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ST_DELETE</name></expr>;</return>
</block_content>}</block></function>












<function><type><name>VALUE</name></type>
<name>rb_hash_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_ITER_LEV</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>clear_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ar_clear</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>st_clear</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>hash_aset</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>update_arg</name></name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_value</name></name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>old_value</name></name> <operator>=</operator> <operator>*</operator><name>val</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_key</name></name> <operator>=</operator> <operator>*</operator><name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_value</name></name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>val</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash_key_str</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_FL_ANY_RAW</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>FL_EXIVAR</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_fstring</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_str_new_frozen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>hash_aset_str</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>update_arg</name></name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>existing</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_OBJ_FROZEN</name><argument_list>(<argument><expr><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>key</name> <operator>=</operator> <call><name>rb_hash_key_str</name><argument_list>(<argument><expr><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>hash_aset</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<macro><name>NOINSERT_UPDATE_CALLBACK</name><argument_list>(<argument>hash_aset</argument>)</argument_list></macro>
<macro><name>NOINSERT_UPDATE_CALLBACK</name><argument_list>(<argument>hash_aset_str</argument>)</argument_list></macro>




























<function><type><name>VALUE</name></type>
<name>rb_hash_aset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>iter_lev</name> <init>= <expr><call><name>RHASH_ITER_LEV</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_modify</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_TABLE_NULL_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>iter_lev</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>no_new_key</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ar_alloc_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_TYPE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>&amp;</operator><name>identhash</name> <operator>||</operator> <call><name>rb_obj_class</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rb_cString</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_UPDATE_ITER</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>iter_lev</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash_aset</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_UPDATE_ITER</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>iter_lev</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash_aset_str</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>hash</name> <operator>==</operator> <name>hash2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>hash</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_ITER_LEV</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"can't replace hash during iteration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hash2</name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>COPY_DEFAULT</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ar_clear</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ar_free_and_clear_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>st_init_table_with_size</name><argument_list>(<argument><expr><call><name>RHASH_TYPE</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_CLEAR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>st_clear</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_TBL_RAW</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>=</operator> <call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>, <argument><expr><name>rb_hash_rehash_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

















<function><type><name>VALUE</name></type>
<name>rb_hash_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>rb_hash_size_num</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>long</name><operator>)</operator><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_empty_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>Qtrue</name></expr> </then><else>: <expr><name>Qfalse</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>each_value_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>




















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_each_value</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>each_value_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>each_key_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_each_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>each_key_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>each_pair_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>each_pair_i_fast</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_yield_values2</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_each_pair</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_pair_yield_optimizable</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>each_pair_i_fast</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>each_pair_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>transform_keys_args</name><block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>trans</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>block_given</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>transform_keys_hash_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>transarg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>transform_keys_args</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>transarg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>trans</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>trans</name></name></expr></init></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>result</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>new_key</name> <init>= <expr><call><name>rb_hash_lookup2</name><argument_list>(<argument><expr><name>trans</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>new_key</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>block_given</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>new_key</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>new_key</name> <operator>=</operator> <name>key</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>new_key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>transform_keys_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>new_key</name> <init>= <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>new_key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_transform_keys</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>transform_keys_args</name></name></type> <name>transarg</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>transarg</name><operator>.</operator><name>trans</name></name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>transarg</name><operator>.</operator><name>block_given</name></name> <operator>=</operator> <call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>transarg</name><operator>.</operator><name>trans</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>transarg</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>transform_keys_hash_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>transarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>transform_keys_i</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_hash_flatten</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>;</function_decl>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_transform_keys_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>trans</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>block_given</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>trans</name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>block_given</name> <operator>=</operator> <call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_TABLE_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>pairs</name> <init>= <expr><call><name>rb_hash_flatten</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_hash_clear</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>new_key</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>trans</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_key</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>new_key</name> <operator>=</operator> <call><name>rb_hash_lookup2</name><argument_list>(<argument><expr><name>trans</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>block_given</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_key</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>new_key</name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>new_key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>transform_values_foreach_func</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ST_REPLACE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>transform_values_foreach_replace</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>new_value</name> <init>= <expr><call><name>rb_yield</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_transform_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>hash_copy</name><argument_list>(<argument><expr><call><name>hash_alloc</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_stlike_foreach_with_replace</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>transform_values_foreach_func</name></expr></argument>, <argument><expr><name>transform_values_foreach_replace</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_transform_values_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>hash_enum_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_TABLE_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_stlike_foreach_with_replace</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>transform_values_foreach_func</name></expr></argument>, <argument><expr><name>transform_values_foreach_replace</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>to_a_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_to_a</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>to_a_i</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>inspect_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_str_buf_cat_ascii</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_buf_cat_ascii</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"=&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>inspect_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_usascii_str_new2</name><argument_list>(<argument><expr><literal type="string">"{...}"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_buf_new2</name><argument_list>(<argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>inspect_i</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>rb_usascii_str_new2</name><argument_list>(<argument><expr><literal type="string">"{}"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_exec_recursive</name><argument_list>(<argument><expr><name>inspect_hash</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_to_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash_set_pair</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>pair</name></decl>;</decl_stmt>

<expr_stmt><expr><name>pair</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"wrong element type %s (expected array)"</literal></expr></argument>,
<argument><expr><call><name>rb_builtin_class_name</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"element has wrong array length (expected 2, was %ld)"</literal></expr></argument>,
<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>to_h_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_set_pair</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_to_h_block</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>h</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>to_h_i</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_to_h</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_hash_to_h_block</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rb_cHash</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>flags</name> <init>= <expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_dup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <name>RHASH_PROC_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>keys_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>













<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_hash_keys</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>size</name> <init>= <expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>keys</name> <init>= <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>keys</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ST_DATA_COMPATIBLE_P</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>keys</argument>, <argument>ptr</argument>, <argument>{
if (RHASH_AR_TABLE_P(hash)) {
size = ar_keys(hash, ptr, size);
}
else {
st_table *table = RHASH_ST_TABLE(hash);
size = st_keys(table, ptr, size);
}
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_set_len</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>keys_i</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>keys</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>values_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>













<function><type><name>VALUE</name></type>
<name>rb_hash_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>values</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>size</name> <init>= <expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>values</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ST_DATA_COMPATIBLE_P</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>values</argument>, <argument>ptr</argument>, <argument>{
size = ar_values(hash, ptr, size);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>table</name> <init>= <expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>values</argument>, <argument>ptr</argument>, <argument>{
size = st_values(table, ptr, size);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_set_len</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>values_i</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>values</name></expr>;</return>
</block_content>}</block></function>




















<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_hash_has_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hash_stlike_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_hash_search_value</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_has_value</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rb_hash_search_value</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>equal_data</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>eql</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>eql_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>equal_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator>struct <name>equal_data</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>val2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_stlike_lookup</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><ternary><condition><expr><name><name>data</name><operator>-&gt;</operator><name>eql</name></name></expr> ?</condition><then> <expr><call><name>rb_eql</name><argument_list>(<argument><expr><name>val1</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val2</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>rb_equal</name><argument_list>(<argument><expr><name>val1</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val2</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>recursive_eql</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>equal_data</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator>struct <name>equal_data</name><operator>*</operator><operator>)</operator><name>dt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>eql_i</name></expr></argument>, <argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>data</name><operator>-&gt;</operator><name>result</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>equal_data</name></name></type> <name>data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>hash1</name> <operator>==</operator> <name>hash2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>, <argument><expr><name>T_HASH</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_respond_to</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>, <argument><expr><name>idTo_hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eql</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_eql</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>, <argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>, <argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_TABLE_EMPTY_P</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RHASH_TABLE_EMPTY_P</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_TYPE</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RHASH_TYPE</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>hash2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>eql</name></name> <operator>=</operator> <name>eql</name></expr>;</expr_stmt>
<return>return <expr><call><name>rb_exec_recursive_paired</name><argument_list>(<argument><expr><name>recursive_eql</name></expr></argument>, <argument><expr><name>hash1</name></expr></argument>, <argument><expr><name>hash2</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
if (!(rb_equal(RHASH_IFNONE(hash1), RHASH_IFNONE(hash2)) &amp;&amp;
FL_TEST(hash1, RHASH_PROC_DEFAULT) == FL_TEST(hash2, RHASH_PROC_DEFAULT)))
return Qfalse;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></function>

























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hash_equal</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><name>hash2</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_eql</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hash_equal</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><name>hash2</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>hash_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name> <modifier>*</modifier></type><name>hval</name> <init>= <expr><operator>(</operator><name>st_index_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name><name>hdata</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>hdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdata</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_hash</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>hval</name> <operator>^=</operator> <call><name>st_hash</name><argument_list>(<argument><expr><name>hdata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hdata</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>size</name> <init>= <expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>hval</name> <init>= <expr><call><name>rb_hash_start</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>hval</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>hval</name></expr></argument>, <argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name>rb_hash_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hash_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>hval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>hval</name> <operator>=</operator> <call><name>rb_hash_end</name><argument_list>(<argument><expr><name>hval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>hval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_hash_invert_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_invert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>h</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rb_hash_invert_i</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_hash_update_callback</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>update_arg</name></name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>old_value</name></name> <operator>=</operator> <operator>*</operator><name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_value</name></name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_key</name></name> <operator>=</operator> <operator>*</operator><name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_value</name></name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<macro><name>NOINSERT_UPDATE_CALLBACK</name><argument_list>(<argument>rb_hash_update_callback</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_hash_update_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RHASH_UPDATE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>rb_hash_update_callback</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_hash_update_block_callback</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>update_arg</name></name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>newvalue</name> <init>= <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>value</name></expr></argument>, <argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>old_value</name></name> <operator>=</operator> <operator>*</operator><name>value</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_key</name></name> <operator>=</operator> <operator>*</operator><name>key</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_value</name></name> <operator>=</operator> <name>newvalue</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>newvalue</name></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<macro><name>NOINSERT_UPDATE_CALLBACK</name><argument_list>(<argument>rb_hash_update_block_callback</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_hash_update_block_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RHASH_UPDATE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>rb_hash_update_block_callback</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>












































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_update</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>block_given</name> <init>= <expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_hash_modify</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>to_hash</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>block_given</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rb_hash_update_block_i</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rb_hash_update_i</name></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>self</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>update_func_arg</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_hash_update_func</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_hash_update_func_callback</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>update_arg</name></name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>update_func_arg</name></name> <modifier>*</modifier></type><name>uf_arg</name> <init>= <expr><operator>(</operator>struct <name>update_func_arg</name> <operator>*</operator><operator>)</operator><name><name>arg</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>newvalue</name> <init>= <expr><name><name>uf_arg</name><operator>-&gt;</operator><name>value</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>uf_arg</name><operator>-&gt;</operator><name>func</name></name>)<argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>key</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>value</name></expr></argument>, <argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>old_value</name></name> <operator>=</operator> <operator>*</operator><name>value</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_key</name></name> <operator>=</operator> <operator>*</operator><name>key</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>new_value</name></name> <operator>=</operator> <name>newvalue</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>newvalue</name></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<macro><name>NOINSERT_UPDATE_CALLBACK</name><argument_list>(<argument>rb_hash_update_func_callback</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rb_hash_update_func_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg0</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>update_func_arg</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator>struct <name>update_func_arg</name> <operator>*</operator><operator>)</operator><name>arg0</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>hash</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_UPDATE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>rb_hash_update_func_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_hash_update_by</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash2</name></decl></parameter>, <parameter><decl><type><name>rb_hash_update_func</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_modify</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hash2</name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>func</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>update_func_arg</name></name></type> <name>arg</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>hash1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>, <argument><expr><name>rb_hash_update_func_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash2</name></expr></argument>, <argument><expr><name>rb_hash_update_i</name></expr></argument>, <argument><expr><name>hash1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>hash1</name></expr>;</return>
</block_content>}</block></function>
































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_merge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_hash_update</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><call><name>rb_hash_dup</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>assoc_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>lookup2_call</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>rb_hash_lookup2</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>reset_hash_type_arg</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name> <modifier>*</modifier></type><name>orighash</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>reset_hash_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>reset_hash_type_arg</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator>struct <name>reset_hash_type_arg</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>orighash</name></name></expr>;</expr_stmt>
<return>return <expr><name>Qundef</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>assoc_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_equal</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>















<function><type><name>VALUE</name></type>
<name>rb_hash_assoc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>st_hash_type</name></name> <modifier>*</modifier></type><name>orighash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ar_force_convert_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>orighash</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>orighash</name> <operator>!=</operator> <operator>&amp;</operator><name>identhash</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>reset_hash_type_arg</name></name></type> <name>ensure_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>st_hash_type</name></name></type> <name>assochash</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>assochash</name><operator>.</operator><name>compare</name></name> <operator>=</operator> <name>assoc_cmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>assochash</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name><name>orighash</name><operator>-&gt;</operator><name>hash</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <operator>&amp;</operator><name>assochash</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ensure_arg</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ensure_arg</name><operator>.</operator><name>orighash</name></name> <operator>=</operator> <name>orighash</name></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>rb_ensure</name><argument_list>(<argument><expr><name>lookup2_call</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>reset_hash_type</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>ensure_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>assoc_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rassoc_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_equal</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>














<function><type><name>VALUE</name></type>
<name>rb_hash_rassoc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rassoc_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>flatten_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>pair</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_cat</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_flatten</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><call><name>NUM2INT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_hash_to_a</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>flatten_i</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary_flatten_level</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>id_flatten_bang</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ary_flatten_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>level</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>id_flatten_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>flatten_i</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>delete_if_nil</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ST_DELETE</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_if_not_nil</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_compact</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>set_if_not_nil</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_compact_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>delete_if_nil</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>hash</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type><name>rb_init_identtable_with_size</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_compare_by_id</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>identtable</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_hash_compare_by_id_p</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>hash</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_hash_modify_check</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ar_force_convert_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>hash_alloc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>identtable</name> <operator>=</operator> <call><name>rb_init_identtable_with_size</name><argument_list>(<argument><expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>identtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>rb_hash_rehash_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>identtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_CLEAR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_force_recycle</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>










<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_hash_compare_by_id_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>type</name> <operator>==</operator> <operator>&amp;</operator><name>identhash</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ident_hash_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>RHASH_ST_TABLE_SET</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>st_init_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>identhash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>st_table</name> <modifier>*</modifier></type>
<name>rb_init_identtable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_init_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>identhash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_table</name> <modifier>*</modifier></type>
<name>rb_init_identtable_with_size</name><parameter_list>(<parameter><decl><type><name>st_index_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>st_init_table_with_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name>identhash</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>any_p_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>any_p_i_fast</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>any_p_i_pattern</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ret</name> <init>= <expr><call><name>rb_funcall</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></argument>, <argument><expr><name>idEqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_any_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_EMPTY_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>any_p_i_pattern</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_pair_yield_optimizable</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>any_p_i_fast</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>any_p_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>




















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_dig</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self</name> <operator>=</operator> <call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><operator>*</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>--</operator><name>argc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>self</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>argv</name></expr>;</expr_stmt>
<return>return <expr><call><name>rb_obj_dig</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>hash_le_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>rb_hash_lookup2</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>Qundef</name> <operator>&amp;&amp;</operator> <call><name>rb_equal</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_CONTINUE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Qfalse</name></expr>;</expr_stmt>
<return>return <expr><name>ST_STOP</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_le</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>hash2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash1</name></expr></argument>, <argument><expr><name>hash_le_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_le</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>other</name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>hash_le</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_lt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>other</name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>hash_le</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_ge</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>other</name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>hash_le</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_gt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>other</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>other</name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>hash_le</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>
<name>hash_proc_call</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_hash_aref</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>*</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_to_proc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_func_proc_new</name><argument_list>(<argument><expr><name>hash_proc_call</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_hash_deconstruct_keys</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>keys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_new_i</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_STOP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>*</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITE</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>val</name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>rb_hash_add_new_element</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>hash</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hash_ar_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ar_update</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><name>add_new_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ar_try_convert_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tbl</name> <operator>=</operator> <call><name>RHASH_TBL_RAW</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>st_update</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>key</name></expr></argument>, <argument><expr><name>add_new_i</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>st_data_t</name></type>
<name>key_stringify</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>rb_cString</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RB_OBJ_FROZEN</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
<expr><call><name>rb_hash_key_str</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>key</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ar_bulk_insert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>k</name> <init>= <expr><call><name>key_stringify</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>v</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ar_insert</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_hash_bulk_insert</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><name>argc</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>size</name> <init>= <expr><name>argc</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_TABLE_NULL_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>RHASH_AR_TABLE_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hash_ar_table</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RHASH_TBL_RAW</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RHASH_AR_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>RHASH_AR_TABLE_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>size</name> <operator>&lt;=</operator> <name>RHASH_AR_TABLE_MAX_SIZE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ar_bulk_insert</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_bulk_insert_into_st_table</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>origenviron</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ENVIRON</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((e) = rb_w32_get_environ())</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_ENVIRON</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_w32_free_environ(e)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>my_environ</name></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>environ</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>environ</name></cpp:macro> <cpp:value>my_environ</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>getenv</name></cpp:undef>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>w32_getenv</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>w32_getenv_unknown</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<function_decl><type><name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<if_stmt><if>if <condition>(<expr><call><name>rb_locale_encindex</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>rb_ascii8bit_encindex</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>rb_w32_getenv</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>rb_w32_ugetenv</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>w32_getenv</name> <operator>=</operator> <name>func</name><operator>)</operator><operator>(</operator><name>name</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>w32_getenv</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><name>w32_getenv_unknown</name></expr></init>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getenv</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>w32_getenv(n)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>environ</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>environ</name></cpp:macro> <cpp:value>(*_NSGetEnviron())</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ENVIRON</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_ENVIRON</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>environ</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_ENVIRON</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(e)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_ENVIRON</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENV_IGNORECASE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENVMATCH</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(STRCASECMP((s1), (s2)) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENVNMATCH</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(STRNCASECMP((s1), (s2), (n)) == 0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENVMATCH</name><parameter_list>(<parameter><type><name>n1</name></type></parameter>, <parameter><type><name>n2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(strcmp((n1), (n2)) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENVNMATCH</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(memcmp((s1), (s2), (n)) == 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_enc_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>internal</name> <init>= <expr><call><name>rb_default_internal_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ecflags</name> <init>= <expr><name>ECONV_INVALID_REPLACE</name> <operator>|</operator> <name>ECONV_UNDEF_REPLACE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>utf8</name> <init>= <expr><call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_enc_str_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>internal</name></expr> ?</condition><then> <expr><name>internal</name></expr> </then><else>: <expr><name>enc</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><call><name>rb_str_cat_conv_enc_opts</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>utf8</name></expr></argument>, <argument><expr><name>ecflags</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_str_initialize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><call><name>rb_external_str_new_with_enc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_enc_str_new_cstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>env_enc_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_str_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>env_enc_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>rb_locale_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_str_new2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>env_str_new</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>TZ_ENV</name><index>[]</index></name> <init>= <expr><literal type="string">"TZ"</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>rb_encoding</name> <modifier>*</modifier></type>
<name>env_encoding_for</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ENVMATCH</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>PATH_ENV</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_filesystem_encoding</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_locale_encoding</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_name_new</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>env_enc_str_new_cstr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>env_encoding_for</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>get_env_cstr</name><parameter_list>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>pstr</name></decl></parameter>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<parameter><decl><type><name>VALUE</name></type> <name>str</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name> <init>= <expr><operator>*</operator><name>pstr</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rb_encoding</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><call><name>rb_enc_get</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_asciicompat</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"bad environment variable %s: ASCII incompatible encoding: %s"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>rb_enc_name</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_enc_str_asciionly_p</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pstr</name> <operator>=</operator> <name>str</name> <operator>=</operator> <call><name>rb_str_conv_enc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>rb_utf8_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"bad environment variable %s: contains null byte"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_str_fill_terminator</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> 
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_env_ptr</name><parameter_list>(<parameter><type><name>var</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(var = get_env_cstr(&amp;(val), #var))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_env_ptr</name><parameter_list>(<parameter><type><name>var</name></type></parameter>, <parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(var = get_env_cstr(val, #var))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>env_name</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SafeStringValue</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_env_ptr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>env_name</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>env_name(&amp;(s))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>env_aset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>nm</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_delete</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nam</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nam</name> <operator>=</operator> <call><name>env_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>nam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><call><name>ENVMATCH</name><argument_list>(<argument><expr><name>nam</name></expr></argument>, <argument><expr><name>TZ_ENV</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ruby_reset_timezone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>value</name> <init>= <expr><call><name>env_str_new2</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ruby_setenv</name><argument_list>(<argument><expr><name>nam</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ENVMATCH</name><argument_list>(<argument><expr><name>nam</name></expr></argument>, <argument><expr><name>PATH_ENV</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_delete_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>env_delete</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_f_getenv</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nam</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nam</name> <operator>=</operator> <call><name>env_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>nam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>env</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>env_name_new</name><argument_list>(<argument><expr><name>nam</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>


























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_fetch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>block_given</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nam</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>block_given</name> <operator>=</operator> <call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>block_given</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"block supersedes default value argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nam</name> <operator>=</operator> <call><name>env_name</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>nam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>env</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>block_given</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_key_err_raise</name><argument_list>(<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"key not found: \"%"</literal><name>PRIsVALUE</name><literal type="string">"\""</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>envtbl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>env_name_new</name><argument_list>(<argument><expr><name>nam</name></expr></argument>, <argument><expr><name>env</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>rb_env_path_tainted</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_warn_deprecated_to_remove</name><argument_list>(<argument><expr><literal type="string">"rb_env_path_tainted"</literal></expr></argument>, <argument><expr><literal type="string">"3.2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETENV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNSETENV</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__sun</name></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>in_origenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>env</name> <operator>=</operator> <name>origenviron</name></expr>;</init> <condition><expr><operator>*</operator><name>env</name></expr>;</condition> <incr><expr><operator>++</operator><name>env</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>env</name> <operator>==</operator> <name>str</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>envix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>nam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>env</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ENVNMATCH</name><argument_list>(<argument><expr><name><name>env</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>nam</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>env</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 
</block_content>}</block></for> 
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>getenvsize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WCHAR</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>WCHAR</name><modifier>*</modifier></type> <name>porg</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>lstrlenW</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>p</name> <operator>-</operator> <name>porg</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>getenvblocksize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MAX_ENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>_MAX_ENV</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><literal type="number">32767</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_envsize</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>_WIN32_WINNT</name> <operator>&lt;</operator> <literal type="number">0x0600</literal> <operator>&amp;&amp;</operator> <call><name>rb_w32_osver</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>WCHAR</name><modifier>*</modifier></type> <name>p</name> <init>= <expr><call><name>GetEnvironmentStringsW</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>getenvsize</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FreeEnvironmentStringsW</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <call><name>getenvblocksize</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETENV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNSETENV</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></cpp:if>


<macro><name>NORETURN</name><argument_list>(<argument>static void invalid_envname(const char *name)</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>invalid_envname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_syserr_fail_str</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>, <argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"ruby_setenv(%s)"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>check_envname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>invalid_envname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>ruby_setenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MINGW_HAS_SECURE_API</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>RUBY_MSVCRT_VERSION</name> <operator>&gt;=</operator> <literal type="number">80</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE__WPUTENV_S</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>VALUE</name></type> <name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>wname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WCHAR</name> <modifier>*</modifier></type><name>wvalue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>failed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check_envname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>check_envsize</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name> <operator>+</operator> <name>len2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<goto>goto <name>fail</name>;</goto> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>wname</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>WCHAR</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wvalue</name> <operator>=</operator> <name>wname</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>wname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>wvalue</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__WPUTENV_S</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>wname</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>L</name><literal type="char">'='</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>wname</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>WCHAR</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_UTF8</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>wname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wvalue</name> <operator>=</operator> <name>wname</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>wvalue</name> <operator>=</operator> <name>L</name><literal type="char">'\0'</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__WPUTENV_S</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>wname</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>L</name><literal type="char">'='</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__WPUTENV_S</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>failed</name> <operator>=</operator> <call><name>_wputenv</name><argument_list>(<argument><expr><name>wname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>failed</name> <operator>=</operator> <call><name>_wputenv_s</name><argument_list>(<argument><expr><name>wname</name></expr></argument>, <argument><expr><name>wvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>value</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SetEnvironmentVariable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ERROR_ENVVAR_NOT_FOUND</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition> <block>{<block_content>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>invalid_envname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETENV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNSETENV</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>setenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_sys_fail_str</name><argument_list>(<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"setenv(%s)"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VOID_UNSETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>unsetenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>unsetenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_sys_fail_str</name><argument_list>(<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"unsetenv(%s)"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__sun</name></expr></cpp:elif>




<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>mem_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env_ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mem_ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>check_envname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mem_size</name> <operator>=</operator> <name>len</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>mem_ptr</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>mem_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mem_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_sys_fail_str</name><argument_list>(<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"malloc("</literal><name>PRIuSIZE</name><literal type="string">")"</literal></expr></argument>, <argument><expr><name>mem_size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>mem_ptr</name></expr></argument>, <argument><expr><name>mem_size</name></expr></argument>, <argument><expr><literal type="string">"%s=%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>env_ptr</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><operator>(</operator><name>str</name> <operator>=</operator> <operator>*</operator><name>env_ptr</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>env_ptr</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>in_origenv</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>(</operator><name><name>env_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>env_ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>env_ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>putenv</name><argument_list>(<argument><expr><name>mem_ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>mem_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_sys_fail_str</name><argument_list>(<argument><expr><call><name>rb_sprintf</name><argument_list>(<argument><expr><literal type="string">"putenv(%s)"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name><operator>=</operator><call><name>envix</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>environ</name> <operator>==</operator> <name>origenviron</name></expr>)</condition> <block>{<block_content> 
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmpenv</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>max</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name><name>environ</name><index>[<expr><name>max</name></expr>]</index></name></expr>;</condition> <incr><expr><name>max</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name>tmpenv</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>, <argument><expr><name>max</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>max</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> 
<expr_stmt><expr><name><name>tmpenv</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>ruby_strdup</name><argument_list>(<argument><expr><name><name>environ</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>tmpenv</name><index>[<expr><name>max</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>environ</name> <operator>=</operator> <name>tmpenv</name></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>envp</name> <init>= <expr><name>origenviron</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>envp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>envp</name> <operator>!=</operator> <name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>envp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>envp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>environ</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>REALLOC_N</name><argument_list>(<argument><expr><name>environ</name></expr></argument>, <argument><expr><name>char</name><operator>*</operator></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>environ</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>char</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ruby_unsetenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ruby_setenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>













































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_aset_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>nm</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>env_aset</name><argument_list>(<argument><expr><name>nm</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_aset</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>nm</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>env_delete</name><argument_list>(<argument><expr><name>nm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>SafeStringValue</name><argument_list>(<argument><expr><name>nm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SafeStringValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>get_env_ptr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>nm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>get_env_ptr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ruby_setenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ENVMATCH</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>PATH_ENV</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>nm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>ENVMATCH</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>TZ_ENV</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ruby_reset_timezone</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_keys</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>env_str_new</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><operator>*</operator><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>env</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_f_keys</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>env_keys</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_env_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ehash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>env</name></expr> ;</condition> <incr><expr><operator>++</operator><name>env</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_each_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ehash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>keys</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_env_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>env_keys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ehash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_values</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>env_str_new2</name><argument_list>(<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>env</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_f_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>env_values</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_each_value</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ehash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>values</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_env_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>env_values</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ehash</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_each_pair</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ehash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_env_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>env_str_new</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><operator>*</operator><name>env</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>env_str_new2</name><argument_list>(<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>env</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_pair_yield_optimizable</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ehash</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_reject_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ehash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>keys</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>del</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_env_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>env_keys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>rb_f_getenv</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>env_delete</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>del</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>del</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>envtbl</name></expr>;</return>
</block_content>}</block></function>





















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_delete_if</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ehash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_env_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>env_reject_bang</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>envtbl</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_values_at</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_f_getenv</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_select</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ehash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>keys</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_env_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>env_keys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>rb_f_getenv</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>






































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_select_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ehash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>keys</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>del</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_env_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>env_keys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>rb_f_getenv</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>env_delete</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>del</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>del</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>envtbl</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_keep_if</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ehash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rb_env_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>env_select_bang</name><argument_list>(<argument><expr><name>ehash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>envtbl</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_slice</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>value</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>rb_f_getenv</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>Qnil</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_env_clear</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>keys</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>env_keys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>rb_f_getenv</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>env_delete</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>envtbl</name></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_env_clear</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_usascii_str_new2</name><argument_list>(<argument><expr><literal type="string">"ENV"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_buf_new2</name><argument_list>(<argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>env</name> <operator>!=</operator> <name>environ</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_buf_cat</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><operator>*</operator><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"=&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><call><name>rb_str_new2</name><argument_list>(<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>env</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_to_a</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>env_str_new</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><operator>*</operator><name>env</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>env_str_new2</name><argument_list>(<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>env</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_none</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>env</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_empty_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>env</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>


























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_has_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>env_name</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_assoc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>env_name</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>env_str_new2</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_has_value</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dmy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>env</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>





















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_rassoc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dmy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>rb_str_new</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><operator>*</operator><name>env</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>env</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_key</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dmy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>str</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SafeStringValue</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>env_str_new</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><operator>*</operator><name>env</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>env</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dmy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_warn_deprecated</name><argument_list>(<argument><expr><literal type="string">"ENV.index"</literal></expr></argument>, <argument><expr><literal type="string">"ENV.key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>env_key</name><argument_list>(<argument><expr><name>dmy</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_to_hash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>env_str_new</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><operator>*</operator><name>env</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>env_str_new2</name><argument_list>(<argument><expr><name>s</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>env</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_f_to_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>env_to_hash</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_to_h</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>env_to_hash</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>rb_hash_to_h_block</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_reject</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_hash_delete_if</name><argument_list>(<argument><expr><call><name>env_to_hash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_freeze</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"cannot freeze ENV"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>self</name></expr>;</return> 
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_shift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>GET_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>env</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>key</name> <init>= <expr><call><name>env_str_new</name><argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>, <argument><expr><name>s</name><operator>-</operator><operator>*</operator><name>env</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name> <init>= <expr><call><name>env_str_new2</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><call><name>RSTRING_PTR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>env_delete</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_assoc_new</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>FREE_ENVIRON</name><argument_list>(<argument><expr><name>environ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_invert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_hash_invert</name><argument_list>(<argument><expr><call><name>env_to_hash</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>env_replace_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>keys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>env_aset</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_ary_includes</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_delete</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>keys</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>env_keys</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>env</name> <operator>==</operator> <name>hash</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>env</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>env_replace_i</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>env_delete</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>env</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>env_update_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>env_aset</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>env_update_block_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>oldval</name> <init>= <expr><call><name>rb_f_getenv</name><argument_list>(<argument><expr><name>Qnil</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>env_aset</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>





































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>env_update</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>env</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>env</name> <operator>==</operator> <name>hash</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>env</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>to_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>rb_foreach_func</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><ternary><condition><expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr> ?</condition><then>
<expr><name>env_update_block_i</name></expr> </then><else>: <expr><name>env_update_i</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>env</name></expr>;</return>
</block_content>}</block></function>























































































































































































































<function><type><name>void</name></type>
<name>Init_Hash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_intern</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_intern_const(str)</cpp:value></cpp:define>
<expr_stmt><expr><name>id_hash</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_default</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"default"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_flatten_bang</name> <operator>=</operator> <call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"flatten!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_hash_iter_lev</name> <operator>=</operator> <call><name>rb_make_internal_id</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rb_cHash</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Hash"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><name>rb_mEnumerable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><name>empty_hash_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>rb_hash_s_create</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"try_convert"</literal></expr></argument>, <argument><expr><name>rb_hash_s_try_convert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>rb_hash_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>, <argument><expr><name>rb_hash_replace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"rehash"</literal></expr></argument>, <argument><expr><name>rb_hash_rehash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"to_hash"</literal></expr></argument>, <argument><expr><name>rb_hash_to_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"to_h"</literal></expr></argument>, <argument><expr><name>rb_hash_to_h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"to_a"</literal></expr></argument>, <argument><expr><name>rb_hash_to_a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>rb_hash_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"to_proc"</literal></expr></argument>, <argument><expr><name>rb_hash_to_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>rb_hash_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>rb_hash_aref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>rb_hash_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"eql?"</literal></expr></argument>, <argument><expr><name>rb_hash_eql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><name>rb_hash_fetch_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"[]="</literal></expr></argument>, <argument><expr><name>rb_hash_aset</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"store"</literal></expr></argument>, <argument><expr><name>rb_hash_aset</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"default"</literal></expr></argument>, <argument><expr><name>rb_hash_default</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"default="</literal></expr></argument>, <argument><expr><name>rb_hash_set_default</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"default_proc"</literal></expr></argument>, <argument><expr><name>rb_hash_default_proc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"default_proc="</literal></expr></argument>, <argument><expr><name>rb_hash_set_default_proc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>, <argument><expr><name>rb_hash_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><name>rb_hash_index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>rb_hash_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><name>rb_hash_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"empty?"</literal></expr></argument>, <argument><expr><name>rb_hash_empty_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"each_value"</literal></expr></argument>, <argument><expr><name>rb_hash_each_value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"each_key"</literal></expr></argument>, <argument><expr><name>rb_hash_each_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"each_pair"</literal></expr></argument>, <argument><expr><name>rb_hash_each_pair</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>rb_hash_each_pair</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"transform_keys"</literal></expr></argument>, <argument><expr><name>rb_hash_transform_keys</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"transform_keys!"</literal></expr></argument>, <argument><expr><name>rb_hash_transform_keys_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"transform_values"</literal></expr></argument>, <argument><expr><name>rb_hash_transform_values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"transform_values!"</literal></expr></argument>, <argument><expr><name>rb_hash_transform_values_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"keys"</literal></expr></argument>, <argument><expr><name>rb_hash_keys</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"values"</literal></expr></argument>, <argument><expr><name>rb_hash_values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"values_at"</literal></expr></argument>, <argument><expr><name>rb_hash_values_at</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"fetch_values"</literal></expr></argument>, <argument><expr><name>rb_hash_fetch_values</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"shift"</literal></expr></argument>, <argument><expr><name>rb_hash_shift</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>, <argument><expr><name>rb_hash_delete_m</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"delete_if"</literal></expr></argument>, <argument><expr><name>rb_hash_delete_if</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"keep_if"</literal></expr></argument>, <argument><expr><name>rb_hash_keep_if</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>, <argument><expr><name>rb_hash_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"select!"</literal></expr></argument>, <argument><expr><name>rb_hash_select_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"filter"</literal></expr></argument>, <argument><expr><name>rb_hash_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"filter!"</literal></expr></argument>, <argument><expr><name>rb_hash_select_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"reject"</literal></expr></argument>, <argument><expr><name>rb_hash_reject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"reject!"</literal></expr></argument>, <argument><expr><name>rb_hash_reject_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name>rb_hash_slice</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"clear"</literal></expr></argument>, <argument><expr><name>rb_hash_clear</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"invert"</literal></expr></argument>, <argument><expr><name>rb_hash_invert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"update"</literal></expr></argument>, <argument><expr><name>rb_hash_update</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"replace"</literal></expr></argument>, <argument><expr><name>rb_hash_replace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"merge!"</literal></expr></argument>, <argument><expr><name>rb_hash_update</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"merge"</literal></expr></argument>, <argument><expr><name>rb_hash_merge</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"assoc"</literal></expr></argument>, <argument><expr><name>rb_hash_assoc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"rassoc"</literal></expr></argument>, <argument><expr><name>rb_hash_rassoc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"flatten"</literal></expr></argument>, <argument><expr><name>rb_hash_flatten</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"compact"</literal></expr></argument>, <argument><expr><name>rb_hash_compact</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"compact!"</literal></expr></argument>, <argument><expr><name>rb_hash_compact_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"include?"</literal></expr></argument>, <argument><expr><name>rb_hash_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"member?"</literal></expr></argument>, <argument><expr><name>rb_hash_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"has_key?"</literal></expr></argument>, <argument><expr><name>rb_hash_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"has_value?"</literal></expr></argument>, <argument><expr><name>rb_hash_has_value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"key?"</literal></expr></argument>, <argument><expr><name>rb_hash_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"value?"</literal></expr></argument>, <argument><expr><name>rb_hash_has_value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"compare_by_identity"</literal></expr></argument>, <argument><expr><name>rb_hash_compare_by_id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"compare_by_identity?"</literal></expr></argument>, <argument><expr><name>rb_hash_compare_by_id_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"any?"</literal></expr></argument>, <argument><expr><name>rb_hash_any_p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"dig"</literal></expr></argument>, <argument><expr><name>rb_hash_dig</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"&lt;="</literal></expr></argument>, <argument><expr><name>rb_hash_le</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>, <argument><expr><name>rb_hash_lt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"&gt;="</literal></expr></argument>, <argument><expr><name>rb_hash_ge</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>, <argument><expr><name>rb_hash_gt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"deconstruct_keys"</literal></expr></argument>, <argument><expr><name>rb_hash_deconstruct_keys</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"ruby2_keywords_hash?"</literal></expr></argument>, <argument><expr><name>rb_hash_s_ruby2_keywords_hash_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cHash</name></expr></argument>, <argument><expr><literal type="string">"ruby2_keywords_hash"</literal></expr></argument>, <argument><expr><name>rb_hash_s_ruby2_keywords_hash</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





















































































<expr_stmt><expr><name>origenviron</name> <operator>=</operator> <name>environ</name></expr>;</expr_stmt>
<expr_stmt><expr><name>envtbl</name> <operator>=</operator> <call><name>rb_obj_alloc</name><argument_list>(<argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_extend_object</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><name>rb_mEnumerable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>rb_f_getenv</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><name>env_fetch</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"[]="</literal></expr></argument>, <argument><expr><name>env_aset_m</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"store"</literal></expr></argument>, <argument><expr><name>env_aset_m</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>env_each_pair</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"each_pair"</literal></expr></argument>, <argument><expr><name>env_each_pair</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"each_key"</literal></expr></argument>, <argument><expr><name>env_each_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"each_value"</literal></expr></argument>, <argument><expr><name>env_each_value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>, <argument><expr><name>env_delete_m</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"delete_if"</literal></expr></argument>, <argument><expr><name>env_delete_if</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"keep_if"</literal></expr></argument>, <argument><expr><name>env_keep_if</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name>env_slice</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"clear"</literal></expr></argument>, <argument><expr><name>env_clear</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"reject"</literal></expr></argument>, <argument><expr><name>env_reject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"reject!"</literal></expr></argument>, <argument><expr><name>env_reject_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>, <argument><expr><name>env_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"select!"</literal></expr></argument>, <argument><expr><name>env_select_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"filter"</literal></expr></argument>, <argument><expr><name>env_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"filter!"</literal></expr></argument>, <argument><expr><name>env_select_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"shift"</literal></expr></argument>, <argument><expr><name>env_shift</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"freeze"</literal></expr></argument>, <argument><expr><name>env_freeze</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"invert"</literal></expr></argument>, <argument><expr><name>env_invert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"replace"</literal></expr></argument>, <argument><expr><name>env_replace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"update"</literal></expr></argument>, <argument><expr><name>env_update</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"merge!"</literal></expr></argument>, <argument><expr><name>env_update</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>env_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"rehash"</literal></expr></argument>, <argument><expr><name>env_none</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"to_a"</literal></expr></argument>, <argument><expr><name>env_to_a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><name>env_to_s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>, <argument><expr><name>env_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><name>env_index</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>env_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><name>env_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"empty?"</literal></expr></argument>, <argument><expr><name>env_empty_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"keys"</literal></expr></argument>, <argument><expr><name>env_f_keys</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"values"</literal></expr></argument>, <argument><expr><name>env_f_values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"values_at"</literal></expr></argument>, <argument><expr><name>env_values_at</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"include?"</literal></expr></argument>, <argument><expr><name>env_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"member?"</literal></expr></argument>, <argument><expr><name>env_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"has_key?"</literal></expr></argument>, <argument><expr><name>env_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"has_value?"</literal></expr></argument>, <argument><expr><name>env_has_value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"key?"</literal></expr></argument>, <argument><expr><name>env_has_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"value?"</literal></expr></argument>, <argument><expr><name>env_has_value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"to_hash"</literal></expr></argument>, <argument><expr><name>env_f_to_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"to_h"</literal></expr></argument>, <argument><expr><name>env_to_h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"assoc"</literal></expr></argument>, <argument><expr><name>env_assoc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>envtbl</name></expr></argument>, <argument><expr><literal type="string">"rassoc"</literal></expr></argument>, <argument><expr><name>env_rassoc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>rb_define_global_const</name><argument_list>(<argument><expr><literal type="string">"ENV"</literal></expr></argument>, <argument><expr><name>envtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>ruby_register_rollback_func_for_ensure</name><argument_list>(<argument><expr><name>hash_foreach_ensure</name></expr></argument>, <argument><expr><name>hash_foreach_ensure_rollback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HASH_ASSERT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ar_hint_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>RHASH_AR_TABLE_MAX_SIZE</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
