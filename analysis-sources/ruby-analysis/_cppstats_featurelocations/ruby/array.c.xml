<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\ruby-analysis\_cppstats_featurelocations\ruby\array.c">












<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"debug_counter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/compar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/enum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/rational.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal/vm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"probes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/st.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby/util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transient_heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtin.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>ARRAY_DEBUG</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NDEBUG</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ruby_assert.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>VALUE</name></type> <name>rb_cArray</name></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>id_cmp</name></cpp:macro> <cpp:value>idCmp</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_DEFAULT_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_MAX_SIZE</name></cpp:macro> <cpp:value>(LONG_MAX / (int)sizeof(VALUE))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALL_ARRAY_LEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>should_be_T_ARRAY</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>should_not_be_shared_and_embedded</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><operator>(</operator><name>ary</name><operator>)</operator></expr></argument>, <argument><expr><name>ELTS_SHARED</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>FL_TEST</name><argument_list>(<argument><expr><operator>(</operator><name>ary</name><operator>)</operator></expr></argument>, <argument><expr><name>RARRAY_EMBED_FLAG</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SHARED_P</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(should_be_T_ARRAY((VALUE)(ary))), assert(should_not_be_shared_and_embedded((VALUE)ary)), FL_TEST_RAW((ary),ELTS_SHARED)!=0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_EMBED_P</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(should_be_T_ARRAY((VALUE)(ary))), assert(should_not_be_shared_and_embedded((VALUE)ary)), FL_TEST_RAW((ary), RARRAY_EMBED_FLAG) != 0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_HEAP_PTR</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(!ARY_EMBED_P(a)), RARRAY(a)-&gt;as.heap.ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_HEAP_LEN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(!ARY_EMBED_P(a)), RARRAY(a)-&gt;as.heap.len)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_HEAP_CAPA</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(!ARY_EMBED_P(a)), assert(!ARY_SHARED_ROOT_P(a)), RARRAY(a)-&gt;as.heap.aux.capa)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_EMBED_PTR</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(ARY_EMBED_P(a)), RARRAY(a)-&gt;as.ary)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_EMBED_LEN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(ARY_EMBED_P(a)), (long)((RBASIC(a)-&gt;flags &gt;&gt; RARRAY_EMBED_LEN_SHIFT) &amp; (RARRAY_EMBED_LEN_MASK &gt;&gt; RARRAY_EMBED_LEN_SHIFT)))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_HEAP_SIZE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(!ARY_EMBED_P(a)), assert(ARY_OWNS_HEAP_P(a)), ARY_CAPA(a) * sizeof(VALUE))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_OWNS_HEAP_P</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(should_be_T_ARRAY((VALUE)(a))), !FL_TEST_RAW((a), ELTS_SHARED|RARRAY_EMBED_FLAG))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FL_SET_EMBED</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(!ARY_SHARED_P(a)); FL_SET((a), RARRAY_EMBED_FLAG); RARY_TRANSIENT_UNSET(a); ary_verify(a); } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FL_UNSET_EMBED</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FL_UNSET((ary), RARRAY_EMBED_FLAG|RARRAY_EMBED_LEN_MASK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FL_SET_SHARED</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(!ARY_EMBED_P(ary)); FL_SET((ary), ELTS_SHARED); } while (0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FL_UNSET_SHARED</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>FL_UNSET((ary), ELTS_SHARED)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SET_PTR</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(!ARY_EMBED_P(ary)); assert(!OBJ_FROZEN(ary)); RARRAY(ary)-&gt;as.heap.ptr = (p); } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SET_EMBED_LEN</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { long tmp_n = (n); assert(ARY_EMBED_P(ary)); assert(!OBJ_FROZEN(ary)); RBASIC(ary)-&gt;flags &amp;= ~RARRAY_EMBED_LEN_MASK; RBASIC(ary)-&gt;flags |= (tmp_n) &lt;&lt; RARRAY_EMBED_LEN_SHIFT; } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SET_HEAP_LEN</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(!ARY_EMBED_P(ary)); RARRAY(ary)-&gt;as.heap.len = (n); } while (0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SET_LEN</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (ARY_EMBED_P(ary)) { ARY_SET_EMBED_LEN((ary), (n)); } else { ARY_SET_HEAP_LEN((ary), (n)); } assert(RARRAY_LEN(ary) == (n)); } while (0)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_INCREASE_PTR</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(!ARY_EMBED_P(ary)); assert(!OBJ_FROZEN(ary)); RARRAY(ary)-&gt;as.heap.ptr += (n); } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_INCREASE_LEN</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(!OBJ_FROZEN(ary)); if (ARY_EMBED_P(ary)) { ARY_SET_EMBED_LEN((ary), RARRAY_LEN(ary)+(n)); } else { RARRAY(ary)-&gt;as.heap.len += (n); } } while (0)</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_CAPA</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ARY_EMBED_P(ary) ? RARRAY_EMBED_LEN_MAX : ARY_SHARED_ROOT_P(ary) ? RARRAY_LEN(ary) : ARY_HEAP_CAPA(ary))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SET_CAPA</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(!ARY_EMBED_P(ary)); assert(!ARY_SHARED_P(ary)); assert(!OBJ_FROZEN(ary)); RARRAY(ary)-&gt;as.heap.aux.capa = (n); } while (0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SHARED_ROOT</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(ARY_SHARED_P(ary)), RARRAY(ary)-&gt;as.heap.aux.shared_root)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SET_SHARED</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const VALUE _ary_ = (ary); const VALUE _value_ = (value); assert(!ARY_EMBED_P(_ary_)); assert(ARY_SHARED_P(_ary_)); assert(ARY_SHARED_ROOT_P(_value_)); RB_OBJ_WRITE(_ary_, &amp;RARRAY(_ary_)-&gt;as.heap.aux.shared_root, _value_); } while (0)</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RARRAY_SHARED_ROOT_FLAG</name></cpp:macro> <cpp:value>FL_USER5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SHARED_ROOT_P</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(should_be_T_ARRAY((VALUE)(ary))), FL_TEST_RAW((ary), RARRAY_SHARED_ROOT_FLAG))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SHARED_ROOT_REFCNT</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(assert(ARY_SHARED_ROOT_P(ary)), RARRAY(ary)-&gt;as.heap.aux.capa)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SHARED_ROOT_OCCUPIED</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ARY_SHARED_ROOT_REFCNT(ary) == 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARY_SET_SHARED_ROOT_REFCNT</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(ARY_SHARED_ROOT_P(ary)); RARRAY(ary)-&gt;as.heap.aux.capa = (value); } while (0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FL_SET_SHARED_ROOT</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(!ARY_EMBED_P(ary)); assert(!RARRAY_TRANSIENT_P(ary)); FL_SET((ary), RARRAY_SHARED_ROOT_FLAG); } while (0)</cpp:value></cpp:define>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ARY_SET</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RARRAY_ASET</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RARRAY_ASET</name></cpp:undef>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ARRAY_DEBUG</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ary_verify</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ary_verify_(ary, __FILE__, __LINE__)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_verify_</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ELTS_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>root</name> <init>= <expr><call><name>RARRAY</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared_root</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>root_ptr</name> <init>= <expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>ARY_HEAP_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>root_len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>FL_TEST</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>RARRAY_SHARED_ROOT_FLAG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>root_ptr</name> <operator>&lt;=</operator> <name>ptr</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>root_ptr</name> <operator>+</operator> <name>root_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>RARRAY_EMBED_LEN_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt> 
</block_content>}</block></for>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_TRANSIENT_HEAP</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>rb_transient_heap_managed_ptr_p</name><argument_list>(<argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>rb_transient_heap_verify</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ary_verify</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ary_verify</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>VALUE</name> <modifier>*</modifier></type>
<name>rb_ary_ptr_use_start</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ARRAY_DEBUG</name></expr></cpp:if>
<expr_stmt><expr><call><name>FL_SET_RAW</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>RARRAY_PTR_IN_USE_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ary_ptr_use_end</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ARRAY_DEBUG</name></expr></cpp:if>
<expr_stmt><expr><call><name>FL_UNSET_RAW</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>RARRAY_PTR_IN_USE_FLAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_mem_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>size</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>mem</name><operator>++</operator> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_mem_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
rb_mem_clear(ptr + beg, size);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>memfill</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <name>long</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>register</specifier> <name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>size</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>mem</name><operator>++</operator> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_memfill</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
memfill(ptr + beg, size, val);
RB_OBJ_WRITTEN(ary, Qundef, val);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_memcpy0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>buff_owner_ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>buff_owner_ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">128</literal><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><name>buff_owner_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
MEMCPY(ptr+beg, argv, VALUE, argc);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
for (i=<literal type="number">0</literal>; i&lt;argc; i++) {
RB_OBJ_WRITE(buff_owner_ary, &amp;ptr[i+beg], argv[i]);
}
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_memcpy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ary_memcpy0</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name> <modifier>*</modifier></type>
<name>ary_heap_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>capa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>rb_transient_heap_alloc</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>capa</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RARY_TRANSIENT_SET</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RARY_TRANSIENT_UNSET</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_heap_free_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ruby_sized_xfree</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_heap_free</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RARY_TRANSIENT_UNSET</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ary_heap_free_ptr</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARY_HEAP_SIZE</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_heap_realloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>new_capa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>old_capa</name> <init>= <expr><call><name>ARY_HEAP_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>new_capa</name> <operator>&lt;=</operator> <name>old_capa</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>new_ptr</name> <init>= <expr><call><name>rb_transient_heap_alloc</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>new_capa</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_ptr</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>new_capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RARY_TRANSIENT_UNSET</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>new_ptr</name></expr></argument>, <argument><expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>old_capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>new_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>SIZED_REALLOC_N</name><argument_list>(<argument><expr><call><name>RARRAY</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>new_capa</name></expr></argument>, <argument><expr><name>old_capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_TRANSIENT_HEAP</name></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>rb_ary_transient_heap_evacuate_</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>transient</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>promote</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>transient</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>new_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>old_ptr</name> <init>= <expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>capa</name> <init>= <expr><call><name>ARY_HEAP_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>ARY_HEAP_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_ROOT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>capa</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ARY_OWNS_HEAP_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_PTR_USING_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>promote</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_ptr</name> <operator>=</operator> <call><name>ALLOC_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RARY_TRANSIENT_UNSET</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>new_ptr</name> <operator>=</operator> <call><name>ary_heap_alloc</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>new_ptr</name></expr></argument>, <argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RARRAY</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>new_ptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ary_transient_heap_evacuate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>promote</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_transient_heap_evacuate_</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>promote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ary_detransient</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_transient_heap_evacuate_</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>void</name></type>
<name>rb_ary_detransient</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>

</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_resize_capa</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>capacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>capacity</name> <operator>&gt;</operator> <name>RARRAY_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>ARY_EMBED_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ary_heap_alloc</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>ARY_EMBED_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_UNSET_EMBED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_HEAP_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ary_heap_realloc</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>ARY_HEAP_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>old_capa</name> <init>= <expr><call><name>ARY_HEAP_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>capacity</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <name>capacity</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>RARRAY</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>ary</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_heap_free_ptr</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_SET_EMBED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ary_shrink_capa</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>capacity</name> <init>= <expr><call><name>ARY_HEAP_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>old_capa</name> <init>= <expr><call><name>ARY_HEAP_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>old_capa</name> <operator>&gt;=</operator> <name>capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>old_capa</name> <operator>&gt;</operator> <name>capacity</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ary_heap_realloc</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_double_capa</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>min</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>new_capa</name> <init>= <expr><call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new_capa</name> <operator>&lt;</operator> <name>ARY_DEFAULT_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_capa</name> <operator>=</operator> <name>ARY_DEFAULT_SIZE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>new_capa</name> <operator>&gt;=</operator> <name>ARY_MAX_SIZE</name> <operator>-</operator> <name>min</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new_capa</name> <operator>=</operator> <operator>(</operator><name>ARY_MAX_SIZE</name> <operator>-</operator> <name>min</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>new_capa</name> <operator>+=</operator> <name>min</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_resize_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>new_capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_ary_decrement_share</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>shared_root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>shared_root</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>num</name> <init>= <expr><call><name>ARY_SHARED_ROOT_REFCNT</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_free</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_gc_force_recycle</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>num</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ARY_SET_SHARED_ROOT_REFCNT</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_ary_unshare</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>shared_root</name> <init>= <expr><call><name>RARRAY</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared_root</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_decrement_share</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_UNSET_SHARED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>rb_ary_unshare_safe</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_unshare</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_increment_share</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>shared_root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>num</name> <init>= <expr><call><name>ARY_SHARED_ROOT_REFCNT</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ARY_SET_SHARED_ROOT_REFCNT</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>, <argument><expr><name>num</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>shared_root</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_ary_set_shared</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>shared_root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_increment_share</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_SHARED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_ary_shared_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_SHARED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>rb_ary_modify_check</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_frozen</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ary_modify</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>shared_len</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>shared_root</name> <init>= <expr><call><name>ARY_SHARED_ROOT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>RARRAY_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FL_UNSET_SHARED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_EMBED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>ARY_EMBED_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_decrement_share</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>ARY_SHARED_ROOT_OCCUPIED</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>shared_len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call><operator>)</operator><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>shift</name> <init>= <expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FL_UNSET_SHARED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>shared_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
MEMMOVE(ptr, ptr+shift, VALUE, len);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>FL_SET_EMBED</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_decrement_share</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>ary_heap_alloc</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_unshare</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>rb_gc_writebarrier_remember</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_ensure_room_for_push</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>add_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>old_len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>new_len</name> <init>= <expr><name>old_len</name> <operator>+</operator> <name>add_len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>capa</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>old_len</name> <operator>&gt;</operator> <name>ARY_MAX_SIZE</name> <operator>-</operator> <name>add_len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld too big"</literal></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>new_len</name> <operator>&gt;</operator> <name>RARRAY_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>shared_root</name> <init>= <expr><call><name>ARY_SHARED_ROOT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_ROOT_OCCUPIED</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>new_len</name> <operator>&lt;=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>shared_root</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>capa</name> <operator>=</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_len</name> <operator>&gt;</operator> <name>capa</name> <operator>-</operator> <operator>(</operator><name>capa</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_double_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>capa</name> <operator>=</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_len</name> <operator>&gt;</operator> <name>capa</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_double_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>











<function><type><name>VALUE</name></type>
<name>rb_ary_freeze</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>








<function><type><name>VALUE</name></type>
<name>rb_ary_shared_with_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>RARRAY</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared_root</name></name> <operator>==</operator> <call><name>RARRAY</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>aux</name><operator>.</operator><name>shared_root</name></name> <operator>&amp;&amp;</operator>
<call><name>RARRAY</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name> <operator>==</operator> <call><name>RARRAY</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>as</name><operator>.</operator><name>heap</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>NEWOBJ_OF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr>struct <name>RArray</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <name>RARRAY_EMBED_FLAG</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>RGENGC_WB_PROTECTED_ARRAY</name></expr> ?</condition><then> <expr><name>FL_WB_PROTECTED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>empty_ary_alloc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RUBY_DTRACE_CREATE_HOOK</name><argument_list>(<argument><expr><name>ARRAY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ary_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>capa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative array size (or size too big)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>&gt;</operator> <name>ARY_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"array size too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>RUBY_DTRACE_CREATE_HOOK</name><argument_list>(<argument><expr><name>ARRAY</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>ary_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>&gt;</operator> <name>RARRAY_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ary_heap_alloc</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_UNSET_EMBED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_HEAP_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_new_capa</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>capa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ary_new</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_new</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>RARRAY_EMBED_LEN_MAX</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
(<name>rb_ary_new_from_args</name>)<parameter_list>(<parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ar</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ARY_SET</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ar</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_ary_tmp_new_from_values</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>elts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>ary_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>elts</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>elts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_new_from_values</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>elts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_tmp_new_from_values</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>elts</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_tmp_new</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>capa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>ary_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_transient_heap_evacuate</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_tmp_new_fill</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>capa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>ary_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ary_memfill</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>capa</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_transient_heap_evacuate</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ary_free</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ARY_OWNS_HEAP_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>USE_DEBUG_COUNTER</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>ARY_SHARED_ROOT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>ARY_HEAP_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_ary_extracapa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_TRANSIENT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_ary_transient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_ary_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_heap_free</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_ary_embed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_ary_shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_ROOT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ARY_SHARED_ROOT_OCCUPIED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_ary_shared_root_occupied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>RUBY_FUNC_EXPORTED</name> <name>size_t</name></type>
<name>rb_ary_memsize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ARY_OWNS_HEAP_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ary_discard</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_free</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>|=</operator> <name>RARRAY_EMBED_FLAG</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>RARRAY_EMBED_LEN_MASK</name> <operator>|</operator> <name>RARRAY_TRANSIENT_FLAG</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_make_shared</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ARY_SHARED_ROOT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>ARY_SHARED_ROOT_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>OBJ_FROZEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_transient_heap_evacuate</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_shrink_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_SHARED_ROOT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_SHARED_ROOT_REFCNT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>capa</name> <init>= <expr><call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>NEWOBJ_OF</name><argument_list>(<argument><expr><name>shared</name></expr></argument>, <argument><expr>struct <name>RArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>T_ARRAY</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>RGENGC_WB_PROTECTED_ARRAY</name></expr> ?</condition><then> <expr><name>FL_WB_PROTECTED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_transient_heap_evacuate</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FL_UNSET_EMBED</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>shared</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>shared</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_mem_clear</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>shared</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>capa</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_SHARED_ROOT</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_SHARED_ROOT_REFCNT</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>shared</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_SHARED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_DEBUG_COUNTER_INC</name><argument_list>(<argument><expr><name>obj_ary_shared_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_SHARED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OBJ_FREEZE</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>shared</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_make_substitution</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>RARRAY_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>subst</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>subst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>subst</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>subst</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>rb_ary_increment_share</name><argument_list>(<argument><expr><call><name>ary_make_shared</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_assoc_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>car</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>cdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>car</name></expr></argument>, <argument><expr><name>cdr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_to_array_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_convert_type_with_id</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>, <argument><expr><literal type="string">"Array"</literal></expr></argument>, <argument><expr><name>idTo_ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>to_ary</name></cpp:macro> <cpp:value>rb_to_array_type</cpp:value></cpp:define>

<function><type><name>VALUE</name></type>
<name>rb_check_array_type</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_check_convert_type_with_id</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>, <argument><expr><literal type="string">"Array"</literal></expr></argument>, <argument><expr><name>idTo_ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_check_to_array</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_check_convert_type_with_id</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>, <argument><expr><literal type="string">"Array"</literal></expr></argument>, <argument><expr><name>idTo_a</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_s_try_convert</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

























































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_initialize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ARY_OWNS_HEAP_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_heap_free</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_unshare_safe</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_EMBED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warning</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"02"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_replace</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative array size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>ARY_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"array size too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_resize_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"block supersedes default value argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ary_memfill</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_s_create</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><call><name>ary_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>argv</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ary_store</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld too small for array; minimum: %ld"</literal></expr></argument>,
<argument><expr><name>idx</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><operator>-</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>ARY_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld too big"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_double_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_mem_clear</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>idx</name> <operator>-</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_make_partial</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>klass</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset</name><operator>+</operator><name>len</name> <operator>&lt;=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>RARRAY_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>ary_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>shared</name></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><call><name>ary_alloc</name><argument_list>(<argument><expr><name>klass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FL_UNSET_EMBED</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>shared</name> <operator>=</operator> <call><name>ary_make_shared</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_set_shared</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ARY_INCREASE_PTR</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_make_shared_copy</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ary_make_partial</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>ary_take_pos_flags</name>
<block>{
<decl><name>ARY_TAKE_FIRST</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>ARY_TAKE_LAST</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_take_first_or_last</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ary_take_pos_flags</name></name></type> <name>last</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>RUBY_ASSERT_ALWAYS</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative array size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>ary_make_partial</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

















<function><type><name>VALUE</name></type>
<name>rb_ary_push</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>idx</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><operator>(</operator><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call>, <name>ary</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>target_ary</name> <init>= <expr><call><name>ary_ensure_room_for_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
RB_OBJ_WRITE(target_ary, &amp;ptr[idx], item);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_cat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>oldlen</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>target_ary</name> <init>= <expr><call><name>ary_ensure_room_for_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ary_memcpy0</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>oldlen</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>target_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>oldlen</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_push_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_cat</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_pop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_OWNS_HEAP_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name>n</name> <operator>*</operator> <literal type="number">3</literal> <operator>&lt;</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>ARY_DEFAULT_SIZE</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>ary_resize_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>n</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>--</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_pop_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_ary_pop</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ary_take_first_or_last</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ARY_TAKE_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_INCREASE_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><operator>-</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_shift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>ARY_DEFAULT_SIZE</name></expr>)</condition> <block>{<block_content>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
MEMMOVE(ptr, ptr+<literal type="number">1</literal>, VALUE, len-<literal type="number">1</literal>);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> 
<expr_stmt><expr><call><name>ARY_INCREASE_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>top</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>ARY_SET</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_make_shared</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>ARY_SHARED_ROOT_OCCUPIED</name><argument_list>(<argument><expr><call><name>ARY_SHARED_ROOT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_INCREASE_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>ARY_INCREASE_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>top</name></expr>;</return>
</block_content>}</block></function>
























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_shift_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_ary_shift</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ary_take_first_or_last</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ARY_TAKE_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_behead</name><argument_list>(<argument><expr><name>ary</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_ary_behead</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name><operator>&lt;=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ary</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_ROOT_OCCUPIED</name><argument_list>(<argument><expr><call><name>ARY_SHARED_ROOT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<label><name>setup_occupied_shared</name>:</label>
<expr_stmt><expr><call><name>ary_mem_clear</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_INCREASE_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>ARY_DEFAULT_SIZE</name></expr>)</condition> <block>{<block_content>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
MEMMOVE(ptr, ptr+n, VALUE, RARRAY_LEN(ary)-n);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ary_make_shared</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>setup_occupied_shared</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ARY_INCREASE_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><operator>-</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_ensure_room_for_unshift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>new_len</name> <init>= <expr><name>len</name> <operator>+</operator> <name>argc</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>capa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>head</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sharedp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>ARY_MAX_SIZE</name> <operator>-</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld too big"</literal></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>shared_root</name> <init>= <expr><call><name>ARY_SHARED_ROOT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>capa</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_ROOT_OCCUPIED</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>capa</name> <operator>&gt;</operator> <name>new_len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>head</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sharedp</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>makeroom_if_need</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>capa</name> <operator>=</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>capa</name> <operator>-</operator> <operator>(</operator><name>capa</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&lt;=</operator> <name>new_len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_double_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>new_len</name> <operator>&gt;</operator> <name>ARY_DEFAULT_SIZE</name> <operator>*</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>capa</name> <operator>=</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_make_shared</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>head</name> <operator>=</operator> <name>sharedp</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>makeroom</name>;</goto>
<label><name>makeroom_if_need</name>:</label>
<if_stmt><if>if <condition>(<expr><name>head</name> <operator>-</operator> <name>sharedp</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>room</name></decl>;</decl_stmt>
<label><name>makeroom</name>:</label>
<expr_stmt><expr><name>room</name> <operator>=</operator> <name>capa</name> <operator>-</operator> <name>new_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>room</name> <operator>-=</operator> <name>room</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>sharedp</name> <operator>+</operator> <name>argc</name> <operator>+</operator> <name>room</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>head</name> <operator>=</operator> <name>sharedp</name> <operator>+</operator> <name>argc</name> <operator>+</operator> <name>room</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>head</name> <operator>-</operator> <name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ARY_SHARED_ROOT_OCCUPIED</name><argument_list>(<argument><expr><call><name>ARY_SHARED_ROOT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ARY_SHARED_ROOT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>

<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
MEMMOVE(ptr + argc, ptr, VALUE, len);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_unshift_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>target_ary</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>target_ary</name> <operator>=</operator> <call><name>ary_ensure_room_for_unshift</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_memcpy0</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>target_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_unshift</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_unshift_m</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>item</name></expr></argument>,<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>
<name>rb_ary_elt</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name> <operator>&lt;=</operator> <name>offset</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_entry</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_entry_internal</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_subseq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>klass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>alen</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;</operator> <name>alen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>alen</name> <operator>&lt;</operator> <name>len</name> <operator>||</operator> <name>alen</name> <operator>&lt;</operator> <name>beg</name> <operator>+</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>alen</name> <operator>-</operator> <name>beg</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>klass</name> <operator>=</operator> <call><name>rb_obj_class</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ary_new</name><argument_list>(<argument><expr><name>klass</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>ary_make_partial</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>klass</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_ary_aref2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>e</name></decl></parameter>)</parameter_list>;</function_decl>





































<function><type><name>VALUE</name></type>
<name>rb_ary_aref</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_ary_aref2</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_ary_aref1</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_aref2</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>beg</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>beg</name> <operator>+=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_ary_subseq</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>MJIT_FUNC_EXPORTED</name> <name>VALUE</name></type>
<name>rb_ary_aref1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Qfalse</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>Qnil</name></expr>:</case>
<return>return <expr><name>Qnil</name></expr>;</return>
<default>default:</default>
<return>return <expr><call><name>rb_ary_subseq</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>














<function><type><name>VALUE</name></type>
<name>rb_ary_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_first</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>ary_take_first_or_last</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ARY_TAKE_FIRST</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
















<function><type><name>VALUE</name></type>
<name>rb_ary_last</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>ary_take_first_or_last</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ARY_TAKE_LAST</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_fetch</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>ifnone</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>block_given</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"11"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ifnone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>block_given</name> <operator>=</operator> <call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>block_given</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"block supersedes default value argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>idx</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>block_given</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld outside of array bounds: %ld...%ld"</literal></expr></argument>,
<argument><expr><name>idx</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>-</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ifnone</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_rindex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <operator>(</operator><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_to_ary</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>tmp</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_ary_splice</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>rptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>rlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>rofs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"negative length (%ld)"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>beg</name> <operator>+=</operator> <name>olen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld too small for array; minimum: %ld"</literal></expr></argument>,
<argument><expr><name>beg</name> <operator>-</operator> <name>olen</name></expr></argument>, <argument><expr><operator>-</operator><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>olen</name> <operator>&lt;</operator> <name>len</name> <operator>||</operator> <name>olen</name> <operator>&lt;</operator> <name>beg</name> <operator>+</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>olen</name> <operator>-</operator> <name>beg</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>optr</name> <init>= <expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>rofs</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>rptr</name> <operator>&gt;=</operator> <name>optr</name> <operator>&amp;&amp;</operator> <name>rptr</name> <operator>&lt;</operator> <name>optr</name> <operator>+</operator> <name>olen</name><operator>)</operator></expr> ?</condition><then> <expr><name>rptr</name> <operator>-</operator> <name>optr</name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;=</operator> <name>olen</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>target_ary</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;</operator> <name>ARY_MAX_SIZE</name> <operator>-</operator> <name>rlen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld too big"</literal></expr></argument>, <argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>target_ary</name> <operator>=</operator> <call><name>ary_ensure_room_for_push</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>rlen</name><operator>-</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>beg</name> <operator>+</operator> <name>rlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_mem_clear</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>, <argument><expr><name>beg</name> <operator>-</operator> <name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rofs</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rptr</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>rofs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ary_memcpy0</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>, <argument><expr><name>rptr</name></expr></argument>, <argument><expr><name>target_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>alen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>olen</name> <operator>-</operator> <name>len</name> <operator>&gt;</operator> <name>ARY_MAX_SIZE</name> <operator>-</operator> <name>rlen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld too big"</literal></expr></argument>, <argument><expr><name>olen</name> <operator>+</operator> <name>rlen</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>alen</name> <operator>=</operator> <name>olen</name> <operator>+</operator> <name>rlen</name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>alen</name> <operator>&gt;=</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_double_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>rlen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
<argument><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>beg</name> <operator>+</operator> <name>rlen</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>beg</name> <operator>+</operator> <name>len</name></expr></argument>,
<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>olen</name> <operator>-</operator> <operator>(</operator><name>beg</name> <operator>+</operator> <name>len</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>rofs</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rptr</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>rofs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>RB_OBJ_WB_UNPROTECT_FOR</name><argument_list>(<argument><expr><name>ARRAY</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
<argument><expr><call><name>MEMMOVE</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>beg</name></expr></argument>, <argument><expr><name>rptr</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ary_set_len</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>capa</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"can't set length of shared "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>capa</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_bug</name><argument_list>(<argument><expr><literal type="string">"probable buffer overflow: %ld for %ld"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>capa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><name>VALUE</name></type>
<name>rb_ary_resize</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>olen</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>olen</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>olen</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ary</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>ARY_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld too big"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>olen</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_double_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ary_mem_clear</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ARY_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>RARRAY_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>tmp</name><index>[<expr><name>RARRAY_EMBED_LEN_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_discard</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MEMCPY</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>ARY_EMBED_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>ARY_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>olen</name> <operator>&gt;</operator> <name>len</name> <operator>+</operator> <name>ARY_DEFAULT_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_heap_realloc</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_HEAP_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>




































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_aset</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>beg</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>rpl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>range</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fixnum</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<label><name>range</name>:</label>
<expr_stmt><expr><name>rpl</name> <operator>=</operator> <call><name>rb_ary_to_ary</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_splice</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>rpl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>rpl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>rpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>argv</name><index>[<expr><name>argc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>fixnum</name>:</label>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_insert</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ary</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>minpos</name> <init>= <expr><operator>-</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>minpos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"index %ld too small for array; minimum: %ld"</literal></expr></argument>,
<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>minpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_splice</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_enum_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_length</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



















<function><type><name>VALUE</name></type>
<name>rb_ary_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_each_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_reverse_each</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>nlen</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nlen</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nlen</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>nlen</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_length</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_empty_p</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_dup</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>dup</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>dup</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_resurrect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ary_make_partial</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>extern</specifier> <name>VALUE</name></type> <name>rb_output_fs</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ary_join_1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sep</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>first</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>recursive_join</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>argp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>sep</name> <init>= <expr><name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name><name>arg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name><name>arg</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"recursive array join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ary_join_1</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type>
<name>ary_join_0</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sep</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_join_1</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sep</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>T_STRING</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<label><name>str_join</name>:</label>
<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<label><name>ary_join</name>:</label>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>ary</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"recursive array join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sep</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>first</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_exec_recursive</name><argument_list>(<argument><expr><name>recursive_join</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<goto>goto <name>str_join</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<goto>goto <name>ary_join</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_obj_as_string</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>str_join</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_join</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>sep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>val</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_usascii_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>StringValue</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>tmp</name> <operator>!=</operator> <name>val</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_buf_new</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <operator>(</operator><name>n</name><operator>-</operator><name>i</name><operator>)</operator><operator>*</operator><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_enc_associate</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_usascii_encoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>ary_join_0</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_join_1</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>RSTRING_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_str_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_str_set_len</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_join_0</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_join_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>sep</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name>sep</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sep</name> <operator>=</operator> <name>rb_output_fs</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"$, is set to non-nil value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_ary_join</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>inspect_ary</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>str</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_usascii_str_new_cstr</name><argument_list>(<argument><expr><literal type="string">"[...]"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>rb_str_buf_new2</name><argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>rb_inspect</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_enc_copy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>rb_str_buf_append</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>rb_str_buf_cat2</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_inspect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_usascii_str_new2</name><argument_list>(<argument><expr><literal type="string">"[]"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_exec_recursive</name><argument_list>(<argument><expr><name>inspect_ary</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_to_s</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_inspect</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_to_a</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rb_cArray</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>dup</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_replace</name><argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>dup</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_to_h</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>block_given</name> <init>= <expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>elt</name> <init>= <expr><ternary><condition><expr><name>block_given</name></expr> ?</condition><then> <expr><call><name>rb_yield_force_blockarg</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>e</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>key_value_pair</name> <init>= <expr><call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>key_value_pair</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"wrong element type %"</literal><name>PRIsVALUE</name><literal type="string">" at %ld (expected array)"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>key_value_pair</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"wrong array length at %ld (expected 2, was %ld)"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>key_value_pair</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_hash_aset</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>key_value_pair</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>key_value_pair</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_to_ary_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_reverse</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>p1</name> <operator>&lt;</operator> <name>p2</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><name>p1</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>p1</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p2</name><operator>--</operator> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_reverse</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>p1</argument>, <argument>{
p2 = p1 + len - <literal type="number">1</literal>; 
ary_reverse(p1, p2);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> 
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_reverse_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_reverse</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_reverse_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>dup</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<do>do<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p2</name><operator>--</operator> <operator>=</operator> <operator>*</operator><name>p1</name><operator>++</operator></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>--</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>dup</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>long</name></type>
<name>rotate_count</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>cnt</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>len</name> <operator>-</operator> <operator>(</operator><operator>~</operator><name>cnt</name> <operator>%</operator> <name>len</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>cnt</name> <operator>%</operator> <name>len</name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_rotate_ptr</name><parameter_list>(<parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cnt</name> <operator>==</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><operator>*</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VALUE</name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ary_reverse</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>cnt</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>cnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ary_reverse</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ary_reverse</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_rotate</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>cnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>cnt</name> <operator>=</operator> <call><name>rotate_count</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>ary_rotate_ptr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_rotate_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_rotate</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_rotate_m</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>rotated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>cnt</name> <init>= <expr><operator>(</operator><ternary><condition><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rotated</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>rotate_count</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>cnt</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>rotated</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>rotated</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>rotated</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rotated</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>ary_sort_data</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cmp_opt_data</name></name></type> <name>cmp_opt</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>sort_reentered</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"sort reentered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sort_1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ap</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dummy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ary_sort_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>dummy</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>retval</name> <init>= <expr><call><name>sort_reentered</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>ary</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>VALUE</name> <operator>*</operator><operator>)</operator><name>ap</name></expr></init></decl>, <decl><type ref="prev"/><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>VALUE</name> <operator>*</operator><operator>)</operator><name>bp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rb_yield_values2</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_cmpint</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sort_reentered</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>ary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>sort_2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ap</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dummy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ary_sort_data</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>dummy</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>retval</name> <init>= <expr><call><name>sort_reentered</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>ary</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>VALUE</name> <operator>*</operator><operator>)</operator><name>ap</name></expr></init></decl>, <decl><type ref="prev"/><name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>VALUE</name> <operator>*</operator><operator>)</operator><name>bp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CMP_OPTIMIZABLE</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>cmp_opt</name></name></expr></argument>, <argument><expr><name>Integer</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>long</name><operator>)</operator><name>a</name> <operator>&gt;</operator> <operator>(</operator><name>long</name><operator>)</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>long</name><operator>)</operator><name>a</name> <operator>&lt;</operator> <operator>(</operator><name>long</name><operator>)</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRING_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>STRING_P</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CMP_OPTIMIZABLE</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>cmp_opt</name></name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_str_cmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>CMP_OPTIMIZABLE</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>cmp_opt</name></name></expr></argument>, <argument><expr><name>Float</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_float_cmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>rb_funcallv</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>id_cmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_cmpint</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sort_reentered</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>ary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

























<function><type><name>VALUE</name></type>
<name>rb_ary_sort_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>ary_make_substitution</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>ary_sort_data</name></name></type> <name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>ary</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>cmp_opt</name><operator>.</operator><name>opt_methods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>cmp_opt</name><operator>.</operator><name>opt_inited</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE</name><argument_list>(<argument>tmp</argument>, <argument>ptr</argument>, <argument>{
ruby_qsort(ptr, len, sizeof(VALUE),
rb_block_given_p()?sort_1:sort_2, &amp;data);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> 
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>rb_ary_unshare</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_EMBED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>ARY_EMBED_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARY_EMBED_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ARY_EMBED_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FL_UNSET_SHARED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FL_UNSET_EMBED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rb_ary_unshare</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ary_heap_free</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_HEAP_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>ARY_HEAP_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>FL_FREEZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_EMBED</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>FL_FREEZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS_RAW</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>rb_cArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>






























<function><type><name>VALUE</name></type>
<name>rb_ary_sort</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_sort_bang</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>VALUE</name></type> <name>rb_ary_bsearch_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>;</function_decl>






















































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_bsearch</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>index_result</name> <init>= <expr><call><name>rb_ary_bsearch_index</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>index_result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name>index_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>index_result</name></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_bsearch_index</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>high</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>mid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>smaller</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>satisfied</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>low</name> <operator>&lt;</operator> <name>high</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mid</name> <operator>=</operator> <name>low</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>smaller</name> <operator>=</operator> <operator>(</operator><name>SIGNED_VALUE</name><operator>)</operator><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>v</name> <operator>==</operator> <name>Qtrue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>satisfied</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>smaller</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>v</name> <operator>==</operator> <name>Qfalse</name> <operator>||</operator> <name>v</name> <operator>==</operator> <name>Qnil</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>smaller</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>rb_obj_is_kind_of</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>rb_cNumeric</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>zero</name> <init>= <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><call><name>rb_cmpint</name><argument_list>(<argument><expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>id_cmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zero</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>smaller</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>smaller</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"wrong argument type %"</literal><name>PRIsVALUE</name>
<literal type="string">" (must be numeric, true, false or nil)"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>smaller</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>satisfied</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><name>low</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>
<name>sort_by_i</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_sort_by_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>sorted</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sorted</name> <operator>=</operator> <call><name>rb_block_call</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>rb_intern</name><argument_list>(<argument><expr><literal type="string">"sort_by"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sort_by_i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_replace</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>sorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_collect</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>collect</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>collect</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>collect</name></expr></argument>, <argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>collect</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_collect_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_get_values_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>olen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><function_decl><type><name>VALUE</name></type> (<modifier>*</modifier><name>func</name>) <parameter_list>(<parameter><decl><type><name>VALUE</name></type></decl></parameter>, <parameter><decl><type><name>long</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>FIX2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>end</name> <init>= <expr><ternary><condition><expr><name>olen</name> <operator>&lt;</operator> <name>beg</name><operator>+</operator><name>len</name></expr> ?</condition><then> <expr><name>olen</name></expr> </then><else>: <expr><name>beg</name><operator>+</operator><name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>beg</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_ary_resize</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>beg</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>append_values_at_single</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>olen</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>beg</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier><specifier>const</specifier></type> <name>src</name> <init>= <expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>end</name> <init>= <expr><name>beg</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>long</name></type> <name>prevlen</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <name>olen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_cat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>src</name> <operator>+</operator> <name>beg</name></expr></argument>, <argument><expr><ternary><condition><expr><name>end</name> <operator>&gt;</operator> <name>olen</name></expr> ?</condition><then> <expr><name>olen</name><operator>-</operator><name>beg</name></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <name>olen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>prevlen</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_values_at</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>olen</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>append_values_at_single</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>olen</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_select</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>select_bang_arg</name> <block>{
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name><name>len</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>select_bang_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name><name>struct</name> <name>select_bang_arg</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>ary</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i1</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i1</name> <operator>=</operator> <name>i2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i1</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name><name>arg</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>i1</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>!=</operator> <name>i2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>i2</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>i1</name> <operator>==</operator> <name>i2</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><name>ary</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>select_bang_ensure</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name><name>struct</name> <name>select_bang_arg</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>ary</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i1</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>i2</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i2</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name>i2</name> <operator>&lt;</operator> <name>i1</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>i1</name></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
MEMMOVE(ptr + i2, ptr + i1, VALUE, tail);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i2</name> <operator>+</operator> <name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_select_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>select_bang_arg</name></name></type> <name>args</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>ary</name></name> <operator>=</operator> <name>ary</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>.</operator><name>len</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>select_bang_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>select_bang_ensure</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_keep_if</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_select_bang</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ary_resize_smaller</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>ARY_DEFAULT_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_resize_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





















<function><type><name>VALUE</name></type>
<name>rb_ary_delete</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><name>item</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i1</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i1</name> <operator>=</operator> <name>i2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i1</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i1</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>!=</operator> <name>i2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i2</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i2</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ary_resize_smaller</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>rb_ary_delete_same</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i1</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i1</name> <operator>=</operator> <name>i2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i1</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i1</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>item</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>!=</operator> <name>i2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i2</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>i2</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ary_resize_smaller</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_delete_at</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>del</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>del</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
MEMMOVE(ptr+pos, ptr+pos+<literal type="number">1</literal>, VALUE, len-pos-<literal type="number">1</literal>);
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>ARY_INCREASE_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>del</name></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_delete_at_m</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>rb_ary_delete_at</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_slice_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>arg1</name></decl>, <decl><type ref="prev"/><name>arg2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>orig_len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>delete_pos_len</name>:</label>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>orig_len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>orig_len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>orig_len</name> <operator>&lt;</operator> <name>pos</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>orig_len</name> <operator>&lt;</operator> <name>pos</name> <operator>+</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>orig_len</name> <operator>-</operator> <name>pos</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>arg2</name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call><operator>+</operator><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_splice</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>arg2</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arg1</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Qtrue</name></expr>:</case>

<goto>goto <name>delete_pos_len</name>;</goto>
<case>case <expr><name>Qnil</name></expr>:</case>

<return>return <expr><name>Qnil</name></expr>;</return>
<default>default:</default>

<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>rb_ary_delete_at</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_reject</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>orig</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>reject_bang_i</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name><name>struct</name> <name>select_bang_arg</name></name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary</name> <init>= <expr><name><name>arg</name><operator>-&gt;</operator><name>ary</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i1</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i1</name> <operator>=</operator> <name>i2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i1</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name><name>arg</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>i1</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i1</name> <operator>!=</operator> <name>i2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>len</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>i2</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>i1</name> <operator>==</operator> <name>i2</name><operator>)</operator></expr> ?</condition><then> <expr><name>Qnil</name></expr> </then><else>: <expr><name>ary</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_reject_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>select_bang_arg</name></name></type> <name>args</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>ary</name></name> <operator>=</operator> <name>ary</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>.</operator><name>len</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>args</name><operator>.</operator><name>len</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><call><name>rb_ensure</name><argument_list>(<argument><expr><name>reject_bang_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name>select_bang_ensure</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_reject_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ary_reject_bang</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_reject</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>rejected_ary</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rejected_ary</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_reject</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>rejected_ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rejected_ary</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_delete_if</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary_enum_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_reject_bang</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>VALUE</name></type>
<name>take_i</name><argument_list>(<argument><expr><call><name>RB_BLOCK_CALL_FUNC_ARGLIST</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>cbarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><name>cbarg</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_iter_break</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rb_ary_new4</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>take_items</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_ary_subseq</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_check_block_call</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>idEach</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>take_i</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eTypeError</name></expr></argument>, <argument><expr><literal type="string">"wrong argument type %"</literal><name>PRIsVALUE</name><literal type="string">" (must respond to :each)"</literal></expr></argument>,
<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_zip</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>take_items</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>arity</name> <init>= <expr><call><name>rb_block_arity</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arity</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>work</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>VALUE</name></expr></argument>, <argument><expr><name>work</name></expr></argument>, <argument><expr><name>argc</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>tmp</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>rb_ary_elt</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>rb_yield_values2</name><argument_list>(<argument><expr><name>argc</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>work</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>work</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>argc</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name> <init>= <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>argc</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_transpose</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>elen</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>alen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>alen</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>alen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>alen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>to_ary</name><argument_list>(<argument><expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name>elen</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>elen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>elen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>alen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>elen</name> <operator>!=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eIndexError</name></expr></argument>, <argument><expr><literal type="string">"element size differs (%ld should be %ld)"</literal></expr></argument>,
<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>elen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator><name>elen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_store</name><argument_list>(<argument><expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>














<function><type><name>VALUE</name></type>
<name>rb_ary_replace</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>copy</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>orig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>orig</name> <operator>=</operator> <call><name>to_ary</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>copy</name> <operator>==</operator> <name>orig</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>copy</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>RARRAY_EMBED_LEN_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>shared_root</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ARY_OWNS_HEAP_P</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_heap_free</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>shared_root</name> <operator>=</operator> <call><name>ARY_SHARED_ROOT</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_UNSET_SHARED</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>FL_SET_EMBED</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>shared_root</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_decrement_share</name><argument_list>(<argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>shared_root</name> <init>= <expr><call><name>ary_make_shared</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_OWNS_HEAP_P</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_heap_free</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_unshare_safe</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>FL_UNSET_EMBED</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_PTR</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><call><name>ARY_HEAP_PTR</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><call><name>ARY_HEAP_LEN</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_set_shared</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>shared_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>copy</name></expr>;</return>
</block_content>}</block></function>











<function><type><name>VALUE</name></type>
<name>rb_ary_clear</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_unshare</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_EMBED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ARY_DEFAULT_SIZE</name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_resize_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>ARY_DEFAULT_SIZE</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_fill</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>item</name> <init>= <expr><name>Qundef</name></expr></init></decl>, <decl><type ref="prev"/><name>arg1</name></decl>, <decl><type ref="prev"/><name>arg2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>beg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"02"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_scan_args</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"12"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>item</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<switch>switch <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>beg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>rb_range_beg_len</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>beg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><name>beg</name> <operator>=</operator> <ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>beg</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>beg</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>beg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>beg</name></expr> </then><else>: <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>beg</name> <operator>&gt;=</operator> <name>ARY_MAX_SIZE</name> <operator>||</operator> <name>len</name> <operator>&gt;</operator> <name>ARY_MAX_SIZE</name> <operator>-</operator> <name>beg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"argument too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>beg</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <call><name>ARY_CAPA</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_resize_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ary_mem_clear</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name> <operator>==</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><name>beg</name></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>end</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name><operator>&gt;=</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ARY_SET</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ary_memfill</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>beg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>
























<function><type><name>VALUE</name></type>
<name>rb_ary_plus</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>xlen</name></decl>, <decl><type ref="prev"/><name>ylen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>to_ary</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xlen</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ylen</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>xlen</name> <operator>+</operator> <name>ylen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>xlen</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>xlen</name></expr></argument>, <argument><expr><name>ylen</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_append</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_splice</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>





















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_concat_multi</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_concat</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>args</name> <init>= <expr><call><name>rb_ary_tmp_new</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_concat</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ary_append</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ary_verify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VALUE</name></type>
<name>rb_ary_concat</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ary_append</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><call><name>to_ary</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_times</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>times</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary2</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>t</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_string_type</name><argument_list>(<argument><expr><name>times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_ary_join</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ary2</name> <operator>=</operator> <call><name>ary_new</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ARY_MAX_SIZE</name><operator>/</operator><name>len</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"argument too big"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>*=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ary2</name> <operator>=</operator> <call><name>ary_new</name><argument_list>(<argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name> <operator>&lt;=</operator> <name>len</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>len</name><operator>-</operator><name>t</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>out</name>:</label>
<return>return <expr><name>ary2</name></expr>;</return>
</block_content>}</block></function>





















<function><type><name>VALUE</name></type>
<name>rb_ary_assoc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>rb_equal</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>



















<function><type><name>VALUE</name></type>
<name>rb_ary_rassoc</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<call><name>rb_equal</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>recursive_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name> <modifier>*</modifier></type><name>p1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt> 


<expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p1</name> <operator>!=</operator> <operator>*</operator><name>p2</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><operator>*</operator><name>p1</name></expr></argument>, <argument><expr><operator>*</operator><name>p2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>!=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len1</name> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>RARRAY_CONST_PTR</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_equal</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ary1</name> <operator>==</operator> <name>ary2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_respond_to</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>idTo_ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_exec_recursive_paired</name><argument_list>(<argument><expr><name>recursive_equal</name></expr></argument>, <argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>recursive_eql</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt> 
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_eql</name><argument_list>(<argument><expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_eql</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ary1</name> <operator>==</operator> <name>ary2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>T_ARRAY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_exec_recursive_paired</name><argument_list>(<argument><expr><name>recursive_eql</name></expr></argument>, <argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_index_t</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>rb_hash_start</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>(</operator><name>st_index_t</name><operator>)</operator><name>rb_ary_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>rb_hash</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>rb_hash_uint</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>rb_hash_end</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ST2FIX</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>













<function><type><name>VALUE</name></type>
<name>rb_ary_includes</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_includes_by_eql</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>item</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_eql</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>recursive_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recur</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>recur</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qundef</name></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e1</name> <init>= <expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>e2</name> <init>= <expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>rb_funcallv</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>id_cmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>e2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>Qundef</name></expr>;</return>
</block_content>}</block></function>































<function><type><name>VALUE</name></type>
<name>rb_ary_cmp</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary2</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ary1</name> <operator>==</operator> <name>ary2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_exec_recursive_paired</name><argument_list>(<argument><expr><name>recursive_cmp</name></expr></argument>, <argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_add_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>elt</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_hash_add_new_element</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>
<name>ary_tmp_hash_new</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>size</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>rb_hash_new_with_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_make_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>ary_tmp_hash_new</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>ary_add_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_add_hash_by</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name> <init>= <expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>k</name> <init>= <expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rb_hash_add_new_element</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>hash</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>ary_make_hash_by</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name> <init>= <expr><call><name>ary_tmp_hash_new</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>ary_add_hash_by</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ary_recycle_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>RBASIC_CLASS</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RHASH_ST_TABLE_P</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>RHASH_ST_TABLE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RHASH_ST_CLEAR</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_diff</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary2</name> <operator>=</operator> <call><name>to_ary</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ary3</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>SMALL_ARRAY_LEN</name> <operator>||</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>SMALL_ARRAY_LEN</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>elt</name> <init>= <expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_ary_includes_by_eql</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary3</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ary3</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ary_make_hash</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_hash_stlike_lookup</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary3</name></expr></argument>, <argument><expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ary_recycle_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary3</name></expr>;</return>
</block_content>}</block></function>






























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_difference_multi</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary_diff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>t0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_hash</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ary_diff</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>to_ary</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>is_hash</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>length</name> <operator>&gt;</operator> <name>SMALL_ARRAY_LEN</name> <operator>&amp;&amp;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>SMALL_ARRAY_LEN</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>is_hash</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ary_make_hash</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>elt</name> <init>= <expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>is_hash</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_hash_stlike_lookup</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_ary_includes_by_eql</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary_diff</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary_diff</name></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_and</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>ary3</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>vv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary2</name> <operator>=</operator> <call><name>to_ary</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ary3</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ary3</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>SMALL_ARRAY_LEN</name> <operator>&amp;&amp;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>SMALL_ARRAY_LEN</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_ary_includes_by_eql</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_ary_includes_by_eql</name><argument_list>(<argument><expr><name>ary3</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary3</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>ary3</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ary_make_hash</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vv</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>v</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_hash_stlike_delete</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary3</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ary_recycle_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary3</name></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_intersection_multi</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_and</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ary_hash_orset</name><parameter_list>(<parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>existing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>existing</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ST_STOP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>key</name> <operator>=</operator> <operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>VALUE</name><operator>)</operator><name>arg</name></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_ary_union</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary_union</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>elt</name> <init>= <expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_ary_includes_by_eql</name><argument_list>(<argument><expr><name>ary_union</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>ary_union</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rb_ary_union_hash</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>hash</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>elt</name> <init>= <expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_hash_stlike_update</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>elt</name></expr></argument>, <argument><expr><name>ary_hash_orset</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>elt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RB_OBJ_WRITTEN</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>Qundef</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_or</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary1</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>ary3</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ary2</name> <operator>=</operator> <call><name>to_ary</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>SMALL_ARRAY_LEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ary3</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_union</name><argument_list>(<argument><expr><name>ary3</name></expr></argument>, <argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_union</name><argument_list>(<argument><expr><name>ary3</name></expr></argument>, <argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary3</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ary_make_hash</name><argument_list>(<argument><expr><name>ary1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_union_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>ary2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ary3</name> <operator>=</operator> <call><name>rb_hash_values</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_recycle_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary3</name></expr>;</return>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_union_multi</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>sum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>ary_union</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sum</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>to_ary</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>sum</name> <operator>&lt;=</operator> <name>SMALL_ARRAY_LEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ary_union</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_ary_union</name><argument_list>(<argument><expr><name>ary_union</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_ary_union</name><argument_list>(<argument><expr><name>ary_union</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>ary_union</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ary_make_hash</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_ary_union_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>ary_union</name> <operator>=</operator> <call><name>rb_hash_values</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_recycle_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary_union</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_max</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cmp_opt_data</name></name></type> <name>cmp_opt</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qundef</name></expr></init></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>num</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>rb_nmin_run</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Qundef</name> <operator>||</operator> <call><name>rb_cmpint</name><argument_list>(<argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Qundef</name> <operator>||</operator> <call><name>OPTIMIZED_CMP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>cmp_opt</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_min</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cmp_opt_data</name></name></type> <name>cmp_opt</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qundef</name></expr></init></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>num</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>rb_nmin_run</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Qundef</name> <operator>||</operator> <call><name>rb_cmpint</name><argument_list>(<argument><expr><call><name>rb_yield_values</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Qundef</name> <operator>||</operator> <call><name>OPTIMIZED_CMP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>cmp_opt</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_minmax</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>rb_call_super</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_assoc_new</name><argument_list>(<argument><expr><call><name>rb_ary_min</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>rb_ary_max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>push_value</name><parameter_list>(<parameter><decl><type><name>st_data_t</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>st_data_t</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>ary</name></expr></argument>, <argument><expr><operator>(</operator><name>VALUE</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ST_CONTINUE</name></expr>;</return>
</block_content>}</block></function>




























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_uniq_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>hash_size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ary_make_hash_by</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ary_make_hash</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>hash_size</name> <operator>=</operator> <call><name>RHASH_SIZE</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>hash_size</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ARY_SHARED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_unshare</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FL_SET_EMBED</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ary_resize_capa</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>hash_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_foreach</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>push_value</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_recycle_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_uniq</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>uniq</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>uniq</name> <operator>=</operator> <call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ary_make_hash_by</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uniq</name> <operator>=</operator> <call><name>rb_hash_values</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>ary_make_hash</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uniq</name> <operator>=</operator> <call><name>rb_hash_values</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>uniq</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>hash</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ary_recycle_hash</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>uniq</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_compact_bang</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>t</name> <operator>=</operator> <operator>(</operator><name>VALUE</name> <operator>*</operator><operator>)</operator><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><operator>*</operator><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>t</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>p</name> <operator>-</operator> <call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>n</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ary_resize_smaller</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_compact</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_compact_bang</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_count</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>obj</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_equal</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>flatten</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>stack</name></decl>, <decl><type ref="prev"/><name>result</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>, <decl><type ref="prev"/><name>elt</name></decl>, <decl><type ref="prev"/><name>vmemo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>memo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_data_t</name></type> <name>id</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>elt</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>ary</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to flatten recursive array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ary_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ary_memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>RARRAY_CONST_PTR_TRANSIENT</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>ary_new</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ARY_DEFAULT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vmemo</name> <operator>=</operator> <call><name>rb_hash_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>vmemo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>memo</name> <operator>=</operator> <call><name>st_init_numtable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_hash_st_table_set</name><argument_list>(<argument><expr><name>vmemo</name></expr></argument>, <argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>memo</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>ary</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>memo</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>tmp</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ary</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elt</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name>level</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_check_array_type</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RBASIC</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>vmemo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_clear</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"flatten reentered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>tmp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>st_is_member</name><argument_list>(<argument><expr><name>memo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>st_clear</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"tried to flatten recursive array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>st_insert</name><argument_list>(<argument><expr><name>memo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>(</operator><name>st_data_t</name><operator>)</operator><name>Qtrue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ary</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>(</operator><name>st_data_t</name><operator>)</operator><name>ary</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_delete</name><argument_list>(<argument><expr><name>memo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>rb_ary_pop</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_pop</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>st_clear</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RBASIC_SET_CLASS</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>rb_obj_class</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>





















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_flatten_bang</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>mod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>level</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>, <decl><type ref="prev"/><name>lv</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lv</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><name>Qnil</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_modify_check</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>level</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name>lv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>flatten</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>ary</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>mod</name> <operator>=</operator> <call><name>ARY_EMBED_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_obj_freeze</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rb_ary_replace</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mod</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ARY_SET_EMBED_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_flatten</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>level</name> <operator>=</operator> <call><name>NUM2INT</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ary_make_shared_copy</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>flatten</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>ary</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ary_make_shared_copy</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RAND_UPTO</name><parameter_list>(<parameter><type><name>max</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(long)rb_random_ulong_limited((randgen), (max)-1)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_shuffle_bang</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>randgen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_ary_modify</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE</name><argument_list>(<argument>ary</argument>, <argument>ptr</argument>, <argument>{
while (i) {
long j = RAND_UPTO(i);
VALUE tmp;
if (len != RARRAY_LEN(ary) || ptr != RARRAY_CONST_PTR_TRANSIENT(ary)) {
rb_raise(rb_eRuntimeError, <literal type="string">"modified during shuffle"</literal>);
}
tmp = ptr[--i];
ptr[i] = ptr[j];
ptr[j] = tmp;
}
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt> 
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_shuffle</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>randgen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>ary</name> <operator>=</operator> <call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_ary_shuffle_bang</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>ary</name></expr></argument>, <argument><expr><name>randgen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_sample</name><parameter_list>(<parameter><decl><type><name>rb_execution_context_t</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>randgen</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>nv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>to_array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name><name>idx</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name><name>rnds</name><index>[<expr><call><name>numberof</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>memo_threshold</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>to_array</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>RAND_UPTO</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><call><name>rb_ary_elt</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>nv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"negative sample number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>rnds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>RAND_UPTO</name><argument_list>(<argument><expr><name>len</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>k</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;=</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>rnds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<return>return <expr><call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>rnds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>rb_ary_new_from_values</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>rnds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>rnds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>rnds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>rnds</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>rnds</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>l</name> <init>= <expr><name>j</name></expr></init></decl>, <decl><type ref="prev"/><name>g</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>l</name> <operator>=</operator> <name>i</name></expr><operator>,</operator> <expr><name>g</name> <operator>=</operator> <operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;=</operator> <name>l</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>++</operator><name>k</name> <operator>&gt;=</operator> <name>g</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<return>return <expr><call><name>rb_ary_new_from_args</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name>memo_threshold</name> <operator>=</operator>
<ternary><condition><expr><name>len</name> <operator>&lt;</operator> <literal type="number">2560</literal></expr> ?</condition><then> <expr><name>len</name> <operator>/</operator> <literal type="number">128</literal></expr> </then><else>:
<expr><ternary><condition><expr><name>len</name> <operator>&lt;</operator> <literal type="number">5120</literal></expr> ?</condition><then> <expr><name>len</name> <operator>/</operator> <literal type="number">64</literal></expr> </then><else>:
<expr><ternary><condition><expr><name>len</name> <operator>&lt;</operator> <literal type="number">10240</literal></expr> ?</condition><then> <expr><name>len</name> <operator>/</operator> <literal type="number">32</literal></expr> </then><else>:
<expr><name>len</name> <operator>/</operator> <literal type="number">16</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <call><name>numberof</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name><name>sorted</name><index>[<expr><call><name>numberof</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sorted</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>idx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>rnds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>rnds</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <name><name>sorted</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sorted</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sorted</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sorted</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>*</operator><operator>(</operator><name>i</name><operator>-</operator><name>j</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sorted</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>idx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE_TRANSIENT</name><argument_list>(<argument>result</argument>, <argument>ptr_result</argument>, <argument>{
for (i=<literal type="number">0</literal>; i&lt;n; i++) {
ptr_result[i] = RARRAY_AREF(ary, idx[i]);
}
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <name>memo_threshold</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>max_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RUBY_UNTYPED_DATA_WARNING</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RUBY_UNTYPED_DATA_WARNING</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<decl_stmt><decl><type><name>VALUE</name></type> <name>vmemo</name> <init>= <expr><call><name>Data_Wrap_Struct</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>st_free_table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>st_table</name> <modifier>*</modifier></type><name>memo</name> <init>= <expr><call><name>st_init_numtable_with_size</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>vmemo</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>memo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new_capa</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE</name><argument_list>(<argument>result</argument>, <argument>ptr_result</argument>, <argument>{
for (i=<literal type="number">0</literal>; i&lt;n; i++) {
long r = RAND_UPTO(len-i) + i;
ptr_result[i] = r;
if (r &gt; max_idx) max_idx = r;
}
len = RARRAY_LEN(ary);
if (len &lt;= max_idx) n = <literal type="number">0</literal>;
else if (n &gt; len) n = len;
RARRAY_PTR_USE_TRANSIENT(ary, ptr_ary, {
for (i=<literal type="number">0</literal>; i&lt;n; i++) {
long j2 = j = ptr_result[i];
long i2 = i;
st_data_t value;
if (st_lookup(memo, (st_data_t)i, &amp;value)) i2 = (long)value;
if (st_lookup(memo, (st_data_t)j, &amp;value)) j2 = (long)value;
st_insert(memo, (st_data_t)j, (st_data_t)i2);
ptr_result[i] = ptr_ary[j2];
}
});
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>DATA_PTR</name><argument_list>(<argument><expr><name>vmemo</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>st_free_table</name><argument_list>(<argument><expr><name>memo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_dup</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RB_GC_GUARD</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>RARRAY_PTR_USE</name><argument_list>(<argument>result</argument>, <argument>ptr_result</argument>, <argument>{
for (i=<literal type="number">0</literal>; i&lt;n; i++) {
j = RAND_UPTO(len-i) + i;
nv = ptr_result[j];
ptr_result[j] = ptr_result[i];
ptr_result[i] = nv;
}
}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>RBASIC_SET_CLASS_RAW</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rb_cArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_cycle_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>mul</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>n</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>Qnil</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>HUGE_VAL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>mul</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mul</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>INT2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>LONG2FIX</name><argument_list>(<argument><expr><name>mul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>rb_fix_mul_fix</name><argument_list>(<argument><expr><call><name>rb_ary_length</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_cycle</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rb_ary_cycle_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>NIL_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qnil</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <literal type="number">0</literal> <operator>&lt;</operator> <name>n</name><operator>--</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></while>
<return>return <expr><name>Qnil</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tmpary</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_ary_tmp_new(n)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tmpary_discard</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ary_discard(a), RBASIC_SET_CLASS_RAW(a, rb_cArray))</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>yield_indexed_values</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>values</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name> <modifier>*</modifier><specifier>const</specifier></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>result</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>r</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ARY_SET</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>!</operator><call><name>RBASIC</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>klass</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>void</name></type>
<name>permute0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier><specifier>const</specifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>used</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>unused</name> <init>= <expr><call><name>memchr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>used</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>n</name><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>unused</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>index</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><index>[<expr><operator>--</operator><name>index</name></expr>]</index></name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>used</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>unused</name> <operator>-</operator> <name>used</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>used</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><operator>++</operator><name>index</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name>r</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>used</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>yield_indexed_values</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"permute reentered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><index>[<expr><operator>--</operator><name>index</name></expr>]</index></name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>used</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>i</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>descending_factorial</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>how_many</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>cnt</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>how_many</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>LONG2FIX</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>--</operator><name>how_many</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>v</name> <init>= <expr><operator>--</operator><name>from</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>rb_int_mul</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>LONG2FIX</name><argument_list>(<argument><expr><name>how_many</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>binomial_coefficient</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>comb</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>comb</name> <operator>&gt;</operator> <name>size</name><operator>-</operator><name>comb</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>comb</name> <operator>=</operator> <name>size</name><operator>-</operator><name>comb</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>comb</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>comb</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>LONG2FIX</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>comb</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_int_mul</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>size</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_int_idiv</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_permutation_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>k</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>args</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>descending_factorial</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_permutation</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>rb_ary_permutation_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NIL_P</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&lt;</operator> <name>r</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content> 
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>t0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>long</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><name>r</name><operator>+</operator><call><name>roomof</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>used</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <name>r</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary0</name> <init>= <expr><call><name>ary_make_shared_copy</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>ary0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>used</name></expr></argument>, <argument><expr><name>char</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>permute0</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>used</name></expr></argument>, <argument><expr><name>ary0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_SET_CLASS_RAW</name><argument_list>(<argument><expr><name>ary0</name></expr></argument>, <argument><expr><name>rb_cArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>combinate0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier><specifier>const</specifier></type> <name>stack</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>lev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MEMZERO</name><argument_list>(<argument><expr><name>stack</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>long</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>lev</name><operator>++</operator></expr>;</init> <condition><expr><name>lev</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>lev</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>lev</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>lev</name></expr>]</index></name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>yield_indexed_values</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>stack</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"combination reentered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lev</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>lev</name><operator>--</operator></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name><name>stack</name><index>[<expr><name>lev</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>+</operator><name>n</name> <operator>==</operator> <name>len</name><operator>+</operator><name>lev</name><operator>+</operator><literal type="number">1</literal></expr>)</condition>;</do>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_combination_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>k</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>binomial_coefficient</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_combination</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>rb_ary_combination_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name> <operator>&lt;</operator> <name>n</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary0</name> <init>= <expr><call><name>ary_make_shared_copy</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>t0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>long</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>ary0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>combinate0</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>ary0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_SET_CLASS_RAW</name><argument_list>(<argument><expr><name>ary0</name></expr></argument>, <argument><expr><name>rb_cArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>void</name></type>
<name>rpermute0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier><specifier>const</specifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>index</name> <operator>&lt;</operator> <name>r</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>yield_indexed_values</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"repeated permute reentered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <operator>++</operator><name><name>p</name><index>[<expr><operator>--</operator><name>index</name></expr>]</index></name><operator>)</operator> <operator>&gt;=</operator> <name>n</name></expr>)</condition>;</do>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_repeated_permutation_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>k</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><operator>!</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_int_positive_pow</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_repeated_permutation</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>rb_ary_repeated_permutation_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content> 
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content> 
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>t0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>long</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary0</name> <init>= <expr><call><name>ary_make_shared_copy</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>ary0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rpermute0</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>ary0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_SET_CLASS_RAW</name><argument_list>(<argument><expr><name>ary0</name></expr></argument>, <argument><expr><name>rb_cArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rcombinate0</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier><specifier>const</specifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>rest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VALUE</name></type> <name>values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>index</name> <operator>&lt;</operator> <name>r</name><operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>yield_indexed_values</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"repeated combination reentered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <operator>++</operator><name><name>p</name><index>[<expr><operator>--</operator><name>index</name></expr>]</index></name><operator>)</operator> <operator>&gt;=</operator> <name>n</name></expr>)</condition>;</do>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_repeated_combination_size</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>args</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>eobj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>k</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>binomial_coefficient</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




























<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_repeated_combination</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>NUM2LONG</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>RETURN_SIZED_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>rb_ary_repeated_combination_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>rb_ary_new3</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>t0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>long</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>ary0</name> <init>= <expr><call><name>ary_make_shared_copy</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>ary0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rcombinate0</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>ary0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RBASIC_SET_CLASS_RAW</name><argument_list>(<argument><expr><name>ary0</name></expr></argument>, <argument><expr><name>rb_cArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>






















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_product</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>argc</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>t0</name> <init>= <expr><call><name>tmpary</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>VALUE</name></type> <name>t1</name> <init>= <expr><name>Qundef</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>arrays</name> <init>= <expr><call><name>RARRAY_PTR</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>counters</name> <init>= <expr><call><name>ALLOCV_N</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qnil</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>resultlen</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RBASIC_CLEAR_CLASS</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>ARY_SET_LEN</name><argument_list>(<argument><expr><name>t0</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arrays</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ary</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>arrays</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>Qnil</name></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>arrays</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>to_ary</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>counters</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>


<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>arrays</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>arrays</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>ary_make_shared_copy</name><argument_list>(<argument><expr><name><name>arrays</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>k</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>arrays</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MUL_OVERFLOW_LONG_P</name><argument_list>(<argument><expr><name>resultlen</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRangeError</name></expr></argument>, <argument><expr><literal type="string">"too big to product"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>resultlen</name> <operator>*=</operator> <name>k</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>resultlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VALUE</name></type> <name>subarray</name> <init>= <expr><call><name>rb_ary_new2</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>subarray</name></expr></argument>, <argument><expr><call><name>rb_ary_entry</name><argument_list>(<argument><expr><name><name>arrays</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>counters</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FL_SET</name><argument_list>(<argument><expr><name>t0</name></expr></argument>, <argument><expr><name>FL_USER5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_yield</name><argument_list>(<argument><expr><name>subarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>FL_TEST</name><argument_list>(<argument><expr><name>t0</name></expr></argument>, <argument><expr><name>FL_USER5</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eRuntimeError</name></expr></argument>, <argument><expr><literal type="string">"product reentered"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>FL_UNSET</name><argument_list>(<argument><expr><name>t0</name></expr></argument>, <argument><expr><name>FL_USER5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>rb_ary_push</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>subarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>





<expr_stmt><expr><name>m</name> <operator>=</operator> <name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>counters</name><index>[<expr><name>m</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>counters</name><index>[<expr><name>m</name></expr>]</index></name> <operator>==</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name><name>arrays</name><index>[<expr><name>m</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>counters</name><index>[<expr><name>m</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>m</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>counters</name><index>[<expr><name>m</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>tmpary_discard</name><argument_list>(<argument><expr><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ALLOCV_END</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><call><name>NIL_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>ary</name></expr> </then><else>: <expr><name>result</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_take</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>obj</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"attempt to take negative size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>rb_ary_subseq</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_take_while</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>rb_ary_take</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_drop</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><call><name>NUM2LONG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_raise</name><argument_list>(<argument><expr><name>rb_eArgError</name></expr></argument>, <argument><expr><literal type="string">"attempt to drop negative size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_subseq</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>Qnil</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>rb_ary_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_drop_while</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_ENUMERATOR</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>rb_ary_drop</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_any_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>idEqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>Qfalse</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_all_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>idEqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_none_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qtrue</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>idEqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>Qtrue</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_one_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VALUE</name></type> <name>result</name> <init>= <expr><name>Qfalse</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rb_warn</name><argument_list>(<argument><expr><literal type="string">"given block not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_funcall</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>idEqq</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>RTEST</name><argument_list>(<argument><expr><call><name>rb_yield</name><argument_list>(<argument><expr><call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>Qfalse</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>Qtrue</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_dig</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UNLIMITED_ARGUMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self</name> <operator>=</operator> <call><name>rb_ary_at</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><operator>*</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>--</operator><name>argc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>self</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>argv</name></expr>;</expr_stmt>
<return>return <expr><call><name>rb_obj_dig</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>self</name></expr></argument>, <argument><expr><name>Qnil</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>VALUE</name></type>
<name>finish_exact_sum</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>r</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>z</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_fix_plus</name><argument_list>(<argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>Qundef</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_fix_plus</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>T_BIGNUM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_big_plus</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_rational_plus</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>n</name> <operator>&amp;&amp;</operator> <name>z</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_fix_plus</name><argument_list>(<argument><expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>











































<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_sum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>VALUE</name> <modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>VALUE</name></type> <name>e</name></decl>, <decl><type ref="prev"/><name>v</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>block_given</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>rb_check_arity</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><call><name>LONG2FIX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>block_given</name> <operator>=</operator> <call><name>rb_block_given_p</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>v</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>Qundef</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>block_given</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FIXABLE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_big_plus</name><argument_list>(<argument><expr><call><name>LONG2NUM</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>T_BIGNUM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_big_plus</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>T_RATIONAL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>Qundef</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rb_rational_plus</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<goto>goto <name>not_exact</name>;</goto></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>finish_exact_sum</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>argc</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>

<label><name>not_exact</name>:</label>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>finish_exact_sum</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>i</name><operator>!=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>




<decl_stmt><decl><type><name>double</name></type> <name>f</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>NUM2DBL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
<goto>goto <name>has_float_value</name>;</goto>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>block_given</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>RB_FLOAT_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<label><name>has_float_value</name>:</label>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>RFLOAT_VALUE</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>FIXNUM_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>FIX2LONG</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>T_BIGNUM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_big2dbl</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>RB_TYPE_P</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>T_RATIONAL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>rb_num2dbl</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<goto>goto <name>not_float</name>;</goto></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>signbit</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>signbit</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>NAN</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>f</name> <operator>+</operator> <name>x</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>f</name> <operator>-</operator> <name>t</name><operator>)</operator> <operator>+</operator> <name>x</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>x</name> <operator>-</operator> <name>t</name><operator>)</operator> <operator>+</operator> <name>f</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>f</name> <operator>+=</operator> <name>c</name></expr>;</expr_stmt>
<return>return <expr><call><name>DBL2NUM</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>

<label><name>not_float</name>:</label>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>DBL2NUM</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<goto>goto <name>has_some_value</name>;</goto>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>RARRAY_LEN</name><argument_list>(<argument><expr><name>ary</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>RARRAY_AREF</name><argument_list>(<argument><expr><name>ary</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>block_given</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>rb_yield</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<label><name>has_some_value</name>:</label>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>rb_funcall</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idPLUS</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VALUE</name></type>
<name>rb_ary_deconstruct</name><parameter_list>(<parameter><decl><type><name>VALUE</name></type> <name>ary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>ary</name></expr>;</return>
</block_content>}</block></function>















































































































































































































































<function><type><name>void</name></type>
<name>Init_Array</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>rb_intern</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rb_intern</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>rb_intern_const(str)</cpp:value></cpp:define>

<expr_stmt><expr><name>rb_cArray</name> <operator>=</operator> <call><name>rb_define_class</name><argument_list>(<argument><expr><literal type="string">"Array"</literal></expr></argument>, <argument><expr><name>rb_cObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_include_module</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><name>rb_mEnumerable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_alloc_func</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><name>empty_ary_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>rb_ary_s_create</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_singleton_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"try_convert"</literal></expr></argument>, <argument><expr><name>rb_ary_s_try_convert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"initialize"</literal></expr></argument>, <argument><expr><name>rb_ary_initialize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"initialize_copy"</literal></expr></argument>, <argument><expr><name>rb_ary_replace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>, <argument><expr><name>rb_ary_inspect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"to_s"</literal></expr></argument>, <argument><expr><literal type="string">"inspect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"to_a"</literal></expr></argument>, <argument><expr><name>rb_ary_to_a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"to_h"</literal></expr></argument>, <argument><expr><name>rb_ary_to_h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"to_ary"</literal></expr></argument>, <argument><expr><name>rb_ary_to_ary_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"=="</literal></expr></argument>, <argument><expr><name>rb_ary_equal</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"eql?"</literal></expr></argument>, <argument><expr><name>rb_ary_eql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>, <argument><expr><name>rb_ary_hash</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><name>rb_ary_aref</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"[]="</literal></expr></argument>, <argument><expr><name>rb_ary_aset</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"at"</literal></expr></argument>, <argument><expr><name>rb_ary_at</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"fetch"</literal></expr></argument>, <argument><expr><name>rb_ary_fetch</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"first"</literal></expr></argument>, <argument><expr><name>rb_ary_first</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"last"</literal></expr></argument>, <argument><expr><name>rb_ary_last</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"concat"</literal></expr></argument>, <argument><expr><name>rb_ary_concat_multi</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"union"</literal></expr></argument>, <argument><expr><name>rb_ary_union_multi</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"difference"</literal></expr></argument>, <argument><expr><name>rb_ary_difference_multi</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"intersection"</literal></expr></argument>, <argument><expr><name>rb_ary_intersection_multi</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>, <argument><expr><name>rb_ary_push</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"push"</literal></expr></argument>, <argument><expr><name>rb_ary_push_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"append"</literal></expr></argument>, <argument><expr><literal type="string">"push"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"pop"</literal></expr></argument>, <argument><expr><name>rb_ary_pop_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"shift"</literal></expr></argument>, <argument><expr><name>rb_ary_shift_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"unshift"</literal></expr></argument>, <argument><expr><name>rb_ary_unshift_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"prepend"</literal></expr></argument>, <argument><expr><literal type="string">"unshift"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"insert"</literal></expr></argument>, <argument><expr><name>rb_ary_insert</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"each"</literal></expr></argument>, <argument><expr><name>rb_ary_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"each_index"</literal></expr></argument>, <argument><expr><name>rb_ary_each_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"reverse_each"</literal></expr></argument>, <argument><expr><name>rb_ary_reverse_each</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>, <argument><expr><name>rb_ary_length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_alias</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><literal type="string">"length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"empty?"</literal></expr></argument>, <argument><expr><name>rb_ary_empty_p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"find_index"</literal></expr></argument>, <argument><expr><name>rb_ary_index</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>, <argument><expr><name>rb_ary_index</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"rindex"</literal></expr></argument>, <argument><expr><name>rb_ary_rindex</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"join"</literal></expr></argument>, <argument><expr><name>rb_ary_join_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"reverse"</literal></expr></argument>, <argument><expr><name>rb_ary_reverse_m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"reverse!"</literal></expr></argument>, <argument><expr><name>rb_ary_reverse_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"rotate"</literal></expr></argument>, <argument><expr><name>rb_ary_rotate_m</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"rotate!"</literal></expr></argument>, <argument><expr><name>rb_ary_rotate_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"sort"</literal></expr></argument>, <argument><expr><name>rb_ary_sort</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"sort!"</literal></expr></argument>, <argument><expr><name>rb_ary_sort_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"sort_by!"</literal></expr></argument>, <argument><expr><name>rb_ary_sort_by_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"collect"</literal></expr></argument>, <argument><expr><name>rb_ary_collect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"collect!"</literal></expr></argument>, <argument><expr><name>rb_ary_collect_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"map"</literal></expr></argument>, <argument><expr><name>rb_ary_collect</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"map!"</literal></expr></argument>, <argument><expr><name>rb_ary_collect_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>, <argument><expr><name>rb_ary_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"select!"</literal></expr></argument>, <argument><expr><name>rb_ary_select_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"filter"</literal></expr></argument>, <argument><expr><name>rb_ary_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"filter!"</literal></expr></argument>, <argument><expr><name>rb_ary_select_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"keep_if"</literal></expr></argument>, <argument><expr><name>rb_ary_keep_if</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"values_at"</literal></expr></argument>, <argument><expr><name>rb_ary_values_at</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"delete"</literal></expr></argument>, <argument><expr><name>rb_ary_delete</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"delete_at"</literal></expr></argument>, <argument><expr><name>rb_ary_delete_at_m</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"delete_if"</literal></expr></argument>, <argument><expr><name>rb_ary_delete_if</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"reject"</literal></expr></argument>, <argument><expr><name>rb_ary_reject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"reject!"</literal></expr></argument>, <argument><expr><name>rb_ary_reject_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"zip"</literal></expr></argument>, <argument><expr><name>rb_ary_zip</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"transpose"</literal></expr></argument>, <argument><expr><name>rb_ary_transpose</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"replace"</literal></expr></argument>, <argument><expr><name>rb_ary_replace</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"clear"</literal></expr></argument>, <argument><expr><name>rb_ary_clear</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"fill"</literal></expr></argument>, <argument><expr><name>rb_ary_fill</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"include?"</literal></expr></argument>, <argument><expr><name>rb_ary_includes</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"&lt;=&gt;"</literal></expr></argument>, <argument><expr><name>rb_ary_cmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name>rb_ary_aref</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"slice!"</literal></expr></argument>, <argument><expr><name>rb_ary_slice_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"assoc"</literal></expr></argument>, <argument><expr><name>rb_ary_assoc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"rassoc"</literal></expr></argument>, <argument><expr><name>rb_ary_rassoc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><name>rb_ary_plus</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>, <argument><expr><name>rb_ary_times</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><name>rb_ary_diff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>, <argument><expr><name>rb_ary_and</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>, <argument><expr><name>rb_ary_or</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>, <argument><expr><name>rb_ary_max</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>, <argument><expr><name>rb_ary_min</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"minmax"</literal></expr></argument>, <argument><expr><name>rb_ary_minmax</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"uniq"</literal></expr></argument>, <argument><expr><name>rb_ary_uniq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"uniq!"</literal></expr></argument>, <argument><expr><name>rb_ary_uniq_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"compact"</literal></expr></argument>, <argument><expr><name>rb_ary_compact</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"compact!"</literal></expr></argument>, <argument><expr><name>rb_ary_compact_bang</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"flatten"</literal></expr></argument>, <argument><expr><name>rb_ary_flatten</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"flatten!"</literal></expr></argument>, <argument><expr><name>rb_ary_flatten_bang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>, <argument><expr><name>rb_ary_count</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"cycle"</literal></expr></argument>, <argument><expr><name>rb_ary_cycle</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"permutation"</literal></expr></argument>, <argument><expr><name>rb_ary_permutation</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"combination"</literal></expr></argument>, <argument><expr><name>rb_ary_combination</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"repeated_permutation"</literal></expr></argument>, <argument><expr><name>rb_ary_repeated_permutation</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"repeated_combination"</literal></expr></argument>, <argument><expr><name>rb_ary_repeated_combination</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"product"</literal></expr></argument>, <argument><expr><name>rb_ary_product</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"take"</literal></expr></argument>, <argument><expr><name>rb_ary_take</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"take_while"</literal></expr></argument>, <argument><expr><name>rb_ary_take_while</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"drop"</literal></expr></argument>, <argument><expr><name>rb_ary_drop</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"drop_while"</literal></expr></argument>, <argument><expr><name>rb_ary_drop_while</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"bsearch"</literal></expr></argument>, <argument><expr><name>rb_ary_bsearch</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"bsearch_index"</literal></expr></argument>, <argument><expr><name>rb_ary_bsearch_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"any?"</literal></expr></argument>, <argument><expr><name>rb_ary_any_p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"all?"</literal></expr></argument>, <argument><expr><name>rb_ary_all_p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"none?"</literal></expr></argument>, <argument><expr><name>rb_ary_none_p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"one?"</literal></expr></argument>, <argument><expr><name>rb_ary_one_p</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"dig"</literal></expr></argument>, <argument><expr><name>rb_ary_dig</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"sum"</literal></expr></argument>, <argument><expr><name>rb_ary_sum</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>rb_define_method</name><argument_list>(<argument><expr><name>rb_cArray</name></expr></argument>, <argument><expr><literal type="string">"deconstruct"</literal></expr></argument>, <argument><expr><name>rb_ary_deconstruct</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"array.rbinc"</cpp:file></cpp:include>
</unit>
